// ---------------- [ File: bitcoinleveldb-options/src/options.rs ]
crate::ix!();

//-------------------------------------------[.cpp/bitcoin/src/leveldb/util/options.cc]
//-------------------------------------------[.cpp/bitcoin/src/leveldb/include/leveldb/options.h]

/// Options to control the behavior of a
/// database (passed to DB::Open)
/// 
#[derive(Getters,MutGetters,Setters)]
#[getset(get="pub",get_mut="pub",set="pub")]
pub struct Options {

    /* -------- Parameters that affect behavior  -------- */

    /// Comparator used to define the order of keys in the table.
    ///
    /// Default: a comparator that uses lexicographic byte-wise ordering
    ///
    /// REQUIRES: The client must ensure that the comparator supplied here has
    /// the same name and orders keys *exactly* the same as the comparator
    /// provided to previous open calls on the same DB.
    ///
    comparator:        Box<dyn SliceComparator>,

    /// If true, the database will be created if it is missing.
    ///
    create_if_missing: bool,

    /// If true, an error is raised if the database already exists.
    ///
    error_if_exists:   bool,

    /// If true, the implementation will do aggressive checking of the data it
    /// is processing and will stop early if it detects any errors.
    ///
    /// This may have unforeseen ramifications: for example, a corruption of one
    /// DB entry may cause a large number of entries to become unreadable or for
    /// the entire DB to become unopenable.
    ///
    paranoid_checks:   bool,

    /// Use the specified object to interact with the environment, e.g. to
    /// read/write files, schedule background work, etc.
    ///
    /// Default: `None`. A higher layer is expected to substitute the
    /// processâ€‘global default environment before first use if this is left
    /// unset.
    ///
    env:               Option<Rc<RefCell<dyn Env>>>,

    /// Any internal progress/error information generated by the DB will be
    /// written to `info_log` if it is `Some`, or to a file stored in the same
    /// directory as the DB contents if `info_log` is `None`.
    ///
    info_log:          Option<*mut dyn Logger>,

    /* ------ Parameters that affect performance  ------ */

    /// Amount of data to build up in memory (backed by an unsorted log on disk)
    /// before converting to a sorted on-disk file.
    ///
    /// Larger values increase performance, especially during bulk loads.
    ///
    /// Up to two write buffers may be held in memory at the same time, so you
    /// may wish to adjust this parameter to control memory usage.
    ///
    /// Also, a larger write buffer will result in a longer recovery time the
    /// next time the database is opened.
    ///
    write_buffer_size:      usize,

    /// Number of open files that can be used by the DB.
    ///
    /// You may need to increase this if your database has a large working set
    /// (budget one open file per 2MB of working set).
    ///
    max_open_files:         i32,

    /// Control over blocks (user data is stored in a set of blocks, and a block
    /// is the unit of reading from disk).
    ///
    /// If non-null, use the specified cache for blocks.
    ///
    /// If null, leveldb will automatically create and use an 8MB internal
    /// cache.
    ///
    block_cache:            *mut Cache,

    /// Approximate size of user data packed per block.
    ///
    /// Note that the block size specified here corresponds to uncompressed
    /// data.
    ///
    /// The actual size of the unit read from disk may be smaller if compression
    /// is enabled.  This parameter can be changed dynamically.
    ///
    block_size:             usize,

    /// Number of keys between restart points for delta encoding of keys.
    ///
    /// This parameter can be changed dynamically. Most clients should leave
    /// this parameter alone.
    ///
    block_restart_interval: i32,

    /// Leveldb will write up to this amount of bytes to a file before switching
    /// to a new one.
    ///
    /// Most clients should leave this parameter alone.  However if your
    /// filesystem is more efficient with larger files, you could consider
    /// increasing the value.  The downside will be longer compactions and hence
    /// longer latency/performance hiccups.
    ///
    /// Another reason to increase this parameter might be when you are
    /// initially populating a large database.
    ///
    max_file_size:          usize,

    /// Compress blocks using the specified compression algorithm.  This
    /// parameter can be changed dynamically.
    ///
    /// Default: kSnappyCompression, which gives lightweight but fast
    /// compression.
    ///
    /// Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
    ///
    ///    ~200-500MB/s compression
    ///    ~400-800MB/s decompression
    ///
    /// Note that these speeds are significantly faster than most persistent
    /// storage speeds, and therefore it is typically never worth switching to
    /// kNoCompression.  Even if the input data is incompressible, the
    /// kSnappyCompression implementation will efficiently detect that and will
    /// switch to uncompressed mode.
    ///
    compression: CompressionType,

    /// EXPERIMENTAL: If true, append to existing MANIFEST and log files when
    /// a database is opened.  This can significantly speed up open.
    ///
    /// Default: currently false, but may become true later.
    ///
    reuse_logs:    bool,

    /// If non-null, use the specified filter policy to reduce disk reads.
    ///
    /// Many applications will benefit from passing the result of
    /// `new_bloom_filter_policy()` here.
    ///
    filter_policy: Box<dyn FilterPolicy>,
}

impl Default for Options {

    fn default() -> Self {
        trace!("Options::default: initializing default database options");

        Options {
            // -------- Behavior parameters --------
            comparator:             Box::new(BytewiseComparatorImpl::default()),
            create_if_missing:      false,
            error_if_exists:        false,
            paranoid_checks:        false,
            env:                    None,
            info_log:               None,

            // -------- Performance parameters --------
            write_buffer_size:      4 * 1024 * 1024,
            max_open_files:         1000,
            block_cache:            core::ptr::null_mut(),
            block_size:             4 * 1024,
            block_restart_interval: 16,
            max_file_size:          2 * 1024 * 1024,
            compression:            CompressionType::Snappy,
            reuse_logs:             false,

            // LevelDB uses nullptr here; we must supply *some* policy.
            // A no-op / pass-through filter is the closest semantic match.
            filter_policy:          Box::new(NullFilterPolicy::default()),
        }
    }
}
