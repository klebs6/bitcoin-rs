// ---------------- [ File: bitcoinleveldb-table/src/block.rs ]
/*!
  | Decodes the blocks generated by
  | block_builder.cc.
  |
  */

crate::ix!();

//-------------------------------------------[.cpp/bitcoin/src/leveldb/table/block.h]

pub struct Block {

    data:           *const u8,
    size:           usize,

    /**
      | Offset in data_ of restart array
      |
      */
    restart_offset: u32,

    /**
      | Block owns data_[]
      |
      */
    owned:          bool,
}

unsafe impl Send for Block {}
unsafe impl Sync for Block {}

//-------------------------------------------[.cpp/bitcoin/src/leveldb/table/block.cc]
impl Drop for Block {

    fn drop(&mut self) {
        if self.owned {
            tracing::debug!(
                "Block::drop: owned block dropped without explicit deallocation (size = {}, ptr = {:p})",
                self.size,
                self.data
            );
        } else {
            tracing::trace!(
                "Block::drop: nonâ€‘owned block dropped (size = {}, ptr = {:p})",
                self.size,
                self.data
            );
        }
    }
}

impl Block {

    /**
      | Initialize the block with the specified
      | contents.
      |
      */
    pub fn new(contents: &BlockContents) -> Self {
        let data_ptr = contents.data().data();
        let mut size = contents.data().size();
        let mut restart_offset: u32 = 0;

        tracing::trace!(
            "Block::new: initializing from contents: ptr={:p}, size={}, heap_allocated={}, cachable={}",
            data_ptr,
            size,
            contents.heap_allocated,
            contents.cachable
        );

        let trailer_len = core::mem::size_of::<u32>();

        if size < trailer_len {
            tracing::error!(
                "Block::new: contents too small ({}) for restart array; marking block as error",
                size
            );
            size = 0;
        } else {
            let max_restarts_allowed =
                (size - trailer_len) / trailer_len;

            // Compute actual restart count from the trailer.
            let tmp_block = Block {
                data: data_ptr,
                size,
                restart_offset: 0,
                owned: contents.heap_allocated,
            };

            let num_restarts = tmp_block.num_restarts() as usize;
            if num_restarts > max_restarts_allowed {
                tracing::error!(
                    "Block::new: NumRestarts ({}) exceeds maximum allowed ({}); marking block as error",
                    num_restarts,
                    max_restarts_allowed
                );
                size = 0;
            } else {
                let off = size
                    - (1 + num_restarts) * trailer_len;
                restart_offset = off as u32;
                tracing::trace!(
                    "Block::new: restart_offset={} (num_restarts={})",
                    restart_offset,
                    num_restarts
                );
            }
        }

        Block {
            data: data_ptr,
            size,
            restart_offset,
            owned: contents.heap_allocated,
        }
    }

    pub fn size(&self) -> usize {
        trace!("Block::size called; size={}", self.size);
        self.size
    }

    #[inline]
    pub fn num_restarts(&self) -> u32 {
        trace!(
            "Block::num_restarts called; size={}, data={:p}",
            self.size,
            self.data
        );

        let trailer_len = core::mem::size_of::<u32>();
        if self.size < trailer_len {
            error!(
                "Block::num_restarts called on block smaller than trailer (size={})",
                self.size
            );
            return 0;
        }

        unsafe {
            let offset = self.size - trailer_len;
            let ptr = self.data.add(offset);
            let bytes = core::slice::from_raw_parts(ptr, trailer_len);
            let num = decode_fixed32(bytes);
            trace!("Block::num_restarts decoded num_restarts={}", num);
            num
        }
    }

    pub fn new_iterator(&mut self, comparator: Box<dyn SliceComparator>) -> *mut LevelDBIterator {
        todo!();
        /*
            if (size_ < sizeof(uint32_t)) {
        return NewErrorIterator(Status::Corruption("bad block contents"));
      }
      const uint32_t num_restarts = NumRestarts();
      if (num_restarts == 0) {
        return NewEmptyIterator();
      } else {
        return new Iter(comparator, data_, restart_offset_, num_restarts);
      }
        */
    }
}

/**
  | Helper routine: decode the next block entry
  | starting at "p", storing the number of shared
  | key bytes, non_shared key bytes, and the length
  | of the value in "*shared", "*non_shared", and
  | "*value_length", respectively.  Will not
  | dereference past "limit".
  |
  | If any errors are detected, returns nullptr.
  | Otherwise, returns a pointer to the key delta
  | (just past the three decoded values).
  */
#[inline] pub fn decode_entry(
        p:            *const u8,
        limit:        *const u8,
        shared:       *mut u32,
        non_shared:   *mut u32,
        value_length: *mut u32) -> *const u8 {
    
    todo!();
        /*
            if (limit - p < 3) return nullptr;
      *shared = reinterpret_cast<const uint8_t*>(p)[0];
      *non_shared = reinterpret_cast<const uint8_t*>(p)[1];
      *value_length = reinterpret_cast<const uint8_t*>(p)[2];
      if ((*shared | *non_shared | *value_length) < 128) {
        // Fast path: all three values are encoded in one byte each
        p += 3;
      } else {
        if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
        if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
        if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
      }

      if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
        return nullptr;
      }
      return p;
        */
}

///--------------------
pub struct BlockIter {

    base:          LevelDBIterator,

    comparator:    Box<dyn SliceComparator>,

    /**
      | underlying block contents
      |
      */
    data:          *const u8,

    /**
      | Offset of restart array (list of fixed32)
      |
      */
    restarts:      u32,

    /**
      | Number of uint32_t entries in restart
      | array
      |
      */
    num_restarts:  u32,

    /**
      | current_ is offset in data_ of current
      | entry. >= restarts_ if !Valid
      |
      */
    current:       u32,

    /**
      | Index of restart block in which current_
      | falls
      |
      */
    restart_index: u32,

    key_:          String,
    value:         Slice,
    status:        Status,
}

impl BlockIter {

    #[inline] pub fn compare(&self, 
        a: &Slice,
        b: &Slice) -> i32 {
        
        todo!();
        /*
            return comparator_->Compare(a, b);
        */
    }

    /**
      | Return the offset in data_ just past
      | the end of the current entry.
      |
      */
    #[inline] pub fn next_entry_offset(&self) -> u32 {
        
        todo!();
        /*
            return (value_.data() + value_.size()) - data_;
        */
    }
    
    pub fn get_restart_point(&mut self, index: u32) -> u32 {
        
        todo!();
        /*
            assert(index < num_restarts_);
        return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
        */
    }
    
    pub fn seek_to_restart_point(&mut self, index: u32)  {
        
        todo!();
        /*
            key_.clear();
        restart_index_ = index;
        // current_ will be fixed by ParseNextKey();

        // ParseNextKey() starts at the end of value_, so set value_ accordingly
        uint32_t offset = GetRestartPoint(index);
        value_ = Slice(data_ + offset, 0);
        */
    }
    
    pub fn new(
        comparator:   Box<dyn SliceComparator>,
        data:         *const u8,
        restarts:     u32,
        num_restarts: u32) -> Self {
    
        todo!();
        /*
        : comparator(comparator),
        : data(data),
        : restarts(restarts),
        : num_restarts(num_restarts),
        : current(restarts_),
        : restart_index(num_restarts_),

            assert(num_restarts_ > 0);
        */
    }
    
    pub fn valid(&self) -> bool {
        
        todo!();
        /*
            return current_ < restarts_;
        */
    }
    
    pub fn status(&self) -> crate::Status {
        
        todo!();
        /*
            return status_;
        */
    }
    
    pub fn key(&self) -> Slice {
        
        todo!();
        /*
            assert(Valid());
        return key_;
        */
    }
    
    pub fn value(&self) -> Slice {
        
        todo!();
        /*
            assert(Valid());
        return value_;
        */
    }
    
    pub fn next(&mut self)  {
        
        todo!();
        /*
            assert(Valid());
        ParseNextKey();
        */
    }
    
    pub fn prev(&mut self)  {
        
        todo!();
        /*
            assert(Valid());

        // Scan backwards to a restart point before current_
        const uint32_t original = current_;
        while (GetRestartPoint(restart_index_) >= original) {
          if (restart_index_ == 0) {
            // No more entries
            current_ = restarts_;
            restart_index_ = num_restarts_;
            return;
          }
          restart_index_--;
        }

        SeekToRestartPoint(restart_index_);
        do {
          // Loop until end of current entry hits the start of original entry
        } while (ParseNextKey() && NextEntryOffset() < original);
        */
    }
    
    pub fn seek(&mut self, target: &Slice)  {
        
        todo!();
        /*
            // Binary search in restart array to find the last restart point
        // with a key < target
        uint32_t left = 0;
        uint32_t right = num_restarts_ - 1;
        while (left < right) {
          uint32_t mid = (left + right + 1) / 2;
          uint32_t region_offset = GetRestartPoint(mid);
          uint32_t shared, non_shared, value_length;
          const char* key_ptr =
              DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
                          &non_shared, &value_length);
          if (key_ptr == nullptr || (shared != 0)) {
            CorruptionError();
            return;
          }
          Slice mid_key(key_ptr, non_shared);
          if (Compare(mid_key, target) < 0) {
            // Key at "mid" is smaller than "target".  Therefore all
            // blocks before "mid" are uninteresting.
            left = mid;
          } else {
            // Key at "mid" is >= "target".  Therefore all blocks at or
            // after "mid" are uninteresting.
            right = mid - 1;
          }
        }

        // Linear search (within restart block) for first key >= target
        SeekToRestartPoint(left);
        while (true) {
          if (!ParseNextKey()) {
            return;
          }
          if (Compare(key_, target) >= 0) {
            return;
          }
        }
        */
    }
    
    pub fn seek_to_first(&mut self)  {
        
        todo!();
        /*
            SeekToRestartPoint(0);
        ParseNextKey();
        */
    }
    
    pub fn seek_to_last(&mut self)  {
        
        todo!();
        /*
            SeekToRestartPoint(num_restarts_ - 1);
        while (ParseNextKey() && NextEntryOffset() < restarts_) {
          // Keep skipping
        }
        */
    }
    
    pub fn corruption_error(&mut self)  {
        
        todo!();
        /*
            current_ = restarts_;
        restart_index_ = num_restarts_;
        status_ = Status::Corruption("bad entry in block");
        key_.clear();
        value_.clear();
        */
    }
    
    pub fn parse_next_key(&mut self) -> bool {
        
        todo!();
        /*
            current_ = NextEntryOffset();
        const char* p = data_ + current_;
        const char* limit = data_ + restarts_;  // Restarts come right after data
        if (p >= limit) {
          // No more entries to return.  Mark as invalid.
          current_ = restarts_;
          restart_index_ = num_restarts_;
          return false;
        }

        // Decode next entry
        uint32_t shared, non_shared, value_length;
        p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
        if (p == nullptr || key_.size() < shared) {
          CorruptionError();
          return false;
        } else {
          key_.resize(shared);
          key_.append(p, non_shared);
          value_ = Slice(p + non_shared, value_length);
          while (restart_index_ + 1 < num_restarts_ &&
                 GetRestartPoint(restart_index_ + 1) < current_) {
            ++restart_index_;
          }
          return true;
        }
        */
    }
}
