# bitcoinleveldb-skiplist

`bitcoinleveldb-skiplist` is a Rust crate that provides an implementation of a skip list data structure tailored for integration with LevelDB. Skip lists are a probabilistic data structure that offer a compromise between ease of implementation and performance, effectively facilitating fast search, insertion, and erasure operations. This implementation is optimized for using arenas for memory management, thus improving performance by reducing heap fragmentation and boosting cache friendliness.

## Overview

A skip list comprises layers of linked lists, where the bottom level is an ordinary sorted linked list. Each higher level acts as an express lane for the levels below, allowing fast transversal for search and insert operations. In `bitcoinleveldb-skiplist`, nodes and their corresponding levels are generated with a randomized height, maintaining a probabilistic balance similar to balanced trees while requiring less structural adjustment during insertions and deletions.

This crate's main components include:

- **`SkipListComparator<K>`**: A trait for custom comparison of keys.
- **`SkipListIterator<'a, K, C>`**: An iterator over the skip list allowing forward and backward traversal.
- **`SkipListNode<K>`**: Internal representation of a node in the skip list.
- **`SkipList<K, C>`**: The main data structure implementing the skip list with support for customizable comparators and arena-based memory allocation.

## Usage

This library is ideal for environments where efficient in-memory data storage and access patterns are crucial, such as in database engines and real-time computation systems. The `SkipList` allows custom comparator implementation by using the `SkipListComparator` trait, providing flexibility for domain-specific optimizations.

```rust
use bitcoinleveldb_skiplist::{SkipList, SkipListComparator};

// Comparator implementation for i32 keys
struct IntComparator;
impl SkipListComparator<i32> for IntComparator {
    fn compare(&self, a: &i32, b: &i32) -> i32 {
        a.cmp(b) as i32
    }
}

fn main() {
    let arena = Arena::new(); // Hypothetical arena allocator
    let skiplist = SkipList::new(IntComparator, &arena);
    // Basic operations can now be used on the skiplist...
}
```

## Features
- **Arena Memory Management**: Efficient memory allocation and reduced fragmentation.
- **Randomized Height Node Allocation**: Ensures optimal average performance.
- **Custom Comparator Support**: Enable various sorting criteria.

## License

This project is licensed under the MIT License.

## Disclaimer
This README.md file was generated by an AI model and may not be 100% accurate, however, it should be pretty good.
