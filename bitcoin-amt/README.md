# bitcoin-amt

Type-safe Bitcoin amount primitives and wallet ownership flags extracted from `bitcoin-core` semantics.

> **Note**: This README was generated by an AI model and may not be 100% accurate, though it should be a close approximation of the crate's intent and API.

---

## Overview

`bitcoin-amt` provides minimal but semantically rich primitives for working with Bitcoin wallet amounts and ownership classification, closely mirroring Bitcoin Core's `IsMine` logic and money range checks.

It focuses on three concerns:

1. **Amount representation** in satoshis, including negative values for intermediate accounting.
2. **Wallet ownership flags** ("IsMine" semantics) via a bitflag type.
3. **Cachable per-flag amounts** split between watch-only and spendable balances.

The crate is intentionally small and low-level. It is designed to be embedded within higher-level Bitcoin libraries, wallet engines, and UTXO/accounting layers.

## Crate Features at a Glance

- `Amount = i64` in **satoshis** (1 BTC = 100_000_000 sats).
- `money_range(&Amount) -> bool` validating values against `MAX_MONEY`.
- `IsMineType` as a `bitflags!`-based classification of ownership:
  - `ISMINE_NO`
  - `ISMINE_WATCH_ONLY`
  - `ISMINE_SPENDABLE`
  - `ISMINE_USED`
  - `ISMINE_ALL`
  - `ISMINE_ALL_USED`
  - `ISMINE_ENUM_ELEMENTS` (sentinel / count of logical enum elements)
- `IsMineFilter = u8`, suitable for compact storage and indexing.
- `CachableAmount`: an indexed cache of amounts keyed by `IsMine` flags, tracking which entries are valid via a `BitSet`.

This mirrors Bitcoin Core wallet semantics sufficiently to integrate with descriptor-based or legacy wallet designs.

## Installation

Add to your `Cargo.toml`:

```toml
[dependencies]
bitcoin-amt = "0.1.19"
```

The crate targets Rust **edition 2021** and is licensed under **MIT**.

## Core Types

### `Amount`

```rust
/// Amount in satoshis (can be negative)
pub type Amount = i64;
```

Design notes:
- **Unit**: always satoshis, not BTC.
- **Sign**: can be negative to support internal accounting (e.g., deltas, fees, reorg adjustments).

You are responsible for using `money_range` (or stronger invariants) to ensure that user-facing balances stay within the protocol-defined range.

### `IsMineFilter`

```rust
/// Used for bitflags of isminetype
pub type IsMineFilter = u8;
```

`IsMineFilter` is a compact, indexable representation (0-based) that corresponds to flags in `IsMineType` and to indices in the `CachableAmount::value` array.

It is suitable for:
- Array indexing
- Compact serialization (e.g., in persistence formats or network messages internal to a wallet implementation)

### `IsMineType`

```rust
bitflags! {
    pub struct IsMineType: u32 {
        const ISMINE_NO            = 0;
        const ISMINE_WATCH_ONLY    = 1 << 0;
        const ISMINE_SPENDABLE     = 1 << 1;
        const ISMINE_USED          = 1 << 2;
        const ISMINE_ALL           = Self::ISMINE_WATCH_ONLY.bits | Self::ISMINE_SPENDABLE.bits;
        const ISMINE_ALL_USED      = Self::ISMINE_ALL.bits        | Self::ISMINE_USED.bits;
        const ISMINE_ENUM_ELEMENTS = Self::ISMINE_ALL_USED.bits + 1;
    }
}
```

The semantics follow Bitcoin Core's `IsMine` description:

- **LegacyScriptPubKeyMan**
  - `ISMINE_NO`: scriptPubKey not in wallet.
  - `ISMINE_WATCH_ONLY`: scriptPubKey imported as watch-only.
  - `ISMINE_SPENDABLE`: scriptPubKey corresponds to an address whose private key is in the wallet.
  - `ISMINE_USED`: scriptPubKey corresponds to a **used** address (helps wallet hygiene, gap limit handling, and privacy heuristics).
  - `ISMINE_ALL`: all flags except `USED`.
  - `ISMINE_ALL_USED`: all flags including `USED`.

- **DescriptorScriptPubKeyMan / future ScriptPubKeyMan**
  - `ISMINE_NO`: scriptPubKey not in wallet.
  - `ISMINE_SPENDABLE`: scriptPubKey matches a descriptor-derived wallet script.
  - `ISMINE_USED`: same notion of usedness as above.

`ISMINE_ENUM_ELEMENTS` acts as a sentinel for sizing arrays that store per-flag values.

### `CachableAmount`

```rust
/// Cachable amount subdivided into watchonly and spendable parts.
pub struct CachableAmount {
    cached: BitSet,
    value: [Amount; IsMineType::ISMINE_ENUM_ELEMENTS.bits as usize],
}
```

`CachableAmount` maintains a small array of `Amount` values, each associated with a particular `IsMineFilter` index, and a parallel `BitSet` that tracks which entries are validly computed.

This is primarily used to cache balances in wallet contexts, e.g.:
- total watch-only value,
- total spendable value,
- partitioned by flags such as `USED`.

#### Methods

```rust
impl CachableAmount {
    #[inline]
    pub fn reset(&mut self) {
        self.cached.reset();
    }

    pub fn set(&mut self, filter: IsMineFilter, value: Amount) {
        self.cached.set(filter.into(), true);
        self.value[filter as usize] = value;
    }
}
```

- `reset` invalidates all cached values.
- `set` marks the entry for `filter` as valid and stores the `Amount` in the backing array.

Wallet implementations typically combine this with additional getters that:
- check the `BitSet` before reading a value,
- lazily compute aggregates if not cached.

## Range Checking

```rust
#[inline]
pub fn money_range(n_value: &Amount) -> bool {
    *n_value >= 0 && *n_value <= MAX_MONEY
}
```

`money_range` enforces the economic constraint that a value must be within `[0, MAX_MONEY]`, where `MAX_MONEY` is the protocol-level upper bound (typically 21_000_000 BTC expressed in satoshis, i.e. `2_100_000_000_000_000` sats).

Use this function whenever you:
- accept external values that should represent real balances,
- validate transaction outputs or computed wallet totals,
- guard against overflow or pathological values during deserialization.

Note: `Amount` can be negative, but `money_range` explicitly forbids negative values. This allows you to distinguish between internal deltas and externally valid balances.

## Example Usage

### Basic amount handling

```rust
use bitcoin_amt::{Amount, money_range};

fn validate_user_balance(balance_sats: i64) -> Option<Amount> {
    let amt: Amount = balance_sats;
    if money_range(&amt) {
        Some(amt)
    } else {
        None
    }
}
```

### Caching watch-only vs spendable

```rust
use bitcoin_amt::{Amount, IsMineFilter, CachableAmount};

fn update_cache(cache: &mut CachableAmount, watch_only: Amount, spendable: Amount) {
    const FILTER_WATCH_ONLY: IsMineFilter = 1; // example mapping
    const FILTER_SPENDABLE: IsMineFilter = 2;  // example mapping

    cache.set(FILTER_WATCH_ONLY, watch_only);
    cache.set(FILTER_SPENDABLE, spendable);
}
```

In a real wallet, `IsMineFilter` values should be aligned with your mapping from `IsMineType` variants to indices.

## Integration Notes

- **Repository**: <https://github.com/klebs6/bitcoin-rs>
- **License**: MIT
- **Intended consumers**: Low-level Bitcoin wallet engines, indexing nodes, UTXO managers, and analytic tooling that need to stay semantically close to Bitcoin Core.

The crate does not attempt to provide a complete wallet; instead, it aims to provide interoperable primitives for money amounts and ownership semantics that can be shared across higher-level components.

When integrating:
- Propagate `Amount` throughout your accounting layer in satoshis.
- Use `IsMineType` and `IsMineFilter` to partition balances.
- Employ `CachableAmount` in your balance cache or view abstraction to avoid recomputing aggregates on each query.

---

If any detail appears inconsistent with the actual implementation, please consult the source in the `bitcoin-rs` repository and treat this README as a high-level guide rather than a formal specification.
