// ---------------- [ File: bitcoinleveldb-block/src/block.rs ]
/*!
  | Decodes the blocks generated by
  | block_builder.cc.
  |
  */

crate::ix!();

//-------------------------------------------[.cpp/bitcoin/src/leveldb/table/block.h]

pub struct Block {

    pub(crate) data:           *const u8,
    pub(crate) size:           usize,

    /**
      | Offset in data_ of restart array
      |
      */
    pub(crate) restart_offset: u32,

    /**
      | Block owns data_[]
      |
      */
    pub(crate) owned:          bool,
}

impl Debug for Block {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        trace!("entering Debug::fmt for Block");

        // Pointer values are logged as raw addresses.
        let data_addr = self.data as usize;

        let result = f
            .debug_struct("Block")
            .field("data_ptr", &format_args!("{:#x}", data_addr))
            .field("size", &self.size)
            .field("restart_offset", &self.restart_offset)
            .field("owned", &self.owned)
            .finish();

        trace!("exiting Debug::fmt for Block");
        result
    }
}

unsafe impl Send for Block {}
unsafe impl Sync for Block {}

//-------------------------------------------[.cpp/bitcoin/src/leveldb/table/block.cc]
impl Block {

    #[inline]
    pub fn size(&self) -> usize {
        trace!("Block::size called => {}", self.size);
        self.size
    }

    #[inline]
    pub fn data_ptr(&self) -> *const u8 {
        trace!("Block::data_ptr called => {:p}", self.data);
        self.data
    }

    #[inline]
    pub fn restart_offset(&self) -> u32 {
        trace!(
            "Block::restart_offset called => {}",
            self.restart_offset
        );
        self.restart_offset
    }

    #[inline]
    pub fn is_owned(&self) -> bool {
        trace!("Block::is_owned called => {}", self.owned);
        self.owned
    }

    #[inline]
    pub fn num_restarts(&self) -> u32 {
        trace!(
            "Block::num_restarts called; size={}, data={:p}",
            self.size,
            self.data
        );

        let trailer_len = core::mem::size_of::<u32>();
        if self.size < trailer_len {
            error!(
                "Block::num_restarts called on block smaller than trailer (size={})",
                self.size
            );
            return 0;
        }

        unsafe {
            let offset = self.size - trailer_len;
            let ptr    = self.data.add(offset);
            let num    = bitcoinleveldb_coding::decode_fixed32(ptr);
            trace!("Block::num_restarts decoded num_restarts={}", num);
            num
        }
    }
}

#[cfg(test)]
mod block_struct_behavior_tests {
    use super::*;

    #[traced_test]
    fn block_accessors_report_expected_values() {
        let mut backing = vec![0u8; 8];
        let trailer = 7u32.to_le_bytes();
        backing[4..].copy_from_slice(&trailer);

        let data_ptr = backing.as_ptr();
        let size     = backing.len();
        let restart_offset = 4u32;

        let block = Block {
            data:           data_ptr,
            size,
            restart_offset,
            owned:          false,
        };

        trace!("constructed Block in test: data={:p}, size={}, restart_offset={}, owned={}", data_ptr, size, restart_offset, false);

        assert_eq!(block.size(), size);
        assert_eq!(block.data_ptr(), data_ptr);
        assert_eq!(block.restart_offset(), restart_offset);
        assert!(!block.is_owned());
    }

    #[traced_test]
    fn block_num_restarts_returns_zero_for_block_smaller_than_trailer() {
        let block = Block {
            data:           core::ptr::null(),
            size:           core::mem::size_of::<u32>() - 1,
            restart_offset: 0,
            owned:          false,
        };

        trace!("testing num_restarts on undersized block");
        let n = block.num_restarts();
        debug!("num_restarts for undersized block => {}", n);
        assert_eq!(n, 0);
    }

    #[traced_test]
    fn block_num_restarts_decodes_trailer_as_little_endian_u32() {
        let expected_restarts: u32 = 42;
        let mut backing = vec![0u8; 16];
        let trailer = expected_restarts.to_le_bytes();
        backing[12..].copy_from_slice(&trailer);

        let block = Block {
            data:           backing.as_ptr(),
            size:           backing.len(),
            restart_offset: 0,
            owned:          false,
        };

        trace!("testing num_restarts on valid block, size={}", backing.len());
        let decoded = block.num_restarts();
        debug!("decoded num_restarts => {}", decoded);
        assert_eq!(decoded, expected_restarts);
    }
}
