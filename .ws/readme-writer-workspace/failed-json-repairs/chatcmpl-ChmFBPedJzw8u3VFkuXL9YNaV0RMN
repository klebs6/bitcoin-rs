{
  "fields": {
    "crate_name": "bitcoinleveldb-sync",
    "full_readme_markdown": "# bitcoinleveldb-sync\n\nThin synchronization helpers for integrating `parking_lot` mutexes with LevelDB-derived code in `bitcoin-rs`.\n\nThis crate currently provides a single primitive, `MutexLock`, which wraps a raw pointer to a `parking_lot::RawMutex` and acquires/releases the lock using RAII. The design mirrors the C++ annotations (`SCOPED_LOCKABLE`, `EXCLUSIVE_LOCK_FUNCTION`, `UNLOCK_FUNCTION`) used in the original Bitcoin Core / LevelDB codebase, enabling relatively direct porting of concurrency patterns while still feeling idiomatic to Rust.\n\n> **Note**  
> This README was generated by an AI model and may not be 100% accurate; however, it should be a close and useful description of the crate's intent and usage.\n\n---\n\n## Motivation\n\nThe original LevelDB and Bitcoin Core codebases rely on coarse- and fine-grained mutex locking via raw pointers and thread-safety annotations. When porting such code to Rust—especially when staying close to the original structure for auditability and behavioral fidelity—it is sometimes convenient to:\n\n- Keep mutexes allocated and owned in one place (C++-like global or struct fields),\n- Pass raw pointers to low-level helpers, and\n- Use lexical, RAII-style locking that is explicit in function signatures.\n\n`bitcoinleveldb-sync` exists as a compatibility layer for exactly this scenario in the `bitcoin-rs` project. It is intentionally small and narrow in scope.\n\n---\n\n## Crate features\n\n- **RAII mutex guard over `parking_lot::RawMutex` pointers**  \n  `MutexLock` acquires a `RawMutex` in `new` and releases it in `Drop`.\n\n- **Pointer-based interface**  \n  Uses `*mut parking_lot::RawMutex` to closely mirror the C++ interface during incremental porting.\n\n- **Annotation-friendly**  \n  Attributes like `#[SCOPED_LOCKABLE]`, `#[EXCLUSIVE_LOCK_FUNCTION(mu)]`, and `#[UNLOCK_FUNCTION]` are preserved, which can be useful for static-analysis or documentation tools mirroring the C++ thread-safety annotations.\n\n- **Minimal dependency surface**  \n  Depends on `parking_lot` for the underlying primitive, and otherwise stays out of your way.\n\n---\n\n## Safety model\n\n`MutexLock` is intentionally low-level and makes the following assumptions:\n\n- The caller passes a **valid**, properly initialized pointer to a `parking_lot::RawMutex`.\n- The mutex outlives all `MutexLock` instances created from that pointer.\n- The same raw mutex is not concurrently locked by other mechanisms that violate `parking_lot`'s locking discipline.\n\nViolating these conditions is **undefined behavior** and can cause deadlocks, memory corruption, or other failures. This is by design: the crate is intended for controlled, internal use in `bitcoin-rs`, rather than as a general-purpose concurrency abstraction.\n\n---\n\n## Type overview\n\n```rust\nuse parking_lot::RawMutex;\n\n#[SCOPED_LOCKABLE]\npub struct MutexLock {\n    mu: *const RawMutex,\n}\n\nimpl Drop for MutexLock {\n    #[UNLOCK_FUNCTION]\n    fn drop(&mut self) {\n        if !self.mu.is_null() {\n            unsafe { (*self.mu).unlock(); }\n        }\n    }\n}\n\nimpl MutexLock {\n    #[EXCLUSIVE_LOCK_FUNCTION(mu)]\n    pub fn new(mu: *mut RawMutex) -> Self {\n        if mu.is_null() {\n            panic!(\"must provide valid pointer to this constructor\");\n        }\n\n        let mut x = Self { mu };\n\n        unsafe { (*x.mu).lock(); }\n\n        x\n    }\n}\n```\n\nConceptually, `MutexLock` is equivalent to a very small subset of a classic RAII lock-guard:\n\n- `MutexLock::new(mu)` → lock operation,\n- `Drop` implementation → unlock operation.\n\nUnlike `parking_lot::MutexGuard`, it operates on `RawMutex` and a raw pointer, without any notion of associated protected data.\n\n---\n\n## Usage\n\n### Basic example\n\n```rust\nuse bitcoinleveldb_sync::MutexLock;\nuse parking_lot::RawMutex;\nuse std::sync::Arc;\n\nstruct SharedState {\n    mu: RawMutex,\n    // additional fields, e.g. shared data\n}\n\nimpl SharedState {\n    fn critical_section(&self) {\n        // SAFETY: &self ensures that `self.mu` lives for the duration,\n        // and we never move or free the mutex while locked.\n        let _lock = MutexLock::new(&self.mu as *const RawMutex as *mut RawMutex);\n\n        // Perform operations that must be mutually exclusive.\n        // When `_lock` is dropped (end of scope or panic), the mutex is unlocked.\n    }\n}\n\nfn main() {\n    let state = Arc::new(SharedState { mu: RawMutex::INIT });\n\n    let s2 = state.clone();\n    let handle = std::thread::spawn(move || {\n        s2.critical_section();\n    });\n\n    state.critical_section();\n    handle.join().unwrap();\n}\n```\n\nThe above example shows how you might embed a `RawMutex` into a shared struct and use `MutexLock` to create a scoped critical section.\n\n### Error handling and panics\n\n- If `MutexLock::new` receives a null pointer, it panics with a diagnostic message.\n- If a panic occurs inside the critical section, the `Drop` implementation still runs, ensuring the mutex is released.\n\nThis emulates the exception-safety guarantees of C++ RAII in the presence of Rust panics.\n\n---\n\n## Design notes\n\n### Why `RawMutex` and raw pointers?\n\n`parking_lot::RawMutex` is a low-level primitive that does not associate data with the mutex, which makes it suitable for porting C/C++ code that already manages its own shared state layout. `MutexLock` deliberately:\n\n- Avoids generics and lifetimes beyond the minimal `'static` expectation implicit in the raw pointer,\n- Leaves responsibility for memory management to the caller,\n- Minimizes overhead and abstraction leakage in performance-sensitive code paths (e.g., LevelDB compaction, block validation pipelines).\n\nFor idiomatic Rust code that is not trying to remain structurally close to LevelDB/Bitcoin Core, you should usually prefer higher-level synchronisation primitives such as:\n\n- `parking_lot::Mutex<T>` and `MutexGuard<T>`,\n- `std::sync::Mutex<T>` and `MutexGuard<T>`.\n\n### Thread-safety annotations\n\nThe attributes like `#[SCOPED_LOCKABLE]`, `#[EXCLUSIVE_LOCK_FUNCTION(mu)]`, and `#[UNLOCK_FUNCTION]` do not have semantics in stable Rust by themselves. They are typically used by:\n\n- Static analysis tools,\n- Documentation generators,\n- Internal compile-time checks in mixed-language environments.\n\nPreserving these annotations makes ported code easier to cross-reference with the original C++ implementation, and keeps the mental model aligned with the existing concurrency contracts.\n\n---\n\n## Integration with `bitcoin-rs`\n\nThis crate lives in the `bitcoin-rs` monorepo:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\nIt is intended as an internal building block for the LevelDB-related components and other modules that require very precise control of locking behavior without rearchitecting the original algorithms.\n\nBecause it is a micro-crate, its public surface is deliberately small and may evolve as `bitcoin-rs`'s internal needs change.\n\n---\n\n## License\n\nMIT\n\nThis matches the license of the surrounding `bitcoin-rs` project. Consult the repository for full licensing details and notices.\n\n---\n\n## Caveats and guidance\n\n- This crate is **not** a general-purpose concurrency toolkit; it is a specialized shim.\n- Misuse of raw pointers or `RawMutex` can cause memory-unsafe behavior. Treat all `unsafe` blocks and pointer manipulations with rigorous scrutiny.\n- When writing new Rust-native code, prefer idiomatic `parking_lot::Mutex` or `std::sync::Mutex` instead of this crate, unless you specifically need exact semantic alignment with LevelDB/Bitcoin Core patterns.\n",
    "package_categories": [
      "concurrency",
      "development-tools",
      "cryptography"
    ],
    "package_description": "Low-level RAII-style lock helper for parking_lot::RawMutex, used to port LevelDB/Bitcoin Core-style mutex patterns into the bitcoin-rs project via raw pointer-based scoped locking.",
    "package_keywords": [
      "bitcoin",
      "leveldb",
      "mutex",
      "parking_lot",
      "synchronization"
    ]
  },
  "struct_docs": " This structure is a directive indicating which fields we need you to provide for us in your response to our query.\n",
  "struct_name": "AiReadmeWriterDesiredOutput",
  "type": "struct"
}