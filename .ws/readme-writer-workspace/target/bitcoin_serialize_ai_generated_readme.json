{
  "crate_name": "bitcoin-serialize",
  "full_readme_markdown": "# bitcoin-serialize\n\nLow-level, allocation-conscious (de)serialization primitives that mirror Bitcoin Core's C++ serialization framework, implemented in Rust.\n\nThe crate targets protocol implementers and systems engineers who need **byte-for-byte compatibility** with Bitcoin Core's wire format, including CompactSize, VarInt, fixed-width integer encodings, IEEE-754 doubles, vectors, maps, and custom formatter-based serialization.\n\n> NOTE: This README.md was generated by an AI model and may not be perfectly accurate. It is intended to be a high-fidelity approximation of the crate's design and usage, but the source code is the ultimate authority.\n\n---\n\n## Design goals\n\n- **Compatibility with Bitcoin Core**\n  - Match the semantics of C++ `Serialize` / `Unserialize`, `CSizeComputer`, `CompactSize`, `VarInt`, `Using<Formatter>`, and `VectorFormatter`.\n  - Preserve DoS-safety constraints, especially incremental vector allocation with configurable maximum block size.\n\n- **Zero-/low-cost abstractions**\n  - Traits and const generics are used to resolve most decisions at compile time.\n  - `SizeComputer` pretends to be an `io::Write` sink, allowing size computation to reuse normal `BtcSerialize` implementations.\n\n- **Formatter-based extensibility**\n  - Explicit separation between **what** is serialized (your types) and **how** bytes are laid out (formatters like `VarIntFormatter`, `CompactSizeFormatter`, `CustomUintFormatter`, etc.).\n  - Formatters compose (\n    e.g. `VectorFormatter<VarIntFormatter<...>>`, nested `VectorFormatter` for matrices, or wrapper-based adapters).\n\n- **Type safety with const generics**\n  - `VarIntMode` and `CustomUintFormatter<const BYTES: i32, const BIG_ENDIAN: bool>` enforce invariants at compile time.\n  - `ModeConstraint` ensures that only admissible integer domains are used for a given `VarIntMode`.\n\n---\n\n## Core concepts\n\n### 1. `BtcSerialize` / `BtcUnserialize`\n\nThe crate defines its own serialization traits instead of using `serde`:\n\n```rust\npub trait BtcSerialize<Stream> {\n    fn serialize(&self, s: &mut Stream);\n}\n\npub trait BtcUnserialize<Stream> {\n    fn unserialize(&mut self, s: &mut Stream);\n}\n``\n\n- `Stream` is usually something that implements `std::io::Write` or `std::io::Read`, but can also be `SizeComputer` or other custom streams.\n- A wide range of standard types has built-in implementations, e.g. primitive integers, `bool`, `String`, arrays of `u8`, `Vec<T>`, `HashMap`, `HashSet`, `Box`, `Arc`, tuples, and a Bitcoin-like `PreVector`.\n\nThis trait design deliberately mirrors Bitcoin Core's design, enabling transposition of protocol code from C++ to Rust with minimal structural changes.\n\n### 2. Formatters and `ValueFormatter<T>`\n\nA **formatter** encapsulates *how* a value of type `T` is physically encoded:\n\n```rust\npub trait ValueFormatter<T> {\n    fn ser<S: Write>(&mut self, s: &mut S, value: &T);\n    fn unser<S: Read>(&mut self, s: &mut S, value: &mut T);\n}\n```\n\nKey formatters provided:\n\n- `VarIntFormatter<const Mode: VarIntMode>` – Bitcoin's VarInt encoding with pluggable modes.\n- `CompactSizeFormatter<const RangeCheck: bool>` – Bitcoin's CompactSize length encoding with optional maximum-size enforcement.\n- `EncodedDoubleFormatter` – bit-exact IEEE-754 `f64` codec using the raw `u64` payload.\n- `VectorFormatter<F>` – collection formatter parameterized by an element formatter `F`.\n- `CustomUintFormatter<const BYTES: i32, const BIG_ENDIAN: bool>` – fixed-width unsigned integer formatter with compile-time width and endianness.\n- `DefaultFormatter` – adapter connecting any `T` that already implements `BtcSerialize`/`BtcUnserialize` to the formatter interface.\n- `LimitedStringFormatter<'a, const Limit: usize>` – string formatter with compile-time maximum length.\n\nThese formatters underpin the `Wrapper<'a, F, T>` type and the provided macros.\n\n### 3. `Wrapper` and `using`\n\n`Wrapper<'a, F, T>` directs serialization of `T` through a specific formatter `F` while reusing the generic `BtcSerialize` / `BtcUnserialize` machinery:\n\n```rust\npub struct Wrapper<'a, F, T> {\n    object:  &'a mut T,\n    _marker: PhantomData<F>,\n}\n\npub fn using<'a, F, T>(t: &'a mut T) -> Wrapper<'a, F, T> {\n    Wrapper::new(t)\n}\n```\n\nThe crate implements `BtcSerialize` and `BtcUnserialize` for `Wrapper<'a, F, T>` whenever `F: ValueFormatter<T>`.\n\nThis is analogous to `Using<Formatter>(obj)` in Bitcoin Core and allows you to write:\n\n```rust\nuse bitcoin_serialize::{using, VarIntFormatter, VarIntMode, BtcSerialize};\n\nfn write_varint_u64<W: std::io::Write>(w: &mut W, value: &mut u64) {\n    w.serialize(&using::<VarIntFormatter<{ VarIntMode::Default }>, _>(value));\n}\n```\n\nIn practice, you often use the macro sugar instead.\n\n### 4. VarInt modes and constraints\n\nBitcoin's VarInt encoding is specialized and slightly nontrivial. This crate models supported encodings via a const-generic enum:\n\n```rust\n#[derive(Clone, Debug, ConstParamTy, PartialEq, Eq)]\npub enum VarIntMode {\n    Default,\n    NonNegativeSigned,\n}\n\npub trait ModeConstraint<const M: VarIntMode, I> {}\n```\n\n`ModeConstraint` is implemented selectively:\n\n```rust\nimpl<I: Unsigned> ModeConstraint<{ VarIntMode::Default }, I> for () {}\nimpl<I: Signed>   ModeConstraint<{ VarIntMode::NonNegativeSigned }, I> for () {}\n```\n\nThis statically prevents misuse; for example, you cannot accidentally pass a signed integer to `VarIntMode::Default`.\n\nEncoding/decoding is implemented by:\n\n```rust\npub fn write_var_int<Stream, I, const Mode: VarIntMode>(os: &mut Stream, n: I) where\n    (): ModeConstraint<Mode, I>,\n    Stream: Write,\n    I: Into<u128> + Copy\n{ /* ... */ }\n\npub fn read_var_int<Stream, I, const Mode: VarIntMode>(is: &mut Stream) -> I where\n    (): ModeConstraint<Mode, I>,\n    Stream: Read,\n    I: TryFrom<u128>,\n    <I as TryFrom<u128>>::Error: core::fmt::Debug\n{ /* ... */ }\n```\n\nMathematically, the encoding uses a **prefix-decremented base-128 representation** (matching Bitcoin Core), where all but the final byte have the high continuation bit set and an adjusted magnitude to maintain canonical encoding.\n\n`VarIntFormatter<Mode>` hooks this into the formatter interface and further supports the `varint!` and `varint_mode!` macros.\n\n### 5. CompactSize encoding\n\nBitcoin’s `CompactSize` is a non-linear variable-length integer encoding optimized for the typical case of small lengths but able to represent up to 64-bit values:\n\n- `n < 253`      → single byte `n`.\n- `n ≤ 0xFFFF`   → `0xFD` followed by `u16` little-endian.\n- `n ≤ 0xFFFF_FFFF` → `0xFE` followed by `u32` little-endian.\n- else           → `0xFF` followed by `u64` little-endian.\n\nThe crate exposes both pure functions and a formatter interface:\n\n```rust\npub fn get_size_of_compact_size(n_size: u64) -> u32;\npub fn write_compact_size<Stream: Write>(os: &mut Stream, n_size: u64);\npub fn read_compact_size<Stream: Read>(is: &mut Stream, range_check: Option<bool>) -> u64;\n\npub struct CompactSizeFormatter<const RangeCheck: bool>;\n```\n\n`RangeCheck = true` enforces `n_size <= MAX_SIZE` (a DoS resilience guard, as in Bitcoin Core) and panics otherwise.\n\n---\n\n## Helper macros\n\nThis crate provides a macro DSL that mirrors Bitcoin Core’s C++ macro layer.\n\n### `varint!` and `varint_mode!`\n\n```rust\n#[macro_export]\nmacro_rules! varint_mode {{\n    ($obj:expr, $mode:ident) => {\n        $crate::var_int_formatter::VarIntFormatter::<{\n            $crate::var_int_mode::VarIntMode::$mode\n        }>::new($obj)\n    };\n}}\n\n#[macro_export]\nmacro_rules! varint {{\n    ($obj:expr) => {\n        $crate::var_int_formatter::VarIntFormatter::<{\n            $crate::var_int_mode::VarIntMode::Default\n        }>::new($obj)\n    };\n}}\n```\n\nUsage:\n\n```rust\nuse bitcoin_serialize::{varint, BtcSerialize};\n\nfn write_version<W: std::io::Write>(w: &mut W, version: &mut u32) {\n    w.serialize(&varint!(version));\n}\n```\n\n### `compactsize!`\n\n```rust\n#[macro_export]\nmacro_rules! compactsize {{\n    ($obj:expr) => {\n        $crate::compact_size_formatter::CompactSizeFormatter::<true>::new($obj)\n    };\n}}\n```\n\n`RangeCheck = true` is wired in; this is appropriate for length fields.\n\nUsage:\n\n```rust\nuse bitcoin_serialize::{compactsize, BtcSerialize};\n\nfn write_len<W: std::io::Write>(w: &mut W, len: &mut u64) {\n    w.serialize(&compactsize!(len));\n}\n```\n\n### `limited_string!`\n\n```rust\n#[macro_export]\nmacro_rules! limited_string {{\n    ($obj:expr, $n:ident) => {\n        $crate::limited_string_formatter::LimitedStringFormatter::<$n> { item: $obj }\n    };\n}}\n```\n\nAllows enforcing a compile-time upper bound on decoded string length.\n\n### `readwrite!`, `readwriteas!`, `ser_read!`, `ser_write!`, and `formatter_methods!`\n\nThese macros help you implement C++-style composite serialization logic for your own types:\n\n```rust\n#[macro_export]\nmacro_rules! formatter_methods {{\n    ($cls:ident, $obj:ident) => {\n        fn ser<Stream: std::io::Write>(&self, s: &mut Stream) {\n            Self::serialization_ops(self, s, $crate::action::SerActionSerialize {})\n        }\n        fn unser<Stream: std::io::Read>(&mut self, s: &mut Stream) {\n            Self::serialization_ops(self, s, $crate::action::SerActionUnserialize {})\n        }\n        fn serialization_ops<Stream, Op>(\n            &mut self,\n            s: &mut Stream,\n            ser_action: Op,\n        ) where\n            Stream: std::io::Read + std::io::Write,\n            Op: crate::action::SerActionSerialize + crate::action::SerActionUnserialize,\n        {\n            let $obj = self;\n            // user-supplied body follows the macro invocation\n        }\n    };\n}}\n```\n\nExample – implementing a custom formatter and plugging it into `BtcSerialize`:\n\n```rust\nuse bitcoin_serialize::{\n    formatter_methods,\n    serialize_methods,\n    readwrite,\n    varint,\n    BtcSerialize,\n    BtcUnserialize,\n};\n\n#[derive(Clone, Default)]\nstruct MyHeader {\n    version: i32,\n    timestamp: u32,\n}\n\nstruct MyHeaderFormatter;\n\nimpl MyHeaderFormatter {\n    formatter_methods!(MyHeaderFormatter, obj);\n}\n\n// Provide the serialization body:\nimpl MyHeaderFormatter {\n    fn serialization_ops<Stream, Op>(\n        &mut self,\n        s: &mut Stream,\n        op: Op,\n    ) where\n        Stream: std::io::Read + std::io::Write,\n        Op: bitcoin_serialize::SerActionSerialize + bitcoin_serialize::SerActionUnserialize,\n    {\n        let obj = self; // already set by macro in the real code\n        // Example layout: VarInt version, then raw timestamp\n        readwrite!(s, op, varint!(&mut obj.version), &mut obj.timestamp);\n    }\n}\n\n// Tie it to BtcSerialize / BtcUnserialize for the type of interest:\nserialize_methods!(MyHeader, obj);\n```\n\n> Note: The exact macro composition in real code is slightly different; refer to the examples and the source for idiomatic patterns.\n\n### `serialize_methods!`\n\n```rust\n#[macro_export]\nmacro_rules! serialize_methods {{\n    ($cls:ident, $obj:ident) => {\n        impl<Stream: std::io::Write> $crate::serialize::BtcSerialize<Stream> for $cls {\n            fn serialize(&self, s: &mut Stream) {\n                let mut me = self.clone();\n                me.ser(s);\n            }\n        }\n        impl<Stream: std::io::Read> $crate::unserialize::BtcUnserialize<Stream> for $cls {\n            fn unserialize(&mut self, s: &mut Stream) {\n                self.unser(s);\n            }\n        }\n    };\n}}\n```\n\nThis macro bridges a type that exposes `ser` and `unser` methods into `BtcSerialize` / `BtcUnserialize` via cloning for the serialize phase.\n\n---\n\n## Size computation and `SizeComputer`\n\nComputing serialized sizes without actually emitting bytes is needed for resource planning and fee computation. This crate provides a faithful reimplementation of `CSizeComputer`:\n\n```rust\npub struct SizeComputer {\n    n_size:    usize,\n    n_version: i32,\n}\n\nimpl SizeComputer {\n    pub fn new(n_version_in: i32) -> Self;\n    pub fn add_bytes(&mut self, n_size: usize);\n    pub fn write_ptr(&mut self, _psz: *const u8, n_size: usize);\n    pub fn seek(&mut self, n_size: usize);\n    pub fn size(&self) -> usize;\n    pub fn get_version(&self) -> i32;\n}\n\nimpl Write for SizeComputer { /* increments counters only */ }\n\nimpl<'a, T> std::ops::Shl<&'a T> for SizeComputer\nwhere\n    T: BtcSerialize<SizeComputer>,\n{\n    type Output = SizeComputer;\n    fn shl(mut self, rhs: &'a T) -> Self::Output { /* ... */ }\n}\n```\n\nConvenience functions:\n\n```rust\npub fn get_serialize_size<T>(t: &T, n_version: Option<i32>) -> usize\nwhere\n    T: BtcSerialize<SizeComputer>;\n\npub fn get_serialize_size_many<Args>(n_version: i32, args: &Args) -> usize\nwhere\n    Args: SerializeMany<SizeComputer>;\n```\n\nThis allows you to compute sizes for arbitrary objects and tuples that implement `BtcSerialize` or `SerializeMany` without code duplication.\n\nExample:\n\n```rust\nuse bitcoin_serialize::{BtcSerialize, SizeComputer, get_serialize_size};\n\n#[derive(Clone)]\nstruct TxHeader { /* fields with BtcSerialize implementations */ }\n\nfn size_of_header(h: &TxHeader) -> usize {\n    get_serialize_size(h, Some(0))\n}\n```\n\n---\n\n## Vector and matrix helpers for `f64`\n\nThe crate includes dedicated helpers for serialization of vectors and matrices of `f64`, using `EncodedDoubleFormatter` under the hood:\n\n```rust\npub fn write_vec_f64_fmt<S: Write>(s: &mut S, v: &Vec<f64>);\npub fn read_vec_f64_fmt<S: Read>(s: &mut S) -> Vec<f64>;\n\npub fn write_matrix_f64_fmt<S: Write>(s: &mut S, m: &Vec<Vec<f64>>);\npub fn read_matrix_f64_fmt<S: Read>(s: &mut S) -> Vec<Vec<f64>>;\n```\n\nSerialization layout:\n\n- A `Vec<T>` is encoded as a CompactSize length, followed by each element encoded by the chosen formatter.\n- `Vec<f64>` therefore becomes: `CompactSize(len)`, then `len` encoded doubles.\n- A `Vec<Vec<f64>>` (matrix) nests `VectorFormatter<EncodedDoubleFormatter>`, resulting in a CompactSize row count, then each row as `Vec<f64>`.\n\nThis design is suitable for deterministic numerical serialization, where exact IEEE-754 bit patterns must be preserved for reproducibility (e.g. consensus-critical simulations, deterministic randomization, or cryptographic precomputation tables).\n\n---\n\n## Low-level primitives and utilities\n\nThe crate also exposes several low-level, Bitcoin-compatible primitives:\n\n- **Fixed-endian integer IO**:\n\n  ```rust\n  pub fn write_u32_le<W: Write>(w: &mut W, v: u32) -> IoResult<()>;\n  pub fn read_u32_le<R: Read>(r: &mut R) -> IoResult<u32>;\n\n  pub fn ser_writedata8<Stream: Write>(s: &mut Stream, obj: u8);\n  pub fn ser_writedata16<Stream: Write>(s: &mut Stream, obj: u16);\n  pub fn ser_writedata32<Stream: Write>(s: &mut Stream, obj: u32);\n  pub fn ser_writedata64<Stream: Write>(s: &mut Stream, obj: u64);\n\n  pub fn ser_readdata8<Stream: Read>(s: &mut Stream) -> u8;\n  pub fn ser_readdata16<Stream: Read>(s: &mut Stream) -> u16;\n  pub fn ser_readdata32<Stream: Read>(s: &mut Stream) -> u32;\n  pub fn ser_readdata64<Stream: Read>(s: &mut Stream) -> u64;\n  ```\n\n- **IEEE-754 double encoding**:\n\n  ```rust\n  pub fn encode_double(v: f64) -> u64;\n  pub fn decode_double(x: u64) -> f64;\n\n  pub fn write_encoded_f64<W: Write>(w: &mut W, v: f64) -> IoResult<()>;\n  pub fn read_encoded_f64<R: Read>(r: &mut R) -> IoResult<f64>;\n  ```\n\n- **Fast uniform mapping** (`map_into_range`): Given a 64-bit uniformly random `x` in `[0, 2^64)`, map it uniformly into `[0, n)` by taking the upper 64 bits of `x * n`:\n\n  ```rust\n  pub fn map_into_range(x: u64, n: u64) -> u64;\n  ```\n\n  This is based on Lemire's fast modulo reduction without bias:\n\n  \\[\n  \\text{map}(x, n) = \\left\\lfloor \\frac{x \\cdot n}{2^{64}} \\right\\rfloor\n  \\]\n\n  On platforms with `__int128` support, this is implemented directly; otherwise it falls back to a 32×32→64-bit decomposition.\n\n---\n\n## Tuple serialization (`SerializeMany` / `UnserializeMany`)\n\nTo emulate Bitcoin Core's variadic templates for serializing multiple arguments in lockstep, the crate defines:\n\n```rust\npub trait SerializeMany<Stream> {\n    fn serialize_many(&self, s: &mut Stream);\n}\n\npub trait UnserializeMany<Stream> {\n    fn unserialize_many(&mut self, s: &mut Stream);\n}\n```\n\nImplementations are provided for tuples up to arity 4 (and can be extended). This is what powers macros like `readwrite!` and enables `get_serialize_size_many`.\n\nExample:\n\n```rust\nuse bitcoin_serialize::{SerializeMany, UnserializeMany, BtcSerialize, BtcUnserialize};\n\nfn write_pair<S: std::io::Write, A, B>(s: &mut S, a: &A, b: &B)\nwhere\n    S: std::io::Write,\n    A: BtcSerialize<S>,\n    B: BtcSerialize<S>,\n{\n    (a, b).serialize_many(s);\n}\n```\n\n---\n\n## Safety and failure modes\n\n- **Panics on malformed data**: For consensus-like usage, it is often preferable to abort rather than attempt recovery on structurally invalid data. Functions such as `read_compact_size`, `read_var_int`, and `CustomUintFormatter::*` will panic on non-canonical encodings or out-of-range values.\n- **Bounds checks**: `CompactSize` and vector deserialization apply range checks and incremental allocation limits (`MAX_VECTOR_ALLOCATE`) to reduce memory-exhaustion attack surface.\n- **`unsafe` usage**: Restricted to performance-critical string handling (`String::as_mut_vec()` length manipulation) and slice reinterpretation for `&[u8]` deserialization. These sections are carefully constrained and mirror the C++ semantics.\n\nWhen integrating into external systems, consider whether panics are acceptable or whether additional defensive wrappers should be introduced.\n\n---\n\n## Example: serializing a simple struct\n\nSuppose you have a basic header struct and want a Bitcoin-like serialization layout:\n\n```rust\nuse bitcoin_serialize::{\n    BtcSerialize, BtcUnserialize,\n    write_compact_size, read_compact_size,\n    ser_writedata32, ser_readdata32,\n};\n\n#[derive(Clone, Default)]\nstruct SimpleHeader {\n    version: u32,\n    payload_size: u64,\n}\n\nimpl<Stream: std::io::Write> BtcSerialize<Stream> for SimpleHeader {\n    fn serialize(&self, s: &mut Stream) {\n        ser_writedata32(s, self.version);\n        write_compact_size(s, self.payload_size);\n    }\n}\n\nimpl<Stream: std::io::Read> BtcUnserialize<Stream> for SimpleHeader {\n    fn unserialize(&mut self, s: &mut Stream) {\n        self.version = ser_readdata32(s);\n        self.payload_size = read_compact_size(s, Some(true));\n    }\n}\n```\n\nWith this in place, `SimpleHeader` can be serialized to any stream that implements `Write`, or to a `SizeComputer` for size estimation.\n\n---\n\n## When to use this crate\n\nUse `bitcoin-serialize` when:\n\n- You need **exact compatibility** with Bitcoin Core's wire-level serialization.\n- You are porting or reusing C++ serialization logic and want a **nearly isomorphic Rust API**, including macros and formatters.\n- You need deterministic, low-level control over the encoded byte layout, including advanced constructs like partial streams, size pre-computation, custom allocators, or incremental vector decoding.\n\nIf you only require high-level schema-based serialization and do not care about Bitcoin Core compatibility, `serde` with a suitable data format might be more appropriate. This crate is specialized for Bitcoin-style protocols and the engineering constraints that accompany them.\n\n---\n\n## Repository and license\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n- Crate: `bitcoin-serialize`, version `0.1.19`\n- License: MIT\n\nConsult the repository for integration examples, tests, and the latest API extensions.\n",
  "package_categories": [
    "cryptography",
    "network-programming",
    "algorithms",
    "data-structures",
    "science"
  ],
  "package_description": "Bitcoin Core–compatible low-level serialization primitives for Rust, including VarInt, CompactSize, fixed-endian integers, IEEE-754 doubles, vector and map codecs, size computation, and formatter-based extensible (de)serialization.",
  "package_keywords": [
    "bitcoin",
    "serialization",
    "varint",
    "compactsize",
    "protocol"
  ]
}