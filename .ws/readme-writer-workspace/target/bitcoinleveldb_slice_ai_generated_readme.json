{
  "crate_name": "bitcoinleveldb-slice",
  "full_readme_markdown": "# bitcoinleveldb-slice\n\nA low-level, pointer-based slice type used internally by the `bitcoin-rs` LevelDB bindings. It mirrors the semantics of LevelDB's C++ `leveldb::Slice`: a cheap, non-owning view into externally managed bytes with explicit lifetime and safety responsibilities.\n\n> **Safety disclaimer**\n>\n> `Slice` is a thin wrapper around a raw pointer (`*const u8`) and a length. It **does not** manage memory, and it performs no lifetime tracking beyond debug assertions. The caller is responsible for ensuring that the referenced memory remains valid and immutable for the entire lifetime of the `Slice` value.\n\n> **Provenance disclaimer**\n>\n> This README was generated by an AI model based on the public interface of the crate. It may not be perfectly accurate or exhaustive, but it should be a good approximation of the crate's intent and usage. Always defer to the crate's source code and tests for authoritative behavior.\n\n---\n\n## Overview\n\n`bitcoinleveldb-slice` provides a single core type:\n\n```rust\npub struct Slice {\n    data: *const u8,\n    size: usize,\n}\n```\n\nThis type is:\n\n- **Non-owning** – it never allocates or frees; it just points at memory owned by something else.\n- **Copy-free** – constructing a `Slice` from a string or byte slice does not copy the bytes.\n- **C-FFI friendly** – can be constructed from raw C strings (`*const u8` interpreted as `char*` / null-terminated) and plain pointers plus explicit length.\n- **Comparable** – supports equality, prefix checks, and three-way byte-wise ordering compatible with typical database and key-value store semantics.\n\nThis design is suitable for high-performance storage engines where the cost of copying data dominates and where ownership is controlled at a higher abstraction layer.\n\n## Features at a Glance\n\n- `Slice::from_ptr_len(*const u8, usize)` – construct from a raw pointer plus a byte length.\n- `impl From<&[u8]> for Slice` – construct from a Rust byte slice without copying.\n- `impl From<&String> for Slice` – construct from a `String` without copying.\n- `impl From<*const u8> for Slice` – construct from a C-style null-terminated string.\n- `Slice::empty()` – constant-time check for zero length.\n- `Slice::clear()` – reset to an empty slice.\n- `Slice::remove_prefix(n)` – logically drop the first `n` bytes (pointer bump + length decrement).\n- `Slice::starts_with(&Slice)` – constant-time prefix check (`O(prefix_len)` byte-wise).\n- `Slice::compare(&Slice)` – three-way lexicographic comparison, returning an `i32` (<0, 0, >0).\n- `Slice::to_string()` – copy data into a `String` (lossy UTF-8 conversion).\n- `Index<usize>` – `slice[i]` returns the `i`-th byte with bounds checking via assertion.\n- `PartialEq`/`Eq` – equality defined by size and byte-wise content.\n\nLogging hooks (`info!`, `debug!`, `trace!`, `warn!`) are embedded throughout; the crate expects a `log`-compatible backend to be configured by the consumer for runtime diagnostics.\n\n## Core Semantics\n\n`Slice` behaves conceptually like:\n\n```rust\nstruct Slice<'a> {\n    data: &'a [u8];\n}\n```\n\nbut implemented as a pointer and length to interface cleanly with C APIs and avoid Rust lifetime generics in public FFI signatures. This mirrors the classic design of low-level storage engines:\n\n- **Aliasing is allowed**: many `Slice` instances may point to overlapping regions.\n- **Immutability is assumed**: callers are expected not to mutate the underlying bytes while they are observed through `Slice` (the type does not enforce this).\n- **Ordering**: `compare` implements lexicographic ordering over the byte sequence, using a `memcmp`-like primitive (`compare_bytes`). This is critical for ordered key spaces in LevelDB-style LSM trees.\n\nIn mathematical terms, consider `Slice` as representing a word over the finite alphabet `{0, 1, ..., 255}`. The `compare` function implements the standard lexicographic order on words induced by the usual order on bytes.\n\n## Usage\n\n### Constructing Slices\n\n#### From a Rust `String`\n\n```rust\nuse bitcoinleveldb_slice::Slice;\n\nlet s = String::from(\"hello\");\nlet slice = Slice::from(&s);\n\nassert!(!slice.empty());\nassert_eq!(slice.to_string(), \"hello\");\n```\n\n**Lifetimes**: `slice` borrows the contents of `s` via a raw pointer; dropping or mutating `s` while `slice` is used is undefined behavior.\n\n#### From a byte slice `&[u8]`\n\n```rust\nlet bytes: &[u8] = &[0x01, 0x02, 0x03];\nlet slice = Slice::from(bytes);\n\nassert_eq!(slice.empty(), false);\nassert_eq!(slice[0], 0x01);\n```\n\nIf `bytes` is empty, `Slice::from(bytes)` produces a canonical empty slice pointing at a static empty buffer.\n\n#### From a C-style string pointer\n\n```rust\nuse bitcoinleveldb_slice::Slice;\nuse std::ffi::CString;\n\nlet c = CString::new(\"leveldb\").unwrap();\nlet ptr = c.as_ptr() as *const u8;\n\n// Interprets ptr as a null-terminated string.\nlet slice = Slice::from(ptr);\n\nassert_eq!(slice.to_string(), \"leveldb\");\n```\n\nIf the pointer is null, an empty `Slice` is returned.\n\n#### From raw pointer and length\n\n```rust\nuse bitcoinleveldb_slice::Slice;\n\nunsafe {\n    let buf: [u8; 4] = *b\"test\";\n    let slice = Slice::from_ptr_len(buf.as_ptr(), buf.len());\n    assert_eq!(slice.to_string(), \"test\");\n}\n```\n\nThis is the most direct constructor for interoperation with foreign code where you already have explicit length metadata.\n\n### Observing and Manipulating Slices\n\n#### Empty check and clearing\n\n```rust\nlet mut slice = Slice::from(&String::from(\"data\"));\nassert!(!slice.empty());\n\nslice.clear();\nassert!(slice.empty());\n```\n\n`clear` logically detaches the `Slice` from the previously referenced memory by pointing it at a static empty buffer.\n\n#### Removing a prefix\n\n```rust\nlet mut slice = Slice::from(&String::from(\"abcdef\"));\n\nslice.remove_prefix(2);  // now represents \"cdef\"\nassert_eq!(slice.to_string(), \"cdef\");\n```\n\n`remove_prefix(n)` advances the internal pointer by `n` bytes and reduces the size by `n`. An assertion guards against `n > size`.\n\n#### Indexing\n\n```rust\nlet slice = Slice::from(&String::from(\"xyz\"));\n\nassert_eq!(slice[0], b'x');\nassert_eq!(slice[1], b'y');\nassert_eq!(slice[2], b'z');\n```\n\nIndexing performs a runtime assertion that `i < size`. Access is then performed via `unsafe` pointer arithmetic.\n\n#### String conversion\n\n```rust\nlet bytes = [0xf0, 0x9f, 0x92, 0x96]; // valid UTF-8 sequence\nlet slice = Slice::from(&bytes[..]);\n\nlet s = slice.to_string(); // uses String::from_utf8_lossy\n```\n\n`to_string` always allocates and copies the underlying bytes, decoding via `String::from_utf8_lossy`. Invalid UTF-8 is replaced with the Unicode replacement character.\n\n### Comparisons and Ordering\n\n#### Equality\n\n```rust\nlet s1 = Slice::from(&String::from(\"abc\"));\nlet s2 = Slice::from(&String::from(\"abc\"));\nlet s3 = Slice::from(&String::from(\"abd\"));\n\nassert_eq!(s1, s2);\nassert_ne!(s1, s3);\n```\n\nEquality is defined as equal length and byte-wise identity via `compare_bytes`.\n\n#### Prefix checks\n\n```rust\nlet base = Slice::from(&String::from(\"abcdef\"));\nlet prefix = Slice::from(&String::from(\"abc\"));\nlet non_prefix = Slice::from(&String::from(\"abd\"));\n\nassert!(base.starts_with(&prefix));\nassert!(!base.starts_with(&non_prefix));\n```\n\n`starts_with` compares only the prefix length using `compare_bytes` and returns `true` when the prefix is identical.\n\n#### Three-way comparison\n\n```rust\nlet a = Slice::from(&String::from(\"a\"));\nlet b = Slice::from(&String::from(\"b\"));\nlet aa = Slice::from(&String::from(\"aa\"));\n\nassert!(a.compare(&b) < 0);\nassert!(b.compare(&a) > 0);\nassert!(a.compare(&aa) < 0); // \"a\" is a prefix of \"aa\", but shorter\n```\n\nThis is suitable for implementing ordered maps, sorted tables, or delegating to LSM-tree comparators. The semantics align with the standard `memcmp`-then-length rule:\n\n1. Compare the first `min(len(self), len(b))` bytes.\n2. If they differ, the sign of the result is the sign of the first differing byte.\n3. If they are identical and lengths differ, the shorter slice is considered smaller.\n\n## Safety Considerations\n\nBecause `Slice` is fundamentally unsafe, there are important constraints:\n\n- **Memory validity**: The underlying memory must remain allocated and immutable for the entire lifetime of the `Slice`.\n- **No internal lifetime tracking**: The compiler cannot help you with dangling pointers here. Treat `Slice` as you would treat FFI pointers.\n- **Thread safety**: Whether a `Slice` is `Send` or `Sync` depends on its definition and Rust's auto-trait derivation. Conceptually, as a raw pointer plus length, it is safe to move between threads only if the backing memory is itself safe to access concurrently.\n- **Logging in unsafe paths**: Many methods log, including ones that use `unsafe`. Ensure that logging backends are well-behaved and do not introduce reentrancy issues for your use case.\n\nIn contexts such as a LevelDB implementation, `Slice` typically points to memory controlled by the storage engine (e.g., table blocks, memtable allocations). Higher-level logic enforces correct lifetimes; this crate deliberately stays minimal.\n\n## Integration with `bitcoin-rs` / LevelDB\n\nThis crate is designed to live inside a broader ecosystem (`bitcoin-rs`) and to work closely with LevelDB-style bindings. Typical patterns include:\n\n- Representing keys and values from on-disk blocks without copying.\n- Passing around temporary views during compaction, write batching, and iteration.\n- Using `compare` to define a canonical ordering for keys in SSTables and memtables.\n\nFor arbitrarily large data sets, avoiding unnecessary copies significantly improves throughput and reduces memory pressure, particularly in log-structured merge tree architectures.\n\n## Logging Behavior\n\nThe implementation uses standard `log` macros:\n\n- `info!` on construction and state-transition operations.\n- `debug!` on index operations and comparisons.\n- `trace!` on lightweight checks and conversions.\n- `warn!` when encountering anomalous situations (e.g., null pointer passed to `From<*const u8>`).\n\nTo see these logs, configure a logger in your binary (e.g., `env_logger`, `tracing-log`, or any other `log`-compatible backend) and set the appropriate log level.\n\n## License\n\nThis crate is licensed under the MIT License. See the `LICENSE` file in the repository for details.\n\n## Repository\n\nThe source code for this crate is hosted in the monorepo:\n\n- <https://github.com/klebs6/bitcoin-rs>\n\nIssues and pull requests related specifically to `bitcoinleveldb-slice` should reference the crate name and version in their description for clarity.\n",
  "package_categories": [
    "algorithms",
    "data-structures",
    "network-programming",
    "encoding",
    "science"
  ],
  "package_description": "Low-level, non-owning byte Slice type for LevelDB-style storage in bitcoin-rs, providing pointer-based views, prefix operations, lexicographic comparison, and FFI-friendly interoperability without copying.",
  "package_keywords": [
    "bitcoin",
    "leveldb",
    "slice",
    "ffi",
    "storage"
  ]
}