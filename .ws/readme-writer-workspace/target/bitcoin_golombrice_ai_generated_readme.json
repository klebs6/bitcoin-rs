{
  "crate_name": "bitcoin-golombrice",
  "full_readme_markdown": "# bitcoin-golombrice\n\nA minimal, BIP‑158–oriented implementation of Golomb‑Rice coding and Golomb‑coded sets (GCS) for Bitcoin compact block filters.\n\n> NOTE: This README was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful description of the crate.\n\n---\n\n## Overview\n\n`bitcoin-golombrice` implements the core primitives required for [BIP‑158](https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki) Golomb‑coded filters:\n\n- **Golomb‑Rice scalar codec**\n  - `golomb_rice_encode` – bit‑level encoder over an arbitrary `Write`.\n  - `golomb_rice_decode` – bit‑level decoder over an arbitrary `Read`.\n- **GCSFilter** – a compact, probabilistic set representation for membership tests with tunable false‑positive rate.\n- **GcsFilterParams** – filter parameterization (SipHash keys, Golomb parameter `p`, and scaling factor `m`).\n\nThe implementation is aimed at interoperability with Bitcoin Core’s `GCSFilter` (parameterization and serialization layout), making it suitable for SPV/light‑client workflows and Bitcoin indexers.\n\nThe crate focuses on:\n\n- Close tracking of the BIP‑158 construction.\n- Deterministic encoding/decoding via bit‑precise I/O.\n- Efficient membership checks with predictable false‑positive bounds.\n\n## Core Concepts\n\n### Golomb‑Rice coding\n\nA non‑negative integer \\( x \\) is mapped to a pair \\((q, r)\\):\n\n- \\( q = \\lfloor x / 2^p \\rfloor \\) – quotient\n- \\( r = x \\bmod 2^p \\) – remainder (\\(p\\) bits)\n\nEncoding:\n\n1. Write `q` as *unary* code: `q` ones followed by a zero.\n2. Write `r` as `p` raw bits.\n\nDecoding inverts this process. This is exactly what\n\n```rust\npub fn golomb_rice_encode<OStream>(\n    bitwriter: &mut BitStreamWriter<OStream>,\n    p: u8,\n    x: u64,\n) where\n    OStream: Default + Write\n{ /* … */ }\n\npub fn golomb_rice_decode<IStream>(\n    bitreader: &mut BitStreamReader<IStream>,\n    p: u8,\n) -> u64\nwhere\n    IStream: Default + Read\n{ /* … */ }\n```\n\nimplements. The parameter `p` trades off code length and quotient distribution. BIP‑158 uses a fixed `p` per filter type.\n\n### Golomb‑coded sets (GCS)\n\nA GCS over domain elements \\(E\\) uses:\n\n- A keyed hash \\( h: E \\rightarrow [0, f) \\), implemented here via SipHash with keys `siphash_k0`, `siphash_k1`.\n- Sorting of hashed values and Golomb‑Rice coding of their **deltas**.\n\nMembership queries are probabilistic:\n\n- If `match_` / `match_any` returns `false`, the element is *definitely not* in the set.\n- If it returns `true`, the element is in the set **or** it is a false positive with probability bounded by \\(1/m\\).\n\nBIP‑158 chooses `m` to obtain a target false‑positive rate (e.g. \\(1/784931\\) for block filters).\n\n---\n\n## Data Types\n\n```rust\npub type GcsFilterElement = Vec<u8>;\n\npub type GcsFilterElementSet = std::collections::HashSet<GcsFilterElement, ByteVectorHash>;\n```\n\nElements are arbitrary byte vectors; the set requires a `ByteVectorHash` hasher (typically a byte‑wise hash over `Vec<u8>` to use as `HashSet` key).\n\n### `GcsFilterParams`\n\n```rust\n#[derive(Debug, Clone, Getters, Builder)]\n#[builder(setter(into), default)]\n#[getset(get = \"pub\")]\npub struct GcsFilterParams {\n    siphash_k0: u64,\n    siphash_k1: u64,\n    p:          u8,\n    m:          u32,\n}\n```\n\n- `siphash_k0`, `siphash_k1`: SipHash‑2‑4 keys used to hash elements to `[0, n * m)`.\n- `p`: Golomb‑Rice parameter (number of remainder bits).\n- `m`: scaling factor; false‑positive probability is ~`1 / m`.\n\nConstruction:\n\n```rust\nimpl GcsFilterParams {\n    pub fn new(\n        siphash_k0: Option<u64>,\n        siphash_k1: Option<u64>,\n        p:          Option<u8>,\n        m:          Option<u32>,\n    ) -> Self { /* … */ }\n}\n\nimpl Default for GcsFilterParams { /* … */ }\n```\n\n`new` mirrors the C++ `GCSFilter::Params` constructor: each argument is optional, with defaults `(0, 0, 0, 1)` for `(k0, k1, p, m)`.\n\nUsing the derived builder:\n\n```rust\nuse bitcoin_golombrice::GcsFilterParamsBuilder;\n\nlet params = GcsFilterParamsBuilder::default()\n    .siphash_k0(0x1234_5678_9abc_def0)\n    .siphash_k1(0xfedc_ba98_7654_3210)\n    .p(20u8)\n    .m(784_931u32)\n    .build()\n    .unwrap();\n```\n\n### `GCSFilter`\n\n```rust\n#[derive(Builder, Debug, Clone, Getters, Default)]\n#[getset(get = \"pub\")]\n#[builder(setter(into))]\npub struct GCSFilter {\n    params:  GcsFilterParams,\n    n:       u32,\n    f:       u64,\n    encoded: Vec<u8>,\n}\n```\n\n- `params`: filter parameterization.\n- `n`: element count in the set.\n- `f`: equal to `n as u64 * m as u64`; hash range upper bound.\n- `encoded`: serialized form, starting with Bitcoin CompactSize `n`, followed by Golomb‑Rice encoded deltas.\n\nHelper accessors:\n\n```rust\nimpl GCSFilter {\n    pub fn getn(&self) -> u32 { /* … */ }\n    pub fn get_params(&self) -> &GcsFilterParams { /* … */ }\n    pub fn get_encoded(&self) -> &Vec<u8> { /* … */ }\n}\n```\n\nA `From<Option<GcsFilterParams>>` implementation allows constructing an *empty* filter encoding `CompactSize(0)` with chosen or default parameters:\n\n```rust\nlet filter: GCSFilter = None::<GcsFilterParams>.into();\nassert_eq!(filter.getn(), 0);\n```\n\n---\n\n## Creating Filters\n\n### From an element set\n\n```rust\nimpl GCSFilter {\n    /// Build a filter from a concrete element set.\n    pub fn new_with_element_set(\n        params: &GcsFilterParams,\n        elements: &GcsFilterElementSet,\n    ) -> Self { /* … */ }\n}\n```\n\nUsage example:\n\n```rust\nuse std::collections::HashSet;\nuse bitcoin_golombrice::{\n    GCSFilter,\n    GcsFilterParams,\n    GcsFilterElement,\n    GcsFilterElementSet,\n};\n\nfn build_filter(params: &GcsFilterParams) -> GCSFilter {\n    let mut set: GcsFilterElementSet = HashSet::default();\n\n    let key1: GcsFilterElement = b\"scriptpubkey-1\".to_vec();\n    let key2: GcsFilterElement = b\"scriptpubkey-2\".to_vec();\n\n    set.insert(key1);\n    set.insert(key2);\n\n    GCSFilter::new_with_element_set(params, &set)\n}\n```\n\nSemantics:\n\n1. Compute `n = elements.len()`, `f = n * m`.\n2. Serialize `CompactSize(n)`.\n3. Hash each element via SipHash with `siphash_k0`, `siphash_k1` into `[0, f)`.\n4. Sort the hashed values, delta‑encode them, then Golomb‑Rice encode each delta with parameter `p`.\n\n### From an already‑encoded filter\n\n```rust\nimpl GCSFilter {\n    pub fn new_with_encoded_filter(\n        params: &GcsFilterParams,\n        encoded_filter: Vec<u8>,\n    ) -> Self { /* … */ }\n}\n```\n\nThis constructor validates consistency:\n\n- Decodes `CompactSize(n)`.\n- Replays Golomb‑Rice decoding for `n` values.\n- Ensures no surplus bytes remain (`panic!`s otherwise).\n\nUseful when you obtain the encoded filter from the network or from Bitcoin Core and want a typed wrapper and query interface.\n\n---\n\n## Membership Queries\n\n### Hashing into the filter range\n\n```rust\nimpl GCSFilter {\n    /// Hash a data element to an integer in the range [0, N * M).\n    pub fn hash_to_range(&self, element: &GcsFilterElement) -> u64 { /* … */ }\n\n    pub fn build_hashed_set(\n        &self,\n        elements: &GcsFilterElementSet,\n    ) -> Vec<u64> { /* … */ }\n}\n```\n\n- `hash_to_range` applies keyed SipHash and projects into `[0, f)` via `map_into_range`.\n- `build_hashed_set` hashes all elements, reserves capacity, and sorts.\n\n### Single‑element membership\n\n```rust\nimpl GCSFilter {\n    /// Checks if the element may be in the set.\n    /// False positives are possible with probability 1/M.\n    pub fn match_(&self, element: &GcsFilterElement) -> bool { /* … */ }\n}\n```\n\nUsage:\n\n```rust\nlet element: GcsFilterElement = b\"scriptpubkey-1\".to_vec();\nif filter.match_(&element) {\n    // Element is either present or a false positive.\n}\n```\n\n### Multi‑element membership (batched)\n\n```rust\nimpl GCSFilter {\n    /// Checks if any of the given elements may be in the set.\n    /// False positives are possible with probability 1/M per element.\n    /// More efficient than calling `match_` repeatedly.\n    pub fn match_any(&self, elements: &GcsFilterElementSet) -> bool { /* … */ }\n}\n```\n\nThis path hashes and sorts queries once, then streams through the encoded filter via `match_internal` using a classic two‑pointer merge technique.\n\nExample:\n\n```rust\nlet mut queries: GcsFilterElementSet = HashSet::default();\nqueries.insert(b\"candidate-1\".to_vec());\nqueries.insert(b\"candidate-2\".to_vec());\n\nif filter.match_any(&queries) {\n    // At least one query may match the filter.\n}\n```\n\n### Unsafe, pointer‑based core matcher\n\n```rust\nimpl GCSFilter {\n    pub fn match_internal(&self, element_hashes: *const u64, size: usize) -> bool { /* … */ }\n}\n```\n\n`match_internal` operates on a raw pointer to a sorted array of query hashes and performs a streaming comparison against the decoded delta sequence. It:\n\n- Reads `n` from the prefix.\n- Iteratively decodes deltas using `golomb_rice_decode`.\n- Maintains a cumulative `value` and an index `idx` into the query array.\n- Returns early when it finds a match or when the query sequence is exhausted.\n\nFor most use cases, prefer `match_` and `match_any`, which wrap this safely.\n\n---\n\n## Serialization and Interop\n\nThe filter encoding layout matches Bitcoin Core’s `GCSFilter`:\n\n1. `CompactSize(n)` – encoded with `write_compact_size` / `read_compact_size` helpers.\n2. Golomb‑Rice encoded deltas of sorted hashes.\n\nThis makes the crate suitable for interoperating with:\n\n- Block filters (`basic`, `extended`) as defined in BIP‑158.\n- External Bitcoin libraries that expect the exact same wire format.\n\nThe implementation uses `VectorReader` / `VectorWriter` and `BitStreamReader` / `BitStreamWriter` abstractions from the surrounding codebase (`bitcoin-rs`) to guarantee bit‑accurate encoding.\n\n---\n\n## Parameter Selection and False Positives\n\nLet:\n\n- \\( n \\) = number of elements in the filter\n- \\( m \\) = scaling factor in `GcsFilterParams`\n- \\( f = n \\cdot m \\) = hash range size\n\nThen:\n\n- Each element is hashed uniformly into `[0, f)` (modulo SipHash properties and `map_into_range`).\n- BIP‑158’s analysis shows a per‑query false‑positive probability approximately `1 / m`.\n\nOperational guidance:\n\n- Choose `m` large enough for your acceptable false‑positive rate.\n- Choose `p` to balance:\n  - Code length (larger `p` yields shorter unary quotient, longer remainder).\n  - Decoding CPU cost (more bits per value vs more unary runs).\n\nFor exact Bitcoin filter parameters, mirror the constants from BIP‑158 or from Bitcoin Core’s implementation and feed them into `GcsFilterParams`.\n\n---\n\n## Safety and Panics\n\nThis crate uses a few invariants:\n\n- `new_with_encoded_filter` will `panic!` if the encoded filter contains trailing data beyond what decoding `n` elements consumes.\n- `new_with_element_set` and parameter constructors assume `n < 2^32` (enforced via `try_from`).\n- `match_internal` is `unsafe` in spirit (raw pointer input), though its signature is safe; incorrect `element_hashes` / `size` will cause undefined behavior. Use the safe wrappers instead.\n\nWhen integrating into production systems, ensure that untrusted filters are validated at higher layers or handled with error propagation if you adapt this code.\n\n---\n\n## Example End‑to‑End Flow\n\n```rust\nuse std::collections::HashSet;\nuse bitcoin_golombrice::{\n    GCSFilter,\n    GcsFilterParams,\n    GcsFilterElement,\n    GcsFilterElementSet,\n};\n\nfn main() {\n    // 1. Define parameters (example values; use BIP‑158 constants for Bitcoin deployment).\n    let params = GcsFilterParams::new(\n        Some(0x1234_5678_9abc_def0),\n        Some(0xfedc_ba98_7654_3210),\n        Some(20),        // p\n        Some(784_931),   // m – target false positive rate ~ 1/784931\n    );\n\n    // 2. Build an element set.\n    let mut elems: GcsFilterElementSet = HashSet::default();\n    elems.insert(b\"elem-1\".to_vec());\n    elems.insert(b\"elem-2\".to_vec());\n\n    // 3. Construct the filter.\n    let filter = GCSFilter::new_with_element_set(&params, &elems);\n\n    // 4. Serialize to bytes (e.g., for network transmission or storage).\n    let encoded = filter.get_encoded().clone();\n\n    // 5. Reconstruct a filter from bytes.\n    let filter2 = GCSFilter::new_with_encoded_filter(&params, encoded);\n\n    // 6. Query membership.\n    let q: GcsFilterElement = b\"elem-1\".to_vec();\n    assert!(filter2.match_(&q));\n}\n```\n\n---\n\n## License and Repository\n\n- **License:** MIT\n- **Repository:** <https://github.com/klebs6/bitcoin-rs>\n\nThis crate is part of a broader Bitcoin‑related Rust codebase. Consult the repository for example usage, integration points, and parameter constants matching Bitcoin Core.\n",
  "package_categories": [
    "cryptography",
    "algorithms",
    "network-programming",
    "science"
  ],
  "package_description": "BIP-158 compatible Golomb-Rice encoder/decoder and Golomb-coded set (GCS) implementation for Bitcoin compact block filters, with keyed SipHash-based hashing and bit-precise serialization.",
  "package_keywords": [
    "bitcoin",
    "golomb-rice",
    "bip158",
    "compact-filters",
    "gcs"
  ]
}