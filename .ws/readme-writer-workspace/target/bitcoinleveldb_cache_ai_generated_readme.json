{
  "crate_name": "bitcoinleveldb-cache",
  "full_readme_markdown": "# bitcoinleveldb-cache\n\nA faithful, test-focused Rust port of the cache subsystem used by Bitcoin Core's LevelDB fork. It provides an internal, concurrency-safe caching layer with explicit control over memory charge, eviction, and lifecycle semantics, suitable for embedding under higher-level storage engines.\n\n> This README was generated by an AI model and may not be 100% accurate, though it should be a close and practically useful approximation of the crate's intent and API.\n\n---\n\n## Overview\n\n`bitcoinleveldb-cache` exposes a low-level cache abstraction that mimics the behavior and semantics of the original C++ LevelDB/Bitcoin cache implementation. The primary design goals are:\n\n- **Deterministic memory accounting** via explicit `charge` for each value.\n- **Capacity-bounded caching** with eviction when the total charge exceeds the configured capacity.\n- **Opaque values** (`*mut c_void`) for maximal flexibility and interoperability with FFI-heavy or legacy code.\n- **Reference-counted handles** so clients can pin entries and manage lifetimes precisely.\n- **LRU-like eviction** implemented by tracking a logical clock and last-use timestamps.\n\nThe crate is primarily concerned with providing the cache core that Bitcoin's LevelDB adapter depends upon. It is not a general high-level Rust cache with ownership-safe value types; instead, it mirrors the original memory and pointer semantics used by Bitcoin's tests, including custom deleters and test fixtures.\n\n---\n\n## Core Concepts\n\n### 1. Cache Interface and Traits\n\nThe cache API is specified as a trait composition. Any type implementing all the following traits automatically implements the marker trait `CacheInterface`:\n\n- `CacheInsert`\n- `CacheLookup`\n- `CacheRelease`\n- `CacheValue`\n- `CacheErase`\n- `CacheNewId`\n- `CachePrune`\n- `CacheTotalCharge`\n\nThis enables alternative cache implementations (e.g., scan-resistant or different eviction policies) while maintaining a common API boundary.\n\n#### Trait Summary\n\n```rust\npub trait CacheInsert {\n    fn insert(\n        &mut self,\n        key_:    &Slice,\n        value:   *mut c_void,\n        charge:  usize,\n        deleter: CacheDeleterFn,\n    ) -> *mut CacheHandle;\n}\n\npub trait CacheLookup {\n    fn lookup(&mut self, key_: &Slice) -> *mut CacheHandle;\n}\n\npub trait CacheRelease {\n    fn release(&mut self, handle: *mut CacheHandle);\n}\n\npub trait CacheValue {\n    fn value(&mut self, handle: *mut CacheHandle) -> *mut c_void;\n}\n\npub trait CacheErase {\n    fn erase(&mut self, key_: &Slice);\n}\n\npub trait CacheNewId {\n    fn new_id(&mut self) -> u64;\n}\n\npub trait CachePrune {\n    fn prune(&mut self);\n}\n\npub trait CacheTotalCharge {\n    fn total_charge(&self) -> usize;\n}\n\npub type CacheDeleterFn = fn(key_: &Slice, value: *mut c_void);\n```\n\n`CacheInterface` is then defined as:\n\n```rust\nimpl<T> CacheInterface for T where\n    T: CacheInsert\n        + CacheLookup\n        + CacheRelease\n        + CacheValue\n        + CacheErase\n        + CacheNewId\n        + CachePrune\n        + CacheTotalCharge {}\n```\n\n### 2. Built-in LRU Cache\n\nThe main production implementation is the `Cache` type backed by a `CacheRep` struct. It is instantiated via:\n\n```rust\npub fn new_lru_cache(capacity: usize) -> *mut Cache\n```\n\n- `capacity` is expressed in abstract **charge units**, not entry count.\n- Each entry inserted with `charge` contributes to the aggregate `usage` of the cache.\n- When `usage > capacity`, entries are evicted according to an approximate **least-recently-used** policy.\n\nInternally:\n\n- `Cache` stores `Rc<RefCell<CacheRep>>`, making it cloneable and internally synchronized at the Rust level.\n- `CacheRep` manages a `HashMap<Vec<u8>, *mut CacheHandle>` that maps serialized keys to handle pointers.\n- Eviction uses a monotonically increasing logical `clock` (u64) and `last_use` timestamps inside each `CacheHandle`. Candidates with `refs == 1` and the oldest `last_use` are selected for eviction.\n\n### 3. Cache Handles and Reference Semantics\n\nEach cache lookup/insert returns an opaque pointer to a `CacheHandle`:\n\n```rust\n#[derive(Getters, Setters, Builder)]\npub struct CacheHandle {\n    key:      Vec<u8>,\n    value:    *mut c_void,\n    deleter:  CacheDeleterFn,\n    charge:   usize,\n    refs:     u32,\n    in_cache: bool,\n    last_use: u64,\n}\n```\n\nImportant invariants:\n\n- `refs` counts strong references, including the internal cache reference if `in_cache == true`.\n- User code must call `CacheRelease::release` when done with a handle, decrementing `refs`.\n- When `refs` reaches 0, the following occur:\n  - The associated `deleter` is invoked with the `Slice`-view of `key` and the stored `value` pointer.\n  - The `CacheHandle` itself is deallocated.\n\nThis closely replicates the original C++ pointer-based design while making it explicit in Rust. Misuse (forgetting `release` or double-releasing) will generally show up as incorrect reference counts and log messages.\n\n### 4. Key Encoding & Bitcoin/LevelDB Compatibility\n\nA number of helpers are provided for converting between integer keys and the `Slice`/byte representation used internally:\n\n```rust\npub fn encode_key(k: i32) -> Vec<u8>;\npub fn decode_key(k: &Slice) -> i32;\n```\n\n- Encoding uses **little-endian fixed32** semantics, matching LevelDB's `PutFixed32`.\n- `decode_key` asserts that the key size is exactly 4 bytes and then reverses the encoding.\n\nFor values, two helpers exist primarily for tests:\n\n```rust\npub fn decode_value(v: *mut c_void) -> i32;\npub fn encode_value(v: uintptr_t) -> *mut c_void;\n```\n\n`decode_value` expects a pointer to a `CacheTestValue` struct, which is test-only payload carrying both the owning fixture and a logical `i32` value.\n\n### 5. Deleter Semantics\n\nThe cache never assumes ownership of your values beyond calling the `deleter` you provide at insertion time. This enables complex lifetime management across FFI boundaries.\n\nIn tests, the deleter is:\n\n```rust\nimpl CacheTest {\n    pub fn deleter(key_: &Slice, v: *mut c_void) {\n        // Cast `v` to `Box<CacheTestValue>`, record deleted key/value on fixture,\n        // then drop the box exactly once.\n    }\n}\n```\n\nIn production use, you will typically wrap your data structures in a `Box` and provide a deleter that reconstructs the box, performs any side effects, and then allows Rust to drop the object.\n\n---\n\n## Usage\n\n### Adding the Dependency\n\n```toml\n[dependencies]\nbitcoinleveldb-cache = \"0.1.19\"\n```\n\n### Constructing a Cache\n\n```rust\nuse bitcoinleveldb_cache::{new_lru_cache, CacheInterface, CacheInsert, CacheLookup, CacheRelease, CacheValue, CacheErase};\nuse std::ffi::c_void;\n\nfn example_usage() {\n    // Capacity in arbitrary charge units; choose according to your accounting model.\n    let capacity: usize = 1024 * 1024; // e.g. 1 MiB equivalent\n\n    // Allocate a new LRU cache on the heap.\n    let cache_ptr = unsafe { new_lru_cache(capacity) };\n\n    // SAFETY: `cache_ptr` is owned here; ensure you eventually reconstruct the Box and drop it.\n    let cache: &mut bitcoinleveldb_cache::Cache = unsafe { &mut *cache_ptr };\n\n    // Application-specific: encode a key into bytes then into the `Slice` type used by the cache.\n    let key_bytes = bitcoinleveldb_cache::encode_key(42);\n    let key_slice = bitcoinleveldb_cache::Slice::from_ptr_len(key_bytes.as_ptr(), key_bytes.len());\n\n    // Suppose we have some heap-allocated payload.\n    let payload = Box::new(MyPayload { /* ... */ });\n    let payload_ptr: *mut c_void = Box::into_raw(payload) as *mut c_void;\n\n    // Define a deleter that recovers the Box and drops it.\n    fn my_deleter(_key: &bitcoinleveldb_cache::Slice, value: *mut c_void) {\n        if value.is_null() {\n            return;\n        }\n        unsafe {\n            let _: Box<MyPayload> = Box::from_raw(value as *mut MyPayload);\n            // Dropped on scope exit.\n        }\n    }\n\n    // Insert into the cache with an explicit charge.\n    let charge = 128usize; // e.g. approximate size in bytes\n    let handle = cache.insert(&key_slice, payload_ptr, charge, my_deleter);\n\n    // Immediately release our reference if we only want the cache to own it.\n    cache.release(handle);\n\n    // Later: look up the entry.\n    let lookup_handle = cache.lookup(&key_slice);\n    if !lookup_handle.is_null() {\n        let value_ptr = cache.value(lookup_handle);\n        // SAFETY: You must know the actual type; here we re-cast to `MyPayload`.\n        let payload_ref: &mut MyPayload = unsafe { &mut *(value_ptr as *mut MyPayload) };\n        // Use `payload_ref`...\n\n        // Release when done.\n        cache.release(lookup_handle);\n    }\n\n    // When completely finished with the cache, reconstruct the Box and drop it.\n    unsafe {\n        let boxed_cache = Box::from_raw(cache_ptr);\n        drop(boxed_cache); // triggers Cache::drop, which clears entries and calls deleters\n    }\n}\n\nstruct MyPayload {\n    // your data\n}\n```\n\n### Capacity, Charge, and Eviction Model\n\nMathematically, you can think of the cache as maintaining:\n\n- A non-negative capacity \\( C \\in \\mathbb{N} \\).\n- A multiset of entries \\( E = \\{e_i\\} \\), each with an associated non-negative charge \\( c_i \\).\n- A usage \\( U = \\sum_i c_i \\).\n\nThe invariant is that ideally \\( U \\leq C \\). When an insert causes \\( U > C \\), the cache repeatedly selects eviction candidates according to an approximate LRU order until \\( U \\leq C \\) or no evictable entries remain.\n\nEviction candidates must satisfy:\n\n- `in_cache == true`, i.e., the cache still owns a reference.\n- `refs == 1`, meaning no other external user currently holds the handle.\n\nAmong such candidates, the one with smallest `last_use` (oldest) is removed first, implementing a discrete-time LRU policy.\n\nThis behavior matches a widely used pattern in storage engines: approximate LRU policies are usually sufficient to avoid pathological reuse patterns while keeping implementation complexity low.\n\n### Pruning Unused Entries\n\nThe `CachePrune` trait allows manual compaction of entries that are not actively pinned by clients:\n\n```rust\nuse bitcoinleveldb_cache::CachePrune;\n\nfn prune(cache: &mut bitcoinleveldb_cache::Cache) {\n    cache.prune();\n}\n```\n\n`prune` will remove all entries where `in_cache == true` and `refs == 1`, freeing associated memory and invoking deleters. This is particularly useful for tests and memory-pressure simulations.\n\n### Total Charge Introspection\n\nYou can inspect the total accumulated charge at any time:\n\n```rust\nuse bitcoinleveldb_cache::CacheTotalCharge;\n\nfn current_usage(cache: &bitcoinleveldb_cache::Cache) -> usize {\n    cache.total_charge()\n}\n```\n\nThis is typically used by higher layers to monitor memory consumption and tune capacity or charge models.\n\n---\n\n## Testing Infrastructure\n\nThe crate includes a dedicated test harness with the following auxiliary types:\n\n- `CacheTestValue` — an internal payload type storing:\n  - `fixture: *mut CacheTest`\n  - `value: i32`\n\n- `CacheTest` — a fixture that owns a cache pointer and records deleted keys/values.\n\nThese are used to validate the correctness of deletion, eviction, and reference counting by:\n\n- Inserting boxed `CacheTestValue`s into the cache.\n- Using the test-only deleter to record when entries are dropped.\n\nUtility methods such as `CacheTest::insert`, `CacheTest::lookup`, `CacheTest::erase`, and `CacheTest::insert_and_return_handle` are provided to reproduce the original C++ test matrix as closely as possible. Production users should not rely on these types, but they are illustrative of correct integration with the low-level API.\n\n---\n\n## Safety and FFI Considerations\n\nThis crate intentionally operates at a low level:\n\n- Values are **untyped raw pointers** (`*mut c_void`).\n- Lifetime management depends on correct implementation of deleters and disciplined usage of `lookup` / `release` pairs.\n- All casting to and from `*mut c_void` is `unsafe` and must be validated by the caller.\n\nWhen embedding in a larger Rust system, consider:\n\n- Encapsulating all pointer casting behind a safe wrapper type that owns the cache and enforces correct use.\n- Modeling `charge` as the approximate heap footprint (e.g., length of byte buffers, plus metadata) to keep eviction behavior aligned with real memory usage.\n- Performing fuzzing or property-based testing on your wrapper layer if you rely on complex deleter logic.\n\nIn FFI contexts (e.g., when interoperating with C or C++ code derived from Bitcoin Core), this crate's API is intentionally close to the original patterns and should integrate straightforwardly.\n\n---\n\n## Logging\n\nThe implementation uses the `log` crate macros (`trace!`, `debug!`, `info!`, `warn!`, `error!`) extensively to describe internal state transitions:\n\n- Insertions, lookups, erasures, and reference count changes.\n- Eviction decisions and internal invariants.\n- Error conditions such as invalid reference counts or inconsistent `in_cache` flags.\n\nFor meaningful diagnostics during integration or testing, configure a logger (e.g., `env_logger`, `tracing-log`) in your binary or test harness.\n\n---\n\n## Relationship to `bitcoin-rs`\n\nThis crate lives within the `https://github.com/klebs6/bitcoin-rs` repository and is primarily designed to support the LevelDB-esque storage components there. It aims for behavioral fidelity with the upstream Bitcoin Core cache implementation while exposing a Rust interface suitable for systems-level work on UTXO sets, block indices, and related structures.\n\n---\n\n## License\n\nThis crate is licensed under the **MIT** license, consistent with the broader `bitcoin-rs` project.\n\nSee the repository for the full license text and attribution details.\n",
  "package_categories": [
    "algorithms",
    "caching",
    "data-structures",
    "development-tools",
    "network-programming"
  ],
  "package_description": "Low-level, Bitcoin Core–compatible in-memory cache for LevelDB-style storage, providing capacity-bounded LRU eviction, explicit charge-based memory accounting, and opaque pointer values with custom deleters for FFI-heavy systems.",
  "package_keywords": [
    "bitcoin",
    "leveldb",
    "cache",
    "lru",
    "storage"
  ]
}