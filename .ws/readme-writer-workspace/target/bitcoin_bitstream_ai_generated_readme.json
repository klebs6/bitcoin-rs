{
  "crate_name": "bitcoin-bitstream",
  "full_readme_markdown": "# bitcoin-bitstream\n\nLow-level, allocation-aware bit and byte stream utilities extracted from the Bitcoin Core serialization layer, implemented in Rust.\n\nThis crate focuses on:\n\n- **Bit-level I/O** over `Read` / `Write` streams (`BitStreamReader`, `BitStreamWriter`)\n- **Byte-stream buffering** with an internal, security-oriented allocator (`DataStream`)\n- **Overrideable stream views** for type/version–aware serialization front-ends (`OverrideStream`)\n- **Constant-endianness integer accessors** (`read*` / `write*` helpers)\n- **Logging-first design** using `tracing` for observability of all core operations\n\nIt is primarily intended for Bitcoin-style protocol implementors who require strict control over:\n\n- on-the-wire layout (endian, bit packing),\n- buffer lifetime and zeroing behavior, and\n- incremental parsing / framing with explicit rewind and compaction semantics.\n\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate relative to the exact crate state, but it should be a close and practically useful approximation.\n\n---\n\n## Features at a Glance\n\n- **Bit-oriented streaming**\n  - Read and write **up to 64 bits at a time** from/to an arbitrary I/O stream.\n  - No dependency on higher-level serialization frameworks.\n  - Deterministic, shift-based implementation derived from Bitcoin Core.\n\n- **DataStream: a Bitcoin-like serialization buffer**\n  - Backed by `SerializeData = Vec<u8, ZeroAfterFreeAllocator>` (allocator zeroes memory on free in the original C++ design; in Rust, this crate expects an equivalent `ZeroAfterFreeAllocator`).\n  - `n_read_pos` marker separates *consumed* from *unconsumed* bytes.\n  - Mutation APIs closely mirror C++ `CDataStream` semantics (insert, erase, compact, rewind, xor, etc.).\n\n- **Unsafe but explicit pointer I/O**\n  - `write{le,be}{16,32,64}` and `read{le,be}{16,32,64}` operate directly on raw pointers.\n  - Intended for **performance-sensitive** codecs and when integrating with foreign memory layouts.\n\n- **OverrideStream**\n  - Thin, unsafe wrapper over a `*mut Stream: Backend` pointer with explicit `type` and `version` fields.\n  - Used to emulate Bitcoin Core’s pattern of constructing temporary streams with overridden type/version for selective serialization.\n\n- **Observability**\n  - All core operations are annotated with `#[instrument]` and `tracing::{info, debug, trace, error}` calls.\n  - Ideal for debugging protocol encoding bugs and boundary conditions.\n\n---\n\n## Core Types\n\n### `trait Backend`\n\n```rust\npub trait Backend {\n    fn size(&self) -> usize;\n    fn ignore(&mut self, amount: usize);\n}\n```\n\nA minimal API that backends for `OverrideStream` must implement. A `Backend` is conceptually:\n\n- A byte stream with a **known size**, and\n- The ability to **skip** bytes (`ignore`).\n\nYou typically combine `Backend` with `Read`/`Write` for fully functional streams.\n\n---\n\n### `OverrideStream<Stream>`\n\n```rust\npub struct OverrideStream<Stream> {\n    stream:    *mut Stream,\n    n_type:    i32,\n    n_version: i32,\n}\n```\n\nImplements:\n\n- `GetType`, `GetVersion`\n- `StreamItems` (placeholder, `todo!()`)\n- `StreamInto` (placeholder, `todo!()`)\n\nAnd, when `Stream: Backend`:\n\n- `new(stream_ptr: *mut Stream, n_type_in: i32, n_version_in: i32)`\n- `write(&mut self, pch: *const u8, n_size: usize)`\n- `read(&mut self, pch: *mut u8, n_size: usize)`\n- `size(&self) -> usize`\n- `ignore(&mut self, amount: usize)`\n\n**Usage pattern** (unsafe by design):\n\n```rust\nuse bitcoin_bitstream::{Backend, OverrideStream};\nuse std::io::{Read, Write};\n\nstruct MyBuf {\n    buf: Vec<u8>,\n    pos: usize,\n}\n\nimpl Backend for MyBuf {\n    fn size(&self) -> usize { self.buf.len() - self.pos }\n    fn ignore(&mut self, amount: usize) { self.pos = (self.pos + amount).min(self.buf.len()); }\n}\n\nimpl Read for MyBuf {\n    fn read(&mut self, dst: &mut [u8]) -> std::io::Result<usize> {\n        let n = dst.len().min(self.size());\n        dst[..n].copy_from_slice(&self.buf[self.pos..self.pos + n]);\n        self.pos += n;\n        Ok(n)\n    }\n}\n\nimpl Write for MyBuf {\n    fn write(&mut self, src: &[u8]) -> std::io::Result<usize> {\n        self.buf.extend_from_slice(src);\n        Ok(src.len())\n    }\n    fn flush(&mut self) -> std::io::Result<()> { Ok(()) }\n}\n\nlet mut backend = MyBuf { buf: Vec::new(), pos: 0 };\nlet ptr = &mut backend as *mut MyBuf;\nlet mut ovr = OverrideStream::new(ptr, /*type=*/0, /*version=*/1);\n\nlet data = [0x01u8, 0x02, 0x03];\nunsafe {\n    ovr.write(data.as_ptr(), data.len());\n}\n```\n\n**Safety**: `OverrideStream` stores a raw `*mut Stream` and dereferences it under `unsafe`. You must guarantee the pointer is:\n\n- Non-null,\n- Properly aligned,\n- Valid for the lifetime of the `OverrideStream`, and\n- Not simultaneously aliased in ways that violate Rust’s aliasing rules.\n\n---\n\n### `BitStreamReader<IStream>`\n\n```rust\npub struct BitStreamReader<IStream: Default + Read> {\n    istream: Rc<RefCell<IStream>>,\n    buffer:  u8,\n    offset:  i32,\n}\n```\n\n`BitStreamReader` exposes `read(&mut self, nbits: i32) -> u64`, reading **`nbits` most-significant bits** from the underlying `Read` stream, up to 64.\n\n- `offset` is the number of **consumed bits** in `buffer` (`0..=8`).\n- When `offset == 8`, the next byte is fetched from the underlying stream.\n- Bits are read MSB-first from each byte (consistent with Bitcoin’s Huffman-like bit encodings).\n\nExample:\n\n```rust\nuse bitcoin_bitstream::BitStreamReader;\nuse std::{cell::RefCell, io::Cursor, rc::Rc};\n\nlet data = [0b1011_0010u8, 0b0110_0000u8];\nlet cursor = Cursor::new(&data[..]);\nlet rc = Rc::new(RefCell::new(cursor));\n\nlet mut rdr = BitStreamReader::new(rc);\n\n// Read the first 4 bits: 1011 == 0b1011 == 11\nlet first = rdr.read(4);\nassert_eq!(first, 0b1011);\n\n// Next 4 bits: 0010 == 2\nlet second = rdr.read(4);\nassert_eq!(second, 0b0010);\n\n// Cross-byte reads are handled transparently.\nlet third = rdr.read(4); // 0110 == 6\nassert_eq!(third, 0b0110);\n```\n\nThis is appropriate for:\n\n- Compact integer encodings\n- Prefix codes\n- Flag bitfields embedded in the Bitcoin network protocol\n\nMathematically, the reader maintains a sliding window over the bitstream, equivalent to a left-fold of the form\n\n\\[\nR_{k+1} := (R_k \\ll b_k) \\;\\vert\\; M_k,\n\\]\n\nwhere \\( R_k \\) is the accumulated result, \\( b_k \\) is the number of bits consumed on iteration \\( k \\), and \\( M_k \\) is the extracted bit mask from `buffer` at the current offset.\n\n---\n\n### `BitStreamWriter<OStream>`\n\n```rust\npub struct BitStreamWriter<OStream: Default + Write> {\n    ostream: Rc<RefCell<OStream>>,\n    buffer:  u8,\n    offset:  i32,\n}\n```\n\nProvides:\n\n- `new(ostream: Rc<RefCell<OStream>>) -> Self`\n- `write(&mut self, data: u64, nbits: i32)`\n- `flush(&mut self)`\n- `Drop` implementation that auto-flushes remaining bits\n\nSemantics mirror `BitStreamReader`, but in reverse: bits from `data` are streamed out MSB-first into full bytes.\n\n```rust\nuse bitcoin_bitstream::BitStreamWriter;\nuse std::{cell::RefCell, io::Cursor, rc::Rc};\n\nlet buf = Cursor::new(Vec::<u8>::new());\nlet rc = Rc::new(RefCell::new(buf));\n\n{\n    let mut w = BitStreamWriter::new(rc.clone());\n    // write 3 bits 0b101 and then 5 bits 0b10011\n    w.write(0b101, 3);\n    w.write(0b10011, 5);\n    // Drop will flush the final partial byte\n}\n\nlet inner = Rc::try_unwrap(rc).unwrap().into_inner();\nassert_eq!(inner.into_inner(), vec![0b1011_0011]);\n```\n\nThis is suitable for implementing Bitcoin’s compact bit encodings and low-level codecs where you want deterministic bit layout without depending on higher-level formats.\n\n---\n\n### `DataStream`\n\n```rust\npub struct DataStream {\n    vch:        SerializeData,  // Vec<u8, ZeroAfterFreeAllocator>\n    n_read_pos: u32,\n    n_type:     i32,\n    n_version:  i32,\n}\n```\n\n`DataStream` is a buffer-centric abstraction designed to replicate C++ `CDataStream` behavior. The stream is conceptually:\n\n- `vch[..n_read_pos]` — already consumed\n- `vch[n_read_pos..]` — unread / available\n\nKey methods:\n\n- **Construction**\n  - `new(n_type, n_version)` – empty buffer\n  - `new_with_slice(sp, n_type, n_version)` – copy from existing slice\n  - `new_with_args(n_type, n_version, args)` – placeholder for multi-argument serialize\n\n- **Inspection**\n  - `size() -> usize` – unconsumed size\n  - `empty() -> bool`\n  - `str_() -> String` – UTF‑8 lossy view of unconsumed bytes\n  - `get_type()`, `set_type()`, `get_version()`, `set_version()`\n\n- **Cursor / lifetime control**\n  - `rewind(n: Option<usize>) -> bool` – move `n_read_pos` backward or reset to 0\n  - `compact()` – physically drop consumed prefix\n  - `clear()`\n  - `eof() -> bool` – `size() == 0`\n\n- **Raw access**\n  - `as_slice() -> &[u8]`, `as_mut_slice() -> &mut [u8]`\n  - `data() -> *const u8`, `data_mut() -> *mut u8`\n  - `Index` / `IndexMut<usize>` – random access from `n_read_pos`\n\n- **Reading / writing by pointer**\n  - `read(pch: *mut u8, n_size: usize)` – copies from `vch[n_read_pos..]` to `pch`, advances `n_read_pos`\n  - `write(pch: *const u8, n_size: usize)` – extend `vch` by copying from `pch`\n  - `ignore(n_size: i32)` – advance `n_read_pos`, panics on overflow\n\n- **Structural modifications**\n  - `insert_item(it, x) -> ZeroAfterFreeVecIter`\n  - `insert_multi(it, n, x)`\n  - `insert_with_iterator_range(it, first, last)`\n  - `insert_with_pointer_range(it, first, last)`\n  - `erase(it) -> ZeroAfterFreeVecIter`\n  - `erase_range(first, last) -> ZeroAfterFreeVecIter`\n\n- **Utility**\n  - `xor(&mut self, key: &Vec<u8>)` – XORs unread portion with repeating key (typically for simple obfuscation)\n\nExample: basic use as a serialization buffer:\n\n```rust\nuse bitcoin_bitstream::DataStream;\n\nlet mut ds = DataStream::new(/*type=*/0, /*version=*/1);\n\n// write some bytes\nlet payload = b\"hello\";\nunsafe {\n    ds.write(payload.as_ptr(), payload.len());\n}\nassert_eq!(ds.size(), 5);\n\n// read them back\nlet mut out = [0u8; 5];\nunsafe {\n    ds.read(out.as_mut_ptr(), out.len());\n}\nassert_eq!(&out, b\"hello\");\nassert!(ds.empty());\n```\n\nBecause `DataStream` is pointer-based in several APIs, all pointer-safety considerations apply: you must ensure the destination buffers are large enough and valid for writes.\n\n---\n\n## Endian Helpers and Bit Counting\n\nThe crate exposes a series of free functions for direct integer encoding/decoding at fixed endianness, all operating on raw pointers:\n\n```rust\npub fn writebe16(ptr: *mut u8, x: u16);\npub fn writele16(ptr: *mut u8, x: u16);\npub fn writebe32(ptr: *mut u8, x: u32);\npub fn writele32(ptr: *mut u8, x: u32);\npub fn writebe64(ptr: *mut u8, x: u64);\npub fn writele64(ptr: *mut u8, x: u64);\n\npub fn readbe16(ptr: *const u8) -> u16;\npub fn readle16(ptr: *const u8) -> u16;\npub fn readbe32(ptr: *const u8) -> u32;\npub fn readle32(ptr: *const u8) -> u32;\npub fn readbe64(ptr: *const u8) -> u64;\npub fn readle64(ptr: *const u8) -> u64;\n```\n\nThese functions:\n\n- Use `to_{le,be}_bytes` / `from_{le,be}_bytes` internally\n- Call `std::ptr::copy_nonoverlapping` for the actual move\n- Are heavily instrumented with `tracing`; suitable for debugging buffer boundaries\n\nSimple usage:\n\n```rust\nuse bitcoin_bitstream::{writele32, readle32};\n\nlet mut buf = [0u8; 4];\nunsafe {\n    writele32(buf.as_mut_ptr(), 0xDEADBEEF);\n    let x = readle32(buf.as_ptr());\n    assert_eq!(x, 0xDEADBEEF);\n}\n```\n\nThe crate also provides:\n\n```rust\npub fn count_bits(x: u64) -> u64;\n```\n\nThis returns\n\n\\[\n\\min\\{ n \\in \\mathbb{N} : (x \\gg n) = 0 \\}\n\\]\n\nor equivalently `0` if `x == 0`, else `64 - leading_zeros(x)`. In other words, the **position of the highest set bit plus one**, which is the base-2 bit length of `x`.\n\n---\n\n## Error Handling and Panics\n\nThis crate intentionally mirrors C++ behavior and **panics** on several runtime violations:\n\n- `BitStreamReader::read` and `BitStreamWriter::write` panic if `nbits` is not in `0..=64`.\n- `DataStream::read` panics on out-of-bounds reads (`end of data`).\n- `DataStream::ignore` panics on negative lengths or skipping past the end.\n- `OverrideStream::{read, write, ignore}` panic on null backend pointer or if the underlying `Read`/`Write`/`Backend` operations fail.\n\nIn production systems, you may wish to wrap these abstractions in fallible layers or pre-validate buffer boundaries.\n\n---\n\n## Logging / Tracing\n\nAll major operations are annotated with `#[instrument(level = \"trace\")]` and emit via the `tracing` crate:\n\n- `info!` for high-level lifecycle events (construction, major calls),\n- `debug!` for return values and internal decisions,\n- `trace!` for hot-path details, and\n- `error!` for logic violations prior to panicking.\n\nIntegrate with your subscriber of choice:\n\n```rust\nuse tracing_subscriber::FmtSubscriber;\n\nfn main() {\n    let subscriber = FmtSubscriber::builder()\n        .with_max_level(tracing::Level::TRACE)\n        .finish();\n    tracing::subscriber::set_global_default(subscriber).unwrap();\n\n    // use bitcoin-bitstream normally, logs will be emitted to stdout\n}\n```\n\nThis makes it straightforward to diagnose bit/byte-level mismatches between your implementation and a Bitcoin Core reference.\n\n---\n\n## Safety Considerations\n\n- **Raw pointers**: Several APIs (`OverrideStream`, `DataStream::read`/`write`, endian helpers) accept or return raw pointers. Misuse can cause memory unsafety.\n- **Allocator semantics**: The semantics of `ZeroAfterFreeAllocator` (and `SerializeData`) are assumed to be consistent with Bitcoin Core (zero memory on free). Verify the actual implementation in this repository if you rely on this for security.\n- **Aliasing**: When working with `Rc<RefCell<IStream>>` and raw pointers, ensure you do not create aliasing patterns that violate Rust’s safety requirements.\n\nThis crate is targeted at advanced users building protocol-level infrastructure who are comfortable explicitly managing such constraints.\n\n---\n\n## Integration in `Cargo.toml`\n\n```toml\n[dependencies]\nbitcoin-bitstream = \"0.1.19\"\ntracing = \"0.1\"   # for instrumentation output\n```\n\nThe crate uses Rust **edition 2021** and is distributed under the **MIT** license.\n\nThe upstream repository, which may include additional context such as `ZeroAfterFreeAllocator` and related types, is:\n\n- <https://github.com/klebs6/bitcoin-rs>\n\n---\n\n## License\n\nThis project is licensed under the **MIT License**. See the upstream repository for the canonical license text.\n",
  "package_categories": [
    "cryptography",
    "network-programming",
    "algorithms",
    "parsing",
    "science"
  ],
  "package_description": "Low-level Bitcoin-style bit and byte stream utilities providing bit-level readers/writers, a CDataStream-like buffer with secure allocation semantics, and fixed-endian integer accessors for protocol serialization.",
  "package_keywords": [
    "bitcoin",
    "bitstream",
    "serialization",
    "endianness",
    "protocol"
  ]
}