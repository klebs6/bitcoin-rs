{
  "crate_name": "bitcoin-ripemd",
  "full_readme_markdown": "# bitcoin-ripemd\n\nA standalone, low-level RIPEMD‑160 implementation tuned for Bitcoin-style workloads.\n\nThis crate provides a small, `no_std`‑friendly core for computing RIPEMD‑160 message digests, with a focus on:\n\n- Exact replication of the canonical RIPEMD‑160 bit‑level behavior\n- Efficient streaming over arbitrarily long byte sequences\n- Transparent, inspectable implementation suitable for audit and reuse inside Bitcoin libraries\n\n> This README.md was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful description of the crate.\n\n---\n\n## Features at a glance\n\n- Pure Rust RIPEMD‑160 compression function and padding logic\n- Stateful hasher type `Ripemd160` with `new`, `update`, `finalize`, and `reset`\n- Carefully inlined bitwise round functions (`ripemd160_f1`–`f5`) and per‑round helpers\n- Deterministic, Bitcoin‑compatible outputs (e.g., for HASH160: `RIPEMD160(SHA256(x))`)\n- Fine‑grained tracing via the `tracing` crate to inspect internal state evolution (optional at runtime)\n\nThis crate is extracted from, and maintained in sync with, the `bitcoin-rs` repository, and is intended to be usable independently when a minimal RIPEMD‑160 implementation is desired.\n\n---\n\n## Use cases\n\nTypical applications include:\n\n- Bitcoin address construction (P2PKH, P2SH) via HASH160\n- Re‑implementing or auditing Bitcoin consensus code\n- Cryptographic tooling that requires RIPEMD‑160 hashes for interoperability\n- Verification harnesses and fuzzing against alternative RIPEMD‑160 implementations\n\nNote that RIPEMD‑160, while still widely used in Bitcoin, is not recommended for new generic cryptographic designs. Use this crate when *interoperability* with existing protocols explicitly demands RIPEMD‑160.\n\n---\n\n## Quick start\n\nAdd to your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoin-ripemd = \"0.1.19\"\n```\n\nHash a byte slice into a 20‑byte RIPEMD‑160 digest:\n\n```rust\nuse bitcoin_ripemd::Ripemd160;\n\nfn ripemd160_hex(data: &[u8]) -> String {\n    let mut hasher = Ripemd160::new();\n    hasher.update(data);\n\n    let mut out = [0u8; 20]; // RIPEMD160_OUTPUT_SIZE\n    hasher.finalize(&mut out);\n\n    // encode as lowercase hex (example, using `hex` crate)\n    hex::encode(out)\n}\n\nfn main() {\n    let digest_hex = ripemd160_hex(b\"hello world\");\n    println!(\"RIPEMD-160(\\\"hello world\\\") = {}\", digest_hex);\n}\n```\n\nStreaming large data is identical: call `update` repeatedly and `finalize` once at the end.\n\n```rust\nuse bitcoin_ripemd::Ripemd160;\n\nfn hash_chunks(chunks: &[&[u8]]) -> [u8; 20] {\n    let mut h = Ripemd160::new();\n\n    for &chunk in chunks {\n        h.update(chunk);\n    }\n\n    let mut out = [0u8; 20];\n    h.finalize(&mut out);\n    out\n}\n```\n\nIf you want to reuse the same hasher instance for multiple messages:\n\n```rust\nlet mut h = Ripemd160::new();\n\nh.update(b\"message one\");\nlet mut out1 = [0u8; 20];\nh.finalize(&mut out1);\n\nh.reset();\nh.update(b\"message two\");\nlet mut out2 = [0u8; 20];\nh.finalize(&mut out2);\n```\n\n---\n\n## API overview\n\n### `struct Ripemd160`\n\n```rust\npub struct Ripemd160  {\n    s:     [u32; 5],   // internal state words (5 × 32 bits = 160 bits)\n    buf:   [u8; 64],   // partial chunk buffer\n    bytes: u64,        // total bytes ingested\n}\n```\n\nKey methods:\n\n- `Ripemd160::new() -> Self`\n  - Constructs a new hasher with the standard RIPEMD‑160 IV.\n- `Ripemd160::default() -> Self`\n  - Alias for `new`, also initializes the state via `ripemd160_initialize`.\n- `fn update(&mut self, data: &[u8]) -> &mut Self`\n  - High‑level, safe ingestion of arbitrary byte slices.\n  - Internally forwards to `write` and handles chunking into 64‑byte blocks.\n- `fn finalize(&mut self, hash: &mut [u8; RIPEMD160_OUTPUT_SIZE])`\n  - Completes the hash computation, writes the 20‑byte digest into `hash`.\n  - Performs RIPEMD‑160 padding: appends `0x80`, then zeros, then the 64‑bit little‑endian bit length.\n  - Encodes the final 5 × 32‑bit state words in little‑endian order into the caller buffer.\n- `fn reset(&mut self) -> &mut Self`\n  - Zeroes the byte counter and reinitializes the internal state to the RIPEMD‑160 IV, allowing reuse.\n\nThere is also a low‑level pointer interface:\n\n- `fn write(&mut self, data: *const u8, len: usize) -> &mut Self`\n  - Unsafe, but tightly aligned with the internal buffering and transform logic.\n  - Intended for performance‑sensitive code that already manipulates raw pointers.\n\nGenerated accessors (via `getset`):\n\n- `s()`, `s_mut()`: internal state array\n- `buf()`, `buf_mut()`: internal buffer\n- `bytes()`, `bytes_mut()`: total byte counter\n\nThese are mainly useful for diagnostics, testing or integrating with other low‑level primitives.\n\n---\n\n## Cryptographic core\n\nRIPEMD‑160 is a Merkle–Damgård hash function operating on 512‑bit message blocks and maintaining a 160‑bit internal state. Each block is processed through five rounds of non‑linear mixing in *two parallel lanes*, followed by a feed‑forward with the previous state.\n\nThis crate exposes the internal round primitives explicitly, which is invaluable for verification and optimization work:\n\n### Boolean round functions\n\n```rust\npub fn ripemd160_f1(x: u32, y: u32, z: u32) -> u32 { x ^ y ^ z }\npub fn ripemd160_f2(x: u32, y: u32, z: u32) -> u32 { (x & y) | (!x & z) }\npub fn ripemd160_f3(x: u32, y: u32, z: u32) -> u32 { (x | !y) ^ z }\npub fn ripemd160_f4(x: u32, y: u32, z: u32) -> u32 { (x & z) | (y & !z) }\npub fn ripemd160_f5(x: u32, y: u32, z: u32) -> u32 { x ^ (y | !z) }\n```\n\nThese are the five canonical RIPEMD‑160 boolean functions. Each round uses one of them together with:\n\n- a message word `x`\n- a round constant `k`\n- a rotation amount `r`\n\n### One-round update\n\n```rust\npub fn ripemd160_round(\n    a: &mut u32,\n    b: u32,\n    c: &mut u32,\n    d: u32,\n    e: u32,\n    f: u32,\n    x: u32,\n    k: u32,\n    r: i32,\n)\n```\n\nMathematically, this performs (in 32‑bit arithmetic):\n\n\\[\n\\begin{aligned}\nA' &= \\mathrm{ROL}_{r}(A + f + x + k) + E \\\\\nC' &= \\mathrm{ROL}_{10}(C)\n\\end{aligned}\n\\]\n\nwhere `ROL` is a left rotation modulo 2³², implemented by `ripemd160_rol`.\n\n### Per‑round wrappers\n\nThe functions `ripemd160_rXY` (e.g., `ripemd160_r11`, `ripemd160_r22`, `ripemd160_r51`, etc.) bind in the appropriate boolean function, round constant, and rotation schedule for each phase. Their signatures are homogeneous:\n\n```rust\npub fn ripemd160_r11(\n    a: &mut u32,\n    b: u32,\n    c: &mut u32,\n    d: u32,\n    e: u32,\n    x: u32,\n    r: i32,\n)\n```\n\nEach wrapper computes the boolean function `f` for that round and delegates to `ripemd160_round` with its fixed constant `k`. This design keeps the top‑level compression loop (`ripemd160_transform`) legible while still being amenable to inlining and constant propagation.\n\n### Compression function\n\n```rust\npub fn ripemd160_transform(s: *mut u32, chunk: *const u8)\n```\n\n- Expects five 32‑bit state words at `s` and a 64‑byte block at `chunk`.\n- Loads sixteen little‑endian message words `w0…w15`.\n- Initializes two parallel lanes `(a1…e1)` and `(a2…e2)` from the current state.\n- Executes all 80 rounds in the canonical RIPEMD‑160 schedule using the `Rxy` helpers.\n- Performs the final feed‑forward, mixing both lanes back into `s[0..5]`.\n\nThis function is the exact Merkle–Damgård compression primitive; it is exposed for specialized applications that need tighter control or independent verification.\n\n### State initialization\n\n```rust\npub fn ripemd160_initialize(s: *mut u32)\n```\n\nWrites the standard RIPEMD‑160 IV into `s[0..5]`:\n\n```text\nH0 = 0x67452301\nH1 = 0xEFCDAB89\nH2 = 0x98BADCFE\nH3 = 0x10325476\nH4 = 0xC3D2E1F0\n```\n\nThese constants mirror those of SHA‑1 up to endianness nuances and are part of the RIPEMD‑160 specification.\n\n---\n\n## Tracing and observability\n\nThe implementation is instrumented with `tracing` calls at various granularities:\n\n- `trace!` in boolean functions, rotation, and per‑round helpers\n- `debug!` in `ripemd160_transform`\n- `info!` in initialization, default construction, reset, and finalize paths\n\nTo exploit this, configure a `tracing` subscriber in your binary or test harness. For example:\n\n```rust\nuse tracing_subscriber::EnvFilter;\n\nfn main() {\n    tracing_subscriber::fmt()\n        .with_env_filter(EnvFilter::from_default_env())\n        .init();\n\n    // now use Ripemd160; internal state transitions will be logged\n}\n```\n\nYou can then enable detailed logs for a specific module, such as:\n\n```bash\nRUST_LOG=debug,ripemd160=trace cargo test\n```\n\nThis makes the crate useful not only as a hashing library but also as an educational and diagnostic tool when studying RIPEMD‑160.\n\n---\n\n## Safety and low-level behavior\n\n- The `update` API is fully safe and should be preferred for regular application code.\n- The pointer‑based `write`, `ripemd160_transform`, and `ripemd160_initialize` APIs are `unsafe` and assume that the pointers are valid and aligned for the required sizes.\n- All internal arithmetic is performed modulo 2³² using `wrapping_add` and bit rotations, as required for deterministic RIPEMD‑160 semantics.\n\nIf you are integrating this crate into constant‑time critical code, note that RIPEMD‑160 is largely constructed from data‑independent operations (bitwise logic, rotations, and modular additions). However, the usual caveats apply: host/compiler behavior, logging side‑channels, and surrounding protocol choices still matter.\n\n---\n\n## Interoperability notes\n\n- Output size is always 20 bytes (`RIPEMD160_OUTPUT_SIZE`), encoded **little‑endian** word by word.\n- Bitcoin's `HASH160` (RIPEMD‑160(SHA‑256(x))) is supported by composing this crate with a SHA‑256 implementation; this crate intentionally focuses only on RIPEMD‑160.\n- The implementation is designed to be bit‑for‑bit compatible with the widely deployed RIPEMD‑160 reference algorithm.\n\n---\n\n## Repository and maintenance\n\nThis crate is developed and maintained within the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) repository and is versioned as an independent crate (`bitcoin-ripemd`). Issues and pull requests should be filed against that repository.\n\n---\n\n## License\n\nThis crate is licensed under the MIT license, matching the rest of `bitcoin-rs`.\n\nYou are free to use it in proprietary or open‑source software, subject to the terms of the MIT license.\n",
  "package_categories": [
    "cryptography",
    "algorithms",
    "science"
  ],
  "package_description": "Low-level, auditable RIPEMD-160 implementation used by bitcoin-rs, providing a streaming hasher and explicit compression function suitable for Bitcoin HASH160 and interoperability use cases.",
  "package_keywords": [
    "ripemd160",
    "bitcoin",
    "hash",
    "cryptography",
    "digest"
  ]
}