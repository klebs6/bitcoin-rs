{
  "crate_name": "bitcoin-remote",
  "full_readme_markdown": "# bitcoin-remote\n\nLow-level, zero-magic utilities for speaking Bitcoin Core's JSON‑RPC over HTTP, faithfully ported from upstream C++ with strongly typed Rust interfaces.\n\nThis crate does **not** try to be a full Bitcoin wallet or a high-level client library. Instead, it focuses on being a **precise, observable, and testable** substrate for:\n\n- constructing and serializing JSON‑RPC requests and replies,\n- handling Bitcoin Core's RPC error model (codes and HTTP mappings),\n- managing `rpcauth`/cookie-based authentication,\n- resolving Bitcoin-style configuration paths,\n- and handling parameter-conversion metadata reproduced from Bitcoin Core's own RPC tables.\n\nIf you want exact behavioral parity with `bitcoind`'s RPC interface—down to error codes, HTTP status behavior, and batch semantics—this crate is intended for you.\n\n> **Note**: This README was generated by an AI model and may not be 100% accurate. However, it is intended to be a close and practically useful description of the crate.\n\n---\n\n## Features at a Glance\n\n- **HTTP / JSON‑RPC fidelity**\n  - `HTTPStatusCode` enum for mapping internal failures to HTTP status codes.\n  - JSON‑RPC 1.0 compatible wire format with selective adoption of 1.1/2.0 semantics for error structure.\n  - Batch‑reply processing that mirrors upstream C++ behavior, including panic conditions on malformed replies.\n\n- **Bitcoin Core RPC error codes**\n  - `RPCErrorCode` is a `bitflags!` set of all Bitcoin Core RPC error codes, including wallet, P2P, chain, and general application errors.\n  - Aliases for backward compatibility (e.g. `RPC_TRANSACTION_ERROR`) closely track upstream.\n\n- **RPC parameter conversion metadata**\n  - `RPCConvertParam` and `RPCConvertTable` encode which RPC parameters must be treated as *JSON* even when passed as textual CLI arguments.\n  - Lookup by `(method, index)` or `(method, name)` gives you a boolean indicating whether a parameter must be JSON‑parsed before being passed to Core.\n\n- **Authentication cookie helpers**\n  - `generate_auth_cookie`, `get_auth_cookie`, and `delete_auth_cookie` implement the same cookie‑file strategy as Bitcoin Core:\n    - random password generation\n    - temporary file + atomic rename\n    - respect for `-rpccookiefile` from global args\n\n- **JSON‑RPC request and response composition**\n  - `JSONRPCRequest` encapsulates method, params, id, and metadata like `uri`, `auth_user`, and `peer_addr`.\n  - `jsonrpc_request_obj`, `jsonrpc_reply_obj`, `jsonrpc_reply`, and `jsonrpc_error` are low-level helpers over `UniValue`.\n\n- **Instrumentation**\n  - Strategic, structured logging via the `tracing` crate at trace/debug/info levels, intended for production observability without polluting the hot path.\n\nThe crate assumes you are comfortable working close to the protocol: you will handle HTTP transport concerns, lifetimes, and concurrency at your own abstraction layer.\n\n---\n\n## Design Philosophy\n\nThe design mirrors Bitcoin Core's internals:\n\n- **Minimal abstraction leak**: the Rust types are thin wrappers around the behavior of upstream C++ constructs, including panic conditions and error code usage.\n- **Deterministic edge behavior**: malformed batch responses, invalid request objects, and type errors produce panics consistent with the original exception‑throwing C++ implementation.\n- **Explicit data flow**: all JSON objects are composed using `UniValue` (from `uni_value`), not `serde_json`, to follow Core's semantics exactly.\n\nThe goal is to allow you to *reconstruct, inspect, and control* your interaction with a Bitcoin node with maximal transparency.\n\n---\n\n## Core Types and Modules\n\n### HTTPStatusCode\n\n```rust\n#[repr(i32)]\npub enum HTTPStatusCode {\n    HTTP_OK,\n    HTTP_BAD_REQUEST,\n    HTTP_UNAUTHORIZED,\n    HTTP_FORBIDDEN,\n    HTTP_NOT_FOUND,\n    HTTP_BAD_METHOD,\n    HTTP_INTERNAL_SERVER_ERROR,\n    HTTP_SERVICE_UNAVAILABLE,\n}\n```\n\n`HTTPStatusCode` encodes the subset of HTTP codes relevant to JSON‑RPC error mapping. Upstream Core maps certain RPC errors to specific HTTP codes (e.g. `RPC_INVALID_REQUEST` → `HTTP_BAD_REQUEST`). Use this when designing your HTTP layer.\n\n### JSONRPCRequestMode\n\n```rust\npub enum JSONRPCRequestMode {\n    EXECUTE,\n    GET_HELP,\n    GET_ARGS,\n}\n```\n\n`JSONRPCRequestMode` allows you to model whether an incoming request is meant to be executed or used for help/argument introspection. This is primarily useful for CLI frontends or meta‑RPC layers.\n\n### RPCErrorCode (bitflags)\n\n`RPCErrorCode` is defined using `bitflags!` over `i32`. It enumerates the entire Bitcoin Core RPC error space:\n\n- **Standard JSON‑RPC 2.0 errors**: `RPC_INVALID_REQUEST`, `RPC_METHOD_NOT_FOUND`, `RPC_INVALID_PARAMS`, `RPC_INTERNAL_ERROR`, `RPC_PARSE_ERROR`.\n- **General application errors**: `RPC_MISC_ERROR`, `RPC_TYPE_ERROR`, `RPC_INVALID_PARAMETER`, etc.\n- **P2P client errors**: `RPC_CLIENT_NOT_CONNECTED`, `RPC_CLIENT_IN_INITIAL_DOWNLOAD`, `RPC_CLIENT_NODE_CAPACITY_REACHED`, etc.\n- **Chain and mempool errors**.\n- **Wallet errors**: `RPC_WALLET_ERROR`, `RPC_WALLET_INSUFFICIENT_FUNDS`, `RPC_WALLET_UNLOCK_NEEDED`, `RPC_WALLET_ALREADY_LOADED`, etc.\n- **Legacy aliases and reserved codes**, retained for backwards compatibility.\n\nEach error is a bitflag with a specific negative code matching Bitcoin Core's public RPC interface. Example:\n\n```rust\nuse bitcoin_remote::RPCErrorCode;\n\nfn classify(err_code: i32) {\n    if err_code == RPCErrorCode::RPC_WALLET_INSUFFICIENT_FUNDS.bits() {\n        eprintln!(\"insufficient funds: {err_code}\");\n    }\n}\n```\n\nUsing a bitflag type instead of raw `i32` clarifies intent and allows consistent code completion.\n\n### RPCConvertParam & RPCConvertTable\n\nBitcoin Core distinguishes between positional and named RPC parameters that must be treated as *JSON* instead of simple strings. For example, `sendrawtransaction` expects a hex string, whereas `createrawtransaction` may expect complex JSON objects.\n\nThis crate mirrors Core's table‑driven approach using:\n\n```rust\n#[derive(Debug, Getters, MutGetters, Setters, Default, Builder)]\npub struct RPCConvertParam {\n    method_name: &'static str,\n    param_idx:   i32,\n    param_name:  &'static str,\n}\n\n#[derive(Debug, Getters, MutGetters, Setters, Default, Builder)]\npub struct RPCConvertTable {\n    members:         HashSet<(String, i32)>,\n    members_by_name: HashSet<(String, String)>,\n}\n```\n\nand the global instance:\n\n```rust\nlazy_static! {\n    pub static ref RPC_CVT_TABLE: std::sync::Mutex<RPCConvertTable> =\n        std::sync::Mutex::new(RPCConvertTable::new());\n}\n```\n\n`RPCConvertTable::new()` populates `members` and `members_by_name` from a static `vRPCConvertParams` list emitted from upstream definitions. You can query it as follows:\n\n```rust\nuse bitcoin_remote::RPC_CVT_TABLE;\n\nfn param_requires_json(method: &str, index: i32) -> bool {\n    let mut tbl = RPC_CVT_TABLE.lock().expect(\"RPC_CVT_TABLE poisoned\");\n    tbl.convert_with_method_and_idx(method, index)\n}\n\nfn param_requires_json_by_name(method: &str, name: &str) -> bool {\n    let mut tbl = RPC_CVT_TABLE.lock().expect(\"RPC_CVT_TABLE poisoned\");\n    tbl.convert_with_method_and_name(method, name)\n}\n```\n\nThese APIs are intentionally simple: they answer *\"must this parameter be JSON‑parsed?\"* without hiding the table's structure.\n\n### JSONRPCRequest\n\n```rust\npub struct JSONRPCRequest {\n    id:         UniValue,\n    str_method: String,\n    params:     UniValue,\n    mode:       JSONRPCRequestMode,\n    uri:        String,\n    auth_user:  String,\n    peer_addr:  String,\n    context:    Box<dyn Any>,\n}\n```\n\nThe `parse` method implements JSON‑RPC request parsing consistent with Bitcoin Core:\n\n- Validates that the top-level value is an object.\n- Extracts `id` early so subsequent error reports can include it.\n- Checks `method` is present and a string.\n- Accepts `params` as either an array or object; `null` becomes an empty array; all other types panic as invalid.\n\nExample:\n\n```rust\nuse bitcoin_remote::{JSONRPCRequest, jsonrpc_error, RPCErrorCode};\nuse uni_value::{UniValue, VType};\n\nfn parse_single_request(val_request: &UniValue) -> JSONRPCRequest {\n    let mut req = JSONRPCRequest {\n        // reasonable defaults; context populated by caller\n        id: UniValue::null(),\n        str_method: String::new(),\n        params: UniValue::empty_array(),\n        mode: bitcoin_remote::JSONRPCRequestMode::EXECUTE,\n        uri: String::new(),\n        auth_user: String::new(),\n        peer_addr: String::new(),\n        context: Box::new(()),\n    };\n\n    // May panic with a JSON‑encoded error, per Core behavior\n    req.parse(val_request);\n    req\n}\n```\n\nBecause the implementation intentionally panics on structural violations (mirroring C++ exceptions), you should either sanitize input at your HTTP boundary or wrap parsing in higher‑level error handling if you need a non‑panic path.\n\n---\n\n## JSON‑RPC Utilities\n\n### Building requests\n\n```rust\npub fn jsonrpc_request_obj(str_method: &str, params: &UniValue, id: &UniValue) -> UniValue\n```\n\nCreates a minimal JSON‑RPC request object:\n\n```json\n{ \"method\": <str_method>, \"params\": <params>, \"id\": <id> }\n```\n\nExample:\n\n```rust\nuse bitcoin_remote::jsonrpc_request_obj;\nuse uni_value::{UniValue, VType};\n\nlet mut params = UniValue::new(VType::VARR, None);\nparams.push_back(\"getblockchaininfo\");\n\nlet id = UniValue::from(1_i64);\nlet req = jsonrpc_request_obj(\"getblockchaininfo\", &params, &id);\n\nlet wire = req.write(None, None);\n```\n\n### Building replies and errors\n\n```rust\npub fn jsonrpc_reply_obj(result: &UniValue, error: &UniValue, id: &UniValue) -> UniValue\npub fn jsonrpc_reply(result: &UniValue, error: &UniValue, id: &UniValue) -> String\npub fn jsonrpc_error(code: i32, message: &str) -> UniValue\n```\n\nSemantics:\n\n- If `error` is not `null`, the reply's `\"result\"` field is forced to `null`.\n- `jsonrpc_reply` serializes the reply to a compact string and appends a newline (matching Core's `write() + \"\\n\"`).\n\nExample:\n\n```rust\nuse bitcoin_remote::{jsonrpc_reply, jsonrpc_error, RPCErrorCode};\nuse uni_value::UniValue;\n\n// success reply\nlet result = UniValue::from(\"ok\");\nlet error = UniValue::null();\nlet id = UniValue::from(1_i64);\nlet success_wire = jsonrpc_reply(&result, &error, &id);\n\n// error reply\nlet err_obj = jsonrpc_error(\n    RPCErrorCode::RPC_INVALID_PARAMS.bits(),\n    \"invalid parameters supplied\",\n);\nlet error_wire = jsonrpc_reply(&UniValue::null(), &err_obj, &id);\n```\n\n### Batch reply processing\n\n```rust\npub fn jsonrpc_process_batch_reply(in_: &UniValue) -> Vec<UniValue>\n```\n\nParses a batch reply into a `Vec<UniValue>` indexed by numeric `\"id\"`:\n\n- `in_` must be an array; otherwise the function panics with *\"Batch must be an array\"*.\n- Each member must be an object; non‑objects panic with *\"Batch member must be an object\"*.\n- Each member must have an integer `\"id\"` between `0` and `batch_size - 1`; otherwise, a panic with *\"Batch member id is larger than batch size\"* occurs.\n\nThis deterministic behavior makes it straightforward to implement batch clients that rely strictly on index‑based mapping.\n\nExample:\n\n```rust\nuse bitcoin_remote::jsonrpc_process_batch_reply;\nuse uni_value::{UniValue, VType};\n\nfn handle_batch(batch_uv: &UniValue) {\n    let replies = jsonrpc_process_batch_reply(batch_uv);\n    for (idx, reply) in replies.iter().enumerate() {\n        println!(\"reply {idx}: {reply:?}\");\n    }\n}\n```\n\n---\n\n## Authentication Cookie Helpers\n\nBitcoin Core supports a cookie‑file based authentication mechanism. This crate provides low-level helpers that implement the same behavior, including path resolution and atomic writes.\n\n### get_auth_cookie_file\n\n```rust\npub fn get_auth_cookie_file(temp: Option<bool>) -> Box<Path>\n```\n\n- Resolves the absolute path for the RPC auth cookie.\n- If `temp == Some(true)`, appends `.tmp` and returns the path for the temporary file location.\n- Uses `-rpccookiefile=<path>` from global args if present; otherwise it falls back to the default (typically something like `$DATADIR/.cookie`).\n\n### generate_auth_cookie\n\n```rust\npub fn generate_auth_cookie(cookie_out: &mut String) -> bool\n```\n\nSteps:\n\n1. Generate 32 random bytes and hex‑encode them as the password portion.\n2. Construct `\"<COOKIEAUTH_USER>:<hex_password>\"`.\n3. Write to the temporary cookie file (`.tmp`), creating parent directories as needed.\n4. Atomically rename the temporary file to the final auth cookie path.\n\nOn success, `cookie_out` is populated and `true` is returned. Errors are logged via `tracing::error!` and `false` is returned; best‑effort clean‑up is attempted.\n\nExample:\n\n```rust\nuse bitcoin_remote::generate_auth_cookie;\n\nlet mut cookie = String::new();\nif generate_auth_cookie(&mut cookie) {\n    println!(\"Generated cookie: {cookie}\");\n}\n```\n\n### get_auth_cookie\n\n```rust\npub fn get_auth_cookie(cookie_out: &mut String) -> bool\n```\n\n- Reads the cookie from disk into `cookie_out`.\n- Trims trailing `\\n` and optional `\\r` to match C++ `getline` behavior.\n- Returns `false` if the file cannot be opened or read, logging at `debug` or `warn` levels.\n\n### delete_auth_cookie\n\n```rust\npub fn delete_auth_cookie()\n```\n\nAttempts to delete the cookie file. Any I/O error other than *file not found* is logged but otherwise ignored.\n\nExample integration pattern:\n\n```rust\nuse bitcoin_remote::{generate_auth_cookie, get_auth_cookie, delete_auth_cookie};\n\nfn rotate_cookie() {\n    let mut new_cookie = String::new();\n    if !generate_auth_cookie(&mut new_cookie) {\n        eprintln!(\"failed to generate new cookie\");\n        return;\n    }\n\n    let mut read_back = String::new();\n    if get_auth_cookie(&mut read_back) {\n        assert_eq!(new_cookie, read_back);\n    }\n\n    delete_auth_cookie();\n}\n```\n\n---\n\n## Error Semantics and Stability\n\n- **Panics vs. errors**: many functions (`JSONRPCRequest::parse`, `jsonrpc_process_batch_reply`) intentionally use `panic!` on structural violations, to mimic Bitcoin Core's use of exceptions for programmer / protocol errors rather than expected runtime failures.\n- **Logging**: `trace!`, `debug!`, `info!`, `warn!`, and `error!` invocations align with logical phases—construction, parsing, and I/O. In production, you can adjust your `tracing` subscriber level to tune verbosity.\n- **Error codes**: `RPCErrorCode` values are kept numerically identical to upstream. Where upstream deprecates or repurposes codes, the crate favors backward compatibility.\n\nIf you are building public APIs or user‑facing tooling on top of this crate, you may want to wrap these primitives into a non‑panicking facade that translates panics into structured error values.\n\n---\n\n## Example: End‑to‑End Single Call\n\nBelow is a sketch of how you might integrate `bitcoin-remote` into a higher-level HTTP client. This example omits error‑handling and TLS for brevity.\n\n```rust\nuse bitcoin_remote::{\n    jsonrpc_request_obj,\n    jsonrpc_reply,\n    jsonrpc_process_batch_reply,\n};\nuse uni_value::{UniValue, VType};\n\nfn build_getblockchaininfo_request() -> String {\n    let params = UniValue::empty_array();\n    let id = UniValue::from(0_i64);\n    let req_obj = jsonrpc_request_obj(\"getblockchaininfo\", &params, &id);\n    let mut s = req_obj.write(None, None);\n    s.push('\\n');\n    s\n}\n\nfn main() {\n    let body = build_getblockchaininfo_request();\n\n    // send `body` over HTTP POST to bitcoind's RPC endpoint using your\n    // HTTP client of choice (e.g., reqwest). Parse the response into\n    // `UniValue` using the `uni_value` crate, then handle it.\n}\n```\n\n---\n\n## Crate Metadata\n\n- **Crate name**: `bitcoin-remote`\n- **Version**: `0.1.22`\n- **Edition**: Rust 2021\n- **License**: MIT\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\n- **Primary author**: `klebs <none>`\n\n---\n\n## Caveats\n\n- This README was produced by an AI model and may diverge slightly from the exact current API surface, especially around auxiliary functions and constants not shown in the provided interface.\n- Always rely on the actual Rustdoc and source code in the repository for authoritative reference.\n",
  "package_categories": [
    "network-programming",
    "api-bindings",
    "cryptography",
    "finance",
    "development-tools"
  ],
  "package_description": "Low-level, Bitcoin Core–compatible JSON-RPC helper crate providing HTTP status mapping, RPC error codes, auth-cookie management, parameter-conversion tables, and UniValue-based request/reply utilities.",
  "package_keywords": [
    "bitcoin",
    "json-rpc",
    "rpc",
    "auth-cookie",
    "bitcoind"
  ]
}