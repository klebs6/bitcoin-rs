{
  "crate_name": "bitcoinleveldb-limiter",
  "full_readme_markdown": "# bitcoinleveldb-limiter\n\nA small, focused concurrency primitive for bounding resource consumption in the Bitcoin LevelDB stack. It provides a lock-free, atomic counterâ€“based limiter intended for constraining scarce process resources such as file descriptors and mmapped regions.\n\n> This README.md was generated by an AI model and may not be perfectly accurate, though it is designed to be technically precise and practically useful.\n\n---\n\n## Overview\n\n`bitcoinleveldb-limiter` exposes a single type, `Limiter`, which enforces a hard upper bound on the number of concurrently held resources. It is designed for scenarios where allocation is cheap but oversubscription has catastrophic or non-linear system cost (e.g., exhausting file descriptors, virtual address space, or triggering kernel pathologies under massive FD counts).\n\nThe limiter is:\n\n- **Lock-free**: uses an `Atomic<i32>` with relaxed ordering for minimal contention.\n- **Deterministic**: enforces a fixed maximum concurrent acquisition count.\n- **Non-blocking**: acquisition attempts are fail-fast (`bool`), leaving blocking/retry policy to the caller.\n- **Symmetric**: each successful `acquire()` must be paired with exactly one `release()`.\n\nConceptually, `Limiter` is an integer-valued resource semaphore with non-blocking acquisition and a compile-time known capacity.\n\n---\n\n## Core API\n\n```rust\nuse bitcoinleveldb_limiter::Limiter;\n\n/// Construct a limiter with a maximum of `max_acquires` concurrent resources.\n/// Negative values are clamped to 0.\npub fn new(max_acquires: i32) -> Limiter;\n\n/// Attempt to acquire one unit of capacity.\n///\n/// Returns `true` if a resource was successfully acquired, `false` if the\n/// limiter is at capacity and no additional resource can be granted.\npub fn acquire(&self) -> bool;\n\n/// Release one unit of capacity previously acquired by `acquire()`.\n///\n/// Must only be called after a successful `acquire()`. Over-release is\n/// detected in debug builds via `debug_assert!`.\npub fn release(&self);\n```\n\n### Semantics\n\n- `new(max_acquires)`\n  - `max_acquires >= 0`: the limiter starts with exactly `max_acquires` available slots.\n  - `max_acquires < 0`: a warning is logged and capacity is clamped to `0`.\n  - The maximum capacity is immutable for the lifetime of the limiter.\n\n- `acquire()`\n  - Performs an atomic `fetch_sub(1, Relaxed)`.\n  - If the *previous* value was strictly greater than 0, the call succeeds and returns `true`.\n  - If the *previous* value was `<= 0`, capacity is immediately restored via a compensating `fetch_add(1, Relaxed)` and the call returns `false`.\n  - In debug builds, exceeding the configured maximum (indicating mismatched `release()` calls) triggers a `debug_assert!`.\n\n- `release()`\n  - Performs an atomic `fetch_add(1, Relaxed)`.\n  - In debug builds, if the pre-increment value is already at or above `max_acquires`, a `debug_assert!` fires to signal over-release.\n\nThis yields a simple invariant in debug mode:\n\n\\[\n0 \\leq \\text{acquires\\_allowed} \\leq \\text{max\\_acquires}\n\\]\n\nwhen all clients pair acquisitions and releases correctly.\n\n---\n\n## Usage Patterns\n\n### Limiting Open File Descriptors\n\n```rust\nuse bitcoinleveldb_limiter::Limiter;\nuse std::fs::File;\nuse std::io;\nuse std::path::Path;\n\nfn open_bounded<P: AsRef<Path>>(limiter: &Limiter, path: P) -> io::Result<Option<File>> {\n    if !limiter.acquire() {\n        // At capacity: caller decides whether to block, backoff, or degrade.\n        return Ok(None);\n    }\n\n    let file = File::open(path);\n\n    // Ensure capacity is returned even on error paths.\n    if file.is_err() {\n        limiter.release();\n    }\n\n    Ok(file.ok())\n}\n```\n\n### Integrating Into a Pool or Handle Type\n\nWrap the limiter into a higher-level RAII guard so you cannot forget to release:\n\n```rust\nuse bitcoinleveldb_limiter::Limiter;\nuse std::sync::Arc;\n\npub struct Permit {\n    limiter: Arc<Limiter>,\n}\n\nimpl Drop for Permit {\n    fn drop(&mut self) {\n        self.limiter.release();\n    }\n}\n\nimpl Permit {\n    pub fn try_acquire(limiter: Arc<Limiter>) -> Option<Self> {\n        if limiter.acquire() {\n            Some(Permit { limiter })\n        } else {\n            None\n        }\n    }\n}\n```\n\nThis pattern is particularly valuable under complex control flow, where manual bookkeeping is error-prone.\n\n### Backpressure and Retry Strategies\n\nBecause `acquire()` is non-blocking, the caller can implement any policy for handling saturation:\n\n- Immediate failure with a typed error.\n- Bounded retry with exponential backoff.\n- Parking the current thread or task until capacity becomes available.\n\nThis design cleanly separates *resource accounting* (the concern of `Limiter`) from *scheduling and latency* (the concern of the caller or surrounding framework).\n\n---\n\n## Concurrency & Memory Ordering\n\n`Limiter` employs `Atomic<i32>` with `Ordering::Relaxed`. This is adequate because:\n\n- The only shared state is the integer count of permits.\n- Callers do not rely on `Limiter` to publish or synchronize additional data beyond the availability of capacity.\n- Correctness depends solely on arithmetic invariants of the counter, not on happens-before relations for external memory.\n\nIf you use the limiter as part of a synchronization protocol that also coordinates additional shared state, you must introduce the appropriate memory ordering or separate synchronization primitives outside of `Limiter`.\n\nAs with any non-blocking primitive, `Limiter` does **not** provide fairness guarantees: under heavy contention, some threads may experience repeated acquisition failures even while others succeed.\n\n---\n\n## Error Detection & Debugging\n\n`Limiter` uses `debug_assert!` for internal consistency checks:\n\n- Over-release (`release()` called more times than successful `acquire()` calls) is detected.\n- Misbehavior in `acquire()` / `release()` symmetry manifests early in debug builds.\n\nThese checks are removed in `--release` builds, so you should validate your usage under debug configuration during development.\n\nLogging (`trace!`, `debug!`, `warn!`) is employed for observability and can be integrated with a structured logging backend. In production, you typically reduce the log level to keep overhead minimal.\n\n---\n\n## Integration in the `bitcoin-rs` Repository\n\nThis crate originates from the `bitcoin-rs` project and mirrors the resource limiting semantics used in Bitcoin Core's LevelDB integration. Its primary application is preventing pathological resource usage in large on-disk databases while keeping the limiting primitive self-contained and composable.\n\nRepository: <https://github.com/klebs6/bitcoin-rs>\n\n---\n\n## When to Use `Limiter`\n\n`Limiter` is appropriate when:\n\n- You are protecting a small, fixed, global resource pool (FDs, mmaps, cache entries).\n- You want **non-blocking**, low-overhead checks on resource availability.\n- Debug-time detection of misuse is desirable.\n\nYou might prefer a different abstraction when:\n\n- You require blocking behavior or async integration out of the box (consider semaphores in async runtimes).\n- You need fairness, prioritization, or complex admission control (consider queues or more sophisticated schedulers).\n\n`bitcoinleveldb-limiter` deliberately focuses on a single, precise responsibility: safe, low-latency enforcement of a global concurrency bound.\n",
  "package_categories": [
    "concurrency",
    "data-structures",
    "development-tools"
  ],
  "package_description": "Lock-free atomic limiter used to cap concurrent resource usage (e.g., file descriptors and mmaps) in Bitcoin LevelDB integrations, providing a non-blocking counter-based semaphore with debug-time misuse detection.",
  "package_keywords": [
    "bitcoin",
    "leveldb",
    "limiter",
    "concurrency",
    "semaphore"
  ]
}