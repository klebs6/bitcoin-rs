{
  "crate_name": "bitcoin-service",
  "full_readme_markdown": "# bitcoin-service\n\nA low-level, `no_std`-friendly (when built without the `std`-bound dependencies) Rust port of Bitcoin Core's `CService` type and associated hashing utilities. It models a network *service* as the combination of a network address and a TCP port, together with canonical hashing and ordering semantics compatible with the Bitcoin reference implementation.\n\n> Note: This README was generated by an AI model. It may not be perfectly accurate in every detail, but it is intended to be a close and practically useful description of the crate.\n\n---\n\n## Overview\n\n`bitcoin-service` provides a thin but precise abstraction around network endpoints in the Bitcoin stack:\n\n- `Service`: a combination of a `NetAddr` (IP/Tor/I2P/Internal) and a TCP port.\n- `ServiceHash`: a `BuildHasher` for use in `HashMap`/`HashSet` keyed by `Service`, using salted SipHash.\n- `GetServiceRef` / `GetServiceMut`: small traits for types that logically contain or expose a `Service` value.\n\nThe APIs closely follow the semantics of Bitcoin Core's C++ `CService` implementation, including byte-level encoding of addresses and ports, comparison ordering, and keyed hashing.\n\nThis crate lives in the broader `bitcoin-rs` repository, which aims to be a faithful, modular port of Bitcoin Core into safe(ish) Rust.\n\n---\n\n## Crate goals\n\n- **Fidelity to Bitcoin Core**: Behavior and byte layouts should match `CService` so that higher-level P2P and consensus logic can be ported without semantic drift.\n- **Deterministic ordering and hashing**: Implement `Eq`, `Ord`, `Hash`, and `BuildHasher` in a way that is compatible with network data structures and peer management algorithms.\n- **Interoperability with libc sockets**: Provide conversions to and from `libc::sockaddr_in` / `sockaddr_in6`, for integration with low-level networking stacks.\n- **Ergonomic Rust API**: Simple constructors, conversion helpers, and trait abstractions for use across the `bitcoin-rs` workspace.\n\n---\n\n## Data model\n\n```rust\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Service {\n    base: NetAddr,\n    port: u16,\n}\n```\n\nA `Service` is conceptually:\n\n- `base: NetAddr`: the underlying network address (IPv4, IPv6, Tor, I2P, internal, etc.).\n- `port: u16`: the TCP port in host byte order.\n\nFrom a Bitcoin P2P perspective, a `Service` corresponds to a reachable network endpoint: e.g., a full node's advertised address, an outbound connection target, or an address book entry.\n\nThe crate also defines:\n\n```rust\npub struct ServiceHash {\n    salt_k0: u64,\n    salt_k1: u64,\n}\n```\n\nThis type implements `BuildHasher` to construct SipHash instances with per-instance randomness. This is important when using `Service` as a key in `HashMap`/`HashSet`, to reduce hash-collision attacks and accidental worst-case behavior.\n\n---\n\n## Core traits\n\n### `GetServiceRef` / `GetServiceMut`\n\n```rust\npub trait GetServiceRef {\n    fn service(&self) -> &Service;\n}\n\npub trait GetServiceMut {\n    fn service_mut(&mut self) -> &mut Service;\n}\n```\n\nThese traits are minimal accessor traits for types that *contain* or *are logically identified by* a `Service`. They are useful for generic algorithms that operate over peers, address entries, or routing table items.\n\n**Example:**\n\n```rust\nuse bitcoin_service::{GetServiceRef, GetServiceMut, Service};\n\nstruct Peer {\n    addr: Service,\n    // other fields\n}\n\nimpl GetServiceRef for Peer {\n    fn service(&self) -> &Service {\n        &self.addr\n    }\n}\n\nimpl GetServiceMut for Peer {\n    fn service_mut(&mut self) -> &mut Service {\n        &mut self.addr\n    }\n}\n```\n\nThis allows you to write generic utilities that accept any `T: GetServiceRef` and work uniformly across peer representations.\n\n---\n\n## Hashing and ordering semantics\n\n### `Hash` implementation\n\n```rust\nimpl Hash for Service {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.base.net.hash(state);\n        self.port.hash(state);\n        self.base.addr.hash(state);\n    }\n}\n```\n\nThe hash function incorporates:\n\n- `base.net`: typically the network/variant of the address (e.g., IPv4, IPv6, Tor, etc.).\n- `port`: the TCP port.\n- `base.addr`: the underlying address bytes.\n\nThis ensures that two services collide in hash space if and only if they represent the same `(network, address, port)` triple, following Bitcoin Core's internal assumptions.\n\n### `ServiceHash` as a `BuildHasher`\n\n```rust\nimpl BuildHasher for ServiceHash {\n    type Hasher = SipHasher;\n\n    fn build_hasher(&self) -> Self::Hasher {\n        SipHasher::new_with_keys(self.salt_k0, self.salt_k1)\n    }\n}\n\nimpl Default for ServiceHash {\n    fn default() -> Self {\n        Self {\n            salt_k0: Self::get_rand_salt(),\n            salt_k1: Self::get_rand_salt(),\n        }\n    }\n}\n```\n\nHere, `ServiceHash` acts as a keyed SipHash factory:\n\n- `salt_k0` and `salt_k1` are 64-bit random salts.\n- `get_rand_salt()` uses `get_rand(u64::MAX)` (from the broader `bitcoin-rs` utility layer) to produce salts.\n\n**Example usage in a `HashMap`:**\n\n```rust\nuse std::collections::HashMap;\nuse bitcoin_service::{Service, ServiceHash};\n\n// A hashmap keyed by Service with randomized SipHash-based hashing\nlet mut map: HashMap<Service, usize, ServiceHash> =\n    HashMap::with_hasher(ServiceHash::default());\n\n// insert, remove, and query as usual\n```\n\n### Equality and ordering\n\n`Service` implements `Eq`, `PartialEq`, `Ord`, and `PartialOrd`. The semantics mirror Bitcoin Core:\n\n- `Eq`: two `Service` values are equal if their `NetAddr` components are equal and their `port` values match.\n- `Ord`: ordering first compares the `NetAddr`; if equal, compares the port.\n\nThis makes `Service` appropriate as a key in ordered maps (`BTreeMap`, `BTreeSet`) and provides deterministic, topology-related ordering consistent with the reference client.\n\n---\n\n## Conversions and socket interoperability\n\n### From `libc::sockaddr_in` and `sockaddr_in6`\n\n```rust\nimpl From<&libc::sockaddr_in> for Service { /* ... */ }\nimpl From<&libc::sockaddr_in6> for Service { /* ... */ }\n```\n\nThese `From` implementations allow the crate to integrate tightly with low-level socket APIs. Conceptually:\n\n- IPv4: constructs a `NetAddr` from `sin_addr` and sets `port` from `ntohs(sin_port)`, after asserting `AF_INET`.\n- IPv6: constructs a `NetAddr` from `sin6_addr` and `sin6_scope_id` and sets `port` from `ntohs(sin6_port)`, after asserting `AF_INET6`.\n\n### `set_sock_addr`\n\n```rust\npub fn set_sock_addr(&mut self, paddr: *const SocketAddr) -> bool { /* ... */ }\n```\n\n`set_sock_addr` mutates the `Service` based on a `SocketAddr` (backed by `sockaddr_in` or `sockaddr_in6`), returning `true` on success and `false` for unsupported families. This aligns with the C++ logic of dispatching on `sa_family`.\n\n### `get_sock_addr`\n\n```rust\npub fn get_sock_addr(\n    &self,\n    paddr: *mut SocketAddr,\n    addrlen: *mut libc::socklen_t,\n) -> bool { /* ... */ }\n```\n\n`get_sock_addr` produces a concrete `sockaddr_in` or `sockaddr_in6` structure representing this service:\n\n- For IPv4, fills a `sockaddr_in` with `AF_INET`, the underlying IPv4 bytes, and `htons(port)`.\n- For IPv6, fills a `sockaddr_in6` with `AF_INET6`, the IPv6 bytes, scope id, and `htons(port)`.\n- Returns `false` if the requested buffer is too small, or if the underlying `NetAddr` cannot be represented as IPv4 or IPv6.\n\nThis function is safe to call from network code that expects stable POSIX address structures, enabling integration with epoll/kqueue or custom networking stacks.\n\n---\n\n## Construction and helper methods\n\n### Constructors\n\n```rust\nimpl Service {\n    pub fn new_from_net_addr(cip: &NetAddr, port_in: u16) -> Self { /* ... */ }\n\n    pub fn new_from_ip4(ipv4_addr: &InAddr, port_in: u16) -> Self { /* ... */ }\n\n    pub fn new_from_ip6(ipv6_addr: &In6Addr, port_in: u16) -> Self { /* ... */ }\n}\n```\n\nThe provided constructors create a `Service` from higher-level address representations:\n\n- `new_from_net_addr`: wrap an existing `NetAddr` with a port.\n- `new_from_ip4` / `new_from_ip6`: construct the underlying `NetAddr` from `InAddr` / `In6Addr` and combine with the port.\n\n**Example:**\n\n```rust\nuse bitcoin_netaddr::{NetAddr, InAddr};\nuse bitcoin_service::Service;\n\nlet ipv4 = InAddr::from([127, 0, 0, 1]);\nlet svc = Service::new_from_ip4(&ipv4, 8333);\n\nassert_eq!(svc.get_port(), 8333);\n```\n\n### Port and key extraction\n\n```rust\nimpl Service {\n    pub fn get_port(&self) -> u16 { /* ... */ }\n\n    pub fn get_key(&self) -> Vec<u8> { /* ... */ }\n}\n```\n\n- `get_port`: returns the TCP port.\n- `get_key`: returns a byte vector representing the service's address and port, where the port is appended in network-consistent big-endian format: `MSB`, then `LSB`. In pseudocode:\n\n  1. `key = GetAddrBytes()` (address bytes from `NetAddr`).\n  2. `key.push_back(port / 0x100)`.\n  3. `key.push_back(port & 0x0FF)`.\n\nThis key is typically used for address table lookups, caches, or deduplication.\n\n### String representations\n\n```rust\nimpl Service {\n    pub fn to_string_port(&self) -> String { /* ... */ }\n    pub fn to_string_ip_port(&self) -> String { /* ... */ }\n    pub fn to_string(&self) -> String { /* ... */ }\n}\n```\n\n- `to_string_port`: returns a decimal representation of the port, e.g. `\"8333\"`.\n- `to_string_ip_port`: formats the IP and port in a URI-appropriate way:\n  - For IPv4, Tor, I2P, or internal: `ip:port`.\n  - For IPv6: `[ip]:port`.\n- `to_string`: alias for `to_string_ip_port`.\n\nThese formatting rules matter when interoperating with Bitcoin Core logs, user interfaces, or configuration formats, where exact string equality can be significant.\n\n---\n\n## Example: Using `Service` as a key in peer tracking\n\n```rust\nuse std::collections::{HashMap, HashSet};\nuse bitcoin_service::{Service, ServiceHash};\n\nstruct PeerInfo {\n    // ... details such as services, last_seen, ban score, etc.\n}\n\n// A deduplicated set of known peers\nlet mut known_peers: HashSet<Service, ServiceHash> =\n    HashSet::with_hasher(ServiceHash::default());\n\n// A map from peer service to its metadata\nlet mut peer_map: HashMap<Service, PeerInfo, ServiceHash> =\n    HashMap::with_hasher(ServiceHash::default());\n\n// For each discovered or inbound connection, derive a Service and store it\nfn on_new_connection(addr: Service, peer_info: PeerInfo,\n                     known_peers: &mut HashSet<Service, ServiceHash>,\n                     peer_map: &mut HashMap<Service, PeerInfo, ServiceHash>) {\n    if known_peers.insert(addr.clone()) {\n        peer_map.insert(addr, peer_info);\n    }\n}\n```\n\nThis pattern is typical in P2P systems: the `Service` acts as the canonical identifier for a remote endpoint.\n\n---\n\n## Serialization\n\n`Service` derives `Serialize` and `Deserialize` (via Serde), enabling it to be encoded into structured formats (JSON, CBOR, bincode, etc.) or nested inside higher-level protocol data structures.\n\nInternally, the crate intends to align serialization with the Bitcoin Core wire format semantics, but for user-facing Serde usage, you can treat `Service` as a conventional Rust struct.\n\n**Example (JSON):**\n\n```rust\nuse bitcoin_service::Service;\nuse serde_json;\n\n// Assume you have some existing Service value\nlet svc: Service = /* ... */;\n\nlet json = serde_json::to_string(&svc)?;\nlet decoded: Service = serde_json::from_str(&json)?;\nassert_eq!(svc, decoded);\n```\n\n---\n\n## Integration and repository\n\nThis crate is part of the `bitcoin-rs` monorepo:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\nWithin that repository, `bitcoin-service` is one module among several, including network addresses, protocol messages, and consensus logic. It is intended to be imported directly if you only need low-level service/address abstractions, or indirectly via higher-level crates in the workspace.\n\n---\n\n## License\n\n`bitcoin-service` is distributed under the MIT License, consistent with the rest of the `bitcoin-rs` repository.\n\n---\n\n## Status and caveats\n\n- Several methods in the current code are present as skeletons (`todo!()`), reflecting functions ported from C++ with semantics described in comments but not fully implemented yet.\n- The README describes the *intended* behavior, matching Bitcoin Core; consult the actual source and test suite in `bitcoin-rs` for the current implementation status.\n- The public API may evolve as the broader `bitcoin-rs` project refines its module boundaries and trait structure.\n",
  "package_categories": [
    "network-programming",
    "cryptography",
    "parser-implementations",
    "data-structures"
  ],
  "package_description": "Bitcoin Core-compatible network service abstraction (address + TCP port) with hashing, ordering, serde support, and libc socket interoperability, for use across the bitcoin-rs stack.",
  "package_keywords": [
    "bitcoin",
    "networking",
    "service",
    "p2p",
    "address"
  ]
}