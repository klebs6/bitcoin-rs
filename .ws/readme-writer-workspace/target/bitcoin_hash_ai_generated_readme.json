{
  "crate_name": "bitcoin-hash",
  "full_readme_markdown": "# bitcoin-hash\n\nDeterministic, Bitcoin-Core‑faithful hashing utilities and hash‑centric data structures for the `bitcoin-rs` ecosystem.\n\nThis crate provides thin, allocation‑free primitives that closely mirror Bitcoin Core's C++ hashing infrastructure while exposing an idiomatic Rust API. It focuses on correctness with respect to consensus‑relevant behavior and on zero‑cost integration into performance‑sensitive code such as full node implementations, mempools, UTXO sets, and filter indexes.\n\n> **Note**\n> This README was generated by an AI model based on the crate's public interface. It may not be perfectly accurate or complete, but it should be a strong approximation. Consult the source for authoritative details.\n\n---\n\n## Features at a Glance\n\n- **Consensus‑compatible digests**\n  - `Hash256`: Bitcoin's double‑SHA256 (256‑bit) hash function.\n  - `Hash160` and `hash160(..)`: Bitcoin's 160‑bit hash (SHA256 ➜ RIPEMD160).\n  - `hash1`, `hash2`, `serialize_hash`: convenient helpers mirroring Bitcoin Core semantics.\n- **Tagged hashes (BIP‑340 style)**\n  - `tagged_hash(tag: &str) -> HashWriter` and pre‑tagged writers for Taproot:\n    - `HASHER_TAPSIGHASH`, `HASHER_TAPLEAF`, `HASHER_TAPBRANCH`, `HASHER_TAPTWEAK`.\n- **Specialized hashers for core data structures**\n  - `SaltedOutpointHasher`, `SaltedTxidHasher`, `ByteVectorHash`, `SaltedSipHasher`.\n  - `SignatureCacheHasher` implementing `bitcoin_cuckoo_cache::EightWayHasher<u256>`.\n  - `BlockHasher`, `FilterHeaderHasher` for cheap indexing based on low‑64‑bits.\n- **Stream‑based hashing**\n  - `HashWriter`: a write‑only, serialization‑style hasher.\n  - `HashVerifier<S>`: wraps an `std::io::Read` and hashes all bytes as they are read.\n- **Bitcoin data model utilities**\n  - `OutPoint`: transaction outpoint (`txid` + `vout` index) with ordering, hashing, and display.\n  - `BaseHash<HashType>`: a general fixed‑size hash wrapper mirroring Bitcoin Core's `BaseHash` helpers.\n  - `AssumeUtxoHash`, `AssumeUtxoData`, `MapAssumeUtxo` for assumeUTXO snapshot metadata.\n- **Low‑level helpers**\n  - `murmur_hash3`, `read_le64`, `rotl32` – building blocks for filters, caches, and Bloom‑like structures.\n\nThe design goal is to make it trivial to port consensus‑critical code from Bitcoin Core while retaining Rust's type safety and trait ecosystem.\n\n---\n\n## Installation\n\nAdd the crate to your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoin-hash = \"0.1.20\"\n```\n\nThe crate targets Rust 2021 and is licensed under MIT.\n\n---\n\n## Core Types and Functions\n\n### 1. Fundamental hash types\n\n#### `Hash256`\n\nBitcoin defines its main digest function as `double-SHA256`:\n\n\\[\nH_{256}(m) = \\text{SHA256}(\\text{SHA256}(m)).\n\\]\n\n`Hash256` is a stateful hasher implementing this exact construction:\n\n```rust\nuse bitcoin_hash::Hash256;\n\nlet mut h = Hash256::default();\nh.write(b\"hello world\");\nlet mut out = [0u8; Hash256::OUTPUT_SIZE];\nh.finalize(&mut out);\n```\n\nKey properties:\n\n- Streaming interface (`write`, `finalize`, `reset`).\n- Zero allocation; works with fixed‑size arrays.\n- Matches Bitcoin Core's behavior byte‑for‑byte when fed the same serialized data.\n\n#### `Hash160` and `hash160`\n\nBitcoin's 160‑bit hash for P2PKH/P2WPKH, address generation, and script templates is defined as:\n\n\\[\nH_{160}(m) = \\text{RIPEMD160}(\\text{SHA256}(m)).\n\\]\n\n`Hash160` is the streaming variant; `hash160` is a convenience helper operating on any `AsRef<[u8]>`:\n\n```rust\nuse bitcoin_hash::hash160;\nuse bitcoin_hash::u160; // assumed to come from the same crate or a sibling\n\nlet pk_bytes: Vec<u8> = get_public_key_bytes();\nlet digest: u160 = hash160(&pk_bytes);\n```\n\n### 2. High‑level helpers: `hash1`, `hash2`, `serialize_hash`\n\nThese functions capture common patterns from Bitcoin Core:\n\n```rust\nuse bitcoin_hash::{hash1, hash2, serialize_hash, u256};\n\nlet a = b\"foo\";\nlet b = b\"bar\";\n\nlet h_single: u256 = hash1(a);\nlet h_concat: u256 = hash2(a, b);\n\n// `serialize_hash` exists for API compatibility with the C++ codebase.\nlet h_ser: u256 = serialize_hash(a, None, None);\n```\n\n- `hash1` – hash a single blob of bytes with `Hash256`.\n- `hash2` – hash the concatenation of two blobs (`in1 || in2`).\n- `serialize_hash` – placeholder for (de)serialization‑aware hashing; in the Rust port, it simply calls `hash1(obj.as_ref())`.\n\n### 3. Tagged hashes (BIP‑340, Taproot)\n\nTagged hashes are defined as in BIP‑340:\n\n\\[\n\\text{tagged\\_hash}(\\text{tag}, m) = \\text{SHA256}(\\text{SHA256}(\\text{tag})\\,||\\,\\text{SHA256}(\\text{tag})\\,||\\,m).\n\\]\n\n`tagged_hash(tag)` returns a `HashWriter` already primed with `SHA256(tag)` written twice. You then feed the payload and finalize via `HashWriter`:\n\n```rust\nuse bitcoin_hash::{tagged_hash, HashWriter, u256};\n\nlet mut w: HashWriter = tagged_hash(\"TapLeaf\");\nw.write(&serialized_script);\nlet tapleaf_hash: u256 = w.get_hash();\n```\n\nThe crate also exposes pre‑instantiated `lazy_static!` hash writers for the commonly used Taproot tags:\n\n- `HASHER_TAPSIGHASH` – BIP‑341 `TapSighash`.\n- `HASHER_TAPLEAF` – `TapLeaf`.\n- `HASHER_TAPBRANCH` – `TapBranch`.\n- `HASHER_TAPTWEAK` – `TapTweak`.\n\nThese mirror the C++ global singletons and allow direct 1‑to‑1 translation of Taproot‑related code.\n\n### 4. `HashWriter`: serialization‑style hashing\n\n`HashWriter` is a SHA256‑based writer that matches Bitcoin Core’s `CHashWriter`:\n\n```rust\nuse bitcoin_hash::{HashWriter, u256};\n\n// Type and version parameters are for structural compatibility\nlet mut hw = HashWriter::new(SER_GETHASH as i32, 0);\n\nhw.write(&tx_bytes);\nlet txid: u256 = hw.get_hash();       // double-SHA256\nlet cheap: u64 = hw.get_cheap_hash(); // low 64 bits of the double-SHA256\n```\n\nImportant methods:\n\n- `write(&mut self, pch: &[u8])` – feed bytes.\n- `get_hash(&mut self) -> u256` – compute double‑SHA256; invalidates the internal state.\n- `getsha256(&mut self) -> u256` – compute a single SHA256; invalidates the state.\n- `get_cheap_hash(&mut self) -> u64` – the first 64 bits of `get_hash()`.\n\nThe type and version fields (`n_type`, `n_version`) enable future extensibility and parity with C++ serialization code, even though they may not affect the Rust implementation today.\n\nOperator overloads:\n\n```rust\nuse bitcoin_hash::HashWriter;\n\nlet mut w = HashWriter::new(0, 0);\nlet data = b\"payload\";\n\n// `<<` style chaining (mirrors `operator<<` in C++)\nlet mut w2 = w << &data[..];\nlet h = w2.get_hash();\n```\n\n### 5. Stream hashing with `HashVerifier<S>`\n\n`HashVerifier<S>` wraps an `std::io::Read` and forwards all bytes into an internal `HashWriter`:\n\n```rust\nuse bitcoin_hash::{HashVerifier, u256};\nuse std::fs::File;\nuse std::io::Read;\n\nlet file = File::open(\"block.dat\")?;\nlet mut hv = HashVerifier::new(file);\n\nlet mut buf = vec![0u8; 1024];\nhv.read(&mut buf)?;   // reads and hashes 1024 bytes\n\n// … read or `ignore` more …\n\n// finalize by pulling the hash out of the embedded HashWriter\nlet hash: u256 = hv.base.get_hash();\n# Ok::<(), std::io::Error>(())\n```\n\nAdditional capabilities:\n\n- `read(&mut self, buf: &mut [u8])` – `Read::read_exact` + hash.\n- `ignore(&mut self, n: usize)` – read and hash but discard the bytes.\n- `Shr<&mut T>` operator (`>>`‑like) that reads exactly `obj.as_mut().len()` and panics on I/O failure (mimicking C++ stream exceptions).\n\nThis is useful for validating that a streamed serialization matches an expected digest without buffering the entire payload.\n\n### 6. `OutPoint`: transaction output locator\n\n`OutPoint` represents a specific output of a transaction:\n\n```rust\nuse bitcoin_hash::{OutPoint, u256};\n\nlet txid: u256 = get_txid();\nlet op = OutPoint::new(&txid, 0);\n\nassert!(!op.is_null());\nprintln!(\"{}\", op); // e.g. \"OutPoint(0123abc..., 0)\"\n```\n\nSalient traits and methods:\n\n- `new(hash_in: &u256, n_in: u32) -> Self`.\n- `set_null`, `is_null` – sentinel semantics with `OUT_POINT_NULL_INDEX`.\n- `Display`/`to_string` – prints `OutPoint(<first 10 hex chars>, n)` (matching Bitcoin Core’s `ToString`).\n- `Ord`, `Eq`, `Hash` – uses `(hash, n)` ordering and a stable Hash implementation by writing `hash` bytes and `n` in little‑endian.\n\nThe `Hash` impl makes it suitable as a key in `HashMap<OutPoint, _>` or `HashSet<OutPoint>` using default hashers or the provided salted variants.\n\n### 7. Salted hashers and indexing strategies\n\nThe crate includes several SipHash‑based and structure‑aware hashers intended for use in high‑performance containers. Salting randomizes hash functions per process, mitigating collision attacks and certain denial‑of‑service vectors.\n\n#### `SaltedOutpointHasher`\n\nImplements both `BuildHasher` and `Hasher`, enabling use as a custom hasher for `HashMap`/`HashSet` keyed by `OutPoint`:\n\n```rust\nuse bitcoin_hash::{OutPoint, SaltedOutpointHasher};\nuse std::collections::HashMap;\n\nlet map: HashMap<OutPoint, u64, SaltedOutpointHasher> = HashMap::default();\n```\n\nAdditionally, it provides an explicit `invoke` helper mirroring Bitcoin Core's `SipHashUint256Extra`:\n\n```rust\nuse bitcoin_hash::{OutPoint, SaltedOutpointHasher};\n\nlet hasher = SaltedOutpointHasher::default();\nlet op = get_outpoint();\nlet idx: usize = hasher.invoke(&op);\n```\n\nThe implementation uses two 64‑bit keys (`k0`, `k1`) seeded from `rand::rngs::OsRng` and SipHash‑2‑4 internally.\n\n#### `SaltedTxidHasher`\n\nSpecialized SipHash‑based hasher for 256‑bit transaction IDs (`u256`):\n\n```rust\nuse bitcoin_hash::{SaltedTxidHasher, u256};\n\nlet txid: u256 = get_txid();\nlet h = SaltedTxidHasher::default();\nlet bucket: usize = h.invoke(&txid);\n```\n\n#### `ByteVectorHash`\n\nA general SipHash‑2‑4 based `BuildHasher` and `Hasher` intended for arbitrary byte‑vector types used as keys:\n\n```rust\nuse bitcoin_hash::ByteVectorHash;\nuse std::collections::HashSet;\n\nlet mut set: HashSet<Vec<u8>, ByteVectorHash> = HashSet::default();\nset.insert(b\"hello\".to_vec());\n```\n\nIncludes a convenience `invoke(&self, input: &[u8]) -> usize` for ad‑hoc hashing.\n\n#### `SaltedSipHasher`\n\nA lighter helper using SipHash with random keys for generic byte slices:\n\n```rust\nuse bitcoin_hash::SaltedSipHasher;\n\nlet s = SaltedSipHasher::default();\nlet idx = s.invoke(b\"some script bytes\");\n```\n\n#### `SignatureCacheHasher`\n\nImplements `bitcoin_cuckoo_cache::EightWayHasher<u256>`.\n\nMathematically, this decomposes a `u256` (32 bytes) into eight disjoint 32‑bit words, each producing one of the eight hash values required by the cuckoo cache structure:\n\n```rust\nuse bitcoin_hash::{SignatureCacheHasher, u256};\nuse bitcoin_cuckoo_cache::EightWayHasher;\n\nlet key: u256 = get_sigcache_key();\nlet h = SignatureCacheHasher {};\nlet buckets: [u32; 8] = h.hashes(&key);\n```\n\nThis is designed specifically for Bitcoin's signature cache implementation, avoiding recomputation and extra passes over the data.\n\n#### `BlockHasher` and `FilterHeaderHasher`\n\nBoth use `read_le64(hash.as_ref())` to derive a `usize` index from the low 64 bits of a 256‑bit hash.\n\nThese are useful for cheap indexing where full cryptographic collision resistance is not required (e.g., block/file bucketing, compact filter headers).\n\n### 8. AssumeUTXO structures\n\nThe AssumeUTXO mechanism allows nodes to bootstrap validation by accepting an externally supplied UTXO snapshot, identified by a consensus‑critical hash and height/tx‑count metadata.\n\nThis crate models the relevant pieces:\n\n- `AssumeUtxoHash { base: BaseHash<u256> }` – wrapper for the hash of the serialized UTXO snapshot.\n- `AssumeUtxoData { hash_serialized: AssumeUtxoHash, n_chain_tx: u32 }` – configuration for UTXO snapshot load/validation.\n- `MapAssumeUtxo = HashMap<i32, AssumeUtxoData>` – map from block height (or similar integer index) to snapshot data.\n\nUsage example:\n\n```rust\nuse bitcoin_hash::{AssumeUtxoHash, AssumeUtxoData, MapAssumeUtxo, u256};\n\nlet snapshot_hash: u256 = compute_snapshot_hash();\nlet au_hash = AssumeUtxoHash::new(&snapshot_hash);\n\nlet data = AssumeUtxoData {\n    hash_serialized: au_hash,\n    n_chain_tx: 1_000_000,\n};\n\nlet mut map: MapAssumeUtxo = MapAssumeUtxo::new();\nmap.insert(700_000, data);\n```\n\nBecause this configuration is security‑critical, any changes must be coordinated with consensus rules and deployment strategy.\n\n### 9. `BaseHash<HashType>`: generic fixed‑size hash wrapper\n\n`BaseHash<HashType>` encapsulates a fixed‑width hash type (e.g., `u256`) while exposing a pointer‑centric API like Bitcoin Core's `BaseHash` helpers.\n\nConstraints on `HashType`:\n\n- `Clone + Default + Debug + AsRef<[u8]> + AsMut<[u8]> + Ord + Display`.\n\nKey methods:\n\n```rust\nuse bitcoin_hash::BaseHash;\nuse bitcoin_hash::u256;\n\nlet inner: u256 = get_u256();\nlet mut b = BaseHash::new(&inner);\n\nlet size = b.size();       // length in bytes\nlet ptr = b.data();        // *const u8\nlet s = b.to_string();     // hex string via inner Display\n\n// Transparent deref\nlet as_inner: &u256 = &*b;\n```\n\nPointers and ranges:\n\n- `begin`, `end`, `begin_mut`, `end_mut`, `data`, `data_mut` – all mirror C++ semantics.\n- Ordering (`Ord`, `Eq`, `PartialOrd`) forwards to the inner type.\n- `Into<Vec<u8>>` clones the underlying bytes.\n\nThis type is primarily aimed at ease of porting C++ code that expects raw pointer access, while preserving Rust ownership and borrowing rules.\n\n### 10. Low‑level primitives: `murmur_hash3`, `read_le64`, `rotl32`\n\n#### `murmur_hash3`\n\nImplements 32‑bit MurmurHash3 over a byte slice with an explicit seed:\n\n```rust\nuse bitcoin_hash::murmur_hash3;\n\nlet seed: u32 = 0x1234_5678;\nlet val = b\"key\";\nlet h: u32 = murmur_hash3(seed, val);\n```\n\nThis is the same primitive used in Bitcoin Core for Bloom filters, compact filters, and certain probabilistic data structures. The function operates in little‑endian and performs finalization mixing steps as in the reference design.\n\n#### `read_le64`\n\nReads the first eight bytes of a slice as a little‑endian `u64`:\n\n```rust\nuse bitcoin_hash::read_le64;\n\nlet bytes = [1u8, 0, 0, 0, 0, 0, 0, 0];\nlet x = read_le64(&bytes);\nassert_eq!(x, 1);\n```\n\nUsed for cheap hashing and indexing where full collision resistance is unnecessary.\n\n#### `rotl32`\n\nA small wrapper over `u32::rotate_left`:\n\n```rust\nuse bitcoin_hash::rotl32;\n\nlet x = 0x1234_5678u32;\nlet y = rotl32(x, 5); // rotate left by 5 bits\n```\n\nPrimarily used inside hashing primitives; supplied to keep ported code structurally identical.\n\n---\n\n## Error Handling and Invariants\n\n- Many methods are annotated with `debug_assert!` checks rather than returning `Result`. These are designed to catch internal misuse during development without impacting release performance.\n- `HashVerifier::read` and `ignore` surface `std::io::Result<()>`, but the `Shr` operator implementation panics on I/O failure to emulate C++ stream exceptions.\n- Hashing functions expect correctly sized inputs; where necessary they copy fixed‑length slices with explicit bounds checks.\n\nDownstream consumers should treat these primitives as low‑level building blocks with the expectation that higher‑level components handle user‑facing validation and error reporting.\n\n---\n\n## Example: hashing a serialized transaction\n\n```rust\nuse bitcoin_hash::{HashWriter, u256};\n\nfn txid_from_serialized_bytes(tx_bytes: &[u8]) -> u256 {\n    let mut hw = HashWriter::new(SER_GETHASH as i32, 0);\n    hw.write(tx_bytes);\n    hw.get_hash()\n}\n```\n\nIf you already have a single, contiguous slice of the serialized transaction, you may instead use `hash1(tx_bytes)`.\n\n---\n\n## Example: using custom hashers for collections\n\n```rust\nuse bitcoin_hash::{OutPoint, SaltedOutpointHasher, u256};\nuse std::collections::HashMap;\n\nlet mut utxo: HashMap<OutPoint, u64, SaltedOutpointHasher> = HashMap::default();\n\nlet txid: u256 = get_txid();\nlet op = OutPoint::new(&txid, 1);\nutxo.insert(op.clone(), 42);\n\nassert_eq!(utxo.get(&op), Some(&42));\n```\n\nBecause `SaltedOutpointHasher` implements `BuildHasher`, `HashMap::default()` yields a map with that hasher and fresh per‑process SipHash keys.\n\n---\n\n## Repository, License, and Contributions\n\n- **Crate**: `bitcoin-hash` `0.1.20`\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\n- **License**: MIT\n- **Rust edition**: 2021\n- **Author**: `klebs <none>`\n\nContributions should respect consensus compatibility with Bitcoin Core. Any change to hashing behavior, serialization, or snapshot verification logic must be carefully reviewed, as subtle divergences can lead to consensus splits or security regressions.\n",
  "package_categories": [
    "cryptography",
    "mathematics",
    "network-programming",
    "science",
    "development-tools"
  ],
  "package_description": "Bitcoin-Core compatible hashing primitives and hashers for u256-based types, Taproot tagged hashes, OutPoint keys, signature caches, and AssumeUTXO metadata, designed for consensus-safe use in high-performance Rust Bitcoin implementations.",
  "package_keywords": [
    "bitcoin",
    "hashing",
    "taproot",
    "siphash",
    "utxo"
  ]
}