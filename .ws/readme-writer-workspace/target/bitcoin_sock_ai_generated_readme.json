{
  "crate_name": "bitcoin-sock",
  "full_readme_markdown": "# bitcoin-sock\n\nLow-level, cross-platform socket primitives extracted from the Bitcoin Core networking layer, written in Rust.\n\n`bitcoin-sock` provides a thin, well-instrumented RAII wrapper over OS sockets (`CSocket`) together with carefully-behaved higher-level operations such as:\n\n- total-send with transient error handling and timeouts\n- incremental receive until a terminator byte with zero over-read\n- connectivity probing without consuming data (via `MSG_PEEK`)\n- portable timeout/wait logic via `select(2)` or `poll(2)`\n- error classification (`io_error_is_permanent`) and OS-neutral error strings\n\nThe crate is designed for consumers that need explicit control over system calls and error semantics (e.g. Bitcoin node implementations, protocol daemons, or custom P2P stacks) while still benefiting from RAII and structured logging.\n\n> NOTE: This README was generated by an AI model based solely on the crate interface. It may not be perfectly accurate, but it should be a close approximation of the crate's intent and usage.\n\n---\n\n## Design overview\n\n### CSocket and platform abstraction\n\nThe core primitive is the platform-dependent alias `CSocket`:\n\n```rust\n#[cfg(target_os = \"windows\")]\npub type CSocket = usize;      // SOCKET\n\n#[cfg(not(target_os = \"windows\"))]\npub type CSocket = libc::c_int; // POSIX fd\n``\n\nAll operations in this crate are expressed in terms of `CSocket`, with conditional compilation to choose between Winsock (`send`, `recv`, `connect`, `closesocket`, error codes) and POSIX (`send`, `recv`, `connect`, `close`, `errno`).\n\nThis makes the crate appropriate for cross-platform network stacks where you want the exact C API semantics, but in Rust.\n\n### Sock: RAII wrapper around CSocket\n\n`Sock` is the central type:\n\n```rust\n#[derive(Debug, Getters, MutGetters)]\n#[getset(get = \"pub\", get_mut = \"pub\")]\npub struct Sock {\n    socket: CSocket,\n}\n```\n\nKey properties:\n\n- **RAII lifetime management**: `Drop` closes the socket (if not empty), mirroring `std::unique_ptr<SOCKET>` semantics from C++.\n- **Ownership stealing**: `assign_from` and `From<CSocket>` implement move-style transfer of ownership between `Sock` instances.\n- **Empty state**: The sentinel `INVALID_SOCKET` denotes an inert `Sock` that does nothing on drop.\n\n### Low-level system call wrappers\n\n`Sock` exposes exact-thin wrappers around the core socket syscalls:\n\n- `send(&self, data: *const c_void, len: usize, flags: i32) -> isize`\n- `recv(&self, buf: *mut c_void, len: usize, flags: i32) -> isize`\n- `connect(&self, addr: *const SocketAddr, addr_len: libc::socklen_t) -> i32`\n- `get_sock_opt(&self, level, opt_name, opt_val, opt_len) -> i32`\n\nThese mirror the C interfaces verbatim, including flags like `MSG_NOSIGNAL` and `MSG_PEEK` where applicable. The functions are deliberately unsafe in spirit: they accept raw pointers and sizes and return raw OS return codes, converted to Rust integer types.\n\n### Higher-level behaviour and algorithms\n\nOn top of the primitive calls, `Sock` adds value in several ways:\n\n#### 1. Error classification: `io_error_is_permanent`\n\nNetwork errors are not all equal. Temporary conditions such as `EAGAIN`, `EINTR`, or `EWOULDBLOCK` should be retried, while others should be treated as fatal.\n\n```rust\n#[cfg(unix)]\n#[inline]\npub fn io_error_is_permanent(err: i32) -> bool {\n    use libc::{EAGAIN, EINTR, EWOULDBLOCK, EINPROGRESS};\n    !(err == EAGAIN || err == EINTR || err == EWOULDBLOCK || err == EINPROGRESS)\n}\n\n#[cfg(windows)]\n#[inline]\npub fn io_error_is_permanent(err: i32) -> bool {\n    use winapi::um::winsock2::{WSAEAGAIN, WSAEINTR, WSAEWOULDBLOCK, WSAEINPROGRESS};\n    !(err == WSAEAGAIN || err == WSAEINTR || err == WSAEWOULDBLOCK || err == WSAEINPROGRESS)\n}\n```\n\nThis function is used centrally in send/receive loops to distinguish between retryable and terminal errors.\n\n#### 2. Wait and readiness: `wait` and `is_selectable_socket`\n\n`Sock::wait` blocks until the socket becomes ready for the requested `SockEvent`s (read and/or write), bounded by a timeout:\n\n- On Linux with `feature = \"use_poll\"`: uses `poll(2)`.\n- Otherwise: falls back to `select(2)` with an `FD_SETSIZE` check via `is_selectable_socket` to avoid UB on large descriptors.\n\nThis design is intended to faithfully reproduce the behaviour of the original Bitcoin networking code while staying portable.\n\n#### 3. Total send with timeout and interruption: `send_complete`\n\n```rust\nimpl Sock {\n    pub fn send_complete(\n        &self,\n        data: &String,\n        timeout: chrono::Duration,\n        interrupt: &mut ThreadInterrupt,\n    ) {\n        // ...\n    }\n}\n```\n\nAlgorithmically:\n\n1. Convert the user-specified logical timeout (`chrono::Duration`) into a hard deadline (`Instant`).\n2. Loop until all bytes are written.\n3. For each iteration:\n   - Invoke `send` on the remaining byte slice.\n   - On success, advance `sent` and continue.\n   - On failure (`ret <= 0`):\n     - Fetch `last_socket_error` and decide permanent vs transient via `io_error_is_permanent`.\n     - If permanent, panic with an error message from `network_error_string`.\n     - Check `deadline` and `interrupt`; if either fires, panic with an informative message about partial progress.\n     - Compute a bounded wait interval with `compute_bounded_wait(deadline)` and call `wait` for `SOCK_SEND` before retry.\n\nThe logic is carefully structured to avoid busy-waiting while still honouring both timeout and interrupt conditions.\n\nMathematically, you can model the loop as a bounded retry algorithm on a non-deterministic channel with the following invariants:\n\n- **Progress**: `sent` is monotonically non-decreasing and bounded by `data.len()`.\n- **Safety**: All error paths either classify the error as transient (retry) or terminate the function with a precise error message.\n- **Liveness**: Assuming the OS eventually makes the socket writable before `deadline` and `interrupt` stays false, the loop must terminate with `sent == len`.\n\n#### 4. Efficient receive-until-terminator: `recv_until_terminator`\n\n```rust\nimpl Sock {\n    pub fn recv_until_terminator(\n        &self,\n        terminator: u8,\n        timeout: chrono::Duration,\n        interrupt: &mut ThreadInterrupt,\n        max_data: usize,\n    ) -> String {\n        // ...\n    }\n}\n```\n\nCore idea: we want to read until a sentinel byte without consuming any data beyond that point from the socket. Reading byte-by-byte would preserve the invariant but be asymptotically inefficient (roughly `O(n)` syscalls for `n` bytes).\n\nInstead, the implementation uses a repeated pattern of:\n\n1. `MSG_PEEK`-style `recv` into a small buffer (e.g. 512 bytes).\n2. Search for the terminator.\n3. If found at index `pos`, issue a non-peeking read of exactly `pos + 1` bytes and append them to `data`.\n4. If not found, read the full peeked slice.\n5. Maintain `data.len() <= max_data`, panicking if exceeded.\n6. Honour timeout and `interrupt`, with the same `compute_bounded_wait` pattern as in `send_complete`.\n\nThis yields a roughly 50× improvement over byte-wise reading for realistic workloads (as noted by the inline comments), while preserving a strong invariant:\n\n> After `recv_until_terminator` returns, the underlying socket has consumed exactly the bytes up to and including the first occurrence of `terminator`, and no further.\n\nThe returned `String` strips the terminator before returning, and asserts UTF‑8 validity.\n\n#### 5. Connectivity probe without consumption: `is_connected`\n\n```rust\nimpl Sock {\n    pub fn is_connected(&self, errmsg: &mut String) -> bool {\n        // ...\n    }\n}\n```\n\n`is_connected` implements the canonical Bitcoin approach:\n\n1. If the socket is `INVALID_SOCKET`, set `errmsg` to `\"not connected\"` and return `false`.\n2. Issue a `recv` of one byte with `MSG_PEEK`.\n3. Interpret results as:\n   - `ret == -1` and error is transient → treat as still connected.\n   - `ret == -1` and error is permanent → set `errmsg` to the OS error string and return `false`.\n   - `ret == 0` → remote has closed the connection; set `errmsg` to `\"closed\"` and return `false`.\n   - `ret > 0` → data available; socket considered connected.\n\nThis function allows higher-level code to cheaply check connectivity status without altering the read cursor.\n\n### Error reporting helpers\n\nThe crate also provides utilities for system-level error introspection:\n\n- `last_socket_error() -> i32`: returns `errno` on Unix, `WSAGetLastError()` on Windows.\n- `network_error_string(err: i32) -> String`: returns a descriptive message including the error code, using `strerror_r` on Unix or `FormatMessageW` on Windows.\n\nThese are engineered to behave consistently across libc variants (GNU vs POSIX strerror_r) and to produce strings of the form:\n\n```text\n\"<system message> (<code>)\"\n```\n\nwhich mirrors the logic used in C++ Bitcoin Core.\n\n### Socket selectability and descriptor constraints\n\nOn Unix platforms that use `select(2)`, there is a hard ceiling (`FD_SETSIZE`) on descriptors that can safely be used. `is_selectable_socket` encodes this constraint:\n\n```rust\npub fn is_selectable_socket(s: &CSocket) -> bool {\n    #[cfg(any(target_os = \"windows\", feature = \"use_poll\"))]\n    { true }\n\n    #[cfg(not(any(target_os = \"windows\", feature = \"use_poll\")))]\n    { (*s as usize) < libc::FD_SETSIZE as usize }\n}\n``\n\nHigher-level code can use this to decide whether a given socket can participate in a global `select`-based event loop or must instead be handled differently (e.g., via `poll` or epoll in an external layer).\n\n### Socket pair utility (Unix)\n\nFor local IPC and test harnesses, the crate includes:\n\n```rust\n#[cfg(unix)]\npub fn make_socket_pair() -> (libc::c_int, libc::c_int) {\n    // ... AF_UNIX, SOCK_STREAM pair\n}\n```\n\nThis constructs a bidirectional connected pair of Unix domain sockets, asserting on failure; useful for deterministic test constructions and local pipelines.\n\n---\n\n## Traits and abstraction points\n\nThe crate defines several traits that abstract over socket-like backends:\n\n```rust\npub trait SockInterface {}\n\npub trait SockGet {\n    fn get(&self) -> CSocket;\n}\n\npub trait SockRelease {\n    fn release(&mut self) -> CSocket;\n}\n\npub trait Reset {\n    fn reset(&mut self);\n}\n\npub trait SockSend {\n    fn send(&self, data: *const c_void, len: usize, flags: i32) -> isize;\n}\n\npub trait SockRecv {\n    fn recv(&self, buf: *mut c_void, len: usize, flags: i32) -> isize;\n}\n\npub trait SockConnect {\n    fn connect(&self, addr: *const SocketAddr, addr_len: libc::socklen_t) -> i32;\n}\n\npub trait SockGetSockOpt {\n    fn get_sock_opt(\n        &self,\n        level: i32,\n        opt_name: i32,\n        opt_val: *mut c_void,\n        opt_len: *mut libc::socklen_t,\n    ) -> i32;\n}\n\npub trait SockWait {\n    fn wait(&self, timeout: Instant, requested: SockEvent, occurred: *mut SockEvent) -> bool;\n}\n\npub trait SockSendComplete {\n    fn send_complete(\n        &self,\n        data: &String,\n        timeout: Instant,\n        interrupt: &mut ThreadInterrupt,\n    );\n}\n\npub trait SockRecvUntilTerminator {\n    fn recv_until_terminator(\n        &self,\n        terminator: u8,\n        timeout: Instant,\n        interrupt: &mut ThreadInterrupt,\n        max_data: usize,\n    ) -> String;\n}\n\npub trait SockIsConnected {\n    fn is_connected(&self, errmsg: &mut String) -> bool;\n}\n```\n\nThe concrete `Sock` type effectively implements the semantics of these traits. In your own code, you can:\n\n- Implement these traits for alternative backends (e.g., mock sockets for tests, different transport layers, wrappers around async runtimes), while still reusing shared logic.\n- Depend on trait objects or generics bounded by these traits to write code that is backend-agnostic, e.g. a protocol parser that only needs `SockRecvUntilTerminator` and `SockSendComplete`.\n\nThis allows you to decouple *protocol logic* from *transport implementation* while retaining the precise semantics that the Bitcoin networking stack expects.\n\n---\n\n## Usage examples\n\n### Basic RAII management\n\n```rust\nuse bitcoin_sock::{CSocket, Sock};\n\nfn adopt_raw_socket(raw: CSocket) {\n    // Transfer ownership from a raw descriptor into RAII-managed Sock.\n    let mut sock = Sock::from(raw);\n\n    // Query the underlying handle without transferring ownership.\n    let fd = sock.get();\n    println!(\"underlying fd = {}\", fd);\n\n    // Release ownership back to the caller; Sock becomes inert.\n    let raw_again = sock.release();\n    assert_eq!(raw_again, fd);\n}\n```\n\n### Complete send with timeout and interrupt\n\n```rust\nuse bitcoin_sock::Sock;\nuse chrono::Duration;\n\nfn send_message(sock: &Sock, payload: &str, interrupt: &mut ThreadInterrupt) {\n    let timeout = Duration::seconds(30);\n    sock.send_complete(&payload.to_string(), timeout, interrupt);\n}\n```\n\nThe function will either:\n\n- send all bytes, or\n- panic on a permanent error, timeout, or interrupt, describing how many bytes were sent and why the operation aborted.\n\nYou can wrap it and convert panics into error values if you need a non-panicking API at a higher layer.\n\n### Receive a line (or other delimited frame)\n\n```rust\nuse bitcoin_sock::Sock;\nuse chrono::Duration;\n\nfn recv_line(sock: &Sock, interrupt: &mut ThreadInterrupt) -> String {\n    // Read until '\\n', up to 64 KiB, with a 60s timeout.\n    let timeout = Duration::seconds(60);\n    sock.recv_until_terminator(b'\\n', timeout, interrupt, 64 * 1024)\n}\n```\n\nThe returned `String` will exclude the newline terminator and be valid UTF‑8.\n\n### Connectivity probing\n\n```rust\nuse bitcoin_sock::Sock;\n\nfn ensure_connected(sock: &Sock) -> Result<(), String> {\n    let mut errmsg = String::new();\n    if sock.is_connected(&mut errmsg) {\n        Ok(())\n    } else {\n        Err(errmsg)\n    }\n}\n```\n\nThis is particularly useful for long-lived P2P connections where you want to periodically verify liveness without mutating the receive stream.\n\n### Waiting for readiness\n\n```rust\nuse bitcoin_sock::{Sock, SockEvent};\nuse time::Duration;\n\nconst SOCK_RECV: SockEvent = 0x01;\nconst SOCK_SEND: SockEvent = 0x02;\n\nfn wait_for_read(sock: &Sock, max_wait_ms: i64) -> bool {\n    let requested = SOCK_RECV;\n    let mut occurred: SockEvent = 0;\n\n    let timeout = Duration::milliseconds(max_wait_ms);\n    if sock.wait(timeout, requested, &mut occurred as *mut SockEvent) {\n        occurred & SOCK_RECV != 0\n    } else {\n        false\n    }\n}\n```\n\nThis pattern allows you to build sophisticated event loops or integrate `bitcoin-sock` into existing synchronous multiplexing infrastructure.\n\n---\n\n## Integration notes\n\n- **Logging / tracing**: The implementation is instrumented with `trace!`, `debug!`, and `warn!` macros. You should configure your logging/tracing backend (for example via `tracing` or `log`) to obtain detailed diagnostics about socket behaviour.\n- **Panics vs errors**: Several higher-level operations (`send_complete`, `recv_until_terminator`) panic on unrecoverable conditions, as they are modeled after C++ exceptions. If your application requires error-returning APIs, wrap these functions and translate panic payloads into typed error values.\n- **ThreadInterrupt**: The crate expects a `ThreadInterrupt` type exposing an `as_bool()` method to indicate whether a cooperative interrupt has been requested. Integrate this with your own cancellation infrastructure.\n- **Select vs poll**: On Linux, enabling the `use_poll` feature switches the readiness mechanism from `select` to `poll`. This is useful when dealing with many file descriptors or when you need to avoid the `FD_SETSIZE` limit.\n\n---\n\n## Repository, license, and provenance\n\n- Crate name: `bitcoin-sock`\n- Version: `0.1.19`\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n- License: MIT\n- Edition: Rust 2021\n- Author: `klebs <none>`\n\nThis crate appears to be a Rust reimplementation/port of socket handling from Bitcoin Core, with the goal of preserving semantics and behaviour while leveraging Rust's ownership model and RAII.\n\n> Reminder: This README was generated automatically by an AI model. It may omit details or slightly misrepresent edge semantics. Consult the source code in the repository for definitive behaviour.\n",
  "package_categories": [
    "network-programming",
    "algorithms",
    "concurrency",
    "os",
    "development-tools"
  ],
  "package_description": "Low-level, cross-platform RAII wrapper and utilities for raw OS sockets, mirroring Bitcoin Core networking semantics (send/recv, timeouts, readiness, error classification).",
  "package_keywords": [
    "bitcoin",
    "socket",
    "networking",
    "p2p",
    "raii"
  ]
}