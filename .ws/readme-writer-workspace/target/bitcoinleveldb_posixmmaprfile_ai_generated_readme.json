{
  "crate_name": "bitcoinleveldb-posixmmaprfile",
  "full_readme_markdown": "# bitcoinleveldb-posixmmaprfile\n\nHigh‑performance, POSIX `mmap(2)`‑backed implementation of LevelDB's `RandomAccessFile` interface for read‑only files, with deterministic resource management and integrated mmap limiting.\n\n> NOTE: This README was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful description of the crate.\n\n---\n\n## Overview\n\n`bitcoinleveldb-posixmmaprfile` provides a single core type:\n\n```rust\npub struct PosixMmapReadableFile { /* fields elided */ }\n```\n\nIt implements:\n\n- `RandomAccessFileRead` – a low‑level random read API accepting raw pointers.\n- `RandomAccessFile` – marker trait indicating conformance to the LevelDB random access contract.\n- `Named` – exposing a cheap, borrowed `Cow<'_, str>` filename.\n\nThe implementation uses POSIX `mmap()` to map an entire file into memory, then serves random reads by bounding‑checked pointer arithmetic and `Slice` construction. It is designed to be:\n\n- **Thread‑safe for concurrent reads** – state is immutable after construction; reads are race‑free.\n- **Zero‑copy for reads** – no per‑read allocation or copying, only slice creation over an existing mapping.\n- **Robust against overflow** – uses `u128` arithmetic to validate `(offset + n) <= length` before casting.\n- **Resource‑disciplined** – integrates with a `Limiter` object that caps the number of simultaneous mmaps.\n\nThis crate is primarily a building block within the Bitcoin‑adapted LevelDB stack but can be used in any context where you already have an mmap, a limiter, and want a LevelDB‑style `RandomAccessFile` implementation.\n\n---\n\n## Core Type: `PosixMmapReadableFile`\n\n```rust\n#[derive(Getters, Builder, Debug)]\n#[getset(get = \"pub\")]\npub struct PosixMmapReadableFile  {\n    mmap_base:    *const u8,\n    length:       usize,\n    mmap_limiter: *const Limiter,\n    filename:     String,\n}\n```\n\n### Construction\n\n```rust\nimpl PosixMmapReadableFile {\n    /// `mmap_base` must come from a successful `mmap()` and this instance\n    /// takes ownership of the region.\n    ///\n    /// `mmap_limiter` must outlive this instance; one mmap token is released\n    /// when the instance is dropped.\n    pub fn new(\n        filename:     String,\n        mmap_base:    *mut u8,\n        length:       usize,\n        mmap_limiter: *mut Limiter,\n    ) -> Self { /* ... */ }\n}\n```\n\nInvariants and expectations:\n\n- `mmap_base` / `length` describe the full mapped region `[0, length)`.\n- The region **must** be read‑only or at least safe for concurrent reads; the type does not perform synchronization.\n- `mmap_limiter` encapsulates the global policy for how many mmaps are allowed; the caller is responsible for acquiring a slot before constructing the object.\n- A `(null, 0)` mapping is allowed for degenerate/test cases; production code should only allow `mmap_base == null` if `length == 0`.\n\nThe `new` function logs with `tracing` (`trace!`/`warn!`) and uses the auto‑derived builder under the hood for field initialization.\n\n### Reading: `RandomAccessFileRead`\n\n```rust\nimpl RandomAccessFileRead for PosixMmapReadableFile {\n    fn read(\n        &self,\n        offset:   u64,\n        n:        usize,\n        result:   *mut Slice,\n        _scratch: *mut u8,\n    ) -> Status { /* ... */ }\n}\n```\n\nSemantics:\n\n- Computes `offset + n` in `u128` and requires `offset + n <= length`.\n- On **out‑of‑range**:\n  - Writes `Slice::default()` into `*result`.\n  - Returns an IO error `Status` (akin to `PosixError(fname, EINVAL)` in LevelDB's C++ implementation).\n- On **success**:\n  - Computes `let ptr = self.mmap_base().add(offset_usize);`.\n  - Sets `*result = Slice::from_ptr_len(ptr, n);`.\n  - Returns `Status::ok()`.\n\nThis interface is intentionally low‑level for compatibility with the surrounding LevelDB FFI/domain model:\n\n- `Slice` is a lightweight view into `&[u8]`‑like data without transferring ownership.\n- `Status` represents a result status (OK / IO error / etc.) without using Rust's `Result` in the external interface.\n\nBecause `PosixMmapReadableFile` does not mutate internal state during `read`, multiple threads can call `read` concurrently on a shared instance without coordination.\n\n### Resource Management & Drop\n\n```rust\nimpl Drop for PosixMmapReadableFile {\n    fn drop(&mut self) {\n        use libc::{munmap, c_void};\n        // 1. munmap the region if base != null and length > 0\n        // 2. release one token back into the Limiter\n    }\n}\n```\n\nDrop behavior:\n\n1. If `mmap_base != null` and `length > 0`, calls\n   `munmap(mmap_base as *mut c_void, length)`.\n   - On failure, logs a warning with the OS error.\n2. If `mmap_limiter != null`, it unsafely dereferences it as `&Limiter` and calls `release()`.\n\nThis ensures that:\n\n- The OS mapping is torn down exactly once.\n- The global `Limiter` is updated even in the presence of panics or early returns elsewhere.\n\n### Naming\n\n```rust\nimpl Named for PosixMmapReadableFile {\n    fn name(&self) -> Cow<'_, str> {\n        Cow::Borrowed(&self.filename)\n    }\n}\n```\n\n`Named` enables introspection and logging; downstream components can treat any `Named` implementor uniformly for diagnostics and metrics.\n\n---\n\n## Safety Considerations\n\nThis crate uses `unsafe` for:\n\n- Holding raw pointers to the mmap region (`*const u8`).\n- Calling `libc::munmap`.\n- Constructing `Slice` from raw pointers.\n- Interacting with `Limiter` via raw pointer.\n\nKey safety assumptions:\n\n1. **Lifetime of mapping**: The memory pointed to by `mmap_base` remains valid and mapped for the entire lifetime of `PosixMmapReadableFile`.\n2. **Lifetime of limiter**: `mmap_limiter` outlives the `PosixMmapReadableFile` instance, and exactly one acquire/release pair is associated with it.\n3. **Immutability for concurrent reads**: The mapped file is not mutated in a way that would violate Rust's aliasing rules as observed through `Slice` views.\n\nDownstream code should ensure these invariants hold. The crate is designed to encapsulate the unsafe operations while exposing a predictable, LevelDB‑compatible random access abstraction.\n\n---\n\n## Example Usage\n\nBelow is a sketch of how you might integrate `PosixMmapReadableFile` into a higher‑level system. Types like `Limiter`, `Slice`, `Status`, `RandomAccessFileRead`, and `RandomAccessFile` are presumed to come from the broader bitcoinleveldb ecosystem.\n\n```rust\nuse std::{fs::File, os::fd::AsRawFd, ptr};\nuse libc::{mmap, munmap, PROT_READ, MAP_SHARED, MAP_FAILED};\n\nuse bitcoinleveldb_posixmmaprfile::PosixMmapReadableFile;\nuse bitcoinleveldb_core::{Limiter, Slice, Status, RandomAccessFileRead};\n\nfn open_mmaped_random_access(\n    path: &str,\n    limiter: &Limiter,\n) -> Result<PosixMmapReadableFile, std::io::Error> {\n    // Acquire a token in the limiter (API depends on your Limiter type).\n    limiter.acquire()?;\n\n    let file = File::open(path)?;\n    let len = file.metadata()?.len() as usize;\n\n    let fd = file.as_raw_fd();\n    let base = unsafe {\n        mmap(\n            ptr::null_mut(),\n            len,\n            PROT_READ,\n            MAP_SHARED,\n            fd,\n            0,\n        )\n    };\n\n    if base == MAP_FAILED {\n        // Release token if mmap failed\n        limiter.release();\n        return Err(std::io::Error::last_os_error());\n    }\n\n    // Safety: `base` is from a successful mmap, `limiter` will outlive\n    // the PosixMmapReadableFile, and we have acquired exactly one token.\n    let file_ra = PosixMmapReadableFile::new(\n        path.to_owned(),\n        base as *mut u8,\n        len,\n        limiter as *const Limiter as *mut Limiter,\n    );\n\n    Ok(file_ra)\n}\n\nfn read_slice_example(f: &PosixMmapReadableFile, offset: u64, n: usize) -> Result<&[u8], String> {\n    let mut slice = Slice::default();\n    let status: Status = f.read(offset, n, &mut slice as *mut Slice, std::ptr::null_mut());\n\n    if !status.is_ok() {\n        return Err(status.to_string());\n    }\n\n    Ok(slice.as_bytes()) // assuming Slice::as_bytes() -> &[u8]\n}\n```\n\nIn realistic usage, you would not usually call `mmap` or `munmap` yourself; other components establish the mappings and pass them to `PosixMmapReadableFile`.\n\n---\n\n## Logging & Observability\n\nThe implementation uses the [`tracing`](https://crates.io/crates/tracing) ecosystem macros:\n\n- `trace!` on construction, entry into reads, and drop.\n- `debug!` on successful reads and error cases with full context (filename, offsets, lengths, status string).\n- `warn!` when inconsistencies or OS errors are encountered (e.g., non‑zero length with null base, `munmap` failure).\n\nThis yields high‑fidelity observability for:\n\n- Diagnosing unexpected IO patterns.\n- Verifying limiter behavior at runtime.\n- Correlating OS‑level failures with higher‑level operations.\n\n---\n\n## Performance Characteristics\n\nGiven a correctly mapped file and a well‑dimensioned `Limiter`:\n\n- Per‑read overhead is essentially:\n  - Bounds checking via `u128` arithmetic.\n  - Pointer addition and `Slice` construction.\n  - Logging at the configured level.\n- There are **no heap allocations** in the steady‑state `read` path.\n- The operating system's page cache and mmap machinery provide the effective IO bandwidth.\n\nThis makes the type suitable for read‑intensive workloads such as LevelDB table lookups, block index scans, or any workload dominated by many small random reads.\n\n---\n\n## When Not to Use This Crate\n\nYou may prefer a different strategy when:\n\n- The platform does not provide POSIX `mmap` semantics.\n- You are constrained by address space (e.g., 32‑bit environments with very large files).\n- You require write access with transactional guarantees instead of read‑only access.\n\nIn such settings, a pread‑based implementation or explicit buffered IO layer might be more appropriate.\n\n---\n\n## License\n\nThis crate is distributed under the MIT license.\n\n---\n\n## Status\n\nThis README is auto‑generated and may diverge slightly from the actual API surface or dependencies as the crate evolves. Consult the source for the authoritative definition of `Limiter`, `Slice`, `Status`, and the traits implemented here.\n",
  "package_categories": [
    "filesystem",
    "network-programming",
    "data-structures",
    "algorithms"
  ],
  "package_description": "POSIX mmap(2)-backed implementation of a LevelDB-style RandomAccessFile for read-only random file access with explicit mmap limiting and deterministic resource teardown.",
  "package_keywords": [
    "mmap",
    "leveldb",
    "bitcoin",
    "random-access",
    "filesystem"
  ]
}