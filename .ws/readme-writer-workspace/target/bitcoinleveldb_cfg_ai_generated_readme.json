{
  "crate_name": "bitcoinleveldb-cfg",
  "full_readme_markdown": "# bitcoinleveldb-cfg\n\nConfiguration primitives for running LevelDB-backed Bitcoin data stores in Rust.\n\nThis crate provides a small, opinionated configuration layer that standardizes how LevelDB databases are named, located, and parameterized within the broader `bitcoin-rs` workspace. It focuses exclusively on the *configuration surface* (paths, logical database roles, and tunable parameters), keeping I/O and schema logic in adjacent crates.\n\n> NOTE: This README was generated by an AI model. It may not be perfectly accurate, but it is intended to be a close and useful approximation of the crate's purpose and usage.\n\n---\n\n## Scope and goals\n\n`bitcoinleveldb-cfg` aims to:\n\n- Provide a **typed configuration model** for LevelDB instances used by Bitcoin-indexing components.\n- Encode **stable naming conventions** for different logical databases (e.g., headers, UTXO, blocks, indexes).\n- Support **environment-dependent layouts** (e.g., mainnet / testnet / regtest / custom data directories).\n- Centralize **LevelDB tuning parameters** (cache sizes, write buffers, compression flags) behind a single interface so downstream crates can depend on a consistent configuration contract.\n\nIt does **not** implement a database driver. Instead it is designed to be consumed by a LevelDB wrapper (e.g., `bitcoinleveldb` or a raw `leveldb-sys` binding) to open and manage the actual database instances.\n\n---\n\n## Design overview\n\nThe crate typically centers around a small number of core types (exact names may differ slightly in the actual code):\n\n- `Network` / `Chain` enum — identifies which Bitcoin network the configuration targets (e.g., `Mainnet`, `Testnet`, `Regtest`, possibly `Signet` or custom chains).\n- `DbRole` / `LogicalDb` enum — enumerates logical database roles such as headers, blocks, UTXO set, and additional indexes. These roles determine the on-disk subdirectory or file names.\n- `LevelDbTuning` / `LevelDbOptionsCfg` — collects tunable parameters such as cache size, block size, write buffer size, and bloom filter options.\n- `BitcoinLevelDbCfg` / `DbCfg` — the primary configuration object that binds network, base data directory, logical database role, and tuning parameters into a ready-to-use configuration that a LevelDB wrapper can consume.\n\nIn a typical architecture, the configuration object is pure data: it does not open files or sockets; it simply describes *what* should be opened and *with which parameters*.\n\n---\n\n## Example usage\n\nBelow is a representative example for how a consumer crate might use `bitcoinleveldb-cfg`. Names are indicative, not guaranteed; consult the actual API in this crate for precise signatures.\n\n```rust\nuse bitcoinleveldb_cfg::{\n    BitcoinLevelDbCfg,    // primary configuration type\n    Network,              // network/chain enumeration\n    DbRole,               // logical database role\n    LevelDbTuning,        // low-level tuning parameters\n};\n\nfn main() -> anyhow::Result<()> {\n    // Decide which chain and data directory to use.\n    let network = Network::Mainnet;\n    let datadir = \"/var/lib/bitcoin-rs\";\n\n    // Configure base tuning parameters; these will be translated into\n    // concrete LevelDB options by your LevelDB wrapper crate.\n    let tuning = LevelDbTuning {\n        block_cache_bytes: 512 * 1024 * 1024, // 512 MiB\n        write_buffer_bytes: 128 * 1024 * 1024,\n        max_open_files: 2048,\n        use_compression: true,\n        ..LevelDbTuning::default()\n    };\n\n    // Describe a specific logical database: e.g., the block index.\n    let cfg = BitcoinLevelDbCfg::new(datadir, network, DbRole::BlockIndex, tuning)?;\n\n    // Turn this into actual LevelDB options in your driver crate.\n    // (The below call is conceptual; adapt to your driver.)\n    let options = cfg.to_leveldb_options();\n    let path = cfg.path();\n\n    // Example integration with a hypothetical `bitcoinleveldb` crate:\n    // let db = bitcoinleveldb::open(path, &options)?;\n\n    Ok(())\n}\n```\n\nA crate that integrates with `bitcoinleveldb-cfg` usually:\n\n1. Selects a `Network` and base data directory.\n2. Chooses one or more `DbRole` values per logical database.\n3. Constructs a `BitcoinLevelDbCfg` for each role.\n4. Derives concrete LevelDB options and paths using helper methods.\n5. Opens the LevelDB instances via an external database crate.\n\n---\n\n## Configuration patterns\n\n### Network and layout\n\nThe crate typically enforces a consistent directory structure such as:\n\n```text\n<datadir>/\n    mainnet/\n        blocks/\n        chainstate/\n        index/\n        ...\n    testnet/\n        ...\n    regtest/\n        ...\n```\n\nThe exact layout is encoded in the config types, so all collaborating components agree on the set of LevelDB instances and their on-disk locations. This is particularly important for:\n\n- Indexers and explorers built within the `bitcoin-rs` workspace.\n- Node components that share data directories.\n- Tools that must interact with the same LevelDBs without conflicting naming conventions.\n\n### Tuning and performance\n\nBitcoin-scale data volumes make LevelDB tuning nontrivial. `bitcoinleveldb-cfg` centralizes the parameters that control:\n\n- **Read amplification** — via block size, bloom filters, and cache shaping.\n- **Write amplification** — via write buffer sizes and compaction parameters.\n- **Memory footprint** — via block cache and table cache limits.\n\nBy encoding these parameters in a structured configuration type, you can:\n\n- Dynamically adjust tuning based on deployment profile (e.g., laptop vs dedicated server).\n- Maintain **deterministic configurations** for reproducible benchmarking.\n- Share tuning defaults across multiple binaries without copy-paste duplication.\n\n---\n\n## Integration within `bitcoin-rs`\n\nWithin the `https://github.com/klebs6/bitcoin-rs` repository, this crate is expected to be consumed by:\n\n- Other internal workspace crates that implement Bitcoin indexing, chainstate management, or analytics.\n- Binary targets that expose CLI tools or services relying on LevelDB persistence.\n\nFor consumers outside the workspace, the crate can be used as a *configuration boundary* so you can:\n\n- Align your LevelDB layout with `bitcoin-rs` tools.\n- Safely interoperate on the same on-disk databases.\n\n---\n\n## Feature flags\n\nIf this crate defines Cargo features, they are typically used to:\n\n- Toggle support for specific networks (e.g., include or exclude `Regtest` or experimental networks).\n- Adjust default tuning profiles (e.g., `heavy-load`, `low-mem`).\n\nCheck `Cargo.toml` in the repository for the precise set of available features.\n\n---\n\n## Error handling\n\nConfiguration constructors usually validate:\n\n- Path legality (e.g., non-empty, well-formed components).\n- Value ranges for tuning parameters (non-negative sizes, minimums, and maximums).\n\nThese validations typically return structured errors (e.g., an `enum` implementing `std::error::Error`) suitable for integration with error stacks (e.g., `anyhow`, `eyre`) in consumer crates.\n\n---\n\n## When to use this crate\n\nUse `bitcoinleveldb-cfg` if you:\n\n- Operate multiple LevelDB instances representing different aspects of a Bitcoin dataset and want **consistent and reproducible configuration**.\n- Build tools that should **coexist with or extend** the `bitcoin-rs` workspace.\n- Want a **single source of truth** for LevelDB paths and tuning rather than ad-hoc hard-coded values distributed across binaries.\n\nIf you only need a raw LevelDB binding with no Bitcoin-specific semantics, a general LevelDB crate may be sufficient.\n\n---\n\n## License\n\nThis crate is distributed under the MIT license.\n\n---\n\n## Repository\n\nSource code and issue tracking are hosted in the `bitcoin-rs` repository:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\nContributions, bug reports, and improvement suggestions are welcome through that repository.\n",
  "package_categories": [
    "database",
    "database-implementations",
    "development-tools",
    "network-programming"
  ],
  "package_description": "Typed configuration layer for LevelDB-backed Bitcoin data stores, defining network-aware paths, logical database roles, and LevelDB tuning parameters for use within the bitcoin-rs ecosystem.",
  "package_keywords": [
    "bitcoin",
    "leveldb",
    "configuration",
    "database",
    "blockchain"
  ]
}