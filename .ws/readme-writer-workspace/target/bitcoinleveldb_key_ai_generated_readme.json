{
  "crate_name": "bitcoinleveldb-key",
  "full_readme_markdown": "# bitcoinleveldb-key\n\nLow-level internal key encoding utilities for the `bitcoin-rs` LevelDB port. This crate provides a faithful, byte-for-byte reproduction of LevelDB's **internal key** machinery, specialized for Bitcoin's storage engine.\n\nIt focuses on:\n\n- Packing and unpacking LevelDB **internal keys** `(user_key, sequence_number, value_type)` into an opaque byte sequence.\n- Correct ordering semantics via an `InternalKeyComparator` that respects both user key order and sequence numbers.\n- Filter policy adaptation so that user-level Bloom filters remain valid when the DB internally stores extended keys.\n- Efficient construction of lookup keys for MemTable and SSTable access.\n\n> NOTE: This README was generated by an AI model, based only on the exposed public API. It may not be perfectly accurate or complete, but it should be a close and reasonably useful description.\n\n## Design overview\n\nLevelDB (and this port) do **not** store raw user keys directly. Instead, they use an **internal key**:\n\n```text\ninternal_key := user_key || tag\n\nwhere\n  tag := pack(sequence_number: 56 bits, value_type: 8 bits)\n```\n\nThis design allows multiple versions of the same logical user key to coexist, with different `sequence_number` values and `ValueType` variants:\n\n- `ValueType::TypeValue`   — key is present with a value\n- `ValueType::TypeDeletion` — key is logically deleted at that sequence\n\nThe **sort order** for internal keys is:\n\n1. First by the user key, using a user-supplied `SliceComparator` (or bytewise lexicographic fallback).\n2. For equal user keys, by **decreasing** sequence number (newest entries first).\n\nThis crate encapsulates these invariants so that higher-level components (MemTable, SSTable, DB implementation) can operate safely without re-implementing the encoding logic.\n\nThe following invariants are critical and preserved here:\n\n- `ValueType` is `#[repr(u8)]` and the discriminants are **stable on disk** — they must not change.\n- `SequenceNumber` is a 64‑bit integer, but only the high 56 bits are used when packed, leaving the lower 8 bits for `ValueType`.\n- All encoding/decoding paths are little-endian to match LevelDB.\n\n## Crate features and components\n\n### ValueType\n\n```rust\n#[repr(u8)]\n#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\npub enum ValueType {\n    TypeDeletion,\n    TypeValue,\n}\n```\n\nRepresents the logical type of a versioned key. The enum values are encoded directly into the low 8 bits of the tag and therefore must remain stable.\n\n`ValueType::from_tag(tag: u8) -> Option<Self>` maps raw tags back to the enum, enforcing the valid subset `{0x00, 0x01}`.\n\n### Key and Value traits\n\n```rust\npub trait Key {\n    fn key(&self) -> Slice;\n}\n\npub trait Value {\n    fn value(&self) -> Slice;\n}\n```\n\nMinimal traits abstracting over key/value providers that expose their representation as a `Slice` (defined elsewhere in the `bitcoinleveldb` ecosystem).\n\nThese traits are intentionally narrow: they push policy into higher layers and keep the encoding layer purely about bytes.\n\n### ParsedInternalKey\n\n```rust\npub type SequenceNumber = u64;\n\n#[derive(Setters, Getters)]\n#[getset(get = \"pub\", set = \"pub\")]\npub struct ParsedInternalKey {\n    user_key: Slice,\n    sequence: SequenceNumber,\n    ty:       ValueType,\n}\n```\n\n`ParsedInternalKey` is a structured view of an internal key:\n\n- `user_key`: the raw user key bytes\n- `sequence`: the sequence number\n- `ty`: the `ValueType`\n\nKey operations:\n\n- `ParsedInternalKey::new(u: &Slice, seq: &SequenceNumber, t: ValueType) -> Self`\n- `ParsedInternalKey::default()` — uses an empty key and `VALUE_TYPE_FOR_SEEK` as configured elsewhere.\n- `debug_string(&self) -> String` — stable debug formatting: `'<escaped_user>' @ seq : type_tag`.\n\n### InternalKey\n\n```rust\n#[derive(Clone)]\npub struct InternalKey {\n    rep: String,\n}\n```\n\nRepresents a fully encoded internal key as a sequence of bytes. The encoding is **not** UTF‑8 by design; the use of `String` is purely a compatibility artifact with the original LevelDB.\n\nKey methods:\n\n- `InternalKey::new(user_key: &Slice, s: SequenceNumber, t: ValueType) -> Self`  \n  Encodes `(user_key, s, t)` into the `rep` buffer using `append_internal_key`.\n\n- `fn decode_from(&mut self, s: &Slice) -> bool`  \n  Decodes an internal key from raw bytes into `self.rep`. Returns `false` for empty input.\n\n- `fn encode(&self) -> Slice`  \n  Returns a `Slice` view over the internal key bytes. Panics if `rep` is empty.\n\n- `fn user_key(&self) -> Slice`  \n  Extracts the user key portion by stripping the trailing 8‑byte tag.\n\n- `fn set_from(&mut self, p: &ParsedInternalKey)` / `fn clear(&mut self)`  \n  Reset or rebuild `rep` from a parsed representation.\n\n- `fn debug_string(&self) -> String`  \n  Parses the internal representation and renders a `ParsedInternalKey` debug string, or `(bad)<escaped_bytes>` if parsing fails.\n\nThe `Debug` implementation for `InternalKey` uses `debug_string()` instead of raw bytes, yielding stable, human-meaningful logging.\n\n### Encoding helpers\n\n#### pack_sequence_and_type\n\n```rust\npub fn pack_sequence_and_type(seq: u64, t: ValueType) -> u64\n```\n\nPacks `seq` and `t` into a single `u64`:\n\n- High 56 bits: `seq` (constrained by `MAX_SEQUENCE_NUMBER` elsewhere)\n- Low 8 bits: `t as u8` (constrained by `VALUE_TYPE_FOR_SEEK` elsewhere)\n\nEnsures:\n\n- `seq <= MAX_SEQUENCE_NUMBER`\n- `t as u64 <= VALUE_TYPE_FOR_SEEK as u64`\n\n#### internal_key_encoding_length\n\n```rust\npub fn internal_key_encoding_length(k: &ParsedInternalKey) -> usize\n```\n\nReturns `user_key_len + 8`. This is deterministic and matches the C++ implementation.\n\n#### parse_internal_key\n\n```rust\npub fn parse_internal_key(internal_key: &Slice, result: *mut ParsedInternalKey) -> bool\n```\n\nGiven an encoded internal key, fills `*result` with:\n\n- `user_key` = all but last 8 bytes\n- `sequence` = high 56 bits of the decoded tag\n- `ty` = `ValueType::from_tag(low_8_bits)`\n\nReturns `false` if:\n\n- The length is `< 8`.\n- The tag is invalid or beyond `VALUE_TYPE_FOR_SEEK`.\n\nCaller provides a non-null pointer to a `ParsedInternalKey` instance.\n\n#### append_internal_key\n\n```rust\npub fn append_internal_key(result: *mut String, k: &ParsedInternalKey)\n```\n\nAppends the encoded internal key for `k` onto the provided `String` buffer:\n\n1. Copies raw user key bytes.\n2. Packs and appends the (sequence, type) tag via `pack_sequence_and_type` and `encode_fixed64_le`.\n\n### Low-level byte utilities\n\nThese functions provide self-contained, allocation-free primitives for manipulating key bytes:\n\n- `encode_fixed64_le(value: u64) -> [u8; 8]` and `decode_fixed64_le(ptr: *const u8) -> u64` — fixed 64‑bit little-endian encode/decode.\n- `put_varint32_vec(dst: &mut Vec<u8>, v: u32)` — varint32 encoding into an existing `Vec<u8>`.\n- `decode_varint32(src: &[u8]) -> (u32, usize)` — decodes a varint32, asserting on malformed input.\n- `slice_as_bytes(s: &Slice) -> &[u8]` — safe view over a `Slice`.\n- `bytewise_compare(a: &[u8], b: &[u8]) -> i32` — lexicographic compare with LevelDB-style `{-1,0,1}` result.\n\nKey-range shortening helpers, used by compaction and iterators:\n\n- `shorten_separator_user_keys(start: &[u8], limit: &[u8]) -> Option<Vec<u8>>`  \n  Attempts to construct a minimal user key between `start` and `limit` by bumping the first differing byte when possible.\n\n- `find_short_successor_user_key(key: &mut Vec<u8>) -> bool`  \n  Makes `key` a short successor by incrementing the first non-`0xff` byte and truncating after it.\n\nDebug utility:\n\n- `escape_for_debug(input: &[u8]) -> String`  \n  Renders a byte string using C-style escapes for control and non-ASCII bytes.\n\n### extract_user_key\n\n```rust\npub fn extract_user_key(internal_key: &Slice) -> Slice\n```\n\nReturns the user key portion from a full internal key. Panics if the key is shorter than 8 bytes.\n\nThis is the canonical way to slice away the tag when you know you have a valid internal key.\n\n### InternalFilterPolicy\n\n```rust\npub struct InternalFilterPolicy {\n    user_policy: *const dyn FilterPolicy,\n}\n```\n\nWraps a user-provided `FilterPolicy` (e.g., Bloom filter) and transparently converts internal keys into user keys before delegating.\n\nImplements:\n\n- `FilterPolicy`\n- `Named`\n- `CreateFilter`\n- `KeyMayMatch`\n\nKey behavior:\n\n- `create_filter(&self, keys: *const Slice, n: i32, dst: &mut Vec<u8>)`\n  - Rewrites the `keys` array **in place**: each entry becomes its user key by applying `extract_user_key`.\n  - Delegates to `user_policy.create_filter` if provided.\n\n- `key_may_match(&self, k: &Slice, f: &Slice) -> bool`\n  - Extracts `user_key` from internal key `k`.\n  - Delegates to `user_policy.key_may_match`.\n\n- `name(&self) -> Cow<'_, str>`\n  - If no user policy is set, returns an empty name; otherwise forwards.\n\n`InternalFilterPolicy::new(p: *const dyn FilterPolicy) -> Self` constructs a wrapper around `p`. Passing a null pointer disables filtering.\n\n### InternalKeyComparator\n\n```rust\npub struct InternalKeyComparator {\n    user_comparator: *const dyn SliceComparator,\n}\n```\n\nImplements the precise ordering semantics for internal keys:\n\n1. Compare on user key using `user_comparator` if provided, else bytewise.\n2. If equal, compare the packed `sequence+type` tag such that **higher sequence numbers sort first**.\n\nImplements:\n\n- `SliceComparator`\n- `Compare`\n- `Named`\n- `FindShortSuccessor`\n- `FindShortestSeparator`\n\nCore methods:\n\n#### compare_slices\n\n```rust\npub fn compare_slices(&self, akey: &Slice, bkey: &Slice) -> i32\n```\n\n- Extracts user key portions using `extract_user_key`.\n- Compares user keys using `user_comparator` or `bytewise_compare`.\n- If equal, decodes tags via `decode_fixed64_le` and orders by descending tag (`a_num > b_num` yields `-1`).\n\n`compare_internal_key(&self, a: &InternalKey, b: &InternalKey) -> i32` is a convenience wrapper taking `InternalKey` objects.\n\n#### Shortening functions\n\nUsed during compaction to minimize index key sizes while preserving ordering.\n\n- `find_short_successor(&self, k: &mut Vec<u8>)`\n  - Treats `k` as an internal-key byte vector.\n  - Extracts and shortens the user key (via user comparator or `find_short_successor_user_key`).\n  - Re-appends a tag with `MAX_SEQUENCE_NUMBER` and `VALUE_TYPE_FOR_SEEK`.\n  - Ensures the new key is strictly greater than the original in internal-key order.\n\n- `find_shortest_separator(&self, start: &mut Vec<u8>, limit: &[u8])`\n  - Uses user-level separator logic to compute a shorter user key between `start` and `limit`.\n  - Reconstructs a full internal key, again using `MAX_SEQUENCE_NUMBER` and `VALUE_TYPE_FOR_SEEK` for the tag.\n  - Asserts the new key lies strictly between original `start` and `limit` in internal-key order.\n\n`InternalKeyComparator::new(c: *const dyn SliceComparator) -> Self` creates a comparator; `null_slice_comparator()` can be used to trigger fallback bytewise logic without providing a concrete comparator.\n\nThe `name()` implementation returns a stable identifier:\n\n```rust\n\"leveldb.InternalKeyComparator\"\n```\n\n### LookupKey\n\n```rust\npub struct LookupKey {\n    start:  *const u8,\n    kstart: *const u8,\n    end:    *const u8,\n    space:  [u8; 200],\n    buf:    Vec<u8>,\n}\n```\n\n`LookupKey` assists with constructing the exact key bytes used when issuing point lookups against MemTables and internal iterators.\n\nThe layout encoded in `buf` is:\n\n```text\nvarint32(internal_key_len) || user_key || tag\n```\n\nWhere `internal_key_len = user_key_len + 8`.\n\nConstruction:\n\n```rust\nimpl LookupKey {\n    pub fn new(user_key: &Slice, sequence: SequenceNumber) -> Self;\n}\n```\n\nThe constructor:\n\n- Varint-encodes the internal key length into `buf`.\n- Appends the raw user key bytes.\n- Packs `(sequence, VALUE_TYPE_FOR_SEEK)` into a tag and appends it.\n- Sets raw pointers `start`, `kstart`, and `end` inside `buf` for fast slicing.\n\nAccessors:\n\n- `memtable_key(&self) -> Slice`  \n  Returns `varint_len || internal_key` — used directly as the key in the MemTable.\n\n- `internal_key(&self) -> Slice`  \n  Returns `user_key || tag`, i.e., the internal key view.\n\n- `user_key(&self) -> Slice`  \n  Returns the user portion, ensuring there is room for the tag.\n\nThe `Drop` implementation is trivial: the backing `Vec` and stack storage clean themselves up; raw pointers are only references into that storage and do not own anything.\n\n### null_slice_comparator\n\n```rust\npub fn null_slice_comparator() -> *const dyn SliceComparator\n```\n\nConstructs a syntactically valid but semantically null trait-object pointer to `SliceComparator`.\n\nThis is never dereferenced intentionally; it exists solely to exercise and validate the *\"no user comparator provided\"* code paths. It uses `transmute` over `(0usize, 0usize)` for the vtable/data pair and must be handled with care.\n\n## Usage examples\n\n### Encoding and decoding an internal key\n\n```rust\nuse bitcoinleveldb_key::{\n    ParsedInternalKey, InternalKey, ValueType,\n    SequenceNumber, internal_key_encoding_length,\n    parse_internal_key, extract_user_key,\n};\nuse bitcoinleveldb_slice::Slice; // assuming this is the Slice type used in the project\n\nfn roundtrip_example() {\n    let user_bytes = b\"example-key\";\n    let user_slice = unsafe { Slice::from_ptr_len(user_bytes.as_ptr(), user_bytes.len()) };\n\n    let seq: SequenceNumber = 42;\n    let ty = ValueType::TypeValue;\n\n    // Structured representation\n    let parsed = ParsedInternalKey::new(&user_slice, &seq, ty);\n    let encoded_len = internal_key_encoding_length(&parsed);\n    assert_eq!(encoded_len, user_bytes.len() + 8);\n\n    // Opaque InternalKey wrapper\n    let ikey = InternalKey::new(&user_slice, seq, ty);\n    let encoded_slice = ikey.encode();\n\n    // Parse back into ParsedInternalKey\n    let mut parsed_back = ParsedInternalKey::default();\n    let ok = parse_internal_key(&encoded_slice, &mut parsed_back as *mut ParsedInternalKey);\n    assert!(ok);\n\n    let back_user = extract_user_key(&encoded_slice);\n    let back_user_bytes = unsafe {\n        std::slice::from_raw_parts(*back_user.data(), *back_user.size())\n    };\n\n    assert_eq!(back_user_bytes, user_bytes);\n    assert_eq!(*parsed_back.sequence(), seq);\n    assert_eq!(*parsed_back.ty(), ty);\n}\n```\n\n### Using InternalKeyComparator with a bytewise comparator\n\n```rust\nuse bitcoinleveldb_key::{\n    InternalKey, InternalKeyComparator,\n    ValueType, SequenceNumber,\n};\nuse bitcoinleveldb_slice::SliceComparator; // your implementation\n\nfn comparator_example() {\n    // For pure bytewise ordering, you may pass a null comparator and rely on fallback.\n    let cmp = InternalKeyComparator::new(bitcoinleveldb_key::null_slice_comparator());\n\n    let uk1 = b\"a\";\n    let uk2 = b\"a\";\n    let s1: SequenceNumber = 1;\n    let s2: SequenceNumber = 2;\n\n    let k1 = InternalKey::new(\n        &unsafe { bitcoinleveldb_slice::Slice::from_ptr_len(uk1.as_ptr(), uk1.len()) },\n        s1,\n        ValueType::TypeValue,\n    );\n    let k2 = InternalKey::new(\n        &unsafe { bitcoinleveldb_slice::Slice::from_ptr_len(uk2.as_ptr(), uk2.len()) },\n        s2,\n        ValueType::TypeValue,\n    );\n\n    // k2 is newer (higher sequence) and must sort before k1.\n    assert!(cmp.compare_internal_key(&k2, &k1) < 0);\n}\n```\n\n### Building a LookupKey for MemTable access\n\n```rust\nuse bitcoinleveldb_key::{LookupKey, SequenceNumber};\nuse bitcoinleveldb_slice::Slice;\n\nfn memtable_lookup_example() {\n    let user_key_bytes = b\"height:00000010\";\n    let user_key = unsafe { Slice::from_ptr_len(user_key_bytes.as_ptr(), user_key_bytes.len()) };\n    let snapshot_seq: SequenceNumber = 123_456;\n\n    let lookup = LookupKey::new(&user_key, snapshot_seq);\n\n    let memtable_key = lookup.memtable_key();    // varint32(len) || internal_key\n    let internal_key = lookup.internal_key();    // user_key || tag\n    let just_user = lookup.user_key();           // user_key only\n\n    // The MemTable layer treats `memtable_key` as the primary key.\n    drop((memtable_key, internal_key, just_user));\n}\n```\n\n## Integration notes\n\n- This crate is part of the `bitcoin-rs` repository and is intended to be used in concert with sibling crates providing `Slice`, filter policies, comparators, MemTable implementations, and SSTable abstractions.\n- The on-disk format is designed to be **stable and compatible** with the original LevelDB layout; do not change `ValueType` discriminants or encoding routines if you care about read-compatibility.\n- Many functions use `unsafe` with raw pointers (`Slice`, trait-object pointers, etc.). The invariants are mirroring the C++ library; ensure any external uses respect lifetimes and aliasing constraints.\n\n## Repository, license, and authors\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n- Crate: `bitcoinleveldb-key`\n- Edition: 2021\n- License: MIT\n- Author: `klebs <none>`\n\nIf you extend or wrap this crate, preserve the encoding, comparison, and filter semantics to maintain compatibility with existing data and with canonical LevelDB behavior.\n",
  "package_categories": [
    "database",
    "database-implementations",
    "algorithms",
    "data-structures",
    "cryptography"
  ],
  "package_description": "Low-level LevelDB-compatible internal key encoding, comparison, and filter-policy utilities used by bitcoin-rs for on-disk key/value layout and MemTable/SSTable lookups.",
  "package_keywords": [
    "leveldb",
    "bitcoin",
    "database",
    "key-encoding",
    "comparator"
  ]
}