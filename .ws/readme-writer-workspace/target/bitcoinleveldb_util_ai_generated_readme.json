{
  "crate_name": "bitcoinleveldb-util",
  "full_readme_markdown": "# bitcoinleveldb-util\n\nUtility components used by the `bitcoin-rs` / `bitcoinleveldb` codebase, focused on precise control over object lifetime and destructor behavior.\n\nThis crate is intentionally small and low-level. It exports primitives that help emulate C++-style *\"never call the destructor\"* patterns in Rust, primarily for function-local statics and other long-lived objects that must not run cleanup code on shutdown.\n\n> Note: This README.md was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful description of the crate.\n\n---\n\n## Overview\n\nThe key types provided are:\n\n- `DoNotDestruct` – A test/utility struct whose destructor **must never run**. If its `Drop` implementation is invoked, the process will immediately abort.\n- `NoDestructor<T>` – A wrapper that stores a fully-initialized instance of `T` inside `MaybeUninit<T>` and **never drops it**. This is particularly useful for singletons, function-local statics, or global state that must remain valid for the lifetime of the process and does not require orderly teardown.\n- `NoDestructorTest` – A trivial grouping struct, mainly used for tests.\n\nThe semantics are deliberately strict and closer to systems-programming idioms, trading graceful shutdown for predictable performance and the avoidance of complex destructor interactions at process exit.\n\n---\n\n## `DoNotDestruct`\n\n```rust\nuse bitcoinleveldb_util::DoNotDestruct;\n\n// Panics? No. If this is dropped, the process aborts.\nlet obj = DoNotDestruct::new(0xdead_beefu32, 0x0123_4567_89abu64);\n\n// Read and write fields via generated getters/setters (from `getset`):\nlet a = *obj.a();\nlet b = *obj.b();\n\nobj.set_a(1);\nobj.set_b(2);\n```\n\n### Behavior\n\n```rust\nimpl Drop for DoNotDestruct {\n    fn drop(&mut self) {\n        error!(\"DoNotDestruct destructor called! Aborting...\");\n        std::process::abort();\n    }\n}\n```\n\n- Any attempt to drop a `DoNotDestruct` instance (including unwinding across stack frames) will unconditionally call `process::abort()`.\n- The type is primarily intended as a *guardrail* in tests or as documentation of intent: this object is meant to be effectively immortal.\n\n### Construction\n\n```rust\nimpl DoNotDestruct {\n    pub fn new(a: u32, b: u64) -> Self {\n        info!(\"Constructing DoNotDestruct with a=0x{:x}, b=0x{:x}\", a, b);\n        Self { a, b }\n    }\n}\n```\n\nLogging macros (`info!`, `error!`) are used from the standard Rust logging ecosystem (e.g., `log` crate + chosen logger backend). To see log output, configure a logger in your binary (e.g. `env_logger`, `tracing_subscriber`, etc.).\n\n---\n\n## `NoDestructor<T>`\n\n`NoDestructor<T>` stores an instance of `T` in `MaybeUninit<T>`, ensuring that Rust never runs its destructor. This is the Rust analogue of C++ code that uses aligned storage plus placement-new and deliberately omits destructor calls.\n\n### Type definition\n\n```rust\nuse core::mem::MaybeUninit;\n\n#[derive(Debug)]\npub struct NoDestructor<InstanceType> {\n    instance_storage: MaybeUninit<InstanceType>,\n}\n```\n\n### Constructor\n\n```rust\nimpl<InstanceType> NoDestructor<InstanceType> {\n    /// Fully constructs the instance and stores it in `MaybeUninit`,\n    /// then **never** runs the destructor.\n    pub fn new(instance: InstanceType) -> Self {\n        info!(\"NoDestructor::new invoked\");\n        let storage = MaybeUninit::new(instance);\n        Self { instance_storage: storage }\n    }\n}\n```\n\nUsage:\n\n```rust\nuse bitcoinleveldb_util::NoDestructor;\n\nstruct Cache { /* fields omitted */ }\n\nfn global_cache() -> &'static mut Cache {\n    use core::mem::MaybeUninit;\n    use core::sync::atomic::{AtomicBool, Ordering};\n\n    static mut STORAGE: MaybeUninit<NoDestructor<Cache>> = MaybeUninit::uninit();\n    static INIT: AtomicBool = AtomicBool::new(false);\n\n    // Very low-level: caller must ensure this is called in a single-threaded\n    // initialization phase or otherwise synchronize access.\n    if !INIT.load(Ordering::Acquire) {\n        let cache = Cache { /* ... */ };\n        unsafe {\n            STORAGE.write(NoDestructor::new(cache));\n        }\n        INIT.store(true, Ordering::Release);\n    }\n\n    unsafe {\n        // `get()` yields *mut Cache; we convert to &'static mut Cache.\n        &mut *STORAGE.assume_init_ref().get()\n    }\n}\n```\n\n### Pointer access\n\n```rust\nimpl<InstanceType> NoDestructor<InstanceType> {\n    /// Returns a mutable raw pointer to the stored instance.\n    /// Lifetime and aliasing are **not** tracked at the type level.\n    pub fn get(&self) -> *mut InstanceType {\n        trace!(\"NoDestructor::get returning pointer to the stored instance\");\n        self.instance_storage.as_ptr() as *mut InstanceType\n    }\n}\n```\n\nImportant properties:\n\n- The destructor of `InstanceType` is **never called**.\n- `get()` returns a `*mut InstanceType` even though `&self` is shared; this mirrors some C++ patterns but deviates from idiomatic Rust. The burden of ensuring sound aliasing rules and exclusive mutation lies with the caller.\n- The underlying `InstanceType` **must be fully initialized** by the time you call `get()` (which is guaranteed for instances constructed via `NoDestructor::new`).\n\n### Safety considerations\n\nWhile `NoDestructor<T>` itself is safe to construct and use at the type level, it allows patterns where you can trivially violate Rust's higher-level aliasing disciplines if misused. You must:\n\n- Ensure that at most one mutable reference to the underlying `T` exists at any time.\n- Ensure no mutable reference is used concurrently with any shared references where `T`'s invariants would not permit it.\n- Accept that resources owned by `T` (file descriptors, sockets, memory buffers, lock guards, etc.) will never be released by RAII; they must either be leak-tolerant or managed manually.\n\nThis design is appropriate for process-long singletons where resource reclamation is unnecessary or undesirable.\n\n---\n\n## `NoDestructorTest`\n\n```rust\n#[derive(Debug, Getters, Setters, Builder)]\npub struct NoDestructorTest {}\n```\n\nA minimal struct serving as a convenient grouping for tests. Its presence indicates that the crate is used to validate and regression-test the above lifetime primitives.\n\n---\n\n## Design rationale\n\nThe patterns implemented in this crate arise from a specific class of problems in systems and database code:\n\n- Some singletons or subsystems are more expensive, brittle, or risky to tear down than to leak.\n- During shutdown, destructors may depend on global order-of-destruction guarantees that are fragile or impossible to enforce (especially across FFI boundaries or multiple static initializers).\n- In such contexts, an explicit decision is made to construct once and **never destruct**, trading finite resource leaks at process exit for determinism during the lifetime of the program.\n\n### Relation to C++ patterns\n\nC++ often uses patterns like:\n\n- `static SomeType instance;` with non-trivial destructors, whose order-of-destruction across translation units is notoriously complex.\n- `std::aligned_storage` + placement-new, followed by intentionally omitting `~SomeType()` calls.\n\n`NoDestructor<T>` mirrors the second approach using `MaybeUninit<T>` in Rust. `DoNotDestruct` serves as an explicit sentinel type that aborts if any destructor tries to execute, making tests detect any unintentional destruction.\n\n---\n\n## Logging\n\nThe snippets use logging macros such as `info!`, `error!`, and `trace!`. At integration time, you will typically:\n\n```toml\n[dependencies]\nlog = \"0.4\"\n# and a backend of your choice, e.g.\nenv_logger = \"0.11\"\n```\n\nInitialize logging in your binary:\n\n```rust\nfn main() {\n    env_logger::init();\n    // use bitcoinleveldb-util types here\n}\n```\n\nThis allows you to observe constructor calls and any unexpected destructor activity during testing.\n\n---\n\n## When *not* to use this crate\n\nAvoid these primitives if:\n\n- You want idiomatic Rust RAII where destructors reliably run and free resources.\n- You require structured teardown, e.g., for graceful shutdown of network servers.\n- You can express your requirements using `lazy_static`, `once_cell`, or `std::sync::OnceLock` without destructors that cause problems.\n\nUse this crate when you:\n\n- Need full control over when (or whether) destructors execute.\n- Are porting C++ code that already relies on immortal singletons or non-dropping patterns.\n- Operate in a low-level environment (such as an embedded database, block storage engine, or consensus node) where teardown cost and complexity outweigh the benefits.\n\n---\n\n## Repository and license\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n- Crate: `bitcoinleveldb-util`\n- License: MIT\n\nThis crate is a component in the broader `bitcoin-rs` ecosystem. Consult that repository for examples of how these primitives are used in practice inside a leveldb-like storage engine and related Bitcoin infrastructure.\n",
  "package_categories": [
    "development-tools",
    "memory-management",
    "data-structures"
  ],
  "package_description": "Low-level utilities for bitcoin-rs/bitcoinleveldb providing C++-style non-dropping singletons and destructor control via DoNotDestruct and NoDestructor<T>.",
  "package_keywords": [
    "bitcoin",
    "leveldb",
    "lifetime",
    "destructor",
    "singleton"
  ]
}