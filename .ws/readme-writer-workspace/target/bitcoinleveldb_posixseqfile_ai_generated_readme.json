{
  "crate_name": "bitcoinleveldb-posixseqfile",
  "full_readme_markdown": "# bitcoinleveldb-posixseqfile\n\nA small, sharply focused crate that provides a POSIX-backed implementation of LevelDB's `SequentialFile` abstraction, suitable for integration into a Bitcoin-oriented LevelDB port or any storage engine that expects a LevelDB-compatible sequential file API.\n\n> This README was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful approximation of the crate's intent and behavior.\n\n---\n\n## Overview\n\n`bitcoinleveldb-posixseqfile` exposes a single core type:\n\n```rust\npub struct PosixSequentialFile {\n    fd:       i32,\n    filename: String,\n}\n```\n\nIt is designed as a low-level adapter from raw POSIX file descriptors (`read`, `lseek`, `close`) to the traits that model LevelDB's **sequential file** interface:\n\n- `SequentialFile`\n- `SequentialFileRead`\n- `SequentialFileSkip`\n- `Named`\n\nThis crate does **not** own the higher-level database semantics; it only implements efficient, robust, sequential read access over an already-open file descriptor in a form that is idiomatic to a Rust port of LevelDB.\n\nThe design goals are:\n\n- **Strict adherence to LevelDB semantics**: sequential-only reads, explicit skip, and EOF behavior that callers can rely on.\n- **POSIX-conformant behavior**: uses `read(2)`, `lseek(2)`, and `close(2)` directly, with correct handling of `EINTR` and I/O errors.\n- **Thread-friendly, but not thread-safe**: instances can be used by multiple threads if externally synchronized, but internal methods assume exclusive &mut access as per the `SequentialFile` contract.\n- **Minimal overhead**: no allocation in the hot path except what is required to construct `Status` and log messages on error paths.\n\n\n## Core API\n\n### `PosixSequentialFile`\n\n```rust\npub struct PosixSequentialFile {\n    fd:       i32,\n    filename: String,\n}\n\nimpl PosixSequentialFile {\n    pub fn new(filename: String, fd: i32) -> Self { /* ... */ }\n}\n\nimpl SequentialFile for PosixSequentialFile {}\nimpl SequentialFileRead for PosixSequentialFile {}\nimpl SequentialFileSkip for PosixSequentialFile {}\nimpl Named for PosixSequentialFile {}\n```\n\n#### Construction\n\n```rust\nuse bitcoinleveldb_posixseqfile::PosixSequentialFile;\n\n// `fd` must be an open file descriptor positioned at the desired starting offset.\nlet filename = \"/var/lib/blocks/index.leveldb/000123.sst\".to_owned();\nlet fd: i32 = open_file_descriptor_somehow();\n\nlet seq = PosixSequentialFile::new(filename, fd);\n```\n\n- `filename` is stored only for diagnostics and introspection via `Named`.\n- `fd` is assumed to be a valid, open, read-capable POSIX file descriptor.\n- Ownership: `PosixSequentialFile` takes ownership of `fd` and will close it in `Drop`.\n\n#### Naming\n\n```rust\nuse bitcoinleveldb_posixseqfile::PosixSequentialFile;\nuse your_leveldb_traits::Named;\n\nfn print_name(f: &PosixSequentialFile) {\n    println!(\"sequential file: {}\", f.name());\n}\n```\n\nThe `Named` implementation returns a borrowed `Cow<'_, str>` referencing the stored `filename`. This allows logging and error reporting with minimal allocation.\n\n\n### Sequential Reads\n\nThe core of the abstraction is realized via `SequentialFileRead`:\n\n```rust\nimpl SequentialFileRead for PosixSequentialFile {\n    fn read(\n        &mut self,\n        n:       usize,\n        result:  *mut Slice,\n        scratch: *mut u8,\n    ) -> Status { /* ... */ }\n}\n```\n\nSemantics:\n\n- Attempts to read **up to** `n` bytes from the current file offset into the caller-provided buffer at `scratch`.\n- On success:\n  - Sets `*result` to a `Slice` pointing directly into the `scratch` buffer with the actual read size.\n  - If `read` returns 0 (EOF), `*result` is set to an empty `Slice`.\n  - Returns `Status::ok()`.\n- On error (other than `EINTR`):\n  - Constructs a `Status::io_error(ctx, detail)` describing the failure.\n  - Leaves `*result` as an empty `Slice`.\n  - Returns that error `Status`.\n- On `EINTR`:\n  - Logs and automatically retries the `read` syscall in a loop.\n\nThe function is deliberately low-level:\n\n- `result` and `scratch` are raw pointers to avoid any coupling to particular slice or buffer lifetimes in higher layers.\n- The caller guarantees that `scratch` points to a writable buffer of at least `n` bytes for the duration of the call.\n- `Slice` is a lightweight, non-owning view into arbitrary memory, compatible with typical LevelDB-style slice abstractions.\n\nThis design isolates unsafe operations to the implementation, while presenting a deterministic interface to the rest of the LevelDB port.\n\n\n### Skipping Forward\n\nSequential skipping is implemented via `lseek(2)` relative to the current offset:\n\n```rust\nimpl SequentialFileSkip for PosixSequentialFile {\n    fn skip(&mut self, n: u64) -> Status { /* ... */ }\n}\n```\n\nSemantics:\n\n- Moves the file descriptor forward by `n` bytes using `lseek(fd, n, SEEK_CUR)`.\n- If `lseek` succeeds:\n  - Logs the new offset.\n  - Returns `Status::ok()`.\n- If `lseek` fails:\n  - Captures the OS error and maps it into a `Status::io_error` with:\n    - `ctx` set to the file name.\n    - `detail` set to the OS error string.\n  - Returns that `Status`.\n\nNote that this is not a `pread`-style interface: it mutates the underlying file offset. This matches the expectations of LevelDB's `SequentialFile`, which models a forward-only scan.\n\n\n### Drop and Resource Management\n\n`PosixSequentialFile` owns its `fd` and is responsible for closing it when dropped:\n\n```rust\nimpl Drop for PosixSequentialFile {\n    fn drop(&mut self) {\n        // close(fd) with logging and error reporting\n    }\n}\n```\n\n- On `drop`, it invokes `libc::close(self.fd)`.\n- If `close` fails, it logs a warning including the `errno` and OS error text.\n- Regardless of success or failure, the Rust type system ensures that the application can no longer use the file descriptor through this object after drop.\n\nThis RAII discipline reduces the risk of descriptor leaks when used from higher-level code that may early-return on error or panic.\n\n\n## Threading Model\n\n`PosixSequentialFile` is described as:\n\n> Instances of this class are thread-friendly but not thread-safe, as required by the SequentialFile API.\n\nInterpretation:\n\n- **Thread-friendly**: The underlying POSIX syscalls `read`, `lseek`, and `close` are thread-safe *for independent file descriptors*. Multiple `PosixSequentialFile` instances that wrap distinct `fd`s can be used concurrently without interference.\n- **Not thread-safe**: A single `PosixSequentialFile` should not be accessed from multiple threads without synchronization. This is enforced at the Rust level by the use of `&mut self` in `read` and `skip`.\n\nIn other words, concurrency is possible at the database level through sharding or independent files, but this object models a single-threaded cursor over one file.\n\n\n## Error Handling and Status Mapping\n\nAll public trait methods return a `Status` object consistent with LevelDB conventions. While the exact `Status` type is defined elsewhere, this crate uses it as follows:\n\n- `Status::ok()` for successful operations.\n- `Status::io_error(ctx: &Slice, detail: Option<&Slice>)` for OS-level I/O failures.\n\nFor both `read` and `skip`:\n\n1. The OS error is captured via `io::Error::last_os_error()`.\n2. The raw `errno` is obtained via `raw_os_error().unwrap_or(0)` for logging.\n3. The context is the file name; detail is the human-readable error string.\n\nThis allows higher layers to distinguish between logical database errors (e.g., corruption) and environmental errors (e.g., disk full, permission denied), which is essential for robust storage systems.\n\n\n## Logging\n\nThe implementation uses structured logging macros (`trace!`, `debug!`, `warn!`) to emit:\n\n- Entry/exit traces for `new`, `read`, `skip`, and `drop`.\n- Error paths including `errno`, file name, and human-readable error text.\n- EOF conditions (read of 0 bytes) and new offsets after `skip`.\n\nThe macros are assumed to be provided by an external logging facade (e.g., `tracing` or `log`-compatible macros). This crate focuses on ensuring that meaningful, structured context is always available for observability and diagnostics.\n\n\n## Integration in a LevelDB Port\n\n`PosixSequentialFile` is typically not used directly by application code. Instead, it is instantiated by an **environment** or **file system adapter** layer that implements the broader LevelDB `Env` API, for example:\n\n```rust\nuse bitcoinleveldb_posixseqfile::PosixSequentialFile;\nuse your_leveldb_traits::{SequentialFile, SequentialFileRead, SequentialFileSkip, Slice, Status};\n\nfn open_sequential_file(path: &str) -> Result<Box<dyn SequentialFile>, Status> {\n    use std::ffi::CString;\n    use libc::{open, O_RDONLY};\n\n    let c_path = CString::new(path).unwrap();\n    let fd = unsafe { open(c_path.as_ptr(), O_RDONLY) };\n    if fd < 0 {\n        // Map to Status::io_error via your environment layer\n        return Err(/* ... */);\n    }\n\n    Ok(Box::new(PosixSequentialFile::new(path.to_owned(), fd)))\n}\n```\n\nHigher-level database components (iterators, table readers, compaction code) then interact only with the trait objects, not with raw file descriptors or POSIX primitives.\n\n\n## Safety Considerations\n\nAll direct interaction with POSIX syscalls is encapsulated in `unsafe` blocks inside this crate. The public API remains entirely safe **under the following preconditions**:\n\n- The caller:\n  - Supplies a valid, open file descriptor (`fd`) that remains unique to this `PosixSequentialFile` instance.\n  - Avoids using the same file descriptor elsewhere after passing it to `new`.\n  - Provides a `scratch` buffer of length at least `n` bytes for `read`, with a lifetime sufficient for the duration of the call.\n- The crate:\n  - Never dereferences `scratch` or `result` beyond the bounds specified by `n` and the `read` return value.\n  - Does not expose any raw pointers to the caller, only `Slice` values.\n\nWhen used through the intended LevelDB environment layer, these invariants are typically enforced at a single integration point.\n\n\n## Performance Considerations\n\nWhile the crate itself is small, its behavior matters for large sequential scans common in database workloads:\n\n- **No internal buffering**: the caller controls buffering entirely, deciding `n` and the buffer strategy.\n- **Minimal copies**: data is read directly into the caller's buffer; `Slice` is just a view.\n- **EINTR handling**: transient interruptions are retried, avoiding spurious failures under load when signals are present.\n\nFor high-throughput workloads (e.g., LevelDB table scans in block validation), you can tune performance by:\n\n- Choosing a large `n` and reusing a fixed-size `scratch` buffer across calls.\n- Aligning I/O sizes with filesystem or storage hardware characteristics.\n\n\n## Example: Manual Sequential Scan\n\nThe following example shows how you might manually loop over a file sequentially using the traits. This is mostly illustrative; real applications will likely use higher-level iterators.\n\n```rust\nuse bitcoinleveldb_posixseqfile::PosixSequentialFile;\nuse your_leveldb_traits::{SequentialFileRead, Slice, Status};\n\nfn scan_file(mut file: PosixSequentialFile) -> Status {\n    const BUF_SIZE: usize = 64 * 1024;\n    let mut buf = vec![0u8; BUF_SIZE];\n\n    loop {\n        let mut slice = Slice::default();\n        let status = file.read(BUF_SIZE, &mut slice as *mut Slice, buf.as_mut_ptr());\n        if !status.is_ok() {\n            return status;\n        }\n\n        if slice.is_empty() {\n            // EOF\n            break;\n        }\n\n        // Process `slice` as a view into `buf[0..slice.len()]`.\n        process_chunk(&slice);\n    }\n\n    Status::ok()\n}\n```\n\n\n## License\n\nThis crate is licensed under the **MIT** license. See the `LICENSE` file for details.\n\n\n## Rust Edition\n\nThis crate targets **Rust 2024 edition**, leveraging its language semantics while remaining compatible with stable tooling.\n",
  "package_categories": [
    "filesystem",
    "network-programming",
    "data-structures"
  ],
  "package_description": "POSIX-backed implementation of a LevelDB-compatible SequentialFile using read, lseek, and close for efficient sequential file access in Bitcoin-oriented storage engines.",
  "package_keywords": [
    "leveldb",
    "bitcoin",
    "posix",
    "sequential-file",
    "storage"
  ]
}