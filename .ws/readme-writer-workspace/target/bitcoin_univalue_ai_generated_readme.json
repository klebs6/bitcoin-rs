{
  "crate_name": "bitcoin-univalue",
  "full_readme_markdown": "# bitcoin-univalue\n\nA near byte-for-byte Rust transcription of Bitcoin Core's `UniValue` JSON subsystem, designed to preserve the original C++ layout, semantics, and test behavior while exposing an idiomatic Rust surface where possible.\n\n> NOTE: This README was generated by an AI model. It may not be perfectly accurate or exhaustive, but it should be a strong starting point.\n\n---\n\n## Overview\n\n`bitcoin-univalue` provides a minimal, Bitcoin-Core–compatible JSON value type and parser:\n\n- `UniValue`: a dynamically typed JSON value (null, bool, number, string, array, object) mirroring Bitcoin Core's `UniValue` implementation.\n- A hand-ported recursive-descent JSON parser with a lexical/token layer.\n- Canonical JSON number formatting precisely matching Bitcoin Core’s floating-point semantics, including the historical `FormatSaferDouble` quirks.\n- UTF‑8 and UTF‑16 surrogate-pair validation and collation as specified in RFC 4627 / RFC 7159.\n- A set of C-style expectation macros and APIs that keep the Rust code mechanically close to upstream C++ for auditability.\n\nThe crate is primarily intended as infrastructure for Bitcoin-related tooling that must stay behaviorally identical to upstream Bitcoin Core (e.g., for consensus-adjacent tooling, RPC regression testing, or protocol conformance checks), rather than as a general-purpose JSON library.\n\n---\n\n## Design goals\n\n- **Semantic fidelity to Bitcoin Core**\n  - Data model, parser behavior, and formatting must match upstream.\n  - Edge cases (floating-point serialization, invalid JSON rejection, UTF‑8/UTF‑16 handling) are ported together with their upstream tests.\n- **Auditability**\n  - Control flow, names, and state machines remain close to the C++ original.\n  - C-style helper macros (`expect!`, `set_expect!`, `clear_expect!`) preserve the original bitmask-based parser logic.\n- **Rust ergonomics on the edges**\n  - `From<T>` implementations for common scalars.\n  - Index operators for object/array access (`uv[\"key\"]`, `uv[0]`).\n  - Optional utilities such as `check_object`, `get_obj_map`, and pretty-printing.\n\nIf you need a general JSON library, use `serde_json`. If you need *Bitcoin Core–exact* JSON behavior, use `bitcoin-univalue`.\n\n---\n\n## Data model: `UniValue`\n\n```rust\n#[derive(Setters, MutGetters, Getters, Clone, Debug)]\npub struct UniValue  {\n    typ:    uni_value::VType,\n    val:    String,\n    keys:   Vec<String>,\n    values: Vec<UniValue>,\n}\n\nmod uni_value {\n    #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n    pub enum VType {\n        VNULL,\n        VOBJ,\n        VARR,\n        VSTR,\n        VNUM,\n        VBOOL,\n    }\n}\n``\n\n`UniValue` stores:\n\n- the **type tag** (`VType`),\n- a **string payload** for scalars (`val`),\n- and for arrays/objects a `values` vector containing the elements and, for objects, a `keys` vector storing the key order.\n\nThis layout intentionally mirrors the original C++ `UniValue` structure, down to representation and method naming.\n\nA canonical **null value** is provided as a global static:\n\n```rust\nlazy_static! {\n    pub static ref NULL_UNI_VALUE: UniValue = UniValue::default();\n}\n```\n\nBy design, a default `UniValue` is `null`:\n\n```rust\nimpl Default for UniValue {\n    fn default() -> Self { Self::null() }\n}\n```\n\n---\n\n## Construction and conversion\n\n### Constructors\n\n```rust\nimpl UniValue {\n    pub fn null() -> Self;\n    pub fn empty_array() -> Self;\n\n    /// Create with a given type and optional initial string content.\n    pub fn new(initial_type: uni_value::VType, initial_str: Option<&str>) -> Self;\n}\n```\n\nExamples:\n\n```rust\nuse bitcoin_univalue::UniValue;\nuse bitcoin_univalue::uni_value::VType;\n\nlet null = UniValue::null();\nlet arr  = UniValue::empty_array();\n\nlet s = UniValue::new(VType::VSTR, Some(\"hello\"));\nlet n = UniValue::new(VType::VNUM, Some(\"42\"));\n```\n\n### `From<T>` implementations\n\n`UniValue` implements `From` for several scalar types:\n\n```rust\nimpl From<bool>          for UniValue { .. }\nimpl From<i32>           for UniValue { .. }\nimpl From<i64>           for UniValue { .. }\nimpl From<u64>           for UniValue { .. }\nimpl From<usize>         for UniValue { .. }\nimpl From<f64>           for UniValue { .. }\nimpl From<&str>          for UniValue { .. }\nimpl From<String>        for UniValue { .. }\nimpl From<*const u8>     for UniValue { .. }   // C string pointer\nimpl From<Instant>       for UniValue { .. }   // maps to null (upstream behavior)\nimpl From<uni_value::VType> for UniValue { .. }\n```\n\nUsage:\n\n```rust\nlet a = UniValue::from(true);\nlet b = UniValue::from(123_i64);\nlet c = UniValue::from(3.14_f64);\nlet d = UniValue::from(\"string\");\n```\n\n### Type setters\n\n`UniValue` exposes explicit setters to control type and payload:\n\n```rust\nimpl UniValue {\n    pub fn set_i32(&mut self, val: i32) -> bool;\n    pub fn set_i64(&mut self, val: i64) -> bool;\n    pub fn set_u64(&mut self, val: u64) -> bool;\n    pub fn set_float(&mut self, val: f64) -> bool;\n\n    pub fn set_null(&mut self) -> bool;\n    pub fn set_bool(&mut self, val: bool) -> bool;\n    pub fn set_str(&mut self, val: &str) -> bool;\n\n    /// Set from a string representing a JSON number. Validates syntax.\n    pub fn set_num_str(&mut self, val: &String) -> bool;\n\n    pub fn set_array(&mut self) -> bool;\n    pub fn set_object(&mut self) -> bool;\n\n    /// Generic integer convenience.\n    pub fn set_int<T: Debug + std::fmt::Display>(&mut self, val: T) -> bool;\n\n    pub fn clear(&mut self);  // reset to null\n}\n```\n\n`set_num_str` performs syntactic validation against JSON number rules (no hex, no padding whitespace, etc.), via `parse_prechecks` and `valid_num_str` (not shown here but part of the crate).\n\n---\n\n## Introspection and typed accessors\n\n### Type predicates\n\n```rust\nimpl UniValue {\n    pub fn is_null(&self)   -> bool;\n    pub fn is_true(&self)   -> bool;\n    pub fn is_false(&self)  -> bool;\n    pub fn is_bool(&self)   -> bool;\n    pub fn is_str(&self)    -> bool;\n    pub fn is_num(&self)    -> bool;\n    pub fn is_array(&self)  -> bool;\n    pub fn is_object(&self) -> bool;\n\n    pub fn get_type(&self) -> uni_value::VType;\n    pub fn ty(&self) -> uni_value::VType; // shorthand\n\n    pub fn empty(&self) -> bool;  // values vector empty\n    pub fn size(&self)  -> usize; // number of elements for array/object\n}\n```\n\n### Accessors (panic on type mismatch)\n\nThese mirror Bitcoin Core’s `UniValue` API and intentionally **panic** on incorrect types.\n\n```rust\nimpl UniValue {\n    pub fn get_bool(&self) -> bool;\n    pub fn get_str(&self) -> &str;\n    pub fn get_str_mut(&mut self) -> &mut str;\n\n    pub fn get_int(&self)   -> i32;\n    pub fn get_int64(&self) -> i64;\n    pub fn get_real(&self)  -> f64;\n\n    pub fn get_obj(&self)   -> &UniValue;   // ensure object\n    pub fn get_array(&self) -> &UniValue;   // ensure array\n\n    pub fn get_val_str(&self)   -> &String; // raw internal value\n    pub fn get_keys(&self)      -> &Vec<String>; // only for objects\n    pub fn get_values(&self)    -> &Vec<UniValue>; // for objects/arrays\n}\n```\n\nUse these only when the type is known (e.g., after `check_object` or explicit checks).\n\n---\n\n## Object and array manipulation\n\n### Object API\n\n```rust\nimpl UniValue {\n    /// key existence\n    pub fn exists(&self, key: &str) -> bool;\n\n    /// Copy object into a HashMap (no-op if not an object).\n    pub fn get_obj_map(&self, kv: &mut HashMap<String, UniValue>);\n\n    /// Schema-like check: every template key must exist with specified VType.\n    pub fn check_object(&self, template: &HashMap<String, uni_value::VType>) -> bool;\n\n    /// Low-level: find `key` and fill index in `ret_idx`.\n    pub fn find_key(&self, key: &str, ret_idx: &mut usize) -> bool;\n\n    /// Copy every key/value pair from `obj` into `self` (no deduplication).\n    pub fn push_kvs(&mut self, obj: &UniValue) -> bool;\n\n    /// Insert or replace key with val (converted via `Into<UniValue>`).\n    pub fn pushkv<T: Into<UniValue>>(&mut self, key: &str, val: T) -> bool;\n}\n```\n\nExample:\n\n```rust\nuse bitcoin_univalue::UniValue;\nuse std::collections::HashMap;\n\nlet mut obj = UniValue::null();\nobj.set_object();\n\nobj.pushkv(\"answer\", 42_i64);\nobj.pushkv(\"flag\", true);\nobj.pushkv(\"label\", \"node-1\");\n\nassert!(obj.exists(\"answer\"));\nassert_eq!(obj[\"answer\"].get_int64(), 42);\n\nlet mut template = HashMap::new();\nuse bitcoin_univalue::uni_value::VType;\n\ntemplate.insert(\"answer\".to_owned(), VType::VNUM);\ntemplate.insert(\"flag\".to_owned(),   VType::VBOOL);\n\naassert!(obj.check_object(&template));\n```\n\n### Array API\n\n```rust\nimpl UniValue {\n    /// Append a single element using runtime type inspection.\n    pub fn push_back<T: Any>(&mut self, val: &T) -> bool;\n\n    /// Bulk-append a vector of UniValues.\n    pub fn push_backv(&mut self, vec: &Vec<UniValue>) -> bool;\n}\n```\n\nThe `push_back` method supports:\n\n- `UniValue`\n- `bool`, `i32`, `i64`, `u64`, `f64`\n- `&str`, `String`\n\nExample:\n\n```rust\nuse bitcoin_univalue::UniValue;\nuse std::any::Any;\n\nlet mut arr = UniValue::empty_array();\n\narr.push_back(&true as &dyn Any);\narr.push_back(&123_i64 as &dyn Any);\narr.push_back(&\"hello\" as &dyn Any);\n\nassert!(arr.is_array());\nassert_eq!(arr.size(), 3);\nassert!(arr[0].get_bool());\n```\n\n> Note: The `push_back` signature is intentionally constrained to maintain compatibility with the upstream logic and to preserve the ability to downcast from a generic `Any` stream.\n\n---\n\n## Indexing\n\n`UniValue` implements `Index<&str>` and `Index<usize>`:\n\n```rust\nimpl Index<&str> for UniValue {\n    type Output = UniValue;\n\n    fn index(&self, key: &str) -> &Self::Output {\n        // object-only; otherwise returns &NULL_UNI_VALUE\n    }\n}\n\nimpl Index<usize> for UniValue {\n    type Output = UniValue;\n\n    fn index(&self, index: usize) -> &Self::Output {\n        // arrays/objects; otherwise &NULL_UNI_VALUE\n    }\n}\n```\n\nBehavior:\n\n- Attempting to index a non-object with `&str` returns a reference to `NULL_UNI_VALUE`.\n- For arrays/objects, out-of-bounds indices also return `&NULL_UNI_VALUE`.\n\nThis is deliberate: upstream code often relies on a global immutable \"null\" sentinel rather than panicking or returning `Option`.\n\nExample:\n\n```rust\nlet mut obj = UniValue::null();\nobj.set_object();\nobj.pushkv(\"x\", 1_i64);\n\nassert_eq!(obj[\"x\"].get_int64(), 1);\nassert!(obj[\"missing\"].is_null());\n```\n\n---\n\n## JSON parsing and serialization\n\n### Parsing: `UniValue::read`\n\nThe core JSON parser entry point is:\n\n```rust\nimpl UniValue {\n    /// Parse `size` bytes from `raw` into `self`.\n    /// Returns `false` on lexical or structural error; `self` is left cleared on failure.\n    pub fn read(&mut self, raw: *const u8, size: usize) -> bool;\n}\n```\n\nThis is an almost direct translation of Bitcoin Core’s JSON reader. It uses:\n\n- A token layer (`get_json_token`, `JTokenType`) for lexical analysis.\n- A **bitmask of parser expectations** (what token classes are allowed next), encoded in the `ExpectBits` enum.\n- An explicit stack of container pointers to walk nested arrays/objects.\n- A maximum nesting depth (`MAX_JSON_DEPTH`) matching upstream.\n\n### Expectation bitmask and macros\n\n```rust\n#[repr(u32)]\npub enum ExpectBits {\n    EXP_OBJ_NAME,\n    EXP_COLON,\n    EXP_ARR_VALUE,\n    EXP_VALUE,\n    EXP_NOT_VALUE,\n}\n\n#[macro_export]\nmacro_rules! expect { {\n    ($expect_mask:expr,$bit:ident) => {\n        ($expect_mask & (ExpectBits::$bit as u32)) != 0\n    };\n} }\n\n#[macro_export]\nmacro_rules! set_expect { {\n    ($expect_mask:expr,$bit:ident) => {\n        $expect_mask |= ExpectBits::$bit as u32;\n    };\n} }\n\n#[macro_export]\nmacro_rules! clear_expect { {\n    ($expect_mask:expr,$bit:ident) => {\n        $expect_mask &= !(ExpectBits::$bit as u32);\n    };\n} }\n```\n\nThese macros operate on a `u32` bitmask tracking parser state. They reproduce the original C++ macros to keep the `read` function mechanically transcribable.\n\nParser example:\n\n```rust\nuse bitcoin_univalue::UniValue;\n\nlet json = br#\"{\"a\": 1, \"b\": [true, null]}\"#;\n\nlet mut uv = UniValue::null();\nlet ok = uv.read(json.as_ptr(), json.len());\nassert!(ok);\n\nassert!(uv.is_object());\nassert_eq!(uv[\"a\"].get_int64(), 1);\nassert!(uv[\"b\"].is_array());\nassert!(uv[\"b\"][0].get_bool());\nassert!(uv[\"b\"][1].is_null());\n```\n\n> Safety: `read` accepts a raw pointer and length to be compatible with upstream code. It is the caller’s responsibility to ensure the lifetime and validity of the buffer.\n\n### Serialization: `UniValue::write`\n\n```rust\nimpl UniValue {\n    /// Serialise this value to JSON.\n    /// - pretty_indent == 0 → compact, single-line output.\n    /// - indent_level        → current indentation depth.\n    pub fn write(&self, pretty_indent: Option<u32>, indent_level: Option<u32>) -> String;\n}\n```\n\nStrings are escaped via `json_escape`, which uses a precomputed `escapes` lookup table. Pretty-printing uses `indent_str` to append spaces.\n\nExample:\n\n```rust\nlet mut uv = UniValue::null();\nuv.set_object();\nuv.pushkv(\"x\", 1_i64);\nuv.pushkv(\"y\", \"str\");\n\nlet compact = uv.write(Some(0), Some(0));\n// {\"x\":1,\"y\":\"str\"}\n\nlet pretty = uv.write(Some(2), Some(0));\n// {\n//   \"x\": 1,\n//   \"y\": \"str\"\n// }\n```\n\n---\n\n## UTF‑8 / UTF‑16 handling: `JSONUTF8StringFilter`\n\nThe parser must correctly implement RFC 4627 / RFC 7159 rules for JSON strings, notably:\n\n- All JSON strings are sequences of Unicode scalar values.\n- `\\uXXXX` escapes represent UTF‑16 code units; surrogate pairs must be combined into a single scalar value.\n\n`JSONUTF8StringFilter` is a small streaming filter that:\n\n- Accepts raw bytes (`push_back`) that may be part of a multi-byte UTF‑8 sequence.\n- Accepts UCS‑4 codepoints via `push_back_u` (often from decoded `\\uXXXX` sequences).\n- Combines surrogate pairs `(high, low)` into a single scalar value.\n- Tracks invalid sequences (bad continuation bytes, dangling surrogates, etc.).\n\n### Interface\n\n```rust\npub struct JSONUTF8StringFilter  {\n    str_:      Rc<RefCell<String>>,\n    is_valid:  bool,\n    codepoint: u32,\n    state:     u8,\n    surpair:   u32,\n}\n\nimpl JSONUTF8StringFilter {\n    pub fn new(target: Rc<RefCell<String>>) -> Self;\n\n    /// Finalise: no open sequences or surrogate pairs allowed.\n    pub fn finalize(&mut self) -> bool;\n\n    /// Feed a single UTF‑8 byte.\n    pub fn push_back(&mut self, ch: u8);\n\n    /// Feed a full UCS‑4 codepoint (e.g., from `\\uXXXX`).\n    pub fn push_back_u(&mut self, cp: u32);\n}\n```\n\nThis state machine is essentially a deterministic finite automaton over DFA states `(state, surpair)`, verifying that:\n\n- Every UTF‑8 multibyte sequence respects the `10xxxxxx` continuation rule.\n- Surrogate ranges `0xD800..=0xDFFF` are not emitted directly; instead, high/low pairs are combined into a scalar in the supplementary plane.\n- The filter ends in a quiescent state (`state == 0`, `surpair == 0`) before being considered valid.\n\n---\n\n## Canonical floating-point formatting\n\nBitcoin Core's JSON layer uses a special function `FormatSaferDouble` to avoid surprising rounding artifacts and to be stable across libc implementations. `bitcoin-univalue` reimplements this logic **bit-for-bit** as `UniValue::format_f64_canonical`.\n\n```rust\nimpl UniValue {\n    /// Canonical double formatting ported from Bitcoin Core.\n    pub fn format_f64_canonical(val: f64) -> String;\n}\n```\n\nAlgorithm sketch:\n\n1. Use **Ryu** to obtain the shortest finite representation: `short`.\n2. Normalise `short`:\n   - Strip a trailing `.0` unless the value is `0.0`.\n   - If there is no decimal point or an exponent, accept as-is.\n   - If there is a single decimal place and the value is exactly an integer × 0.10, pad a `0` to make two decimals (e.g. `-4.9` → `-4.90`).\n   - If there are more than 2 decimals, keep Ryu’s output as-is.\n3. For the remaining 2-decimal cases, build a `\"%#.17g\"` C-style representation using `libc::snprintf`.\n4. Emulate a **glibc quirk**: toggle the last digit `0 → 1` when doing so still round-trips exactly to the same IEEE-754 value. Keep that variant.\n\nMathematically, this aims at an injective map from finite `f64` to decimal strings (within the domain used by Bitcoin Core) that is **stable** across platforms, while avoiding spurious trailing zeros or unnecessary exponentials.\n\nThe crate's `set_float` method uses this canonical formatter:\n\n```rust\nimpl UniValue {\n    pub fn set_float(&mut self, val: f64) -> bool {\n        self.clear();\n        self.set_typ(uni_value::VType::VNUM);\n        self.set_val(Self::format_f64_canonical(val));\n        true\n    }\n}\n```\n\nThis is essential for deterministic signature payloads, regression testing, and any other application that persists or hashes the JSON textual form.\n\n---\n\n## Numeric parsing helpers\n\nThe crate includes strict numeric prechecks and convenience parsers.\n\n### `parse_prechecks`\n\n```rust\npub fn parse_prechecks(x: &str) -> bool;\n```\n\nChecks:\n\n- Non-empty input.\n- No leading or trailing JSON whitespace (`json_isspace`).\n- No embedded NUL (`\\0`) bytes.\n\nThis is used as a gate for `parse_double`, `parse_int32`, `parse_int64`, and JSON number string validation.\n\n### Integer and float parsing\n\n```rust\npub fn parse_double(x: &String, out: *mut f64) -> bool;\npub fn parse_int32(str_: &String, out: *mut i32) -> bool;\npub fn parse_int64(str_: &String, out: *mut i64) -> bool;\n```\n\nAll three functions:\n\n- Call `parse_prechecks` first.\n- Reject hexadecimal floats (`0x...`) for `parse_double`.\n- Use Rust’s `parse` and perform range checks for `parse_int32`.\n- Write into the raw pointer `out` when non-null (mirroring upstream C API style).\n\nUsing raw pointers allows matching the exact upstream function signatures and calling conventions from FFI or other low-level glue.\n\n---\n\n## Escape table generation utilities\n\nBitcoin Core historically generated a JSON escape lookup table at build time. In Rust, the table ships as a `const` array, but the generator is kept for compatibility and tests.\n\n### `generate_escapes_table`\n\n```rust\npub fn generate_escapes_table() -> String;\n```\n\nBuilds **Rust source code** for a `pub const escapes: [Option<&'static str>; 256]` table, mapping each byte (0–255) to either `None` or a JSON escape string.\n\n### `output_escape` and `univalue_gen_main`\n\n```rust\npub fn output_escape();\n\npub fn univalue_gen_main(_argc: i32, _argv: &[*mut u8]) -> i32;\n```\n\n- `output_escape` writes the generated table source to `stdout`.\n- `univalue_gen_main` is a legacy-style `main` function that calls `init_json_escape` and `output_escape` and returns `0`, preserving the original command-line tool behavior.\n\n### `init_json_escape`\n\n```rust\npub fn init_json_escape();\n```\n\nIn Bitcoin Core this performed expensive one-time table initialization. Here it is an idempotent no-op guarded with `Once`, retained only for API compatibility.\n\n---\n\n## Lookup helpers: `find_value` and `find_value_mut`\n\n```rust\npub fn find_value<'a>(obj: &'a UniValue, name: &'a str) -> &'a UniValue;\n\npub fn find_value_mut<'a>(obj: &'a mut UniValue, name: &'a str) -> &'a mut UniValue;\n```\n\nSemantics:\n\n- If `obj` is not an object, or the key is absent, they return a reference to `NULL_UNI_VALUE`.\n- `find_value_mut` uses `unsafe` to cast the immutable global `NULL_UNI_VALUE` to `&mut` when the key is absent, faithfully mirroring the C++ API that returns a mutable reference to a global **null** value.\n\n> This is intentionally unsafe; callers that mutate the returned null value must do so knowingly.\n\n---\n\n## Error type: `StdException`\n\n```rust\n#[derive(Debug, Clone)]\npub struct StdException(pub String);\n\nimpl std::fmt::Display for StdException { .. }\nimpl std::error::Error for StdException { }\n\npub fn runtime_error<T: Into<String>>(msg: T) -> StdException;\n```\n\n`StdException` is a lightweight stand-in for C++ `std::runtime_error`, allowing the crate to mirror the upstream exception-based API without committing to a broader error type hierarchy.\n\n---\n\n## Logging and tracing\n\nMany functions are annotated with `#[instrument]` and internally call `trace!` macros. These are typically supplied by the `tracing` ecosystem.\n\n- `#[instrument(level = \"trace\")]` decorates functions with structured spans, propagating arguments.\n- `trace!(...)` attaches key–value diagnostics to events.\n\nIn performance-sensitive deployments you can:\n\n- Configure global `tracing` filters to disable `trace`-level events.\n- Compile with features that disable logging in production builds, if provided by the surrounding crate workspace.\n\n---\n\n## Safety and invariants\n\n- Parsing via `read` and the numeric helpers requires valid memory passed as raw pointers.\n- Mutating the sentinel `NULL_UNI_VALUE` (reachable through `find_value_mut`) is undefined from an application-level semantics perspective, though allowed by the crate to preserve compatibility with the C++ interface.\n- Many getters panic on type mismatches, reflecting upstream behavior. Use type predicates or `check_object` for defensive programming.\n\nWhen integrating with consensus- or security-critical Bitcoin software, keep these invariants in mind and model-test any new code paths.\n\n---\n\n## Use cases\n\nTypical use cases for `bitcoin-univalue` include:\n\n- **Re-implementing Bitcoin Core RPCs in Rust**, while keeping response formatting byte-identical.\n- **Regression testing**: comparing Rust-generated JSON against reference Bitcoin Core outputs.\n- **Protocol conformance** tooling where JSON serialization must be canonical and stable across versions and platforms.\n\nFor general JSON work, `serde` + `serde_json` will usually be more ergonomic and feature-rich; `bitcoin-univalue` is specialized infrastructure.\n\n---\n\n## Repository, license, and edition\n\n- Crate: `bitcoin-univalue`\n- Version: `0.1.20`\n- License: MIT\n- Edition: Rust 2021\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\nThe crate is part of the wider `bitcoin-rs` effort to provide a faithful Rust translation of upstream Bitcoin Core.\n",
  "package_categories": [
    "cryptography",
    "network-programming",
    "parsing",
    "development-tools",
    "finance"
  ],
  "package_description": "Rust transcription of Bitcoin Core's UniValue JSON subsystem, providing a Bitcoin-compatible dynamic JSON value type, parser, and canonical number/UTF-8 handling for consensus- and RPC-related tooling.",
  "package_keywords": [
    "bitcoin",
    "json",
    "univalue",
    "rpc",
    "serialization"
  ]
}