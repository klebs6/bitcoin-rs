{
  "crate_name": "bitcoinleveldb-posixwfile",
  "full_readme_markdown": "# bitcoinleveldb-posixwfile\n\nA small, tightly scoped crate providing a POSIX-backed implementation of a LevelDB-style `WritableFile` for the Bitcoin-derived LevelDB port. It encapsulates buffered appends, durable syncing, and careful error handling on UNIX-like systems.\n\n> NOTE: This README was generated by an AI model and may not be 100% accurate, though it should be quite close to the intended behavior. Always consult the source for definitive semantics.\n\n---\n\n## Overview\n\n`bitcoinleveldb-posixwfile` implements a `PosixWritableFile` type that:\n\n- Wraps a Unix file descriptor (`fd: i32`) with a fixed-size write buffer.\n- Implements traits like `WritableFile`, `WritableFileAppend`, `WritableFileFlush`, `WritableFileSync`, and `WritableFileClose` used by the Bitcoin-flavored LevelDB core.\n- Uses low-level POSIX syscalls (`open`, `write`, `fsync` / `fdatasync`, `close`, `fcntl(F_FULLFSYNC)` on Apple targets) via `libc` for predictable behavior.\n- Differentiates manifest files (`MANIFEST*`) from regular files and applies Bitcoin/LevelDB’s durable-fsync discipline: syncing the directory containing the manifest before syncing the manifest itself.\n- Mirrors the semantics of the original C++ LevelDB/Bitcoin implementation as closely as possible, including treatment of error codes and destructor behavior.\n\nThis crate is intentionally minimal and low-level. It is not a general-purpose file API but a precise building block in the Bitcoin-leveldb storage stack, with durability and crash semantics tuned to LevelDB’s expectations.\n\n---\n\n## Core Data Structure: `PosixWritableFile`\n\n```rust\npub struct PosixWritableFile {\n    buf:           [u8; WRITABLE_FILE_BUFFER_SIZE],\n    pos:           usize,\n    fd:            i32,\n    is_manifest:   bool,\n    filename:      String,\n    dirname:       String,\n    ever_valid_fd: bool,\n}\n```\n\nKey invariants and behavior:\n\n- `buf` + `pos`: in-memory staging buffer for appends. Writes are batched to reduce syscall overhead and improve I/O throughput.\n- `fd`:\n  - If `fd >= 0`, the OS file descriptor is considered open and owned by this instance.\n  - If `fd < 0`, the descriptor is treated as closed. A negative descriptor that was once valid is handled idempotently on `close()`.\n- `ever_valid_fd` distinguishes \"never opened\" from \"already closed\"; this allows `close()` to return a realistic `EBADF`-style error when the file was never valid.\n- `is_manifest` and `dirname` are precomputed:\n  - `is_manifest` is true when the basename starts with `\"MANIFEST\"`.\n  - `dirname` holds the directory portion of `filename` (or `\".\"` if none).\n\nConstruction is explicit:\n\n```rust\nimpl PosixWritableFile {\n    pub fn new(filename: String, fd: i32) -> Self { /* ... */ }\n}\n```\n\n`new` does not open the file; the caller is responsible for obtaining an `fd` with the desired flags and mode. This separation keeps POSIX concerns localized and predictable.\n\n---\n\n## Buffering and Append Semantics\n\n### `WritableFileAppend` implementation\n\n```rust\nimpl WritableFileAppend for PosixWritableFile {\n    fn append(&mut self, data: &Slice) -> Status { /* ... */ }\n}\n```\n\nAlgorithm outline:\n\n1. Trivial case: zero-length appends immediately return `Status::ok()`.\n2. Fill remaining space in `buf` until either `data` is exhausted or the buffer becomes full.\n3. If all data fit, return `Ok` without a syscall (purely buffered).\n4. Otherwise, flush the current buffer (`flush_buffer()`). On error, propagate the `Status`.\n5. For remaining data:\n   - If `write_size < WRITABLE_FILE_BUFFER_SIZE`, copy into an empty buffer and return `Ok`.\n   - If `write_size >= WRITABLE_FILE_BUFFER_SIZE`, bypass the buffer and call `write_unbuffered` directly.\n\nThis strategy approximates a batching policy: many small appends are batched in memory; large writes do not incur extra buffering overhead.\n\n### `flush_buffer`\n\n```rust\nimpl PosixWritableFile {\n    pub fn flush_buffer(&mut self) -> crate::Status { /* ... */ }\n}\n\nimpl WritableFileFlush for PosixWritableFile {\n    fn flush(&mut self) -> crate::Status { self.flush_buffer() }\n}\n```\n\n- If `pos == 0`, it is a no-op and returns `Status::ok()`.\n- Otherwise, it calls `write_unbuffered` with the buffer content.\n- It **always** resets `pos` to 0, even if the underlying write fails, to match the C++ LevelDB semantics.\n\n### `write_unbuffered`\n\n```rust\nimpl PosixWritableFile {\n    pub fn write_unbuffered(&mut self, data: *const u8, size: usize) -> crate::Status { /* ... */ }\n}\n```\n\nLow-level loop:\n\n- Calls `libc::write(fd, data, size)` repeatedly until all bytes are written.\n- Handles partial writes by advancing `data` and decreasing `size`.\n- On `EINTR`, logs and retries.\n- On other errors, converts the OS error into a `Status` via `posix_error` and returns immediately.\n\nThis design ensures that higher layers see a simple all-or-error contract, hiding the complexities of partial POSIX writes.\n\n---\n\n## Durability, Syncing, and Manifest Directories\n\nDurability semantics are vital for LevelDB’s correctness under power loss. This crate implements a conservative, Bitcoin-inspired policy.\n\n### `sync_fd`\n\n```rust\nimpl PosixWritableFile {\n    pub fn sync_fd(fd: i32, fd_path: &String, syncing_dir: bool) -> crate::Status { /* ... */ }\n}\n```\n\nBehavior:\n\n1. On macOS / iOS\n   - Try `fcntl(fd, F_FULLFSYNC)` first, which provides stronger guarantees than `fsync()` with respect to power failures.\n   - On success, return `Status::ok()`.\n2. On other platforms\n   - Prefer `fdatasync` where available (Linux, *BSD, Android) for metadata-light syncing.\n   - Fall back to `fsync` when `fdatasync` is not available.\n3. On success (`sync_result == 0`), return `Status::ok()`.\n4. On error\n   - Extract `errno`. If `syncing_dir == true` and `errno == EINVAL`, treat it as a **non-fatal** success. Some filesystems do not support directory fsync; Bitcoin explicitly tolerates this.\n   - Otherwise, log and return an error `Status` via `posix_error(fd_path, err)`.\n\nThis function centralizes platform-conditional behavior and error normalization.\n\n### `sync_dir_if_manifest`\n\n```rust\nimpl PosixWritableFile {\n    pub fn sync_dir_if_manifest(&mut self) -> crate::Status { /* ... */ }\n}\n```\n\n- If `!is_manifest`, it returns `Status::ok()` without making syscalls.\n- For manifest files:\n  1. Convert `dirname` to `CString`. If the directory name contains an embedded NUL, return `io_error` with a descriptive message.\n  2. Open the directory with `open(dir, O_RDONLY)`.\n  3. On success, call `sync_fd(dir_fd, dirname, true)` and then `close(dir_fd)`.\n  4. On failure to open, convert `errno` into a `Status` via `posix_error`.\n\nThis mirrors Bitcoin’s strategy: ensure that directory entries referencing newly created files are durable before the manifest referencing them is considered persistent.\n\n### `sync`\n\n```rust\nimpl WritableFileSync for PosixWritableFile {\n    fn sync(&mut self) -> crate::Status { /* ... */ }\n}\n\n// Rough order of operations inside sync():\n// 1. sync_dir_if_manifest();\n// 2. flush_buffer();\n// 3. sync_fd(fd, filename, false);\n```\n\n- For manifest files, syncs the parent directory first.\n- Flushes any buffered data to the OS via `flush_buffer()`.\n- Performs the final durable sync via `sync_fd` on the file descriptor itself.\n\nThe sequencing is deliberate: LevelDB’s metadata consistency and recovery logic assume that files referenced by the manifest are already on disk by the time the manifest is reported as synced.\n\n---\n\n## Closing and Drop Semantics\n\n### `close`\n\n```rust\nimpl WritableFileClose for PosixWritableFile {\n    fn close(&mut self) -> Status { /* ... */ }\n}\n```\n\nBehavior:\n\n- If `fd < 0`:\n  - If `ever_valid_fd` is true, treat this as a no-op, returning `Status::ok()` (idempotent close).\n  - Otherwise, behave like `close(-1)` would and return an `EBADF`-style error using `posix_error`.\n- If `fd >= 0`:\n  1. Call `flush_buffer()` first.\n  2. Call `libc::close(fd)`.\n  3. If `close()` fails and the flush was successful, propagate the close error as `Status`.\n  4. Set `fd` to `-1` regardless of error, reflecting ownership transfer back to the OS.\n\nThis yields a pragmatic mix of realism (EBADF when the file was never valid) and ergonomic idempotence (multiple `close()` calls on a previously valid file are safe).\n\n### `Drop` implementation\n\n```rust\nimpl Drop for PosixWritableFile {\n    fn drop(&mut self) {\n        if *self.fd() >= 0 {\n            let _ = self.close();\n        }\n    }\n}\n```\n\n- If `fd >= 0`, `drop` calls `close()` and discards any resulting `Status`.\n- If `fd < 0`, it simply logs that the fd is already closed.\n\nThis mirrors the C++ LevelDB destructor: best-effort closure on drop, with errors only observable if you call `close()` explicitly.\n\n---\n\n## Path Utilities\n\n`PosixWritableFile` includes static helpers for file path analysis:\n\n### `dirname_static`\n\n```rust\nimpl PosixWritableFile {\n    pub fn dirname_static(filename: &String) -> String { /* ... */ }\n}\n```\n\n- Returns the directory component of `filename` using the last `'/'`.\n- If no `'/'` is found, returns `\".\"`.\n- Includes an internal `debug_assert!` that the basename does not itself contain `/`.\n\n### `basename`\n\n```rust\nimpl PosixWritableFile {\n    pub fn basename(filename: &String) -> Slice { /* ... */ }\n}\n```\n\n- Returns a `Slice` pointing into the original string’s buffer.\n- If a `/` exists, it returns the substring after the final slash as a borrowed slice.\n- If no `/` is found, returns a slice over the entire filename.\n- The lifetime ties directly to the `filename` value; callers must ensure the string outlives the `Slice` use.\n\n### `is_manifest_static`\n\n```rust\nimpl PosixWritableFile {\n    pub fn is_manifest_static(filename: &String) -> bool { /* ... */ }\n}\n```\n\n- Uses `basename` to obtain the last path component.\n- Interprets any basename starting with `\"MANIFEST\"` as a manifest file.\n- This classification is used internally to determine whether to sync the containing directory in `sync_dir_if_manifest`.\n\n---\n\n## Logging and Diagnostics\n\nThroughout the implementation, logging macros such as `trace!` and `debug!` are invoked to record:\n\n- File names, directory names, and file descriptors.\n- Entry/exit points of critical methods (`append`, `flush_buffer`, `write_unbuffered`, `sync`, `close`, `drop`).\n- System call outcomes and OS error codes.\n\nThis crate assumes a logging facade compatible with those macros (e.g., `tracing`). When integrated with the rest of the `bitcoinleveldb` ecosystem, these logs provide high-resolution introspection of I/O behavior under load and during error conditions.\n\n---\n\n## Integration Expectations\n\nThis crate is designed to be used as part of a larger `bitcoinleveldb` workspace or dependency graph. Typical integration points include:\n\n- Plugging `PosixWritableFile` into a higher-level environment or factory that returns concrete `WritableFile` trait objects to LevelDB’s table and log writers.\n- Passing a pre-opened file descriptor for new files; for example, using `libc::open` or Rust’s `std::os::fd::AsRawFd` interfaces from higher layers, then wrapping that descriptor in `PosixWritableFile::new`.\n- Letting the rest of the LevelDB logic call `append`, `flush`, `sync`, and `close` following LevelDB’s state machine.\n\nThe provided behavior is intentionally conservative: it may favor correctness and persistence guarantees over absolute peak throughput.\n\n---\n\n## Safety and `unsafe` Usage\n\nThe implementation uses `unsafe` blocks for:\n\n- Raw pointer arithmetic during buffer copies.\n- Exposing string data as raw pointers (`Slice::from_ptr_len`).\n- FFI calls into `libc` (`open`, `write`, `fsync`, `fdatasync`, `fcntl`, `close`).\n\nThese usages are localized and guarded by consistent invariants:\n\n- Buffer operations respect bounds via explicit size computations.\n- Loops over `write` errors treat `EINTR` as retryable.\n- All C string interactions ensure NUL termination and report errors if an input path contains internal NULs.\n\nConsumers of the crate interact through safe Rust APIs (`append`, `flush`, `sync`, `close`) and do not need to touch the underlying unsafe elements.\n\n---\n\n## Example (Conceptual)\n\nBelow is a schematic example. Exact types like `Slice`, `Status`, and various `WritableFile*` traits come from the surrounding `bitcoinleveldb` ecosystem and are not redefined here.\n\n```rust\nuse bitcoinleveldb_posixwfile::PosixWritableFile;\nuse bitcoinleveldb_core::{Slice, Status};\nuse std::ffi::CString;\n\nfn open_posix_writable(path: &str) -> Status { // pseudo-signature\n    let c_path = CString::new(path).unwrap();\n    let fd = unsafe { libc::open(c_path.as_ptr(), libc::O_CREAT | libc::O_WRONLY, 0o644) };\n    if fd < 0 {\n        // convert to Status via posix_error in the real integration\n        unimplemented!();\n    }\n\n    let mut wf = PosixWritableFile::new(path.to_string(), fd);\n\n    let data = Slice::from(\"hello world\");\n    wf.append(&data)?;\n    wf.sync()?;\n    wf.close()?;\n\n    Ok(())\n}\n```\n\nIn a real system the `Status` type provides rich error reporting and the traits allow polymorphic substitution of other `WritableFile` backends (e.g., in-memory or testing variants).\n\n---\n\n## Crate Metadata\n\n- **Name:** `bitcoinleveldb-posixwfile`\n- **Version:** `0.1.1`\n- **Edition:** `2024`\n- **License:** MIT\n- **Intended platforms:** POSIX-style systems (Linux, *BSD, macOS, iOS, Android, etc.) with a `libc`-compatible C library.\n\n---\n\n## Reliability Considerations\n\nThis crate exists to deliver robust on-disk behavior under adverse conditions:\n\n- Power-loss durability is emphasized via `fsync`/`fdatasync` and `F_FULLFSYNC` (where available).\n- Certain filesystem idiosyncrasies, specifically directory `fsync` returning `EINVAL`, are tolerated in a manner consistent with Bitcoin Core.\n- Error reporting attempts to be explicit and structured via the `Status` type rather than panicking.\n\nSystems relying on Bitcoin-leveldb can use this component as the final stage of their persistence pipeline, trusting that it adheres to the same invariants as the C++ implementation it mirrors.\n",
  "package_categories": [
    "database",
    "database-implementations",
    "filesystem",
    "science",
    "development-tools"
  ],
  "package_description": "POSIX-backed implementation of a buffered, durable LevelDB-style WritableFile for the Bitcoin-leveldb stack, using libc syscalls for append, flush, sync, and close with manifest-aware directory syncing.",
  "package_keywords": [
    "bitcoin",
    "leveldb",
    "posix",
    "filesystem",
    "storage"
  ]
}