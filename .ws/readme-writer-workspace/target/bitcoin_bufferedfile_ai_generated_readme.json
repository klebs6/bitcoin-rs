{
  "crate_name": "bitcoin-bufferedfile",
  "full_readme_markdown": "# bitcoin-bufferedfile\n\nHigh‑performance, C‑compatible, rewindable buffered reader for `FILE*` streams, modeled on Bitcoin Core's `BufferedFile`. Provides deterministic RAII semantics, fixed‑capacity ring buffering, and a trait‑based deserialization interface suitable for consensus‑critical binary formats.\n\n> **Note**: This README was generated by an AI model. It may contain minor inaccuracies, but it aims to be a faithful and practically useful description of the crate.\n\n---\n\n## Overview\n\n`bitcoin-bufferedfile` exposes a low‑level primitive, [`BufferedFile`], that wraps a raw `*mut libc::FILE` and presents a logically linear byte stream backed by a circular buffer with a configurable rewind window.\n\nThis design allows you to:\n\n- Perform streaming reads from large files without unbounded memory growth.\n- Rewind the stream by a bounded amount without re‑seeking the OS file descriptor.\n- Precisely control error semantics: most failures are treated as logic errors and result in panics with clear diagnostics, matching the expectations of consensus validation code.\n- Integrate with higher‑level, type‑driven deserialization logic via the [`BufferedFileReadable`] trait and the `>>` operator (via `Shr`).\n\nThe crate is deliberately stringent: it prefers to panic rather than silently continue on I/O failure, end‑of‑file, or logical mis‑use (e.g., reading past an explicit limit). This mirrors C++ Bitcoin Core semantics where such violations indicate bugs in the higher‑level protocol code rather than routine recoverable errors.\n\n---\n\n## Core Concepts\n\n### Circular buffer and rewind window\n\n`BufferedFile` maintains:\n\n- A fixed‑size byte buffer `vch_buf`.\n- A **source position** `n_src_pos`: total bytes pulled from the underlying `FILE*` into the buffer.\n- A **read position** `n_read_pos`: logical cursor indicating how many bytes have been consumed.\n- A **rewind budget** `n_rewind`: maximum number of bytes by which reads are permitted to move backwards, implicitly enforced by the buffer size.\n\nThe buffer is indexed by `n_src_pos % buf_len` and `n_read_pos % buf_len`, turning it into a ring (circular) buffer. The invariant `n_src_pos - n_read_pos <= buf_len - n_rewind` ensures that the last `n_rewind` bytes are always available for rewinding without being overwritten by new data.\n\nThis is materially different from `BufReader`: the buffer is not merely an optimization but also encodes *how much history you may rely on*. Attempting to \"rewind\" beyond what the buffer can retain will clamp to the earliest feasible position.\n\n### RAII and FILE* ownership\n\n`BufferedFile` owns a `*mut libc::FILE` and guarantees:\n\n- Automatic `fclose` on `Drop` if the pointer is still non‑null.\n- A safe manual close via [`fclose`](#explicitly-closing-the-file), which nulls out the pointer to preclude double close.\n\nThis makes it straightforward to interoperate with C APIs (including those from Bitcoin Core) that hand out raw `FILE*` handles, while still providing Rust‑style lifetime semantics.\n\n### Type‑driven deserialization\n\nThe trait:\n\n```rust\npub trait BufferedFileReadable {\n    fn read_from_buffer(stream: &mut BufferedFile, out: &mut Self);\n}\n```\n\nabstracts over *how* a type `T` should be read from a `BufferedFile`. Implementors consume bytes from the stream and populate `out`, leaving `stream` positioned *just after* the reading. The trait is intentionally minimal to allow:\n\n- Blanket derives in other crates for simple data structures.\n- Hand‑written implementations for consensus‑critical or bit‑level encodings.\n\nThe crate also implements the right‑shift operator `>>` for ergonomic chaining:\n\n```rust\nimpl<T: BufferedFileReadable> Shr<&mut T> for BufferedFile {\n    type Output = Self;\n\n    fn shr(mut self, rhs: &mut T) -> Self::Output {\n        T::read_from_buffer(&mut self, rhs);\n        self\n    }\n}\n```\n\nThis lets you write C++‑style extraction code:\n\n```rust\n// pseudocode-style usage\nbuffered_file >> &mut header >> &mut payload >> &mut trailer;\n```\n\nwithout exposing the internal reading machinery in user code.\n\n---\n\n## Usage\n\n### Constructing a `BufferedFile`\n\nYou typically start from some external `FILE*` (for example, produced in FFI code or via `libc::fopen`):\n\n```rust\nuse bitcoin_bufferedfile::BufferedFile;\nuse std::ffi::CString;\n\nfn open_buffered(path: &str) -> BufferedFile {\n    let c_path = CString::new(path).expect(\"no interior NULs\");\n\n    let mode   = CString::new(\"rb\").unwrap();\n    let file = unsafe { libc::fopen(c_path.as_ptr(), mode.as_ptr()) };\n    if file.is_null() {\n        panic!(\"unable to open file: {path}\");\n    }\n\n    // buffer size and rewind budget in bytes\n    let buf_size   = 1 << 16;   // 64 KiB\n    let rewind     = 1 << 14;   // 16 KiB of rewind\n    let n_type     = 0;         // application-specific\n    let n_version  = 0;         // application-specific\n\n    BufferedFile::new(file, buf_size, rewind, n_type, n_version)\n}\n```\n\nRequirements:\n\n- `n_rewind_in < n_buf_size`. Violating this will panic on construction.\n- `file_in` must be a valid, open `FILE*`. `BufferedFile` does not perform ownership analysis; it assumes exclusive ownership for the purposes of `fclose`.\n\n### Reading raw bytes\n\nTo pull raw bytes into a caller‑provided buffer:\n\n```rust\nlet mut bf   = open_buffered(\"blocks.dat\");\nlet mut buf  = [0u8; 80]; // e.g., read a Bitcoin block header\n\n// Panics if EOF is reached before 80 bytes or if limit is exceeded\nbf.read(buf.as_mut_ptr(), buf.len());\n\n// Position has advanced by 80 bytes\nlet pos = bf.get_pos();\nprintln!(\"current position: {pos}\");\n```\n\nSemantics:\n\n- `read` will keep refilling the internal buffer until either `n_size` bytes have been copied or the underlying file cannot supply more (EOF or error).\n- If the current read position + requested size exceeds `n_read_limit`, the call panics.\n- On encountering EOF before satisfying `n_size`, the call panics with a diagnostic.\n\n### Rewinding and positioning\n\n`BufferedFile` does not expose a direct \"rewind by N\" function but allows you to set the absolute logical position, subject to the constraints of the ring buffer.\n\n```rust\nlet mut bf = open_buffered(\"blocks.dat\");\n\n// ... perform some reads ...\nlet checkpoint = bf.get_pos();\n\n// read some speculative data\nlet mut tmp = [0u8; 16];\nbf.read(tmp.as_mut_ptr(), tmp.len());\n\n// Try to return to the checkpoint\nlet ok = bf.set_pos(checkpoint);\nif !ok {\n    // the requested position was outside the maintainable window\n    // the stream has been clamped to the earliest feasible position\n    eprintln!(\"checkpoint outside rewind window; position clamped\");\n}\n```\n\n`set_pos` behavior:\n\n- If `n_pos + bufsize < n_src_pos`, the position is *too far back* to be fully represented by the current buffer contents; it clamps to `n_src_pos - bufsize` and returns `false`.\n- If `n_pos > n_src_pos`, the position is *too far forward*; it clamps to `n_src_pos` and returns `false`.\n- Otherwise, it sets `n_read_pos = n_pos` and returns `true`.\n\nThis gives you a robust mechanism to implement limited backtracking parsers where the maximum rollback distance is bounded and known a priori.\n\n### Limiting the readable region\n\nYou can impose a hard upper bound on the logical read position:\n\n```rust\nlet mut bf = open_buffered(\"blocks.dat\");\n\n// allow reading only the first 1 MiB\nlet ok = bf.set_limit(Some(1 << 20));\nassert!(ok);\n\n// remove any explicit limit\nlet _ = bf.set_limit(None);\n```\n\nProperties:\n\n- A limit smaller than the current read position is rejected: `set_limit` returns `false` and leaves the limit unchanged. This protects against nonsensical configurations such as retroactively forbidding already‑performed reads.\n- `read` will panic if a requested read would cross the limit.\n\nThis is particularly useful in protocol code where a message length is read from the wire and then used to bound the subsequent parsing logic.\n\n### Searching for a byte\n\n`find_byte` scans forward until a target byte is encountered:\n\n```rust\nlet mut bf = open_buffered(\"log.bin\");\n\n// search for newline\nbf.find_byte(b'\\n');\nlet newline_pos = bf.get_pos();\nprintln!(\"found newline at {newline_pos}\");\n```\n\nDetails:\n\n- The read pointer ends **on** the matching byte (i.e., `get_pos()` returns the index of `ch`).\n- `fill` is called as needed; failures propagate as panics.\n- If EOF is reached without finding the target byte, the function panics.\n\nThis provides a primitive for delimiter‑based framing without needing to materialize the entire preceding data.\n\n### EOF detection\n\nYou can query whether the stream is at EOF:\n\n```rust\nif bf.eof() {\n    // both the buffer is exhausted and the underlying FILE* reports EOF\n}\n```\n\n`eof()` returns `true` *only* if:\n\n- `n_read_pos == n_src_pos` (no buffered unread bytes), and\n- `feof(src) != 0` (the underlying C stream is at EOF).\n\n---\n\n## Integrating `BufferedFileReadable`\n\nTo leverage the ergonomic `>>` operator and type‑driven parsing, implement `BufferedFileReadable` for your types.\n\n### Example: reading a fixed‑layout struct\n\nSuppose you have a simple header format:\n\n```rust\n#[derive(Debug, Default)]\nstruct Header {\n    magic: u32,\n    version: u32,\n}\n```\n\nYou can implement `BufferedFileReadable` manually:\n\n```rust\nuse bitcoin_bufferedfile::BufferedFile;\nuse bitcoin_bufferedfile::BufferedFileReadable;\nuse std::mem::size_of;\n\nimpl BufferedFileReadable for Header {\n    fn read_from_buffer(stream: &mut BufferedFile, out: &mut Self) {\n        unsafe {\n            // read magic (little-endian assumed as example)\n            let mut buf = [0u8; size_of::<u32>()];\n            stream.read(buf.as_mut_ptr(), buf.len());\n            out.magic = u32::from_le_bytes(buf);\n\n            // read version\n            let mut buf = [0u8; size_of::<u32>()];\n            stream.read(buf.as_mut_ptr(), buf.len());\n            out.version = u32::from_le_bytes(buf);\n        }\n    }\n}\n```\n\nNow you can consume a `Header` from a `BufferedFile` via the shift operator:\n\n```rust\nuse std::ops::Shr;\n\nlet mut bf      = open_buffered(\"header.bin\");\nlet mut header  = Header::default();\n\n// bf >> &mut header consumes bytes and leaves bf advanced\nbf = bf.shr(&mut header);\nprintln!(\"parsed header: {header:?}\");\n```\n\nContract for `BufferedFileReadable::read_from_buffer`:\n\n- **Must** advance the stream to just after the consumed object.\n- **Must not** attempt to read beyond `n_read_limit`; if it does, a panic will occur inside `read`.\n- On encountering malformed data, it is acceptable to panic or to encode an error state into `out`, depending on higher‑level design. The crate itself is agnostic.\n\n### Relationship to Bitcoin serialization\n\nIn the original Bitcoin Core codebase, `CBufferedFile` is used in conjunction with `Unserialize(Stream&, T&)` free functions. This crate exposes the minimal machinery required to port that pattern into Rust:\n\n- `BufferedFile` as the low‑level `Stream`.\n- `BufferedFileReadable::read_from_buffer` as the trait‑based analog of `Unserialize`.\n- `Shr` implementation to preserve the extraction syntax idiom.\n\nThis makes the crate particularly suitable for projects that:\n\n- Reuse Bitcoin Core's on‑disk or on‑wire formats.\n- Need behaviorally faithful reimplementations for consensus‑sensitive code.\n\n---\n\n## Error Model\n\nThe crate intentionally uses panics to signal conditions that, in the context of consensus code, are programmer errors or fatal I/O failures:\n\n- **Construction**: `BufferedFile::new` panics if `n_rewind_in >= n_buf_size`.\n- **fill**: panics if `fread` returns 0 and either EOF is reached or the call fails.\n- **read**: panics if a read attempts to cross `n_read_limit` or if EOF occurs before all requested bytes are read.\n- **find_byte**: panics if the target byte is not found before EOF.\n\nAll such panics are accompanied by `tracing` diagnostics (`error`, `warn`, `trace`, `debug`), enabling you to capture structured logs in production deployments.\n\nIf you require a fully fallible API (returning `Result` instead of panicking), you can build a thin wrapper around `BufferedFile` that:\n\n- Catches panics at the FFI boundary or at top‑level worker threads.\n- Encodes error causes using your project's error type.\n\nHowever, for environments mirroring Bitcoin Core's expectations—where data corruption or I/O failures are terminal—panicking is an adequate and simpler model.\n\n---\n\n## Logging and Observability\n\nThe crate uses the `tracing` ecosystem for diagnostics. Log statements include structured fields such as positions, limits, and buffer capacities:\n\n- `trace!` for high‑frequency events like buffer refills and reads.\n- `debug!` for state transitions like `set_pos` and `fclose`.\n- `warn!` for non‑fatal misconfigurations (e.g., invalid `set_limit` attempts).\n- `error!` for conditions that immediately precede panics.\n\nTo take advantage of this, initialize a subscriber in your application, for example using `tracing-subscriber` in `main`:\n\n```rust\nfn main() {\n    use tracing_subscriber::FmtSubscriber;\n\n    let subscriber = FmtSubscriber::builder()\n        .with_max_level(tracing::Level::TRACE)\n        .finish();\n\n    tracing::subscriber::set_global_default(subscriber)\n        .expect(\"setting tracing default failed\");\n\n    // now use bitcoin-bufferedfile APIs as usual\n}\n```\n\n---\n\n## Safety Considerations\n\n`BufferedFile` is explicitly low‑level and interacts with raw pointers and C APIs. The crate confines `unsafe` to its implementation, but consumers must still respect its contracts:\n\n- The `FILE*` passed to `BufferedFile::new` must not be used elsewhere while the `BufferedFile` exists, to avoid data races and double closes.\n- The lifetime of the underlying file must extend across all operations on the `BufferedFile` (this is enforced in practice by RAII, given correct ownership transfer).\n- When using `read` directly, you are responsible for ensuring that `pch` points to a valid, writable region of at least `n_size` bytes.\n\nIf you stay at the level of `BufferedFileReadable` implementations and slice‑based reading, the primary risk vectors are logical (e.g., misinterpreting on‑disk formats) rather than memory safety violations.\n\n---\n\n## Relationship to the `bitcoin-rs` Workspace\n\nThis crate lives in the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) repository and is designed to be used as an internal building block for a larger ecosystem of Bitcoin‑related crates. It focuses narrowly on faithfully replicating the semantics of Bitcoin Core's buffered file abstraction, rather than trying to provide a general‑purpose Rust I/O layer.\n\nUpstream crates in the workspace typically provide:\n\n- Higher‑level consensus and P2P message parsing.\n- Derives and utilities that implement `BufferedFileReadable` (and related traits) for Bitcoin primitives.\n- Ergonomic, strongly typed frontends that avoid direct exposure of `FILE*` and unsafe APIs.\n\nYou can, however, use `bitcoin-bufferedfile` independently in other projects that require C‑compatible, rewind‑capable buffered reading of binary data.\n\n---\n\n## License\n\nThis crate is distributed under the MIT license, as part of the `bitcoin-rs` repository.\n\nSee the repository for full license text and additional context:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n",
  "package_categories": [
    "filesystem",
    "network-programming",
    "parser-implementations",
    "parsing",
    "development-tools"
  ],
  "package_description": "RAII wrapper around a C FILE* providing a rewindable, ring-buffered binary input stream with strict panic-on-error semantics and a trait-based deserialization interface modeled on Bitcoin Core's BufferedFile.",
  "package_keywords": [
    "bitcoin",
    "bufferedfile",
    "ffi",
    "serialization",
    "io"
  ]
}