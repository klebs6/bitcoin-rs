{
  "crate_name": "bitcoinleveldb-histogram",
  "full_readme_markdown": "# bitcoinleveldb-histogram\n\nFast, deterministic histogram statistics for Bitcoin-leveldb style latency and value distributions.\n\nThis crate provides a faithful Rust implementation of the histogram used inside LevelDB, adapted for the `bitcoinleveldb` subsystem of [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs). It is designed for profiling and characterizing distributions (e.g., operation latencies, sizes, or fees) with negligible runtime overhead and a compact internal representation.\n\n⚠️ **Note:** This README was generated by an AI model based on the exposed interface. It may not perfectly describe every behavior or edge case, but it should be a close approximation.\n\n---\n\n## Features\n\n- Fixed-bucket histogram with `HISTOGRAM_NUM_BUCKETS` logarithmically (LevelDB-style) spaced bucket limits `BUCKET_LIMIT`.\n- Online accumulation of statistics:\n  - `min`, `max`\n  - sample count `num`\n  - linear sum `sum`\n  - quadratic sum `sum_squares`\n- Derived statistics without storing raw samples:\n  - arithmetic mean (average)\n  - standard deviation\n  - median\n  - arbitrary percentile\n- Deterministic merge of histograms without re-processing samples.\n- Human-readable ASCII representation suitable for logs.\n- `no_std`-friendly core (uses `core::fmt::Write`), with logging controlled by the caller's logging setup.\n\nThe design is suitable for high-throughput systems where allocating or storing all samples is undesirable. The histogram approximates the distribution using bucket counts and pre-defined bucket limits, providing excellent tradeoffs between precision, memory, and CPU cost.\n\n---\n\n## Data model\n\n```rust\npub struct Histogram {\n    min:         f64,\n    max:         f64,\n    num:         f64,\n    sum:         f64,\n    sum_squares: f64,\n    buckets:     [f64; HISTOGRAM_NUM_BUCKETS],\n}\n```\n\nSemantics:\n\n- **`min`, `max`**: Smallest and largest sample ever added. When empty, `min` is initialized to the largest bucket limit and `max` is `0.0`.\n- **`num`**: Total number of samples (as `f64` to match LevelDB and simplify arithmetic with large counts).\n- **`sum`**: Sum of all values.\n- **`sum_squares`**: Sum of squares of all values, enabling variance computation without storing samples.\n- **`buckets`**: Per-bucket counts; bucket boundaries are provided by `BUCKET_LIMIT` and follow LevelDB.\n\nThis is an **online algorithm**: each `add` call updates all sufficient statistics in O(number_of_buckets) worst-case for bucketing (linear scan) but typically small constant time, and O(1) for the other aggregates.\n\nThe standard deviation implementation uses the identity:\n\n\\[\n\\operatorname{Var}(X) = E[X^2] - (E[X])^2\n\\]\n\nwith\n\n\\[\nE[X] = \\frac{\\text{sum}}{\\text{num}},\\quad E[X^2] = \\frac{\\text{sum\\_squares}}{\\text{num}}\n\\]\n\nand guarded against small negative values from floating-point error.\n\n---\n\n## Basic usage\n\nAdd this crate to your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoinleveldb-histogram = \"0.1.19\"\n```\n\nCreate a histogram and feed samples:\n\n```rust\nuse bitcoinleveldb_histogram::Histogram;\n\nfn main() {\n    let mut h = Histogram::default();\n\n    // Simulate some latency / cost data\n    for value in [1.0, 5.0, 10.0, 10.0, 100.0] {\n        h.add(value);\n    }\n\n    println!(\"count = {}\", h.num);\n    println!(\"min   = {}\", h.min);\n    println!(\"max   = {}\", h.max);\n    println!(\"avg   = {}\", h.average());\n    println!(\"p50   = {}\", h.median());\n    println!(\"p99   = {}\", h.percentile(99.0));\n    println!(\"std   = {}\", h.standard_deviation());\n\n    // Pretty ASCII representation, similar to LevelDB output\n    println!(\"{}\", h.to_string());\n}\n```\n\nExample output (shape only, exact values depend on bucket configuration):\n\n```text\nCount: 5  Average: 25.2000  StdDev: 38.42\nMin: 1.0000  Median: 10.0000  Max: 100.0000\n------------------------------------------------------\n[       0,       1 )       0   0.000%   0.000% \n[       1,      10 )       2  40.000%  40.000% ########\n[      10,     100 )       2  40.000%  80.000% ########\n[     100,    1000 )       1  20.000% 100.000% ####\n```\n\n---\n\n## Operations\n\n### Construction and reset\n\n```rust\nimpl Default for Histogram {\n    fn default() -> Self;\n}\n\nimpl Histogram {\n    pub fn clear(&mut self);\n}\n```\n\n- `Histogram::default()` initializes an **empty** histogram: internal counters zeroed, `min` set to the largest bucket limit, `max` to `0.0`.\n- `clear()` resets the histogram to this empty state, retaining the allocated bucket array.\n\n### Adding samples\n\n```rust\nimpl Histogram {\n    pub fn add(&mut self, value: f64);\n}\n```\n\n- Performs a linear search over `BUCKET_LIMIT` to locate the bucket index `b` whose range contains `value`.\n- Increments `buckets[b]`.\n- Updates `min`, `max`, `num`, `sum`, and `sum_squares`.\n\nThe linear search mirrors LevelDB: the bucket count is small and the branch-predictable loop is faster than a generic binary search for the typical usage patterns.\n\n### Merging histograms\n\n```rust\nimpl Histogram {\n    pub fn merge(&mut self, other: &Histogram);\n}\n```\n\n- Component-wise aggregation of sufficient statistics:\n  - `num += other.num`\n  - `sum += other.sum`\n  - `sum_squares += other.sum_squares`\n  - per-bucket addition: `self.buckets[i] += other.buckets[i]`\n- `min`/`max` combined as the global extrema across both histograms.\n- If `other.num == 0.0`, merge is a no-op.\n\nThis makes histogram aggregation trivial in multi-threaded systems: each worker thread can maintain its own `Histogram`, then a coordinator merges them at the end, approximating the global distribution with no raw data transfer.\n\n### Descriptive statistics\n\n```rust\nimpl Histogram {\n    pub fn median(&self) -> f64;\n    pub fn percentile(&self, p: f64) -> f64;\n    pub fn average(&self) -> f64;\n    pub fn standard_deviation(&self) -> f64;\n}\n```\n\n#### Average\n\n- If `num == 0.0`, returns `0.0`.\n- Otherwise `sum / num`.\n\n#### Standard deviation\n\n- If `num == 0.0`, returns `0.0`.\n- Uses the `E[X^2] - (E[X])^2` identity (see above).\n- Clamps negative variance from floating-point error to `0.0` before `sqrt`.\n\nMathematically, this computes the **population** standard deviation, not the Bessel-corrected sample standard deviation.\n\n#### Percentile & median\n\n- `median()` is a shorthand for `percentile(50.0)`.\n- `percentile(p)`:\n  - Returns `0.0` if `num <= 0.0`.\n  - Clamps `p` to `[0.0, 100.0]`.\n  - Finds the first bucket where the cumulative count crosses `threshold = num * (p / 100.0)`.\n  - Linearly interpolates inside that bucket based on position within its count range.\n  - Clamps the interpolated value to `[min, max]` to avoid leaking outside the observed range.\n  - If no bucket crosses the threshold due to numerical edge cases, falls back to `max`.\n\nThus percentiles are approximated from the histogram. When bucket spacing is logarithmic, lower percentiles are more precise for small values; higher percentiles focus resolution where buckets are dense.\n\n### String representation\n\n```rust\nimpl Histogram {\n    pub fn to_string(&self) -> String;\n}\n```\n\n`to_string()` produces a compact text summary plus an ASCII-art visualization:\n\n- Header line with `Count`, `Average`, and `StdDev`.\n- Second line with `Min`, `Median`, and `Max`.\n- A row per non-empty bucket:\n  - Half-open interval `[left, right)`.\n  - Absolute count in that bucket.\n  - Bucket-local percentage of total.\n  - Cumulative percentage up to and including that bucket.\n  - A bar of `#` characters (20 total marks correspond to 100% of the distribution in a single bucket).\n\nThis representation is intended for logs and interactive diagnostics.\n\n---\n\n## Logging behavior\n\nThe crate uses logging macros (e.g., `trace!`, `debug!`, `warn!`) to expose internal events and edge cases:\n\n- `trace!` at entry/exit of methods, and for detailed computation steps.\n- `debug!` for noteworthy but non-fatal situations (e.g., percentile on empty histogram).\n- `warn!` if a percentile outside `[0,100]` is requested.\n\nExact logging backend configuration is left to the embedding application; if no logger is configured, logs will be ignored as usual.\n\n---\n\n## Integration examples\n\n### Profiling latency in a storage engine\n\n```rust\nuse bitcoinleveldb_histogram::Histogram;\nuse std::time::{Duration, Instant};\n\nfn profile_ops<F: Fn()>(iterations: usize, op: F) -> Histogram {\n    let mut h = Histogram::default();\n\n    for _ in 0..iterations {\n        let start = Instant::now();\n        op();\n        let elapsed = start.elapsed();\n        let micros = elapsed.as_secs_f64() * 1_000_000.0;\n        h.add(micros);\n    }\n\n    h\n}\n\nfn main() {\n    let histogram = profile_ops(10_000, || {\n        // your database or network operation here\n    });\n\n    println!(\"Latency distribution (µs):\\n{}\", histogram.to_string());\n}\n```\n\n### Aggregating histograms across threads\n\n```rust\nuse bitcoinleveldb_histogram::Histogram;\nuse std::thread;\n\nfn main() {\n    let threads = 4;\n    let per_thread = 1000;\n\n    let handles: Vec<_> = (0..threads)\n        .map(|_| {\n            thread::spawn(move || {\n                let mut h = Histogram::default();\n                for i in 0..per_thread {\n                    h.add((i % 100) as f64);\n                }\n                h\n            })\n        })\n        .collect();\n\n    let mut global = Histogram::default();\n\n    for handle in handles {\n        let local = handle.join().expect(\"thread panicked\");\n        global.merge(&local);\n    }\n\n    println!(\"Global distribution:\\n{}\", global.to_string());\n}\n```\n\n---\n\n## Relationship to LevelDB and bitcoin-rs\n\nThis crate mirrors the histogram design from LevelDB, making it straightforward to:\n\n- Port profiling and diagnostic tooling from C++ LevelDB to Rust.\n- Interpret distributions in `bitcoin-rs` using the same conventions as upstream components.\n\nIf you are interacting directly with LevelDB or with systems already using its histogram output, this crate should produce comparable behavior and text representations, subject to differences in bucket configuration.\n\n---\n\n## License\n\nThis crate is distributed under the **MIT** license.\n\nFor source code, issues, and contributions, see the parent repository:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\n---\n\n*This README.md was generated by an AI model and may not be 100% accurate; however, it should be a good approximation of the crate's behavior and intent.*\n",
  "package_categories": [
    "algorithms",
    "data-structures",
    "mathematics",
    "science",
    "development-tools"
  ],
  "package_description": "LevelDB-compatible fixed-bucket histogram for fast online statistics (min, max, average, percentiles, standard deviation) and mergeable distributions, used by bitcoinleveldb within bitcoin-rs.",
  "package_keywords": [
    "histogram",
    "leveldb",
    "statistics",
    "bitcoin",
    "profiling"
  ]
}