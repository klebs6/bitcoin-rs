{
  "crate_name": "bitcoin-tokenpipe",
  "full_readme_markdown": "# bitcoin-tokenpipe\n\nLow-level, single-byte token pipes for coordinating concurrent work in `bitcoin-rs` and related systems.\n\nThis crate exposes a very small, explicit API around OS pipes / file descriptors, specialized for transmitting *tokens* (one-byte messages) between threads or processes. It is designed to be:\n\n- **Minimal**: no heap allocation, no framing, no buffering beyond the kernel pipe buffer.\n- **Deterministic**: explicit ownership transfer of file descriptors, predictable close semantics.\n- **Interop-friendly**: uses raw `libc` FDs under the hood, so it integrates directly with other C/Rust I/O primitives and event loops.\n\n> Note: This README was generated by an AI model based on the public interface. It may not be perfectly accurate in all edge cases, but it should be a close approximation.\n\n---\n\n## Motivation\n\n`bitcoin-tokenpipe` provides a primitive synchronization and wakeup mechanism built on top of OS pipes:\n\n- Send a single-byte *token* to signal an event (e.g., new work, shutdown, timer expiration).\n- Read a single-byte *token* from another thread or process to detect and react to that event.\n- Integrate the read-end FD into `poll`, `epoll`, `kqueue`, or `select` without additional layers.\n\nThis pattern is frequently used in high-performance networking and systems code to:\n\n- Wake an event loop from another thread.\n- Implement cancellation channels, shutdown notifiers, or work-queue nudges.\n- Bridge between non-Rust components using plain file descriptors.\n\nThe crate deliberately operates on **raw `i32` file descriptors** (or `_pipe` handles on Windows), avoiding higher-level abstractions when direct control is required.\n\n---\n\n## Platform behavior\n\n### Non-Windows (POSIX)\n\nOn Unix-like systems:\n\n- `TokenPipe::make()` uses `libc::pipe` to create a blocking, unidirectional pipe (`fds[0]` = read end, `fds[1]` = write end).\n- `TokenPipeEnd::token_write` and `TokenPipeEnd::token_read` call `sys_write`/`sys_read` wrappers around `write(2)` and `read(2)`, retrying on `EINTR`.\n- Errors are reported as integral status codes via `TokenPipeEndStatus`.\n\n### Windows\n\nOn Windows (MSVCRT environment):\n\n- `TokenPipe::make()` uses `libc::_pipe` with a fixed buffer size and `_O_BINARY`.\n- Only the pipe creation and close semantics are exposed at this crate level. The token read/write API is currently defined only for non-Windows via `#[cfg(not(windows))]`.\n\n---\n\n## Core types\n\n### `TokenPipe`\n\n```rust\npub struct TokenPipe {\n    fds: [i32; 2],\n}\n```\n\n- Represents both ends of a pipe as raw file descriptors.\n- Manages lifetime: `Drop` automatically closes any still-open endpoints.\n- Designed for move semantics and explicit transfer of ownership between components.\n\nKey methods:\n\n- `TokenPipe::make() -> Option<Self>`\n  - Creates a new OS pipe.\n  - Returns `Some(pipe)` on success, `None` on failure (errors logged via `tracing`).\n\n- `TokenPipe::new(fds: [i32; 2]) -> Self`\n  - Wraps an existing pair of FDs.\n  - Caller must ensure `fds` are valid pipe ends in the expected order (read, write).\n\n- `take_read_end(&mut self) -> TokenPipeEnd`\n  - Moves out the read end (index 0), replacing it with `-1` internally.\n  - Can be called at most once for a valid read end.\n\n- `take_write_end(&mut self) -> TokenPipeEnd`\n  - Moves out the write end (index 1), replacing it with `-1` internally.\n\n- `close(&mut self)`\n  - Explicitly closes any still-open FDs.\n  - Idempotent: repeated `close` calls are safe.\n\n- `new_from_other(other: Self) -> Self`\n  - Move-constructs a new `TokenPipe` by taking ownership of all FDs from `other` and invalidating `other`.\n\n- `assign_from(&mut self, other: Self) -> &mut Self`\n  - Closes current FDs, then takes ownership from `other`.\n\n`Drop` automatically calls `close`, so you normally do not need to call `close` manually unless you want to eagerly release resources.\n\n### `TokenPipeEnd`\n\n```rust\npub struct TokenPipeEnd {\n    fd: i32,\n}\n```\n\n- Models one endpoint of the pipe: either the read or write side.\n- Owns exactly one FD and closes it on `Drop`.\n\nOn non-Windows platforms (`#[cfg(not(windows))]`), the following methods are provided:\n\n- `TokenPipeEnd::new(fd: Option<i32>) -> Self`\n  - Constructs an endpoint from an optional FD.\n  - `None` or `Some(-1)` creates a closed endpoint.\n\n- `token_write(&mut self, token: u8) -> i32`\n  - Writes a single byte to the pipe.\n  - Return values:\n    - `0` on success.\n    - `< 0` on failure (see `TokenPipeEndStatus`).\n\n- `token_read(&mut self) -> i32`\n  - Reads a single byte from the pipe.\n  - Return values:\n    - `>= 0`: the token value (0â€“255) cast to `i32`.\n    - `< 0`: status code (see `TokenPipeEndStatus`).\n\n- `close(&mut self)`\n  - Explicitly closes the FD if open, sets it to `-1`.\n\n- `is_open(&mut self) -> bool`\n  - Returns `true` if `fd != -1`.\n\n- `new_from_other(other: TokenPipeEnd) -> Self`\n  - Move-constructs from `other`, invalidating `other`.\n\n- `assign_from(&mut self, other: TokenPipeEnd) -> &mut Self`\n  - Closes the current FD, then takes ownership from `other`.\n\n`Drop` semantics mirror `TokenPipe`: dropping a `TokenPipeEnd` closes the underlying FD if still open.\n\n### `TokenPipeEndStatus` (non-Windows)\n\n```rust\n#[repr(i32)]\npub enum TokenPipeEndStatus {\n    TS_ERR,\n    TS_EOS,\n}\n```\n\nC-style integer codes used by `token_read` and `token_write`:\n\n- `TS_ERR` (typically `0` before casting, but use the variant, not the integer): indicates an I/O error, closed FD usage, or non-recoverable error from `read(2)`/`write(2)`.\n- `TS_EOS`: end-of-stream. The peer closed the pipe (EOF).\n\nBoth `token_read` and `token_write` return plain `i32`, not a Rust `Result`. Callers must interpret negative values as `TokenPipeEndStatus` codes.\n\n---\n\n## Usage examples\n\n### Basic token signalling between threads (Unix-like systems)\n\n```rust\nuse bitcoin_tokenpipe::{TokenPipe, TokenPipeEndStatus};\nuse std::thread;\n\nfn main() {\n    // Create the pipe\n    let mut pipe = TokenPipe::make().expect(\"pipe creation failed\");\n\n    // Split into read / write ends\n    let mut reader = pipe.take_read_end();\n    let mut writer = pipe.take_write_end();\n\n    let handle = thread::spawn(move || {\n        loop {\n            let rc = reader.token_read();\n            if rc < 0 {\n                match rc {\n                    x if x == TokenPipeEndStatus::TS_EOS as i32 => {\n                        // peer closed: normal shutdown\n                        break;\n                    }\n                    _ => {\n                        // error: log / abort as appropriate\n                        break;\n                    }\n                }\n            } else {\n                let token = rc as u8;\n                // handle token\n                println!(\"received token: {}\", token);\n            }\n        }\n    });\n\n    // Send a few tokens\n    for t in 0u8..3 {\n        let rc = writer.token_write(t);\n        assert_eq!(rc, 0);\n    }\n\n    // Close writer to signal EOS\n    writer.close();\n\n    handle.join().unwrap();\n}\n```\n\n### Integration with a poll-based event loop (Unix-like systems)\n\nThe read-end FD can be registered with `epoll`, `kqueue`, or `poll`. When a token is written from another thread, the event loop wakes and consumes the token.\n\n```rust\nuse bitcoin_tokenpipe::TokenPipe;\nuse std::os::fd::AsRawFd; // or `std::os::unix::io::RawFd` depending on Rust version\n\nfn register_with_epoll(epoll_fd: i32, read_end: &bitcoin_tokenpipe::TokenPipeEnd) {\n    use libc::{epoll_ctl, epoll_event, EPOLL_CTL_ADD, EPOLLIN};\n\n    let fd = read_end.get_fd(); // via `getset::Getters` (crate-internal visibility may differ)\n\n    let mut ev = epoll_event {\n        events: EPOLLIN as u32,\n        u64: fd as u64,\n    };\n\n    unsafe {\n        let rc = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &mut ev as *mut _);\n        if rc != 0 {\n            // handle error\n        }\n    }\n}\n```\n\nNote: The actual accessor visibility for `fd` is `pub(crate)` in the current definition, so external consumers may wrap or expose the FD via higher-level components provided by the parent project (`bitcoin-rs`). The example illustrates the intended use pattern at the systems boundary.\n\n---\n\n## Error handling and semantics\n\n`token_read` and `token_write` encapsulate some low-level error behavior:\n\n- `EINTR` is transparently retried.\n- A return of `0` bytes from the OS is mapped to `TS_EOS` (end-of-stream).\n- Any other negative return from `read(2)`/`write(2)` becomes `TS_ERR`.\n\nGiven the current API shape, callers typically treat non-negative values as data and negative values as control/status codes.\n\nExample pattern:\n\n```rust\nuse bitcoin_tokenpipe::TokenPipeEndStatus;\n\nfn handle_read(rc: i32) {\n    if rc >= 0 {\n        let token = rc as u8;\n        // process token\n    } else if rc == TokenPipeEndStatus::TS_EOS as i32 {\n        // graceful shutdown\n    } else {\n        // error path\n    }\n}\n```\n\n---\n\n## Ownership and lifetime\n\n`TokenPipe` and `TokenPipeEnd` are intentionally move-only by design (no `Clone` implementation):\n\n- Each FD is conceptually owned by exactly one Rust value at a time.\n- The `*_from_other` and `assign_from` methods provide explicit, logged transfer of FDs between owning structures.\n- Internally, FDs are invalidated using `-1` after transfer or close.\n\nThis design prevents double-close and makes it easier to reason about descriptor lifetimes when piping through layered components.\n\n---\n\n## Logging and diagnostics\n\nThe crate uses the `tracing` ecosystem for diagnostic logging:\n\n- `trace!` for fine-grained lifecycle events (creation, drop, close, read/write start, success, and failure).\n- `debug!`, `info!`, `warn!`, `error!` for increasingly severe conditions.\n\nIntegrate with `tracing-subscriber` or your preferred backend to capture and analyze runtime behavior.\n\n---\n\n## Relationship to `bitcoin-rs`\n\nThis crate resides in the `https://github.com/klebs6/bitcoin-rs` repository and is primarily intended as an internal infrastructure component:\n\n- It provides a minimal, testable, and well-logged primitive for inter-thread/inter-process signaling.\n- It can be used by higher-level concurrency and networking code within the broader `bitcoin-rs` project without depending on heavyweight async frameworks.\n\nWhile it is reusable in other projects, developers should treat it as a low-level building block rather than a complete concurrency abstraction.\n\n---\n\n## License\n\nLicensed under the MIT license.\n\nSee the `LICENSE` file in the `bitcoin-rs` repository for more details.\n\n---\n\n## Safety considerations\n\n- All system calls are wrapped in `unsafe` blocks, but the public API is safe.\n- Correctness depends on respecting the intended ownership model: do not duplicate FDs externally without ensuring they are not double-closed.\n- The pipe is blocking by default; if integrating into non-blocking or time-bounded systems, configure the underlying FDs accordingly (e.g., via `fcntl` in external code) and handle `EAGAIN`/`EWOULDBLOCK` as appropriate.\n",
  "package_categories": [
    "concurrency",
    "network-programming",
    "development-tools",
    "os"
  ],
  "package_description": "Low-level token-based pipe abstraction around OS file descriptors, used for inter-thread and inter-process signaling in bitcoin-rs with explicit ownership and deterministic close semantics.",
  "package_keywords": [
    "bitcoin",
    "pipe",
    "ipc",
    "tokens",
    "concurrency"
  ]
}