{
  "crate_name": "bitcoin-locked-page-allocator",
  "full_readme_markdown": "# Bitcoin Locked Page Allocator\n\nBitcoin Locked Page Allocator is a Rust crate providing OS-dependent allocation and deallocation of locked and pinned memory pages. It offers a secure memory allocation mechanism by ensuring memory pages remain resident, minimizing the risk of sensitive data being swapped to disk. This functionality is critical for cryptographic applications where keying material must not be exposed to unauthorized access.\n\n## Overview\n\nThe crate defines a trait `LockedPageAllocator` that abstracts memory page allocation and deallocation across different operating systems. Concrete implementations include `Win32LockedPageAllocator` for Windows and `PosixLockedPageAllocator` for Unix-like systems, ensuring cross-platform support.\n\n## Features\n\n- **OS-Specific Implementations**: Provides optimized memory handling for both Windows and Unix-like systems.\n- **Memory Locking**: Utilizes `VirtualLock` on Windows and `mlock` on Unix to pin pages in RAM.\n- **Page Size Determination**: Automatically detects system page size to ensure memory alignment.\n- **Allocation and Deallocation**: Interfaces expose allocation and deallocation methods, with an attempt to keep memory from being swapped out.\n\n## Usage\n\nAfter including the crate in your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoin-locked-page-allocator = \"0.1.18\"\n```\n\nImplement the `LockedPageAllocator` trait for your custom allocator or use the provided implementations for specific operating systems:\n\n```rust\nuse bitcoin_locked_page_allocator::{LockedPageAllocator, AllocateLocked, FreeLocked, GetLimit};\n\n#[cfg(windows)]\nlet mut allocator = Win32LockedPageAllocator::default();\n\n#[cfg(unix)]\nlet mut allocator = PosixLockedPageAllocator::default();\n```\n\n## Example\n\nAllocate and lock a memory page:\n\n```rust\nfn secure_allocate_example() {\n    let mut allocator = PosixLockedPageAllocator::default();\n    let mut locking_success = false;\n    let address = allocator.allocate_locked(1024, &mut locking_success);\n    if locking_success {\n        println!(\"Memory locked successfully.\");\n        allocator.free_locked(address, 1024);\n    } else {\n        println!(\"Failed to lock memory.\");\n    }\n}\n```\n\n## Note\n\nMemory locking mechanisms like `mlock` and `VirtualLock` are best-effort and depend on OS-specific constraints such as per-process limits and system configurations.\n\n---\n\n*Generated by an AI model, accuracy not guaranteed.*",
  "package_categories": [
    "os",
    "memory-management",
    "cryptography",
    "concurrency"
  ],
  "package_description": "Provides OS-dependent allocation of locked memory pages, minimizing paging out of sensitive data.",
  "package_keywords": [
    "allocator",
    "memory",
    "cryptography",
    "secure",
    "pinned"
  ]
}