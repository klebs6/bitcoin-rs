{
  "crate_name": "bitcoin-base58",
  "full_readme_markdown": "# bitcoin-base58\n\nA minimal, Bitcoin-compatible Base58 and Base58Check codec implemented in Rust. This crate focuses on strict, consensus-faithful behavior suitable for wallet software, node implementations, and security‑sensitive tooling.\n\n> NOTE: This README was generated by an AI model based on the public interface of the crate. It may not be perfectly accurate in every detail, but it should be a close and useful approximation.\n\n---\n\n## Features\n\n- **Bitcoin-compatible Base58 alphabet** (`123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`).\n- **Leading‑zero preservation**: leading `0x00` bytes encode to leading `1` characters and round‑trip precisely.\n- **Base58Check support**: double‑SHA256 checksum on the payload, validated on decode.\n- **Strict decoder**:\n  - Rejects whitespace in `decode_base58`.\n  - Rejects characters outside the Base58 alphabet.\n  - Enforces caller‑supplied maximum output length to prevent unbounded allocation.\n- **Raw C‑pointer variants** (`*_raw`) for FFI and low‑level interop with C APIs or in‑place buffers.\n\nThis crate is intentionally narrow: it does *only* Base58/Base58Check, and does so in a way that mirrors the reference Bitcoin implementation.\n\n---\n\n## Base58 and Base58Check: Brief Technical Background\n\nBitcoin’s Base58 encoding is a positional numeral system in radix 58 over a custom alphabet. It is designed to:\n\n- Avoid visually ambiguous characters (`0`, `O`, `I`, `l`).\n- Avoid punctuation that is hard to select or double‑click.\n- Encode arbitrary byte strings into a human‑copyable representation.\n\nFormally, if a byte sequence is interpreted as a big‑endian integer\n\n\\[ n = \\sum_{i=0}^{k-1} b_i 256^{k-1-i}, \\quad b_i \\in [0, 255], \\]\n\nthen the Base58 digits are the coefficients in the base‑58 expansion of `n`.\n\nThe algorithm implemented here does not construct the big integer explicitly. Instead, it uses repeated division/modulo by 58 (or 256) on an array representation, which is asymptotically and practically efficient while avoiding big‑int libraries.\n\n**Base58Check** augments Base58 with a 4‑byte checksum:\n\n1. Compute `d = SHA256(SHA256(payload))`.\n2. Take the first 4 bytes `d[0..4]`.\n3. Append these 4 bytes to `payload`.\n4. Base58‑encode the result.\n\nDecoding performs the inverse and verifies that the checksum bytes match `checksum4_sha256d(payload)`. This is the format used for addresses, WIF keys, and other human‑facing Bitcoin identifiers.\n\n---\n\n## Installation\n\nAdd to your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoin-base58 = \"0.1.20\"\n```\n\nThis crate targets Rust **2021** edition and is licensed under **MIT**.\n\n---\n\n## High‑Level API\n\n### Encoding: raw Base58\n\n```rust\nuse bitcoin_base58::encode_base58;\n\nlet data = b\"hello\";\nlet encoded = encode_base58(data);\nprintln!(\"{}\", encoded);\n```\n\n#### Function\n\n```rust\npub fn encode_base58(input: &[u8]) -> String\n```\n\n- **Input**: arbitrary byte slice.\n- **Output**: Base58 string using the canonical Bitcoin alphabet.\n- **Leading zero handling**: each leading `0x00` becomes a leading `'1'`.\n\nThis function is allocation‑conscious: it precomputes an upper bound on the number of Base58 digits using\n\n\\[ \\lceil \\log_{58}(256) \\rceil \\approx 1.38, \\]\n\nand reserves `input.len() * 138 / 100 + 1` bytes to avoid repeated reallocations.\n\n---\n\n### Encoding: Base58Check (with checksum)\n\n```rust\nuse bitcoin_base58::encode_base_58check;\n\nlet payload = b\"versioned payload\";\nlet addr_like = encode_base_58check(payload);\nprintln!(\"{}\", addr_like);\n```\n\n#### Function\n\n```rust\npub fn encode_base_58check(input: &[u8]) -> String\n```\n\n- Appends `checksum4_sha256d(input)` to `input`.\n- Encodes the concatenation using `encode_base58`.\n- Suitable for Bitcoin‑style addresses and WIF keys once you have prepended the appropriate version byte(s).\n\nThe checksum is **big‑endian bytes in digest order**; there is no integer reinterpretation or endianness flipping, which aligns with Bitcoin Core semantics.\n\n---\n\n### Decoding: raw Base58\n\n```rust\nuse bitcoin_base58::decode_base58;\n\nlet s = \"StV1DL6CwTryKyV\"; // Base58 for \"hello\" under this alphabet\nlet mut out = Vec::new();\nlet ok = decode_base58(s, &mut out, 64);\n\nassert!(ok);\nprintln!(\"decoded: {:?}\", out);\n```\n\n#### Function\n\n```rust\npub fn decode_base58(input: &str, vch_ret: &mut Vec<u8>, max_ret_len: usize) -> bool\n```\n\n- **`input`**: the Base58 string; leading and trailing Unicode whitespace is trimmed.\n- **`vch_ret`**: output buffer that will be **cleared** and then filled with the decoded bytes on success.\n- **`max_ret_len`**: hard cap on the decoded length; if the decoded data would exceed this, the function returns `false`.\n\nBehavioral notes:\n\n- Leading `'1'` characters are interpreted as `0x00` bytes and counted explicitly.\n- Any internal whitespace (after trimming) is rejected.\n- Any character outside the Base58 alphabet is rejected.\n- On **failure**, `vch_ret` is left in a cleared or explicitly empty state.\n\nUse `max_ret_len` defensively when decoding user‑supplied data to avoid memory abuse.\n\n---\n\n### Decoding: Base58Check (with checksum)\n\n```rust\nuse bitcoin_base58::decode_base_58check;\n\nlet addr = \"1BoatSLRHtKNngkdXEeobR76b53LETtpyT\"; // example Bitcoin address-like string\nlet mut payload = Vec::new();\n\nif decode_base_58check(addr, &mut payload, 128) {\n    // payload now contains: [version_byte, data_bytes...]\n    println!(\"payload len = {}\", payload.len());\n} else {\n    eprintln!(\"invalid Base58Check string or checksum mismatch\");\n}\n```\n\n#### Function\n\n```rust\npub fn decode_base_58check(\n    input: &str,\n    vch_ret: &mut Vec<u8>,\n    max_ret_len: usize,\n) -> bool\n```\n\nSteps:\n\n1. Guard `max_ret_len + 4` against `usize` overflow.\n2. Call `decode_base58(input, vch_ret, max_ret_len + 4)`.\n3. Require that at least 4 bytes are present (checksum).\n4. Split `vch_ret` into `payload` and `checksum`.\n5. Verify `checksum == checksum4_sha256d(payload)`.\n6. On success, truncate `vch_ret` to `payload_len` and return `true`.\n\nOn any failure (invalid characters, excessive length, insufficient length, checksum mismatch), `vch_ret` is cleared and `false` is returned.\n\nUse this for all contexts where you expect a Bitcoin Base58Check value and want deterministic, strict verification.\n\n---\n\n## Low‑Level C‑Pointer APIs\n\nThe crate also exposes raw pointer variants that more closely mirror Bitcoin Core’s C++ implementation and are suitable for FFI or in‑place decoding scenarios.\n\n### `decode_base58_raw`\n\n```rust\npub fn decode_base58_raw(psz: *const u8, vch: &mut Vec<u8>, max_ret_len: i32) -> bool\n```\n\n- `psz` is a NUL‑terminated C string (`*const u8`), not a Rust slice.\n- Leading spaces are skipped.\n- Leading `'1'` characters are converted into leading zero bytes; this count is checked against `max_ret_len`.\n- Uses a pre‑sized big‑endian base256 work buffer with length `strlen(psz) * 733 / 1000 + 1`, reflecting\n\n  \\[ \\lceil \\log_{256}(58) \\rceil \\approx 0.733. \\]\n\n- Stops parsing at the first whitespace after the content and requires that the remainder to NUL be whitespace only; any extra nonspace characters cause failure.\n- Enforces `length + zeroes <= max_ret_len`.\n\n`vch` is cleared and filled with the decoded bytes on success; leading zeros are explicitly inserted.\n\n### `decode_base_58check_raw`\n\n```rust\npub fn decode_base_58check_raw(\n    psz: *const u8,\n    vch_ret: &mut Vec<u8>,\n    max_ret_len: i32,\n) -> bool\n```\n\n- Computes an internal budget of `max_ret_len + 4` (clamped to `i32::MAX`) to account for the checksum.\n- Calls `decode_base58_raw` with that budget.\n- Requires at least 4 trailing checksum bytes.\n- Verifies `checksum4_sha256d(payload)` and truncates `vch_ret` to the payload on success.\n\nThese functions are ideal when interfacing with existing C libraries or when decoding directly from C‑style buffers.\n\n---\n\n## Checksum Utility\n\n```rust\npub fn checksum4_sha256d(payload: &[u8]) -> [u8; 4]\n```\n\n- Computes `SHA256(SHA256(payload))` using the `bitcoin-hash` crate’s `Hash256` type.\n- Returns the **first 4 bytes** of the resulting digest, in digest order.\n\nThis function is the canonical checksum used by Bitcoin’s Base58Check. You can compose it with your own encoding logic or use it standalone for manual verification.\n\nExample:\n\n```rust\nuse bitcoin_base58::checksum4_sha256d;\n\nlet payload = b\"example\";\nlet chk = checksum4_sha256d(payload);\nprintln!(\"checksum: {}\", hex::encode(chk));\n```\n\n---\n\n## Error Handling and Security Considerations\n\n- All decode functions return `bool` instead of panicking for malformed input.\n- Internal arithmetic (`size` estimates, buffer operations) uses checked or conservative calculations to avoid overflow.\n- `max_ret_len` / `max_ret_len + 4` guards are explicitly enforced to avoid unbounded growth from attacker‑controlled strings.\n- Whitespace rules are strict to avoid accepting visually modified or accidentally extended input.\n\nFor network‑facing or wallet software, strongly prefer the `*_check` variants to get checksum verification and boundary checks in one call.\n\n---\n\n## Logging\n\nSome functions (e.g., `encode_base_58check`, `decode_base_58check`, `decode_base_58check_raw`, `checksum4_sha256d`) emit structured logs using macros such as `trace!`, `debug!`, `info!`, `warn!`, and `error!`.\n\nIf you enable a compatible logging backend (such as `tracing` with a subscriber), you will see detailed diagnostics about payload lengths, computed checksums, and error reasons (e.g., checksum mismatch). In high‑assurance systems, this can aid observability and incident analysis.\n\n---\n\n## Relationship to `bitcoin-rs` Repository\n\nThis crate lives inside the repository:\n\n- <https://github.com/klebs6/bitcoin-rs>\n\nIt is designed as a modular component that can be reused independently in other projects needing Bitcoin‑style Base58 semantics without pulling in the full node or protocol stack.\n\n---\n\n## License\n\nThis crate is distributed under the **MIT license**.\n\nSee the repository for full licensing details.\n",
  "package_categories": [
    "cryptography",
    "encoding",
    "algorithms",
    "network-programming",
    "development-tools"
  ],
  "package_description": "Bitcoin-compatible Base58 and Base58Check encoding/decoding routines with strict validation, length guards, and checksum verification, suitable for wallet and node implementations.",
  "package_keywords": [
    "bitcoin",
    "base58",
    "base58check",
    "encoding",
    "checksum"
  ]
}