{
  "crate_name": "bitcoinleveldb-snapshot",
  "full_readme_markdown": "# bitcoinleveldb-snapshot\n\nLow-level snapshot list implementation for the LevelDB-inspired storage engine used in `bitcoin-rs`.\n\nThis crate provides the internal snapshot representation for a Bitcoin-oriented fork/port of LevelDB. It exposes:\n\n- An abstract `Snapshot` trait (immutable database view)\n- A `SnapshotImpl` doubly-linked node storing a `SequenceNumber`\n- A `SnapshotList` that maintains a heap-pinned sentinel and a monotonically ordered list of snapshots\n\nIt is primarily intended for internal consumption by the broader `bitcoinleveldb-*` ecosystem rather than for direct end-user use. Nevertheless, the code is fully documented and usable as a general-purpose, pointer-based snapshot list.\n\n> **Note**: This README was generated by an AI model and may not be 100% accurate, but it should be a close approximation of the crate's intent and usage. Inspect the source for definitive semantics.\n\n## Conceptual model\n\nIn an LSM-based keyâ€“value store (such as LevelDB and its descendants), each mutation is assigned a monotonically increasing `SequenceNumber`. A snapshot is a logical view of the database at a specific sequence number. Reads performed under a snapshot must see all writes with `sequence_number <= snapshot_sequence`, and none of the later writes.\n\nThis crate implements the bookkeeping for those snapshots:\n\n- Snapshots are represented as nodes in a circular doubly-linked list.\n- The list has a heap-allocated sentinel head whose address is stable, even if the `SnapshotList` itself moves.\n- Snapshots are ordered by their `SequenceNumber` and appended in monotonically non-decreasing order.\n- Raw pointers (`*mut SnapshotImpl`) are used instead of `Rc`/`Arc` to closely match LevelDB's original design and to minimize overhead.\n\n### Safety and invariants\n\nThe design relies on several invariants, enforced by debug assertions where possible:\n\n- The sentinel head is always self-linked: `head.prev == head` and `head.next == head` for an empty list.\n- For a non-empty list, `head.next` points to the *oldest* snapshot and `head.prev` to the *newest* snapshot.\n- `SnapshotList::new` must be called with monotonically increasing `SequenceNumber`s. A debug assertion checks this when the list is non-empty.\n- `SnapshotList::delete` must never be called with a pointer to the sentinel head.\n- In non-`NDEBUG` builds, each `SnapshotImpl` contains a back-pointer to its owning `SnapshotList`, and `delete` validates that pointer.\n\nAll list links are manipulated via raw pointers under `unsafe` blocks. From the perspective of the public API, the operations are logically safe provided that:\n\n- Callers do not hold onto snapshot pointers after they have been passed to `delete`.\n- Snapshots are not concurrently modified (they represent an immutable DB view, but their list links are mutated internally by the list operations).\n\n## Crate structure\n\nAt a high level, the crate defines:\n\n```rust\npub trait Snapshot {}\n\n#[derive(Getters, Setters)]\n#[getset(get = \"pub\", set = \"pub\")]\npub struct SnapshotImpl {\n    prev:            *mut SnapshotImpl,\n    next:            *mut SnapshotImpl,\n    sequence_number: SequenceNumber,\n    list:            *mut SnapshotList,\n}\n\n#[derive(Getters, Setters)]\n#[getset(get = \"pub\", set = \"pub\")]\npub struct SnapshotList {\n    head: Box<SnapshotImpl>,\n}\n```\n\nWhere `SequenceNumber` is a type alias provided elsewhere in the `bitcoinleveldb` stack (typically `u64`).\n\n`SnapshotImpl` implements `Snapshot`, allowing it to be passed through the higher-level API as an opaque handle.\n\n## Usage\n\nThis crate is designed to be used by the database engine, not by application code directly. In practice, a DB will:\n\n1. Maintain a `SnapshotList` inside the DB state.\n2. On `DB::GetSnapshot` (or equivalent), call `SnapshotList::new(current_sequence_number)` to allocate and link a new snapshot, and return it as a `&dyn Snapshot` to the caller.\n3. On `DB::ReleaseSnapshot`, cast the API-level snapshot reference back to the internal `SnapshotImpl` pointer and call `SnapshotList::delete`.\n\n### Creating and managing snapshots\n\n```rust\nuse bitcoinleveldb_snapshot::{Snapshot, SnapshotImpl, SnapshotList};\n\nfn example() {\n    // Initialize an empty snapshot list with a heap-pinned sentinel.\n    let mut list = SnapshotList::default();\n    assert!(list.empty());\n\n    // Current DB sequence number.\n    let seq1: SequenceNumber = 42;\n\n    // Create a new snapshot. This returns a raw pointer owned by the list.\n    let snap1: *mut SnapshotImpl = list.new(seq1);\n    assert!(!snap1.is_null());\n    assert!(!list.empty());\n\n    unsafe {\n        // Read the sequence number via the generated getter.\n        let sref: &SnapshotImpl = &*snap1;\n        assert_eq!(*sref.sequence_number(), seq1);\n    }\n\n    // Suppose the DB advances and we create another snapshot.\n    let seq2: SequenceNumber = 100;\n    let snap2: *mut SnapshotImpl = list.new(seq2);\n\n    // The oldest snapshot is `snap1`, and the newest is `snap2`.\n    let oldest = list.oldest();\n    let newest = list.newest();\n    assert_eq!(oldest, snap1);\n    assert_eq!(newest, snap2);\n\n    // When snapshots are no longer needed, they must be deleted.\n    // This unlinks and deallocates them.\n    list.delete(snap1 as *const SnapshotImpl);\n    list.delete(snap2 as *const SnapshotImpl);\n\n    assert!(list.empty());\n}\n```\n\nBe very careful to avoid use-after-free: after `delete`, the pointer is invalid.\n\n### Interoperating with higher-level APIs\n\nThe trait `Snapshot` is intentionally minimal:\n\n```rust\npub trait Snapshot {}\n```\n\n`SnapshotImpl` implements `Snapshot`, enabling APIs like:\n\n```rust\nfn db_get_snapshot(list: &mut SnapshotList, seq: SequenceNumber) -> *const dyn Snapshot {\n    // Implementation sketch; actual code may differ in the real DB layer.\n    let impl_ptr: *mut SnapshotImpl = list.new(seq);\n    impl_ptr as *const dyn Snapshot\n}\n\nfn db_release_snapshot(list: &mut SnapshotList, snap: *const dyn Snapshot) {\n    // In the real engine, this downcast is usually done using knowledge of\n    // the concrete representation, often via `SnapshotImpl` internals.\n    let impl_ptr = snap as *const SnapshotImpl;\n    list.delete(impl_ptr);\n}\n```\n\nThe public `Snapshot` interface is intentionally opaque: snapshot semantics (which sequence number, which files, etc.) are upheld entirely by the surrounding engine code. This crate focuses on ownership and ordering of those internal snapshot structures.\n\n## Design details\n\n### Heap-pinned sentinel\n\nThe `SnapshotList` stores a `Box<SnapshotImpl>` sentinel `head`. Its address is stable, even when the `SnapshotList` itself is moved in memory. This allows the list nodes to keep raw pointers to `head` without worrying about self-referential struct invalidation.\n\nOn `Default` construction:\n\n- A `SnapshotImpl` with `sequence_number = 0` is allocated and boxed.\n- `head.prev` and `head.next` are set to point to `head` itself.\n\nThe sentinel is never exposed as a public snapshot and must never be passed to `delete`.\n\n### Oldest and newest snapshots\n\nThe `oldest` and `newest` methods work as follows:\n\n- `oldest` returns `head.next`, i.e., the first real node after the sentinel.\n- `newest` returns `head.prev`, i.e., the last real node before wrapping back to the sentinel.\n\nBoth methods assert that the list is non-empty in debug builds.\n\n### Insertion (`new`)\n\n`SnapshotList::new(sequence_number)` performs:\n\n1. When the list is not empty, assert that the new sequence is `>=` the current newest sequence.\n2. Allocate a `SnapshotImpl` with the given sequence.\n3. In non-`NDEBUG` builds, write its `list` back-pointer.\n4. Insert the new node just before `head`, updating the adjacent `prev`/`next` pointers accordingly.\n\n### Deletion (`delete`)\n\n`SnapshotList::delete(snapshot)` performs:\n\n1. Return early if `snapshot` is null.\n2. Assert that `snapshot` is not the sentinel head.\n3. In non-`NDEBUG` builds, assert that the snapshot's `list` matches `self`.\n4. Relink `prev.next` and `next.prev` to bypass the node.\n5. Clear the node's `prev`, `next`, and (non-`NDEBUG`) `list` fields.\n6. `drop(Box::from_raw(snapshot_mut));` deallocates the node.\n\nThe caller must ensure that `snapshot` is a valid pointer to a node currently linked into this list, and that no further dereferences occur after deletion.\n\n## Concurrency\n\nSnapshots as logical database views are immutable: higher-level code must treat `Snapshot` as read-only once published. The list itself, however, is *not* internally synchronized. The crate does **not** perform any locking; it assumes that the owner (`DB` or similar) enforces appropriate synchronization.\n\nTypical patterns:\n\n- Guard all snapshot list manipulations (`new`, `delete`) with a mutex protecting the DB state.\n- Allow concurrent readers to use snapshots through immutable references once `DB::GetSnapshot` has returned them.\n\n## Logging and diagnostics\n\nThe implementation uses macros such as `debug!`, `trace!`, and `warn!`. These are typically provided by the `log` crate or a similar facade. They offer insight into:\n\n- Creation and deletion of snapshots\n- Pointer topology and list structure changes\n- Empty vs non-empty list checks\n\nIn performance-sensitive deployments you may choose a logging configuration that elides these at compile time.\n\n## Relationship to `bitcoin-rs`\n\nThis crate lives in the `bitcoin-rs` repository:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\nIt is one piece of a broader system that re-implements or adapts LevelDB for use as the backing store for Bitcoin-related data structures. The snapshot system is critical to providing consistent point-in-time reads while compactions, memtable flushes, and other background operations occur.\n\n## License\n\nThis crate is distributed under the MIT license. See the repository for details.\n",
  "package_categories": [
    "database",
    "database-implementations",
    "algorithms",
    "concurrency",
    "development-tools"
  ],
  "package_description": "Internal LevelDB-style snapshot list for bitcoin-rs: a raw-pointer-based doubly-linked list maintaining immutable database snapshots ordered by sequence number.",
  "package_keywords": [
    "bitcoin",
    "leveldb",
    "snapshot",
    "database",
    "lsm-tree"
  ]
}