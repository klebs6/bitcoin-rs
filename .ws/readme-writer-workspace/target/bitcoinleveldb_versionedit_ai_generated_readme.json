{
  "crate_name": "bitcoinleveldb-versionedit",
  "full_readme_markdown": "# bitcoinleveldb-versionedit\n\nLow-level encoding/decoding and manipulation of LevelDB `VersionEdit` records, extracted from the `bitcoin-rs` project. This crate provides a faithful, byte-for-byte compatible Rust implementation of LevelDB's manifest version-edit logic as used by Bitcoin-like workloads.\n\n> NOTE: This README was generated by an AI model. It may not be perfectly accurate, but it is designed to be technically consistent with the exposed API and should be a strong starting point.\n\n---\n\n## Overview\n\nLevelDB stores the evolution of its on-disk state (files per level, sequence-number metadata, compaction pointers, etc.) in a manifest file. Each record in the manifest is a **VersionEdit**: a compact, varint-encoded description of mutations to the logical database version.\n\nThis crate implements:\n\n- A `VersionEdit` struct mirroring LevelDB's internal representation\n- Deterministic encoding of `VersionEdit` into the manifest binary format\n- Robust decoding from manifest records back into a `VersionEdit`\n- Convenience APIs to:\n  - Track added files (per level)\n  - Track deleted files (per level)\n  - Maintain compaction pointers\n  - Maintain log / sequence-number bookkeeping\n  - Derive human-readable debug summaries\n\nIt is designed to be interoperable with existing LevelDB/Bitcoin data, focusing on correctness of serialization and deterministic ordering.\n\nThis crate is **not** a full LevelDB implementation; it is targeted infrastructure for higher-level components (like `VersionSet` and the full storage engine) in `bitcoin-rs`.\n\n---\n\n## Features\n\n- **Binary compatibility with LevelDB manifest format**\n  - Uses varint32/varint64 and length-prefixed slices to match LevelDB's on-disk representation\n  - Tags and field semantics match LevelDB's `VersionEdit`:\n    - `kComparator` (tag 1)\n    - `kLogNumber` (tag 2)\n    - `kNextFileNumber` (tag 3)\n    - `kLastSequence` (tag 4)\n    - `kCompactPointer` (tag 5)\n    - `kDeletedFile` (tag 6)\n    - `kNewFile` (tag 7)\n    - `kPrevLogNumber` (tag 9)\n\n- **Deterministic encoding**\n  - Deleted-file entries are sorted by `(level, file_number)` prior to encoding, guaranteeing that\n    `encode_to -> decode_from -> encode_to` produces **bit-identical** manifest bytes.\n\n- **Convenient high-level mutation API**\n  - `add_file(level, file, size, smallest, largest)`\n  - `delete_file(level, file)`\n  - `set_comparator_name`, `set_log_number`, `set_prev_log_number`, `set_next_file`, `set_last_sequence`\n  - `set_compact_pointer(level, key)`\n\n- **Introspectable**\n  - `debug_string()` yields a multi-line, human-readable summary suitable for logging and debugging, including all scalar fields, compaction pointers, deletions, and new files.\n\n- **Safe defaults & state reset**\n  - `Default` constructs an empty, \"no-op\" `VersionEdit` with all `has_` flags cleared.\n  - `clear()`/`reset_core_state()` allow reuse of a `VersionEdit` while preserving compaction pointers if desired.\n\n---\n\n## Crate Status\n\n- **License:** MIT\n- **Edition:** Rust 2021\n- **Repository:** <https://github.com/klebs6/bitcoin-rs>\n- **Intended users:** implementers of LevelDB-compatible storage layers, Bitcoin node developers, and systems programmers requiring exact reproduction of LevelDB manifest semantics.\n\n---\n\n## Core Data Structures\n\n### `VersionEdit`\n\n```rust\npub struct VersionEdit  {\n    comparator:           String,\n    log_number:           u64,\n    prev_log_number:      u64,\n    next_file_number:     u64,\n    last_sequence:        SequenceNumber,\n    has_comparator:       bool,\n    has_log_number:       bool,\n    has_prev_log_number:  bool,\n    has_next_file_number: bool,\n    has_last_sequence:    bool,\n    compact_pointers:     Vec<(i32, InternalKey)>,\n    deleted_files:        VersionEditDeletedFileSet,\n    new_files:            Vec<(i32, FileMetaData)>,\n}\n\npub type VersionEditDeletedFileSet = HashSet<(i32, u64)>;\n```\n\nConceptually, a `VersionEdit` is a sparse patch to the current logical version:\n\n- **Scalar metadata**\n  - `comparator`: name of the key comparator\n  - `log_number`: current log file number\n  - `prev_log_number`: previous log file number\n  - `next_file_number`: global file-number allocator watermark\n  - `last_sequence`: maximal sequence number visible after applying this edit\n  - `has_*` flags: which of the above are present in this edit\n\n- **Collections**\n  - `compact_pointers: Vec<(level, InternalKey)>`\n  - `deleted_files: HashSet<(level, file_number)>`\n  - `new_files: Vec<(level, FileMetaData)>`\n\nThese mutate the file layout per compaction level.\n\n### Helper functions\n\nThese implement the manifest's binary protocol for specific logical units:\n\n```rust\npub fn get_level(input: &mut Slice, level: &mut i32) -> bool { ... }\n\npub fn get_internal_key(input: &mut Slice, key: &mut InternalKey) -> bool { ... }\n```\n\n- `get_level` reads a LevelDB level (0..N) from a varint32-encoded field.\n- `get_internal_key` reads a length-prefixed slice and decodes it into an `InternalKey`.\n\n---\n\n## Encoding & Decoding Semantics\n\n### Encoding: `VersionEdit::encode_to`\n\n```rust\nimpl VersionEdit {\n    pub fn encode_to(&self, dst: *mut String) { ... }\n}\n```\n\n- Accepts a raw pointer to an owned `String` that serves as a byte buffer.\n- Serializes the `VersionEdit` fields into the LevelDB manifest wire format:\n  - Scalars are emitted only if the corresponding `has_*` flag is true.\n  - `compact_pointers`, `deleted_files`, and `new_files` are written sequentially.\n- `deleted_files` are pre-sorted:\n\n```rust\nlet mut deleted_files_sorted: Vec<(i32, u64)> =\n    self.deleted_files().iter().copied().collect();\ndeleted_files_sorted.sort_unstable();\n```\n\nThis guarantees deterministic encoding irrespective of the internal `HashSet` iteration order.\n\n**Safety model:**\n- The method uses `unsafe` for the raw pointer; you must ensure:\n  - `dst` is non-null and points to a valid `String`\n  - The `String` outlives the call\n\nA higher-level wrapper can be constructed to hide the raw pointer, e.g. by allocating and passing `&mut String` and then casting internally.\n\n### Decoding: `VersionEdit::decode_from`\n\n```rust\nimpl VersionEdit {\n    pub fn decode_from(&mut self, src: &Slice) -> Status { ... }\n}\n```\n\n- Resets the core scalar state and file collections before decoding.\n- Consumes a copy of the input `Slice` and incrementally parses tagged fields.\n- Each tag is matched against the LevelDB tag set; unknown or malformed tags result in a `Status::corruption` with contextual diagnostics.\n- Parsed values are routed through the higher-level mutation functions (`set_*`, `add_file`, `delete_file`, `set_compact_pointer`).\n\nThe loop structure is essentially:\n\n```rust\nwhile msg.is_none() && get_varint32(&mut input, &mut tag) {\n    match tag {\n        1 => { /* comparator */ }\n        2 => { /* log number */ }\n        3 => { /* next file number */ }\n        4 => { /* last sequence */ }\n        5 => { /* compact pointer */ }\n        6 => { /* deleted file */ }\n        7 => { /* new file */ }\n        9 => { /* prev log number */ }\n        _ => { msg = Some(\"unknown tag\"); }\n    }\n}\n```\n\nPost-conditions:\n- On success: returns `Status::ok()` and a fully-populated `VersionEdit`.\n- On failure: returns a corruption `Status` indicating the failing component, and leaves the `VersionEdit` in a reset state (partial mutations are not guaranteed useful).\n\n---\n\n## Public API Usage\n\n### Constructing a basic `VersionEdit`\n\n```rust\nuse bitcoinleveldb_versionedit::VersionEdit;\nuse bitcoinleveldb_types::{InternalKey, SequenceNumber};\n\nfn build_simple_edit() -> VersionEdit {\n    let mut edit = VersionEdit::default();\n\n    // set comparator name\n    let cmp_name = Slice::from(\"leveldb.BytewiseComparator\".as_bytes());\n    edit.set_comparator_name(&cmp_name);\n\n    // log / sequence metadata\n    edit.set_log_number(42);\n    edit.set_prev_log_number(41);\n    edit.set_next_file(1000);\n    edit.set_last_sequence(123_456 as SequenceNumber);\n\n    edit\n}\n```\n\n### Adding a new file\n\n```rust\nfn add_new_sstable(\n    edit: &mut VersionEdit,\n    level: i32,\n    file_number: u64,\n    file_size: u64,\n    smallest: &InternalKey,\n    largest: &InternalKey,\n) {\n    edit.add_file(level, file_number, file_size, smallest, largest);\n}\n```\n\n**Preconditions (mirroring LevelDB's invariants):**\n- `smallest` and `largest` must be the true extremal internal keys in the file.\n- The file must not have been persisted to the VersionSet yet (`VersionSet::SaveTo()` expectation).\n\n### Deleting a file\n\n```rust\nfn mark_file_deleted(edit: &mut VersionEdit, level: i32, file_number: u64) {\n    edit.delete_file(level, file_number);\n}\n```\n\nInternally, this records `(level, file_number)` in `deleted_files`, which will be serialized as one or more `kDeletedFile` entries.\n\n### Compaction pointers\n\n```rust\nfn update_compaction_pointer(\n    edit: &mut VersionEdit,\n    level: i32,\n    key: &InternalKey,\n) {\n    edit.set_compact_pointer(level, key);\n}\n```\n\nThis denotes the logical *resume key* for future compactions at that level.\n\n### Debugging\n\n```rust\nfn log_version_edit(edit: &VersionEdit) {\n    println!(\"{}\", edit.debug_string());\n}\n```\n\nExample output:\n\n```text\nVersionEdit {\n  Comparator: leveldb.BytewiseComparator\n  LogNumber: 42\n  PrevLogNumber: 41\n  NextFile: 1000\n  LastSeq: 123456\n  CompactPointer: 1 userkey1@123\n  DeleteFile: 2 57\n  AddFile: 1 1001 1048576 smallest_key .. largest_key\n}\n```\n\n### Clearing and reusing a `VersionEdit`\n\n```rust\nfn reuse_edit(edit: &mut VersionEdit) {\n    // Reset scalar state and file collections; compact_pointers remain.\n    edit.clear();\n\n    // Now you can repopulate it with new metadata and file deltas.\n}\n```\n\n`clear()` simply delegates to `reset_core_state()`, which zeroes scalars, clears `deleted_files` and `new_files`, and resets `has_*` flags.\n\n---\n\n## Binary Format Details\n\nThis crate encodes/decodes the same schema as canonical LevelDB:\n\n- **Tags** are varint32-encoded integers.\n- **Levels** are varint32-encoded unsigned integers, cast to `i32` in-memory.\n- **File numbers and sizes** use varint64.\n- **Internal keys** are serialized as a length-prefixed slice (`len` as varint32, followed by bytes) and then decoded via `InternalKey::decode_from`.\n- **Comparator name** is also a length-prefixed slice of UTF-8 bytes.\n\nThe serialization order is purely determined by the order of fields in the `VersionEdit` and the order of `compact_pointers` and `new_files` vectors, except for `deleted_files`, which are explicitly sorted, providing deterministic binary output.\n\nThis determinism is critical when one wants to ensure that two logically identical `VersionEdit`s result in the same manifest bytes, which facilitates:\n\n- Reproducible tests\n- Content-addressable storage and hashing\n- Stable replication and snapshot mechanics across nodes\n\n---\n\n## Relationship to LevelDB and Bitcoin\n\nIn LevelDB (and by inheritance, Bitcoin Core's database layout), `VersionEdit` is the backbone for describing structural mutations in the set of SSTables. Bitcoin stores UTXO and block index information in LevelDB-style databases; exact adherence to manifest semantics is mandatory if you need to:\n\n- Read or write existing Bitcoin Core databases\n- Implement alternative nodes that share storage layouts\n- Perform analysis or replay of historical LevelDB states from archived manifests\n\nThis crate intentionally mirrors the C++ LevelDB logic, with additional Rust idioms (e.g., `Default`, strong typing around `Status`, and improved logging).\n\n---\n\n## Safety & Concurrency Considerations\n\n- The core APIs are `&mut self` and therefore **not** thread-safe by themselves; wrap in synchronization primitives (`Mutex`, etc.) if accessed concurrently.\n- `encode_to` uses a raw pointer. Incorrect usage can lead to undefined behavior. If you design higher-level APIs on top of this crate, you are encouraged to encapsulate this unsafety in a small, well-tested layer that exposes only safe abstractions.\n- `decode_from` trusts the `Slice` size; it validates structure but not cryptographic authenticity. For untrusted input, pair it with higher-level validation or checksums.\n\n---\n\n## When to Use This Crate\n\nUse this crate if you need:\n\n- Precise, LevelDB-compatible manifest handling in Rust\n- To interoperate with Bitcoin or other LevelDB-based systems at the storage format level\n- Deterministic, testable `VersionEdit` encoding/decoding\n\nThis crate is probably **too low-level** if you only need a high-level key-value database abstraction; in that case, integrate through whatever higher-layer `VersionSet` or storage API `bitcoin-rs` exposes.\n\n---\n\n## License\n\nThis crate is distributed under the **MIT** license, consistent with the `bitcoin-rs` repository.\n\n---\n\n## Provenance\n\nThis crate is part of the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) repository and focuses exclusively on the `VersionEdit` component of a LevelDB-compatible storage engine.\n\n*Reminder: This README was generated by an AI model and may not perfectly reflect all implementation details or future changes. Always consult the source code and tests for definitive behavior.*\n",
  "package_categories": [
    "database",
    "database-implementations",
    "encoding",
    "algorithms",
    "development-tools"
  ],
  "package_description": "LevelDB-compatible VersionEdit encoding/decoding and manipulation utilities used by bitcoin-rs for manifest and version metadata management.",
  "package_keywords": [
    "leveldb",
    "bitcoin",
    "manifest",
    "versionedit",
    "sstable"
  ]
}