{
  "crate_name": "bitcoin-sha1",
  "full_readme_markdown": "# bitcoin-sha1\n\nA minimal, low-level SHA‑1 implementation tuned for the needs of `bitcoin-rs`.\n\nThis crate exposes a pointer-based, allocation-free SHA‑1 compression function and a thin stateful hasher suitable for environments where you want:\n\n- **Tight control over memory layout and lifetimes** (raw pointers, no `std::io` traits, no heap allocations in the fast path).\n- **Deterministic, standalone SHA‑1** without a large dependency stack.\n- **Instrumentation-friendly internals** (round-level tracing in debug builds).\n\nIt is primarily intended as an internal building block within the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) project, but is usable as a general SHA‑1 primitive for other applications that need similar control.\n\n> **Note:** This README was generated by an AI model. It may contain minor inaccuracies, but it should be a good high-level description of the crate. Always consult the source for exact behavior.\n\n---\n\n## Cryptographic note (security)\n\nSHA‑1 is *cryptographically broken* for collision resistance and must **not** be used for new security-sensitive designs (e.g., digital signatures, long-term content integrity, authentication tags).\n\nWithin Bitcoin, SHA‑1 may appear only in legacy or non‑security‑critical contexts. This implementation should therefore be regarded as a **compatibility / research / tooling** component, not as a modern cryptographic primitive.\n\nIf you need a secure hash function, use a SHA‑2 or SHA‑3 family implementation, or a modern construction such as BLAKE3.\n\n---\n\n## Features and design\n\n- **Explicit state struct**: `Sha1` exposes its internal state array, buffer, and byte counter (via getters) for inspection and debugging.\n- **Raw-pointer oriented API**: `write` accepts `*const u8` and a `len: usize` for zero-copy integration with existing memory management.\n- **Pure Rust core**: Implements the SHA‑1 compression function (80‑round transform) directly in Rust, with explicit endianness handling.\n- **Streaming interface**: Feed arbitrarily sized inputs incrementally, then finalize to yield a 20‑byte digest.\n- **Deterministic padding and length encoding**: SHA‑1 padding logic is implemented explicitly; finalization writes the bit length as big‑endian `u64`.\n\nThe implementation closely follows the standard SHA‑1 structure:\n\n- State vector \\(H_0, \\dots, H_4\\) in `s: [u32; 5]`.\n- 512‑bit blocks processed in `sha1_transform`.\n- Message schedule `W_t` computed from the first 16 32‑bit words using the classic recurrence with rotate‑left by 1 (`sha1_left`).\n- Boolean functions `f1`, `f2`, `f3` and phase‑dependent constants `K1..K4`.\n\n---\n\n## Minimum supported Rust version\n\n- Rust **1.56+** is expected due to the 2021 edition, but this crate is developed with a modern toolchain. Refer to the `bitcoin-rs` repository if you require an explicit MSRV guarantee.\n\n---\n\n## Installation\n\nAdd the crate to your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoin-sha1 = \"0.1.19\"\n```\n\nThen import it as usual:\n\n```rust\nuse bitcoin_sha1::Sha1;\n```\n\n---\n\n## High-level usage\n\n### Hashing a byte slice (via raw pointers)\n\nThe `Sha1` API is deliberately low‑level: `write` operates on a raw pointer and a length. For safe Rust slices, you typically wrap the call in an `unsafe` block:\n\n```rust\nuse bitcoin_sha1::Sha1;\n\nconst SHA1_OUTPUT_SIZE: usize = 20; // from the crate\n\nfn sha1_digest_bytes(input: &[u8]) -> [u8; SHA1_OUTPUT_SIZE] {\n    let mut hasher = Sha1::new();\n\n    unsafe {\n        hasher.write(input.as_ptr(), input.len());\n    }\n\n    let mut out = [0u8; SHA1_OUTPUT_SIZE];\n    hasher.finalize(&mut out);\n    out\n}\n\nfn main() {\n    let msg = b\"hello world\";\n    let digest = sha1_digest_bytes(msg);\n    println!(\"SHA1(\\\"hello world\\\") = {:02x?}\", digest);\n}\n```\n\n### Reusing a hasher\n\nThe `reset` method re-initializes the internal state using the same IV as `new`, without reallocating the struct:\n\n```rust\nuse bitcoin_sha1::Sha1;\n\nfn reuse_example() {\n    let mut h = Sha1::new();\n\n    unsafe { h.write(b\"first\".as_ptr(), 5); }\n    let mut out1 = [0u8; bitcoin_sha1::SHA1_OUTPUT_SIZE];\n    h.finalize(&mut out1);\n\n    h.reset();\n\n    unsafe { h.write(b\"second\".as_ptr(), 6); }\n    let mut out2 = [0u8; bitcoin_sha1::SHA1_OUTPUT_SIZE];\n    h.finalize(&mut out2);\n\n    // out1 and out2 are independent digests\n}\n```\n\n---\n\n## Low-level primitives\n\nThe crate also exposes the internal building blocks of SHA‑1. These are primarily useful for:\n\n- Implementing custom SHA‑1 variants.\n- Analysing or instrumenting the compression function.\n- Educational purposes.\n\n### Boolean functions\n\nThese correspond to the typical SHA‑1 round functions:\n\n```rust\nuse bitcoin_sha1::{sha1_f1, sha1_f2, sha1_f3};\n\nlet (b, c, d) = (0x1234_5678, 0x89ab_cdef, 0x0fed_cba9);\nlet f1 = sha1_f1(b, c, d); // used in rounds 0..=19\nlet f2 = sha1_f2(b, c, d); // used in rounds 20..=39 and 60..=79\nlet f3 = sha1_f3(b, c, d); // used in rounds 40..=59\n```\n\nMathematically, these are:\n\n- \\(f_1(b,c,d) = d \\oplus (b \\wedge (c \\oplus d))\\)\n- \\(f_2(b,c,d) = b \\oplus c \\oplus d\\)\n- \\(f_3(b,c,d) = (b \\wedge c) \\lor (d \\wedge (b \\lor c))\\)\n\nwhere `^` is XOR, `&` is AND, and `|` is OR.\n\n### Single-round helper\n\n`sha1_round` computes one round given the working variables and a schedule word:\n\n```rust\nuse bitcoin_sha1::sha1_round;\n\nlet mut b = 0x0123_4567u32;\nlet mut e = 0x89ab_cdefu32;\nlet a = 0xfedc_ba98;\nlet c = 0x7654_3210;\nlet d = 0xf0e1_d2c3;\nlet f = 0x0bad_f00d;\nlet k = 0x5a82_7999;\nlet w = 0x1234_5678;\n\nsha1_round(a, &mut b, c, d, &mut e, f, k, w);\n// b and e have now been updated as per a SHA-1 round\n```\n\nThis can be used to experiment with reduced-round SHA‑1 or alternative message schedules.\n\n### Core compression function: `sha1_transform`\n\nThe central function is:\n\n```rust\npub fn sha1_transform(state: *mut u32, chunk: *const u8)\n```\n\n- `state` points to an array of 5 big‑endian 32‑bit words (the running hash state).\n- `chunk` points to a 64‑byte block of message data.\n\n`sha1_transform` performs the full 80‑round compression on one 512‑bit block, mutating the `state` in place.\n\nUsage pattern:\n\n```rust\nuse bitcoin_sha1::{sha1_initialize, sha1_transform, SHA1_OUTPUT_SIZE};\n\nfn manual_transform_example(input: &[u8; 64]) -> [u8; SHA1_OUTPUT_SIZE] {\n    let mut s = [0u32; 5];\n\n    unsafe {\n        sha1_initialize(s.as_mut_ptr());\n        sha1_transform(s.as_mut_ptr(), input.as_ptr());\n    }\n\n    let mut out = [0u8; SHA1_OUTPUT_SIZE];\n    for (i, chunk) in out.chunks_exact_mut(4).enumerate() {\n        chunk.copy_from_slice(&s[i].to_be_bytes());\n    }\n    out\n}\n```\n\n### Endianness helpers\n\nThe crate provides small utilities to convert between raw pointers and big‑endian integers:\n\n- `read_be32(p: *const u8) -> u32`\n- `write_be32(p: *mut u8, v: u32)`\n- `write_be64(p: *mut u8, v: u64)`\n\nThey are used internally by the compression and padding logic but are also exposed for callers that already work directly with raw buffers.\n\n---\n\n## The `Sha1` state machine\n\nThe `Sha1` struct encapsulates:\n\n- `s: [u32; 5]` — the internal state words \\(H_0..H_4\\).\n- `buf: [u8; 64]` — a partial block buffer.\n- `bytes: u64` — the total number of **bytes** processed so far.\n\n### Initialization\n\n```rust\nuse bitcoin_sha1::Sha1;\n\nlet mut h = Sha1::new();\n```\n\n`Sha1::new`:\n\n1. Constructs a zeroed `Sha1` via `Default`.\n2. Calls `sha1_initialize` to set the standard SHA‑1 IV.\n\nThe IV corresponds to the classical SHA‑1 initial constants, stored as big‑endian words. (Always refer to the source code to check for any project-specific constants.)\n\n### Incremental updates: `write`\n\n```rust\nimpl Sha1 {\n    pub fn write(&mut self, data: *const u8, len: usize) -> &mut Self;\n}\n```\n\n`write` implements a classic streaming design:\n\n1. Fill any partially filled buffer to 64 bytes; once full, call `sha1_transform`.\n2. Process any further full 64‑byte chunks directly from `data` with no intermediate copying.\n3. Copy any trailing bytes (< 64) into `buf` for the next call.\n\nThe internal `bytes` counter tracks the total number of bytes absorbed and is later used by `finalize` to encode the message length in bits.\n\n### Finalization: `finalize`\n\n```rust\nimpl Sha1 {\n    pub fn finalize(&mut self, hash_out: &mut [u8; SHA1_OUTPUT_SIZE]);\n}\n```\n\n`finalize` performs:\n\n1. **Padding**: Writes a `0x80` byte, then enough zero bytes so that the total length (including the 8‑byte length field) is congruent to 0 modulo 64.\n2. **Length encoding**: Appends an 8‑byte big‑endian representation of the bit length (`self.bytes << 3`).\n3. **Final compression**: Uses `write` to push the padding and length into the usual streaming pipeline.\n4. **Output**: Writes the big‑endian 32‑bit state words into `hash_out`.\n\nYou can call `finalize` multiple times on the same `Sha1` instance without resetting; it will recompute the digest from the current internal state and byte count. To start a fresh hash, call `reset`.\n\n### Reset\n\n```rust\nimpl Sha1 {\n    pub fn reset(&mut self) -> &mut Self;\n}\n```\n\n`reset` sets `bytes` back to 0 and re‑initializes the state with `sha1_initialize`, but retains the allocated buffers.\n\n---\n\n## Logging and debug behavior\n\nThe implementation uses logging macros like `trace!`, `debug!`, and `info!`:\n\n- In debug builds, `sha1_transform` can log round boundaries every 20 rounds.\n- `Sha1::new` and `Sha1::reset` log initialization events.\n\nThis requires a compatible logging facade to be set up in your application (e.g., `log` plus a specific logger implementation). If the macros resolve to no‑ops, the hash behavior is unaffected.\n\n---\n\n## Safety considerations\n\n- The API exposes multiple `unsafe` functions and raw pointer parameters.\n- Callers are responsible for ensuring that pointers are valid, correctly aligned (for the operations performed), and live for the duration of the call.\n- Endianness conversions are implemented via bytewise operations and are portable across architectures.\n\nWhen wrapping this crate in higher-level, safe abstractions, consider:\n\n- Providing `fn update(&mut self, data: &[u8])` and `fn digest(&self) -> [u8; 20]` style APIs.\n- Avoiding exposing raw pointers directly to end users.\n\n---\n\n## Example: safe wrapper\n\nIf you want a safe façade for general application code, you can define:\n\n```rust\nuse bitcoin_sha1::{Sha1, SHA1_OUTPUT_SIZE};\n\npub struct SafeSha1(Sha1);\n\nimpl SafeSha1 {\n    pub fn new() -> Self {\n        SafeSha1(Sha1::new())\n    }\n\n    pub fn update(&mut self, data: &[u8]) {\n        unsafe {\n            self.0.write(data.as_ptr(), data.len());\n        }\n    }\n\n    pub fn finalize(mut self) -> [u8; SHA1_OUTPUT_SIZE] {\n        let mut out = [0u8; SHA1_OUTPUT_SIZE];\n        self.0.finalize(&mut out);\n        out\n    }\n}\n```\n\n---\n\n## Repository and contribution\n\nThis crate resides in the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) repository. Issues and pull requests should be opened there.\n\nPlease:\n\n- Keep changes minimal and well‑reviewed; SHA‑1 is easy to implement incorrectly.\n- Add tests that compare against known SHA‑1 test vectors for any behavior change.\n\n---\n\n## License\n\nThis crate is licensed under the **MIT** license. Refer to the `LICENSE` file in the repository for full terms.\n",
  "package_categories": [
    "cryptography",
    "algorithms",
    "development-tools",
    "science"
  ],
  "package_description": "Low-level, pointer-based SHA-1 implementation used by bitcoin-rs, exposing a streaming hasher and raw compression primitives without extra dependencies.",
  "package_keywords": [
    "sha1",
    "bitcoin",
    "hash",
    "cryptography",
    "digest"
  ]
}