{
  "crate_name": "bitcoinleveldb-posixlogger",
  "full_readme_markdown": "# bitcoinleveldb-posixlogger\n\nA minimal, POSIX-focused logging backend for `bitcoinleveldb`-style systems, implemented as a thin, unsafe wrapper around `libc::FILE` with deterministic buffering and timestamped log formatting.\n\n> This README.md was generated by an AI model. It may not be perfectly accurate in every detail, but it should be a close and useful description of the crate.\n\n## Overview\n\n`bitcoinleveldb-posixlogger` provides a `PosixLogger` implementation designed to mirror the behavior of LevelDB's POSIX logger in C++. It writes log lines directly to a `*mut libc::FILE` using `fwrite`/`fflush`, with explicit control over:\n\n- Timestamp formatting down to microseconds\n- Thread identifier labelling\n- Two-phase buffering: first on a fixed-size stack buffer, then (if needed) on a heap buffer\n- Truncation semantics when log lines exceed the available buffer\n- Ensuring a trailing `\\n` without double-newlines\n\nThe logger is intended for environments where you either already have a C FILE* (e.g., interoperating with C/C++ code or legacy logging subsystems) or you want deterministic, minimal-overhead logging without imposing an opinionated Rust logging facade.\n\nThe type implements the `Logv` and `Logger` traits from the surrounding ecosystem (likely another crate in the `bitcoinleveldb` family). It is **not** a generic Rust logging facade by itself; instead, it is the low-level sink to which higher-level logging abstractions can write.\n\n## Design Goals\n\n- **POSIX-level control**: Use `gettimeofday`, `localtime_r`, `fwrite`, and `fflush` directly.\n- **Deterministic buffering**: Two-phase buffering strategy that first attempts a stack allocation, then falls back to a correctly-sized heap buffer.\n- **Safety via encapsulation**: All unsafe operations are concentrated inside `PosixLogger` methods; the public API is safe (except for the fact that you must pass a valid `FILE*`).\n- **Minimal dependencies**: Built around `libc` and core/std primitives.\n\n## Core Data Type\n\n```rust\n#[derive(Getters)]\n#[getset(get = \"pub\")]\npub struct PosixLogger {\n    fp: *const libc::FILE,\n}\n```\n\n- The logger holds a raw pointer to a C `FILE`. Ownership is taken at construction (`PosixLogger::new`) and released in `Drop` via `fclose`.\n- The generated getter `fp()` returns `*const libc::FILE`, but internally `PosixLogger` casts to `*mut libc::FILE` when writing.\n\n## Safety Model\n\nThis crate is intentionally low-level and uses unsafe code:\n\n- The constructor `PosixLogger::new(fp: *mut libc::FILE)` asserts that `fp` is not null.\n- The `Drop` impl calls `libc::fclose(self.fp as *mut libc::FILE)` if the pointer is non-null.\n- Callers **must** ensure:\n  - The `FILE*` is uniquely owned by the `PosixLogger` (no concurrent closes or writes from other code).\n  - No further use of the `FILE*` after the logger is dropped.\n\nAll other public methods are safe under the assumption that `PosixLogger` has exclusive logical ownership of the `FILE*`.\n\n## Time and Formatting Semantics\n\n### Timestamps\n\n`capture_current_time_components` uses:\n\n- `gettimeofday` to obtain a `libc::timeval` (`tv_sec`, `tv_usec`).\n- `localtime_r` to obtain a `libc::tm` with local time components.\n\nThe header format produced by `construct_log_header_prefix` is:\n\n```text\nYYYY/MM/DD-HH:MM:SS.UUUUUU <thread-id> \n```\n\nExample:\n\n```text\n2025/03/04-17:56:12.123456 ThreadId(7) \n```\n\nThe header is a plain ASCII `String`, including a trailing space ready for the log body.\n\n### Thread Identification\n\n`build_thread_identifier_label` converts `std::thread::current().id()` with `format!(\"{:?}\", ...)`, then truncates to `Self::MAX_THREAD_ID_SIZE` if necessary. This yields a concise, printable thread label that plays well with `Debug` formatting semantics of Rust thread IDs.\n\n## Log Body Construction\n\n`build_log_body_from_format_and_arguments` adapts a C-style format string and a Rust slice of string arguments into a single `String` body.\n\nSignature:\n\n```rust\npub fn build_log_body_from_format_and_arguments(\n    &self,\n    format: *const u8,\n    arguments: &[&str],\n) -> Option<String>\n```\n\nBehavior:\n\n- Interprets `format` as a null-terminated `CStr` (`*const libc::c_char`).\n- Converts to a Rust string (UTF‑8, lossy for invalid bytes).\n- Scans the template, handling:\n  - `%s` → substitutes the next entry from `arguments`.\n  - `%%` → a literal `%`.\n  - Any other `%<char>` combination is copied as-is.\n- Extra arguments beyond the number of `%s` placeholders are ignored.\n- If `format` is null, logs an error and returns `None`.\n\nThis is intentionally a restricted subset of `printf`-style formatting specialized for LevelDB-style logging where only `%s` expansion is required.\n\n## Buffering and Layout\n\n### Sizing\n\n`compute_required_log_bytes(header_bytes, body_bytes)` returns:\n\n```text\nrequired_without_newline = header.len() + body.len()\n```\n\nThis excludes the trailing `\\n`, which may be appended later.\n\n### Stack vs Heap Buffer\n\n`emit_log_line_with_two_phase_buffering` orchestrates the write:\n\n1. Compute `required_without_newline`.\n2. Attempt to format into a fixed `STACK_BUFFER_SIZE` stack buffer.\n3. If the stack buffer is too small, compute a `dynamic_buffer_size` (at least `required_without_newline + 2`) and retry with a heap-allocated `Vec<u8>`.\n\nThe method iterates at most twice: once on the stack, once on the heap.\n\n### Layout\n\n`layout_log_line_in_buffer` decides between full or truncated writes:\n\n```rust\npub fn layout_log_line_in_buffer(\n    &self,\n    header_bytes:             &[u8],\n    body_bytes:               &[u8],\n    buffer_ptr:               *mut u8,\n    buffer_size:              usize,\n    required_without_newline: usize,\n    is_first_iteration:       bool,\n) -> Result<usize, usize>\n```\n\nPolicy:\n\n- If `buffer_size == 0`, logs an error and returns `Ok(0)` (no write).\n- If `header_bytes.len() >= buffer_size`, logs an error and returns `Ok(0)`.\n- If `required_without_newline >= buffer_size - 1`:\n  - On the **first** iteration, returns `Err(dynamic_size)` where `dynamic_size = required_without_newline + 2`. The caller will allocate a heap buffer of at least this size and retry.\n  - On the **second** iteration, calls `copy_truncated_log_line_into_buffer` and returns `Ok(offset)`, ensuring the buffer is filled as much as possible and ends with a newline if possible.\n- Otherwise, calls `copy_full_log_line_into_buffer` and returns `Ok(offset)`.\n\n### Copying and Newline Handling\n\nBoth the full and truncated paths eventually call `ensure_trailing_newline_for_buffer`:\n\n```rust\npub fn ensure_trailing_newline_for_buffer(\n    &self,\n    buffer_ptr:         *mut u8,\n    buffer_size:        usize,\n    current_offset:     usize,\n) -> usize\n```\n\nSemantics:\n\n- If `buffer_size == 0`, returns 0.\n- If `current_offset == 0`, writes `b'\\n'` at position 0 and returns 1.\n- If `current_offset > buffer_size`, clamps to `buffer_size`.\n- Checks the final written byte:\n  - If it is `\\n`, returns `current_offset` unchanged.\n  - If not and `current_offset < buffer_size`, appends a `\\n` and increments the offset.\n  - If not and `current_offset == buffer_size`, logs a warning and leaves the buffer as-is.\n\nThus, writers can assume that, whenever feasible, each emitted log line terminates with exactly one newline.\n\n## Flushing to the Log File\n\n`flush_buffer_to_log_file` writes a buffer into the underlying `FILE*`:\n\n```rust\npub fn flush_buffer_to_log_file(\n    &self,\n    buffer_ptr:    *mut u8,\n    buffer_size:   usize,\n    buffer_offset: usize,\n)\n```\n\n- If `fp()` is null, logs an error and drops the data.\n- If `buffer_ptr` is null, logs an error and returns.\n- If `buffer_offset == 0`, logs a trace and returns.\n- If `buffer_offset > buffer_size`, logs a warning and clamps.\n- Calls `libc::fwrite` with `write_len = min(buffer_offset, buffer_size)`.\n- If `written != write_len`, logs a warning.\n- Calls `libc::fflush` to ensure immediate persistence to the file.\n\n## Logging Entry Point: `logv`\n\nThe main interface required by the `Logv` trait is:\n\n```rust\nimpl Logv for PosixLogger {\n    fn logv(&mut self, format: *const u8, arguments: &[&str]) {\n        // ...\n    }\n}\n```\n\nExecution path:\n\n1. Check that `fp()` and `format` pointers are non-null.\n2. Capture the current timestamp and time components via `capture_current_time_components`.\n3. Build the thread identifier (`build_thread_identifier_label`).\n4. Construct the log body from the C-style format and arguments (`build_log_body_from_format_and_arguments`). If this fails, skip the line.\n5. Construct the header prefix (`construct_log_header_prefix`).\n6. Emit the combined header + body through `emit_log_line_with_two_phase_buffering`.\n\nThis method is designed for integration with a higher-level logging wrapper that provides the `format: *const u8` and `arguments: &[&str]` slices, often mirroring how LevelDB collects its arguments.\n\n## Usage\n\n### Basic Construction\n\n```rust\nuse bitcoinleveldb_posixlogger::PosixLogger;\nuse std::ffi::CString;\n\nfn main() {\n    unsafe {\n        // Open a C FILE* in append mode\n        let path = CString::new(\"/var/log/bitcoinleveldb.log\").unwrap();\n        let mode = CString::new(\"a\").unwrap();\n        let fp = libc::fopen(path.as_ptr(), mode.as_ptr());\n\n        if fp.is_null() {\n            panic!(\"failed to open log file\");\n        }\n\n        let mut logger = PosixLogger::new(fp);\n\n        // Prepare a C-style format string: \"%s: %s\" with two string args\n        let fmt = CString::new(\"%s: %s\").unwrap();\n        let format_ptr = fmt.as_ptr() as *const u8;\n\n        let args = [\"INFO\", \"database opened\"]; // &[&str]\n\n        logger.logv(format_ptr, &args);\n\n        // PosixLogger::drop will fclose(fp) automatically\n    }\n}\n```\n\n### Using as a Backend in a Larger System\n\nTypical integration with a broader `bitcoinleveldb` logging framework might look as follows (sketch):\n\n```rust\nstruct DbEnvironment {\n    logger: PosixLogger,\n}\n\nimpl DbEnvironment {\n    fn log_info(&mut self, msg: &str) {\n        use std::ffi::CString;\n\n        // Single %s placeholder\n        let fmt = CString::new(\"%s\").unwrap();\n        let format_ptr = fmt.as_ptr() as *const u8;\n        let args = [msg];\n\n        self.logger.logv(format_ptr, &args);\n    }\n}\n```\n\nThe environment or database wrapper is responsible for holding the `PosixLogger` as a member and wiring it into the rest of the system.\n\n## Error Reporting and Diagnostics\n\nThe implementation uses logging macros such as `trace!`, `debug!`, `info!`, `warn!`, and `error!`. These macros must be provided by your surrounding project (e.g., through a global logging facade or a local macro re-export). The crate assumes these macros are available and will not compile if they are not defined.\n\nThese internal logs can be helpful when validating the behavior of the logger:\n\n- Buffer sizing problems\n- Null pointers\n- Partial writes via `fwrite`\n- Time acquisition failures (`gettimeofday` / `localtime_r`)\n\nIn production, you may route these macros into a more global logging system for visibility.\n\n## Performance Considerations\n\n- **Stack buffer**: The common path uses a fixed-size stack buffer (`STACK_BUFFER_SIZE`) and avoids heap allocations for typical log lines.\n- **Heap buffer fallback**: On rare large messages, `emit_log_line_with_two_phase_buffering` allocates a single `Vec<u8>` sized precisely for the needed capacity.\n- **System calls**: Each log line ends with `fwrite` + `fflush`. This trades throughput for durability: logs are forced out promptly. Integrators optimizing for high-volume logging may wish to relax flushing frequency at a higher level.\n- **Copying**: Header and body bytes are copied once into the final buffer (`copy_full_log_line_into_buffer` or `copy_truncated_log_line_into_buffer`), and then written with a single system write call.\n\n## Safety and Concurrency\n\n`PosixLogger` does not itself perform any synchronization around the underlying `FILE*`. You must ensure that:\n\n- Either:\n  - Each `PosixLogger` has exclusive ownership of its `FILE*` and is used from a single thread; or\n  - External synchronization (e.g., a `Mutex<PosixLogger>`) is used when logging from multiple threads.\n\nThe internal thread identifier labeling assumes multiple threads may log, but the implementation does not attempt to serialize writes; serialization must be handled by the higher-level system.\n\n## License\n\nThis crate is licensed under the MIT License.\n\n## Caveats\n\n- The `Logv` and `Logger` traits, as well as the logging macros, are assumed to be provided externally (e.g., another crate in the same workspace). This crate focuses on the concrete POSIX implementation.\n- The implementation assumes a POSIX-like environment with `libc` and the usual C runtime facilities available.\n\n",
  "package_categories": [
    "network-programming",
    "development-tools",
    "filesystem",
    "os",
    "rust-patterns"
  ],
  "package_description": "POSIX-backed logging implementation for bitcoinleveldb-style systems that writes timestamped log lines directly to libc::FILE using two-phase buffering and C-compatible format strings.",
  "package_keywords": [
    "logging",
    "posix",
    "libc",
    "leveldb",
    "bitcoin"
  ]
}