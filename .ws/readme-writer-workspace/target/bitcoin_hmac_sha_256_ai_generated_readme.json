{
  "crate_name": "bitcoin-hmac-sha256",
  "full_readme_markdown": "# bitcoin-hmac-sha256\n\nA minimal, allocation-free implementation of HMAC-SHA-256 and RFC 6979 deterministic nonces tailored for Bitcoin-style cryptography and FFI use.\n\n> **Note:** This README was generated by an AI model. It may not be perfectly accurate, but it is intended to be technically solid and practically useful.\n\n---\n\n## Overview\n\nThis crate exposes two tightly scoped primitives:\n\n- `HmacSha256` – a streaming HMAC-SHA-256 construction over an internal `Sha256` implementation.\n- `Rfc6979HmacSha256` – a deterministic pseudo-random generator implementing RFC 6979 §3.2 using HMAC-SHA-256.\n\nThe primary design goals are:\n\n- **Exact behavioral compatibility** with common C/C++-style Bitcoin cryptography code.\n- **FFI-friendly** pointer-based interfaces that mirror C function signatures.\n- **No heap allocation**, predictable stack usage, and fixed-size state.\n- **Deterministic ECDSA nonce generation** for signing, via RFC 6979.\n\nThis is a low‑level crate intended for cryptographic libraries and bindings, not for general application-level hashing.\n\n---\n\n## Cryptographic background\n\n### HMAC-SHA-256\n\nHMAC (Hash-based Message Authentication Code) is defined as\n\n\\[\n\\mathrm{HMAC}_k(m) = H\\Big((k' \\oplus opad) \\,\\Vert\\, H((k' \\oplus ipad) \\,\\Vert\\, m)\\Big),\n\\]\n\nwhere\n\n- `H` is SHA-256,\n- `k'` is the key normalized to the block size of SHA-256 (64 bytes), either by zero-padding or hashing and then zero-padding,\n- `ipad = 0x36` repeated 64 times,\n- `opad = 0x5c` repeated 64 times.\n\n`HmacSha256` implements exactly this construction with an inner and outer `Sha256` state.\n\n### RFC 6979 deterministic nonces\n\nRFC 6979 describes how to derive deterministic ECDSA nonces from a secret key and message hash using an HMAC-based DRBG. This crate:\n\n- Implements the **HMAC-DRBG** procedure from RFC 6979 §3.2 using HMAC-SHA-256.\n- Maintains internal state `(K, V, retry)` in `Rfc6979HmacSha256`.\n- Provides `initialize`, `generate`, and `finalize` procedures via C-friendly functions.\n\nThis is useful in contexts where you must avoid reliance on ambient randomness and instead derive nonces purely from secret key material and the hashed message (e.g., Bitcoin ECDSA signatures).\n\n---\n\n## Features and non-goals\n\n### Features\n\n- HMAC-SHA-256 with a 32‑byte output.\n- Construct from raw key bytes (`*const u8`, length) or safe slices.\n- Streaming API: multiple `write` / `write_ref` calls before `finalize_into`.\n- RFC 6979 HMAC-based DRBG with explicit state.\n- C-compatible FFI functions for both primitives.\n- No allocations, fixed-size internal buffers.\n\n### Non-goals\n\n- No high-level key management or secret zeroization beyond what is explicitly implemented.\n- No asynchronous or multithread-safe abstractions by default.\n- No generic digest abstraction; this crate is specifically about HMAC-SHA-256.\n\n---\n\n## Safety and FFI model\n\nThe crate provides two layers of API:\n\n1. **Safe Rust methods** on the Rust types (`HmacSha256`, `Rfc6979HmacSha256`).\n2. **`unsafe` FFI-style functions** that operate on raw pointers, mirroring the original C implementation.\n\nThe FFI functions are `unsafe` from the caller’s perspective because they assume:\n\n- All passed pointers are valid for reads/writes of the corresponding length.\n- Lifetimes of the pointed-to data exceed the call duration.\n- The output buffers are at least 32 bytes where required.\n\nIf you can, prefer the safe methods; use the FFI-style functions only when integrating with C or C++.\n\n---\n\n## Types and functions\n\n### `HmacSha256`\n\n```rust\n#[derive(Getters, MutGetters, Setters)]\npub struct HmacSha256 {\n    outer: Sha256,\n    inner: Sha256,\n}\n```\n\n#### Construction\n\n```rust\nimpl HmacSha256 {\n    /// Construct from a raw pointer + length (FFI-style, unsafe boundary).\n    pub fn new(key: *const u8, keylen: usize) -> Self { ... }\n\n    /// Construct from a Rust byte slice (preferred).\n    #[inline]\n    pub fn new_with_key(key: &[u8]) -> Self { ... }\n\n    /// Construct directly from a slice.\n    pub fn from_slice(key: &[u8]) -> Self { ... }\n}\n```\n\n`from_slice` implements the standard HMAC key normalization:\n\n- If `key.len() <= 64`, it copies the key into a 64-byte array, zero-padding on the right.\n- If `key.len() > 64`, it hashes the key with `Sha256`, places the 32-byte digest into the beginning of the 64-byte array, and zero-pads the rest.\n- It then derives the `ipad` and `opad` states and initializes the inner and outer `Sha256` contexts.\n\n#### Writing and finalizing\n\n```rust\nimpl HmacSha256 {\n    /// Write data from a raw pointer + length (unsafe boundary).\n    pub fn write(&mut self, data: *const u8, len: usize) -> &mut HmacSha256 { ... }\n\n    /// Write data from a byte slice (safe, preferred).\n    #[inline]\n    pub fn write_ref(&mut self, data: &[u8]) -> &mut HmacSha256 { ... }\n\n    /// Finalize into the provided 32-byte output buffer.\n    pub fn finalize_into(&mut self, out: &mut [u8; HMAC_SHA256_OUTPUT_SIZE]) { ... }\n\n    /// Legacy finalize signature, takes `hash` by value.\n    pub fn finalize(&mut self, mut hash: [u8; HMAC_SHA256_OUTPUT_SIZE]) { ... }\n}\n```\n\nUsage pattern:\n\n```rust\nuse bitcoin_hmac_sha256::HmacSha256;\n\nconst HMAC_SHA256_OUTPUT_SIZE: usize = 32;\n\nlet key = b\"my hmac key\";\nlet msg1 = b\"hello\";\nlet msg2 = b\" world\";\n\nlet mut hmac = HmacSha256::new_with_key(key);\nhmac.write_ref(msg1)\n    .write_ref(msg2);\n\nlet mut tag = [0u8; HMAC_SHA256_OUTPUT_SIZE];\nhmac.finalize_into(&mut tag);\n\n// `tag` now holds HMAC-SHA-256(key, msg1 || msg2)\n```\n\n### `Rfc6979HmacSha256`\n\n```rust\n#[derive(Builder, Getters, Setters, MutGetters)]\npub struct Rfc6979HmacSha256 {\n    v:     [u8; 32],\n    k:     [u8; 32],\n    retry: i32,\n}\n```\n\nThis struct implements the internal state of the RFC 6979 HMAC-DRBG with SHA-256.\n\n#### Initialization\n\n```rust\npub fn rfc6979_hmac_sha256_initialize(\n    rng: *mut Rfc6979HmacSha256,\n    key: *const u8,\n    keylen: usize,\n) { ... }\n```\n\nThis function performs RFC 6979 §3.2 steps (b)–(f):\n\n- Sets `V` to 0x01 repeated.\n- Sets `K` to 0x00 repeated.\n- Mixes in the `key` via a sequence of HMAC invocations (`K`, `V`, and the input key), using the `HmacSha256` primitive.\n- Sets `retry` to `0`.\n\nThe `key` argument should be the RFC 6979 “key material” – usually the concatenation of the private key and hashed message, but that combination is handled by higher-level code.\n\n#### Generation\n\n```rust\npub fn rfc6979_hmac_sha256_generate(\n    rng: *mut Rfc6979HmacSha256,\n    mut out: *mut u8,\n    mut outlen: usize,\n) { ... }\n```\n\nThis function implements RFC 6979 §3.2(h):\n\n- Optionally performs an additional update step when `retry != 0`.\n- Iteratively HMACs the internal `V` value to produce pseudo-random output.\n- Writes exactly `outlen` bytes into `out`, possibly across multiple 32-byte blocks.\n- Sets `retry = 1` to mark that subsequent calls should do the \"extra\" update.\n\nTypical use in ECDSA:\n\n1. Call `rfc6979_hmac_sha256_initialize` with the concatenated key material.\n2. Call `rfc6979_hmac_sha256_generate` to obtain enough bytes for a candidate scalar `k`.\n3. Reduce modulo group order, check validity; if rejected, call `generate` again.\n\n#### Finalization\n\n```rust\npub fn rfc6979_hmac_sha256_finalize(rng: *mut Rfc6979HmacSha256) { ... }\n```\n\nThis function wipes `K` and `V` with zeros and resets `retry` to `0`. You should call this once you are done with the nonce generator to reduce key material lifetime in memory.\n\n---\n\n## FFI-style HMAC functions\n\nThe crate also provides C-like functions that operate on `HmacSha256` via raw pointers. These are useful when exposing the crate to C or C++ or when preserving existing foreign interfaces.\n\n```rust\npub fn hmac_sha256_initialize(\n    hash: *mut HmacSha256,\n    key: *const u8,\n    keylen: usize,\n) { ... }\n\npub fn hmac_sha256_write(\n    hash: *mut HmacSha256,\n    data: *const u8,\n    size: usize,\n) { ... }\n\npub fn hmac_sha256_finalize(\n    hash: *mut HmacSha256,\n    out32: *mut u8,\n) { ... }\n```\n\n### Example (FFI-like, unsafe)\n\n```rust\nuse bitcoin_hmac_sha256::{\n    HmacSha256,\n    hmac_sha256_initialize,\n    hmac_sha256_write,\n    hmac_sha256_finalize,\n};\n\nunsafe {\n    let key = b\"secret\";\n    let data = b\"message\";\n\n    // Memory owned on Rust side; passed to FFI-style API\n    let mut ctx: HmacSha256 = core::mem::zeroed();\n    let mut out = [0u8; 32];\n\n    hmac_sha256_initialize(&mut ctx, key.as_ptr(), key.len());\n    hmac_sha256_write(&mut ctx, data.as_ptr(), data.len());\n    hmac_sha256_finalize(&mut ctx, out.as_mut_ptr());\n\n    // `out` now contains the HMAC tag\n}\n```\n\n---\n\n## Usage with Cargo\n\nAdd the dependency:\n\n```toml\n[dependencies]\nbitcoin-hmac-sha256 = \"0.1.2\"\n```\n\nThe crate is licensed under MIT and targets the Rust **2024** edition.\n\n---\n\n## Security considerations\n\n- This crate provides **low-level primitives** only. It is not a full cryptographic subsystem.\n- It does not attempt to provide constant-time behavior across all operations beyond what direct, branch-minimal code implies. Review for your threat model.\n- Always treat keys and RFC 6979 state as sensitive. Use `rfc6979_hmac_sha256_finalize` to wipe DRBG state once done.\n- Do not reuse RFC 6979 key material across different algorithms or curves without a formal derivation.\n\nFor production systems, you should layer these primitives beneath a rigorously audited signing and key-handling framework.\n\n---\n\n## Testing and interoperability\n\nFor practical use, you should:\n\n- Verify HMAC-SHA-256 outputs against known-good test vectors (e.g., RFC 4231).\n- Verify RFC 6979 nonce streams against reference implementations for the same curve and key material.\n- Confirm that behavior matches the original C or C++ implementation you are migrating from, bit-for-bit.\n\n---\n\n## License\n\nThis crate is distributed under the **MIT** license. See your `Cargo.toml` or accompanying license file for details.\n",
  "package_categories": [
    "cryptography",
    "algorithms",
    "network-programming",
    "finance",
    "no-std"
  ],
  "package_description": "Low-level, allocation-free HMAC-SHA-256 and RFC6979 deterministic nonce generator with FFI-friendly APIs, tailored for Bitcoin-style cryptography.",
  "package_keywords": [
    "hmac",
    "sha256",
    "rfc6979",
    "bitcoin",
    "ecdsa"
  ]
}