{
  "crate_name": "bitcoin-string",
  "full_readme_markdown": "# bitcoin-string\n\nLocale‑independent, consensus‑compatible string, integer, and encoding utilities extracted from the Bitcoin Core codebase and ported to Rust.\n\nThis crate focuses on *reproducing the exact control‑flow and edge‑case semantics* of the original C++ helpers that operate on textual data, numeric literals, base encodings, and fixed‑point monetary values. It is designed for projects that:\n\n- interact with Bitcoin data structures or wire formats,\n- must remain byte‑for‑byte compatible with existing Bitcoin Core behaviour,\n- require constant‑time comparisons or strict parsers for untrusted input.\n\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate in every detail, but it should be a very good approximation of the crate's intent and usage. Always consult the source for definitive behaviour.\n\n---\n\n## Features at a Glance\n\n- **ASCII‑only, locale‑independent case conversion**\n  - [`ToUpper`] and [`ToLower`] traits implemented for `String` and `u8`.\n  - Deterministic, 7‑bit ASCII semantics independent of the process locale.\n\n- **String sanitisation for untrusted text**\n  - [`sanitize_string`] with configurable [`SafeChars`] policies mirroring Bitcoin Core:\n    - `SAFE_CHARS_DEFAULT` — permissive text & URLs.\n    - `SAFE_CHARS_UA_COMMENT` — user‑agent comments.\n    - `SAFE_CHARS_FILENAME` — filenames.\n    - `SAFE_CHARS_URI` — URI components.\n\n- **Bilingual message abstraction**\n  - [`BilingualStr`] carries both `original` (English) and `translated` strings.\n  - Centralised translation dispatch via [`set_translation_fn`] and [`bilingual_tr`].\n  - `bilingual_format!` macro for dual‑language formatted strings.\n\n- **Robust integer parsing utilities**\n  - [`parse_integral`] and type‑specific wrappers (`parse_int32`, `parse_uint64`, …) with explicit success/failure and C‑style out‑pointers.\n  - [`to_integral`] — strict `Option<T>` parser with no whitespace, no leading `+`, and full‑string consumption.\n  - [`locale_independent_atoi`] — exact behavioural clone of C `atoi`/`atoi64` in the C locale, including handling of \"+-\".\n\n- **Fixed‑point and monetary parsing/formatting**\n  - [`parse_fixed_point`] — parse JSON‑syntax numbers into signed 64‑bit fixed‑point values with bounded exponent and mantissa.\n  - [`format_money`] — format `Amount` (Bitcoin amount in satoshis) as decimal coins, trimming redundant trailing zeros while preserving precision constraints.\n  - [`parse_money`] — parse coin‑denominated string amounts (e.g. `\"0.0034\"`) into internal `Amount`, with strict range checks.\n\n- **Base32 / Base64 encoding and decoding**\n  - RFC 4648 compliant encoders: [`encode_base32_bytes`], [`encode_base32`], [`encode_base64_bytes`], [`encode_base64`].\n  - Multiple decoders mirroring historical Bitcoin and Tor/I2P paths:\n    - [`decode_base32_bytes`] — C‑string, padded RFC 4648.\n    - [`decode_base32_bytes_strict`] — Rust `&str`, padded RFC 4648.\n    - [`decode_base32_bytes_nopad_lower`] — lower‑case alphabet, *no* padding, strict tail‑bit checks.\n    - [`decode_base32`] — decode to UTF‑8 `String`.\n    - [`decode_base64_bytes`] — C‑string, padded RFC 4648.\n    - [`decode_base64`] — decode to UTF‑8 `String`.\n  - Shared internal [`convert_bits`] primitive implementing the `FROM → TO` bit‑group mapping logic (as per BIP‑173 and RFC 4648), reusable for custom alphabets.\n\n- **Hex utilities**\n  - [`is_hex`] — validate even‑length, fully‑hex byte strings.\n  - [`is_hex_number`] — validate optional `0x`/`0X` prefixed hex literals.\n  - [`parse_hex`] — parse hex dumps with embedded ASCII whitespace.\n  - [`hex_str`] — lower‑case hex encoding of raw bytes.\n\n- **Timing‑resistant comparison**\n  - [`timing_resistant_equal`] — constant‑time (in the length of `a`) comparison over any `AsRef<[u8]>` type; suitable for secret material comparisons.\n\n- **General string helpers**\n  - [`trim_string`] — configurable trim pattern.\n  - [`remove_prefix`] — prefix stripping.\n  - [`join`] and [`make_unordered_list`] — list composition.\n  - [`valid_as_cstring`] — check for absence of embedded NUL (`\\0`).\n  - [`to_string`] — locale‑independent formatting alias for `format!`.\n  - [`has_prefix`] — const‑generic, byte‑slice prefix test.\n  - [`capitalize`] — ASCII‑only first‑character capitalization.\n\nAll functions are instrumented with [`tracing`] so that call‑site, control‑flow, and error conditions can be observed precisely during testing and production debugging.\n\n---\n\n## Installation\n\n```toml\n[dependencies]\nbitcoin-string = \"0.1.19\"\n```\n\nThis crate targets Rust **edition 2021** and is licensed under **MIT**.\n\n---\n\n## Core Concepts and Guarantees\n\n### Locale‑independent parsing and formatting\n\nMany standard library functions (both in C and some higher‑level languages) exhibit locale‑dependent behaviour for numbers, whitespace, and casing rules. Bitcoin consensus and network code cannot depend on locale, because that would fragment nodes by environment.\n\n`bitcoin-string` intentionally restricts itself to **ASCII and locale‑independent semantics**:\n\n- Numeric parsers (`parse_integral`, `parse_fixed_point`, `parse_money`, `to_integral`, `locale_independent_atoi`) treat input as if processed in the C locale.\n- Case transforms operate strictly on ASCII ranges `A–Z` and `a–z` and leave all other bytes untouched.\n\nThis constraint is crucial when strings represent consensus‑critical data such as numeric fields in transactions, RPC inputs, or on‑disk configuration.\n\n### Fixed‑point representation and overflow discipline\n\n`parse_fixed_point` interprets a JSON number (roughly the grammar from <https://json.org/number.gif>) and maps it into a signed 64‑bit integer with a caller‑supplied decimal *scale* (`decimals`).\n\nConceptually, it computes\n\n\\[\n\\text{mantissa} = \\left\\lfloor x \\times 10^{d} \\right\\rfloor\n\\]\n\nsubject to the invariant\n\n\\[\n|\\text{mantissa}| < 10^{18}\n\\]\n\nwhere `x` is the input real and `d` is `decimals`. Internally it:\n\n1. Parses sign, integral, fractional, and exponential parts.\n2. Accumulates an integer mantissa by scaling the previous mantissa by 10 and adding the new digit, while counting trailing zeros separately to delay scaling (see [`process_mantissa_digit`]).\n3. Applies exponent and decimal point offsets, producing an effective power of 10.\n4. Rejects any underflow or overflow: invalid ranges, exponent outside `[0, 17]`, or mantissa exceeding `10^18 − 1` in magnitude.\n\nThis careful control‑flow is engineered to match the original Bitcoin Core implementation, so that any system using these helpers in Rust remains consistent with C++ peers.\n\n### Timing‑attack resistance\n\n[`timing_resistant_equal`] compares two secrets `a` and `b` such that the running time depends solely on the length of `a`, **not** on the first differing byte position. It does this by:\n\n- XOR‑ing the lengths of `a` and `b` into an accumulator;\n- XOR‑ing every byte of `a` with the corresponding byte of `b` (cycling through `b` if shorter) and OR‑ing the result into the accumulator;\n- returning `acc == 0`.\n\nThis prevents simple timing attacks that exploit early‑exit comparisons.\n\n> **Important**: While this function is designed to be timing‑resistant at the library level, overall application security depends on compiler, CPU, and surrounding control‑flow. Use in conjunction with other standard hardening techniques.\n\n---\n\n## Usage Examples\n\n### Case conversion and sanitisation\n\n```rust\nuse bitcoin_string::{ToUpper, ToLower, sanitize_string, SafeChars};\n\nlet s = \"Hello, World!\".to_string();\nassert_eq!(s.to_upper(), \"HELLO, WORLD!\");\nassert_eq!(s.to_lower(), \"hello, world!\");\n\n// Sanitize for generic text / URLs\nlet raw = \"Visit https://example.com/?q=<script>\";\nlet clean = sanitize_string(raw, Some(SafeChars::SAFE_CHARS_URI as i32));\n// `clean` contains only characters from the SAFE_CHARS_URI set.\n```\n\n### Bilingual strings and translations\n\n```rust\nuse bitcoin_string::{BilingualStr, untranslated, bilingual_tr, set_translation_fn};\n\n// Mark a string as untranslated: original == translated\nlet msg: BilingualStr = untranslated(\"Wallet loaded\");\nassert_eq!(msg.original(), \"Wallet loaded\");\nassert_eq!(msg.translated(), \"Wallet loaded\");\n\n// Install a trivial translation function (e.g. from your i18n layer)\nset_translation_fn(Some(|s: &str| {\n    if s == \"Wallet loaded\" { \"Portefeuille chargé\".to_owned() } else { s.to_owned() }\n}));\n\nlet localized = bilingual_tr(\"Wallet loaded\");\nassert_eq!(localized.original(), \"Wallet loaded\");\nassert_eq!(localized.translated(), \"Portefeuille chargé\");\n```\n\nUsing the `bilingual_format!` macro (from the `tinyformat` module):\n\n```rust\nuse bitcoin_string::{BilingualStr, bilingual_tr};\nuse bitcoin_string::bilingual_format; // macro is exported at crate root\n\nlet tmpl = bilingual_tr(\"Processed {} transactions\");\nlet count = 42;\n\nlet formatted = bilingual_format!(&tmpl, count);\n// formatted.original()  == \"Processed 42 transactions\"\n// formatted.translated() == translation of that template with `42` substituted\n```\n\n### Integer parsing\n\n```rust\nuse bitcoin_string::{parse_int32, parse_uint64, to_integral, locale_independent_atoi};\n\n// C‑style parser with out‑pointer\nlet mut v: i32 = 0;\nlet ok = parse_int32(&\"123\".to_string(), &mut v as *mut i32);\nassert!(ok);\nassert_eq!(v, 123);\n\n// Strict parser that forbids whitespace and leading '+'\nassert_eq!(to_integral::<i64>(\"42\"), Some(42));\nassert_eq!(to_integral::<i64>(\" 42\"), None);\nassert_eq!(to_integral::<i64>(\"+42\"), None);\n\n// `atoi`‑like behaviour\nlet x: i32 = locale_independent_atoi(\"  +123\");\nlet y: i32 = locale_independent_atoi(\"+-5\");\nassert_eq!(x, 123);\nassert_eq!(y, 0); // matches C `atoi(\"+-5\")`\n```\n\n### Fixed‑point parsing\n\n```rust\nuse bitcoin_string::parse_fixed_point;\n\nlet mut amount: i64 = 0;\n// Interpret as 2 decimal places: \"1.23\" → 123\nlet ok = parse_fixed_point(\"1.23\", 2, &mut amount as *mut i64);\nassert!(ok);\nassert_eq!(amount, 123);\n\n// Out‑of‑range exponents or mantissas are rejected\nassert!(!parse_fixed_point(\"1e20\", 0, std::ptr::null_mut()));\n```\n\n### Base32 / Base64 encoding and decoding\n\n```rust\nuse bitcoin_string::{encode_base32, decode_base32_bytes_strict};\nuse bitcoin_string::{encode_base64, decode_base64};\n\nlet data = b\"hello\";\nlet b32 = encode_base32(data, Some(true));\nlet mut invalid = false;\nlet roundtrip = decode_base32_bytes_strict(&b32, Some(&mut invalid as *mut bool));\nassert!(!invalid);\nassert_eq!(roundtrip, data);\n\nlet s = \"hello\".to_string();\nlet encoded = encode_base64(&s);\nlet decoded = decode_base64(&encoded, None);\nassert_eq!(decoded, s);\n```\n\n### Hex utilities\n\n```rust\nuse bitcoin_string::{is_hex, is_hex_number, parse_hex, hex_str};\n\nassert!(is_hex(\"00ff10\"));\nassert!(!is_hex(\"0xff\"));\nassert!(is_hex_number(\"0xff\"));\n\nlet bytes = parse_hex(\"00 ff 10\");\nassert_eq!(hex_str(&bytes), \"00ff10\");\n```\n\n### Timing‑resistant equality\n\n```rust\nuse bitcoin_string::timing_resistant_equal;\n\nlet secret_a = b\"super_secret_key\".to_vec();\nlet secret_b = b\"super_secret_key\".to_vec();\nlet secret_c = b\"super_secret_keZ\".to_vec();\n\nassert!(timing_resistant_equal(&secret_a, &secret_b));\nassert!(!timing_resistant_equal(&secret_a, &secret_c));\n```\n\n---\n\n## Integration Notes\n\n- The crate depends on [`tracing`] for structured logging. In a production application, install an appropriate subscriber (e.g. `tracing-subscriber`) to capture diagnostics.\n- Monetary helpers rely on `Amount`, `COIN`, and `money_range` from the surrounding Bitcoin domain. When used outside the `bitcoin-rs` tree, ensure that these are wired consistently with Bitcoin Core semantics (e.g. `COIN = 100_000_000` for sats per BTC).\n- Many parsers accept raw pointers (for C‑compatibility). In idiomatic Rust code, you can often pass `std::ptr::null_mut()` when you want to check validity but discard the result.\n\n---\n\n## Safety and Security Considerations\n\n- **Pointer arguments**: functions like `parse_integral`, `parse_fixed_point`, `parse_int32`, etc., mirror the original C++ signature pattern and accept raw pointers. The implementations are careful, but the caller is responsible for providing valid, appropriately aligned pointers or `null_mut()`.\n- **Constant‑time claims**: `timing_resistant_equal` is structured to avoid early returns and to depend only on the length of `a`, but micro‑architectural details can still leak information. For critical key‑material handling, consider layering it with additional defences.\n- **Sanitisation**: [`sanitize_string`] enforces an *allowlist* of characters. Pick the correct [`SafeChars`] rule for your context. For example, URIs and filenames have different constraints.\n\n---\n\n## License\n\nThis crate is distributed under the **MIT** license.\n\nThe upstream repository is hosted at: <https://github.com/klebs6/bitcoin-rs>\n\n---\n\n## Provenance\n\nThis crate is part of the `bitcoin-rs` effort to provide a faithful, well‑structured Rust port of the Bitcoin Core codebase. The implementation choices are driven by the goal of **behavioural equivalence**, not by API minimalism. Consequently, some functions retain C‑style signatures and pointer‑based semantics to preserve compatibility with existing call sites.\n\nIf you require different ergonomics (e.g. pure `Result<T, E>` APIs), consider wrapping these primitives in your own higher‑level abstractions while keeping this crate as the compatibility layer.\n\n[`tracing`]: https://docs.rs/tracing\n[`SafeChars`]: #features-at-a-glance\n[`BilingualStr`]: #bilingual-message-abstraction\n[`sanitize_string`]: #case-conversion-and-sanitisation\n[`set_translation_fn`]: #bilingual-strings-and-translations\n[`bilingual_tr`]: #bilingual-strings-and-translations\n[`parse_integral`]: #integer-parsing\n[`parse_fixed_point`]: #fixed-point-parsing\n[`parse_money`]: #fixed-point-and-monetary-parsingformatting\n[`format_money`]: #fixed-point-and-monetary-parsingformatting\n[`encode_base32_bytes`]: #base32--base64-encoding-and-decoding\n[`encode_base32`]: #base32--base64-encoding-and-decoding\n[`encode_base64_bytes`]: #base32--base64-encoding-and-decoding\n[`encode_base64`]: #base32--base64-encoding-and-decoding\n[`decode_base32_bytes`]: #base32--base64-encoding-and-decoding\n[`decode_base32_bytes_strict`]: #base32--base64-encoding-and-decoding\n[`decode_base32_bytes_nopad_lower`]: #base32--base64-encoding-and-decoding\n[`decode_base32`]: #base32--base64-encoding-and-decoding\n[`decode_base64_bytes`]: #base32--base64-encoding-and-decoding\n[`decode_base64`]: #base32--base64-encoding-and-decoding\n[`convert_bits`]: #base32--base64-encoding-and-decoding\n[`timing_resistant_equal`]: #timing-resistant-equality\n[`trim_string`]: #general-string-helpers\n[`remove_prefix`]: #general-string-helpers\n[`join`]: #general-string-helpers\n[`make_unordered_list`]: #general-string-helpers\n[`valid_as_cstring`]: #general-string-helpers\n[`to_string`]: #general-string-helpers\n[`has_prefix`]: #general-string-helpers\n[`capitalize`]: #general-string-helpers\n[`is_hex`]: #hex-utilities\n[`is_hex_number`]: #hex-utilities\n[`parse_hex`]: #hex-utilities\n[`hex_str`]: #hex-utilities\n[`process_mantissa_digit`]: #fixed-point-representation-and-overflow-discipline\n[`to_integral`]: #integer-parsing\n[`locale_independent_atoi`]: #integer-parsing\n[`parse_int32`]: #integer-parsing\n[`parse_uint64`]: #integer-parsing\n[`ToLower`]: #features-at-a-glance\n[`ToUpper`]: #features-at-a-glance\n",
  "package_categories": [
    "cryptography",
    "encoding",
    "parsing",
    "data-structures",
    "development-tools"
  ],
  "package_description": "Bitcoin Core–compatible string, integer, hex, Base32/Base64, and fixed-point monetary utilities with locale-independent semantics and timing-resistant comparison.",
  "package_keywords": [
    "bitcoin",
    "string",
    "base32",
    "base64",
    "hex"
  ]
}