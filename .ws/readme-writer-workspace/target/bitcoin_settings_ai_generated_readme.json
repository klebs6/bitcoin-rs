{
  "crate_name": "bitcoin-settings",
  "full_readme_markdown": "# bitcoin-settings\n\nA faithful, low-level Rust port of Bitcoin Core's configuration and runtime settings machinery. This crate models the full precedence stack (forced values, command-line arguments, read–write settings file, and read-only config file sections) and reproduces Bitcoin Core's historical quirks around negation, precedence, and array flattening.\n\n> NOTE: This README was generated by an AI model and may not be 100% accurate, though it should be a close and useful description of the crate.\n\n---\n\n## Overview\n\n`bitcoin-settings` provides a small but precise abstraction over Bitcoin-style settings resolution. It is intentionally close to the original C++ implementation to enable:\n\n- Bit‑for‑bit compatible behavior with Bitcoin Core's `GetSetting` / `GetSettingsList` / `MergeSettings` logic.\n- Deterministic, pretty-printed JSON persistence of runtime settings.\n- Fine-grained introspection of where an effective value \"came from\" in the precedence chain.\n\nThe crate assumes a JSON‑like value type (`UniValue`) and wraps it in a `SettingsValue` newtype that exposes the subset of behavior needed for the Bitcoin settings algorithm.\n\nThis is not a general configuration framework; it is an emulation of Bitcoin Core's settings semantics suitable for interoperable tooling, alternative node implementations, and integration tests that need to match Core behavior.\n\n---\n\n## Core Concepts and Data Model\n\n### Sources and Precedence\n\nSettings are aggregated from multiple sources with the following **strict precedence order** (highest to lowest):\n\n1. `FORCED` – hard‑wired overrides not exposed to the user.\n2. `COMMAND_LINE` – `-foo` and `-nofoo` style arguments.\n3. `RW_SETTINGS` – runtime read–write settings file (e.g. GUI preferences).\n4. `CONFIG_FILE_NETWORK_SECTION` – `bitcoin.conf` entries inside a named `[section]` (e.g. `[main]`, `[test]`).\n5. `CONFIG_FILE_DEFAULT_SECTION` – `bitcoin.conf` entries before any explicit section.\n\nThese are represented by the enum:\n\n```rust\npub enum Source {\n    FORCED,\n    COMMAND_LINE,\n    RW_SETTINGS,\n    CONFIG_FILE_NETWORK_SECTION,\n    CONFIG_FILE_DEFAULT_SECTION,\n}\n```\n\n### Settings Storage\n\nAll sources are combined into a single `Settings` struct:\n\n```rust\npub struct Settings {\n    forced_settings:      HashMap<String, SettingsValue>,\n    command_line_options: HashMap<String, Vec<SettingsValue>>,\n    rw_settings:          HashMap<String, SettingsValue>,\n    ro_config:            HashMap<String, HashMap<String, Vec<SettingsValue>>>,\n}\n```\n\n- `forced_settings` – single value per key.\n- `command_line_options` – potentially multiple occurrences per key (`-foo=1 -foo=2`).\n- `rw_settings` – single value per key, persisted via `write_settings`.\n- `ro_config` – hierarchical: `section -> name -> values`, where `section == \"\"` encodes the default section.\n\nThe crate uses `derive_builder` and `getset` to provide convenient builders and accessors.\n\n### Value Representation: `SettingsValue`\n\n```rust\n#[derive(Debug, Clone)]\npub struct SettingsValue(pub UniValue);\n```\n\n`SettingsValue` is a thin newtype around `UniValue`, and is intended to mirror Bitcoin Core's use of `UniValue` for settings. It supports:\n\n- Booleans, integers, strings, null, and arrays (arrays are flattened in some APIs).\n- Display as JSON via `fmt::Display` (delegates to `UniValue::write`).\n- Semantic equality via stringified JSON (`PartialEq`, `Eq`).\n- Fast negation detection via `is_false()` (true iff the inner value is a JSON boolean `false`).\n\n### Spans and Negation Semantics: `SettingsSpan`\n\n```rust\npub struct SettingsSpan {\n    data: *const SettingsValue,\n    size: usize,\n}\n```\n\n`SettingsSpan` is a low-level, pointer-based view over a contiguous range of `SettingsValue`s. Its role is to express Bitcoin Core's **negation rules** without allocation or copying:\n\n- A sequence is considered **negated** if its last value is `false`.\n- All values at and before the last boolean `false` are treated as *negated* and therefore excluded from effective iteration.\n- `begin()` returns a pointer to the first *non‑negated* value.\n- `end()` returns the standard one‑past‑the‑end pointer.\n- `empty()` is true if the span is logically empty after taking negation into account.\n\nThis is crucial for modeling user behavior like:\n\n```text\n-foo=1 -foo=2 -foo=0   # final `false` negates earlier settings\n```\n\nThe final `false` does not become a value; it cancels prior ones.\n\n> ⚠ Safety: `SettingsSpan` is fundamentally unsafe: it stores raw pointers and assumes the backing allocations remain alive for the duration of use. The crate's public functions (`get_setting`, `get_settings_list`, etc.) are written to respect these invariants.\n\n### Tuple Formatting: `SettingsTuple`\n\n```rust\npub struct SettingsTuple((String, SettingsValue));\n```\n\n`SettingsTuple` provides a `Display` impl that renders as a single‑entry JSON object, escaping the key and delegating to `SettingsValue` for the value. This directly mirrors C++ code that prints tuples as JSON objects for logging or RPC responses.\n\n---\n\n## Reading and Writing Settings Files\n\nThe crate supports JSON‑encoded settings files for runtime persistence of `rw_settings`.\n\n### Writing: `write_settings`\n\n```rust\npub fn write_settings(\n    path:   &std::path::Path,\n    values: &HashMap<String, SettingsValue>,\n    errors: &mut Vec<String>,\n) -> bool\n```\n\nBehavior:\n\n- Constructs a pretty‑printed JSON object with 4‑space indentation.\n- Sorts keys lexicographically for deterministic output (aids debugging and tests).\n- Serializes each `SettingsValue` via its `Display` implementation.\n- On any I/O error, logs and pushes a descriptive message to `errors` and returns `false`.\n- On success, flushes the file descriptor, returns `true`.\n\nExample:\n\n```rust\nuse bitcoin_settings::{SettingsValue, write_settings};\nuse std::{collections::HashMap, path::PathBuf};\n\nlet mut map = HashMap::new();\nmap.insert(\"maxconnections\".into(), SettingsValue::from(64_i64));\nmap.insert(\"server\".into(), SettingsValue::from(true));\n\nlet mut errors = Vec::new();\nlet path = PathBuf::from(\"settings.json\");\n\nif !write_settings(&path, &map, &mut errors) {\n    eprintln!(\"failed to write settings: {errors:?}\");\n}\n```\n\n### Reading: `read_settings`\n\n```rust\npub fn read_settings(\n    path:   &std::path::Path,\n    values: &mut HashMap<String, SettingsValue>,\n    errors: &mut Vec<String>,\n) -> bool\n```\n\nBehavior:\n\n- Clears `values` and `errors` at the beginning.\n- Silently succeeds if `path` does not exist.\n- Reads the entire file into memory and parses it as a `UniValue`.\n- Requires the top‑level value to be a JSON object; otherwise, records an error.\n- Populates `values` with `key -> SettingsValue(value)` pairs.\n- If a key appears multiple times in the file, insertion triggers a warning and an error entry (the last value wins in the map).\n- Returns `true` iff `errors` remains empty.\n\nExample:\n\n```rust\nuse bitcoin_settings::{read_settings, SettingsValue};\nuse std::{collections::HashMap, path::Path};\n\nlet mut map: HashMap<String, SettingsValue> = HashMap::new();\nlet mut errors = Vec::new();\n\nif read_settings(Path::new(\"settings.json\"), &mut map, &mut errors) {\n    if let Some(v) = map.get(\"maxconnections\") {\n        println!(\"maxconnections = {v}\");\n    }\n} else {\n    eprintln!(\"error(s) reading settings.json: {errors:?}\");\n}\n```\n\n---\n\n## Merging and Querying Settings\n\nThe heart of this crate is the replication of Bitcoin's settings merge algorithm, including historical corner cases.\n\n### Low-Level Merge Driver: `merge_settings`\n\n```rust\npub fn merge_settings<F>(\n    settings: &Settings,\n    section:  &String,\n    name:     &String,\n    mut fn_:  F,\n) where\n    F: FnMut(SettingsSpan, Source),\n```\n\n`merge_settings` traverses all sources (in canonical precedence order) and calls your callback `fn_` with a `SettingsSpan` and the corresponding `Source` tag whenever that source has data for `name`.\n\nYou can implement arbitrary merge policies by interpreting the span:\n\n- `span.empty()` – is there any effective value?\n- `span.last_negated()` – does the last value represent a negation?\n- `span.negated()` – how many values from the end are negated?\n- `span.begin() .. span.end()` – slice of *effective* values (skips negated ones).\n\nThis function is the foundation for `get_setting`, `get_settings_list`, and `only_has_default_section_setting`.\n\n### Single Effective Value: `get_setting`\n\n```rust\npub fn get_setting(\n    settings:                      &Settings,\n    section:                       &str,\n    name:                          &str,\n    ignore_default_section_config: bool,\n    get_chain_name:                bool,\n) -> SettingsValue\n```\n\nThis function computes the **effective single value** for a given option after taking all sources, precedence, negation, and certain legacy quirks into account.\n\nKey behaviors:\n\n- Forced values win outright.\n- For non‑config‑file sources, **later** values override earlier ones.\n- For config file values (both network‑specific and default sections), precedence is **reversed** — the first assignment wins — except when `get_chain_name == true` (special case for chain selection semantics).\n- `ignore_default_section_config == true` suppresses values coming from the default config file section, *except* when the last value is an explicit negation, which is always honored.\n- When `get_chain_name == true`, negated command‑line settings are silently skipped (mirroring Core's idiosyncratic treatment of `-testnet`/`-regtest` negations).\n- If there is no effective value at all, the function returns JSON `null`.\n\nExample (simple, non‑chain setting):\n\n```rust\nuse bitcoin_settings::{Settings, SettingsValue, get_setting};\n\nlet mut settings = Settings::default();\n\n// Suppose command line had: -maxconnections=20 -maxconnections=40\nsettings.command_line_options_mut()\n    .insert(\"maxconnections\".into(), vec![\n        SettingsValue::from(20_i64),\n        SettingsValue::from(40_i64),\n    ]);\n\nlet v = get_setting(&settings, \"\", \"maxconnections\", false, false);\nprintln!(\"effective maxconnections = {v}\"); // 40\n```\n\n### All Effective Values: `get_settings_list`\n\n```rust\npub fn get_settings_list(\n    settings:                      &Settings,\n    section:                       &String,\n    name:                          &String,\n    ignore_default_section_config: bool,\n) -> Vec<SettingsValue>\n```\n\nThis function returns **all effective values** in their final merge order, not just the last one. It also implements several compatibility quirks:\n\n- Negated values (boolean `false`) terminate effective values at their position and mark lower‑priority sources as ignored.\n- However, config file values can temporarily resurrect as **zombie values** if a later command‑line negation is followed by a non‑negated value; in that particular case, config file values become visible again but earlier command‑line values remain ignored.\n- Any `SettingsValue` containing a JSON array is **flattened** into multiple scalar values in the result.\n\nThis is primarily useful for options that are conceptually lists (e.g. addnodes, whitelists).\n\nExample:\n\n```rust\nuse bitcoin_settings::{Settings, SettingsValue, get_settings_list, sv_json};\n\nlet mut settings = Settings::default();\n\n// Config file: addnode=[\"1.2.3.4\", \"5.6.7.8\"]\nsettings.ro_config_mut()\n    .entry(\"\".into())               // default section\n    .or_default()\n    .insert(\"addnode\".into(), vec![sv_json(\"[\\\"1.2.3.4\\\", \\\"5.6.7.8\\\"]\")]);\n\nlet values = get_settings_list(&settings, &\"\".to_string(), &\"addnode\".to_string(), false);\nfor v in values {\n    println!(\"addnode => {v}\");\n}\n// prints each IP as separate SettingsValue\n```\n\n### Detecting Default-Section-Only Values\n\n```rust\npub fn only_has_default_section_setting(\n    settings: &Settings,\n    section:  &str,\n    name:     &str,\n) -> bool\n```\n\nThis helper answers the question:\n\n> \"Is this option set in the default config file section and *not* overridden by any higher‑priority setting (command line, RW settings, or network section)?\"\n\nIt is used to produce warnings about values that are present but effectively ignored, so that users understand why their `bitcoin.conf` changes had no effect.\n\nExample:\n\n```rust\nuse bitcoin_settings::{Settings, SettingsValue, only_has_default_section_setting};\n\nlet mut settings = Settings::default();\n\n// Default section: txindex=1\nsettings.ro_config_mut()\n    .entry(\"\".into())\n    .or_default()\n    .insert(\"txindex\".into(), vec![SettingsValue::from(true)]);\n\nlet ignored = only_has_default_section_setting(&settings, \"main\", \"txindex\");\nprintln!(\"txindex default-only? {ignored}\"); // true if not overridden\n```\n\n---\n\n## Utility: JSON Literal Construction\n\n### `sv_json`\n\n```rust\npub fn sv_json(j: &str) -> SettingsValue\n```\n\nParses a JSON literal into a `SettingsValue` using `UniValue::read`. This is primarily intended for tests and concise construction of complex values (arrays, objects) without hand‑assembling `UniValue` trees.\n\n- Panics if `j` is not valid JSON from `UniValue`'s perspective.\n\nExample:\n\n```rust\nuse bitcoin_settings::sv_json;\n\nlet v = sv_json(\"[1, 2, 3]\");\nprintln!(\"v = {v}\"); // prints the JSON array\n```\n\n---\n\n## Safety and Correctness Considerations\n\n- `SettingsSpan` internally uses raw pointers. All public APIs consuming `SettingsSpan` are carefully written to keep referents alive for the duration of the call. Do not store `SettingsSpan` beyond the immediate callback in `merge_settings`.\n- Comparison (`PartialEq`) for `SettingsValue` is performed by serializing both sides and comparing the resulting strings. This matches Bitcoin Core's behavior but is more expensive than structural comparison. Prefer identity or pointer comparison if you maintain external caches.\n- JSON serialization and deserialization rely on `UniValue`. For strict compatibility with Bitcoin Core, ensure you build `UniValue` with matching parser and writer options.\n\n---\n\n## Intended Use Cases\n\nThis crate is suitable for:\n\n- Alternative Bitcoin nodes that want **drop‑in‑compatible settings resolution**.\n- External tooling that interprets or manipulates Core's JSON settings files.\n- Integration tests verifying that new logic preserves or only intentionally diverges from Core's historical behavior.\n- Research or refactoring efforts that seek to decouple user‑facing configuration semantics from a particular implementation language.\n\nIt is intentionally **not** a general-purpose configuration framework; its design is constrained by compatibility with an existing, widely deployed implementation.\n\n---\n\n## License and Repository\n\n- License: MIT\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\nWithin that repository, this crate lives under the `bitcoin-settings` package. Consult the repository for examples, tests, and integration context.\n",
  "package_categories": [
    "cryptography",
    "network-programming",
    "config",
    "parsing",
    "development-tools"
  ],
  "package_description": "Bitcoin Core-compatible configuration and runtime settings layer in Rust, replicating source precedence, negation semantics, list flattening, and JSON persistence using UniValue-backed SettingsValue.",
  "package_keywords": [
    "bitcoin",
    "settings",
    "configuration",
    "univalue",
    "config-file"
  ]
}