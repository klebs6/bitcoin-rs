{
  "crate_name": "bitcoin-service-flags",
  "full_readme_markdown": "# bitcoin-service-flags\n\nA small, focused Rust crate that models and evaluates Bitcoin P2P `nServices` flags, closely mirroring Bitcoin Core's C++ semantics while exposing a modern, type-safe Rust API.\n\nThis crate is intended for node implementations, indexers, routing daemons, and P2P tooling that need to:\n\n- Represent the Bitcoin wire-level `services` bitfield in a principled way.\n- Decide whether a peer is *interesting* enough to occupy an outbound slot.\n- Decide whether a peer is likely to host a useful `addrman`-style address database.\n- Translate service-flag bitmasks to human-readable strings (for tracing, metrics, or operator UIs).\n\n> NOTE: This README.md was generated by an AI model. It may not be perfectly accurate in every detail, but it is designed to be a good high-level and practical guide to the crate.\n\n---\n\n## Design goals\n\n- **Semantic fidelity to Bitcoin Core**: The logic follows the original C++ behaviour, including interpretation of `NODE_NETWORK`, `NODE_NETWORK_LIMITED`, and the global Initial Block Download (IBD) completion state.\n- **Type safety**: Service flags are represented as a strongly typed `bitflags` `ServiceFlags` enum instead of raw `u64` bitfields, while still allowing unknown bits to round-trip untouched.\n- **Observability**: Functions emit rich `tracing` spans and fields to assist in debugging and production monitoring.\n- **Predictability**: Public functions are pure (except for the global IBD flag read) and document exactly how desirability is computed.\n\n---\n\n## Features\n\n### `ServiceFlags`\n\n```rust\nuse bitcoin_service_flags::ServiceFlags;\n\n// Known service bits (mirrors Bitcoin Core):\n//   NODE_NONE\n//   NODE_NETWORK\n//   NODE_BLOOM\n//   NODE_WITNESS\n//   NODE_COMPACT_FILTERS\n//   NODE_NETWORK_LIMITED\n```\n\nThis bitflag type is backed by `u64` and implements `Serialize`, `Deserialize` (`serde`), `Default`, and `From<u64>`.\n\nProperties:\n\n- `Default` is `ServiceFlags::NODE_NONE`.\n- `From<u64>` preserves **all** bits, including unknown/experimental ones, by delegating to `from_bits_unchecked`. This is essential for protocol robustness: the peer's advertised services are treated as an *opaque bitmap* while still allowing explicit reasoning about known bits.\n\n### Global IBD state\n\n```rust\nuse bitcoin_service_flags::INITIAL_BLOCK_DOWNLOAD_COMPLETED;\nuse std::sync::atomic::Ordering;\n\n// Mark that local node has left Initial Block Download\nINITIAL_BLOCK_DOWNLOAD_COMPLETED.store(true, Ordering::Relaxed);\n```\n\nThis `AtomicBool` encodes whether the **local** node has completed Initial Block Download.\n\nThe desirability of a peer's `NODE_NETWORK_LIMITED` flag is state-dependent:\n\n- **During IBD**: Full `NODE_NETWORK` capability is preferred.\n- **After IBD**: `NODE_NETWORK_LIMITED` peers become acceptable if they also satisfy other desirable bits.\n\nThis follows Bitcoin Core's logic for managing outbound connections and peers.\n\n### Computing desirable service flags\n\n```rust\nuse bitcoin_service_flags::{get_desirable_service_flags, ServiceFlags};\n\nlet peer_services = ServiceFlags::NODE_NETWORK | ServiceFlags::NODE_WITNESS;\nlet desirable     = get_desirable_service_flags(peer_services);\n\nassert!(desirable.contains(ServiceFlags::NODE_WITNESS));\n```\n\n`get_desirable_service_flags(services: ServiceFlags) -> ServiceFlags` returns the **current** set of service flags that a peer *should* advertise to be considered \"interesting\" for outbound slots or prioritised retention.\n\nBehaviour:\n\n- If `services` includes `NODE_NETWORK_LIMITED` **and** `INITIAL_BLOCK_DOWNLOAD_COMPLETED == true`:\n  - Desirable flags are `NODE_NETWORK_LIMITED | NODE_WITNESS`.\n- Otherwise:\n  - Desirable flags are `NODE_NETWORK | NODE_WITNESS`.\n\nThis allows the caller to express both:\n\n- Policy: which services we care about given our current sync state.\n- Diagnostics: which bits we expected from a particular peer.\n\n### Checking whether a peer already satisfies all desirable flags\n\n```rust\nuse bitcoin_service_flags::{\n    has_all_desirable_service_flags,\n    ServiceFlags,\n    INITIAL_BLOCK_DOWNLOAD_COMPLETED,\n};\nuse std::sync::atomic::Ordering;\n\n// Example: assume IBD is done\nINITIAL_BLOCK_DOWNLOAD_COMPLETED.store(true, Ordering::Relaxed);\n\nlet peer = ServiceFlags::NODE_NETWORK_LIMITED | ServiceFlags::NODE_WITNESS;\n\nif has_all_desirable_service_flags(peer) {\n    // safe to keep/use this peer as a full-featured outbound\n}\n```\n\n`has_all_desirable_service_flags(services: ServiceFlags) -> bool` is effectively:\n\n```text\n(services & desirable) == desirable\n```\n\nwhere `desirable = get_desirable_service_flags(services)`.\n\nThis is the canonical check for *\"is this peer fully compliant with what we currently want?\"* given our local IBD state and the peer's advertised capabilities.\n\n### Assessing whether a peer may host a useful address database\n\n```rust\nuse bitcoin_service_flags::{may_have_useful_addressdb, ServiceFlags};\n\nlet peer = ServiceFlags::NODE_NETWORK_LIMITED | ServiceFlags::NODE_WITNESS;\nassert!(may_have_useful_addressdb(peer));\n```\n\n`may_have_useful_addressdb(services: ServiceFlags) -> bool` returns `true` if the peer is likely to support a **robust** on-disk address database (a la Bitcoin Core's `addrman`), i.e.:\n\n- `services` intersects `NODE_NETWORK | NODE_NETWORK_LIMITED`.\n\nThis can be used to bias address seeding logic, peer selection for address gossip, or out-of-band bootstrap strategies.\n\n### Human-readable rendering of service flags\n\nRender a **single bit** index (`0..=63`) to a string:\n\n```rust\nuse bitcoin_service_flags::service_flag_to_str;\n\nassert_eq!(service_flag_to_str(0), \"NETWORK\");\nassert_eq!(service_flag_to_str(3), \"WITNESS\");\n\n// Unknown bit\nassert_eq!(service_flag_to_str(42), \"UNKNOWN[2^42]\");\n```\n\n`service_flag_to_str(bit: usize) -> String`:\n\n- Recognises known bits and yields stable labels:\n  - `NODE_NETWORK`           → `\"NETWORK\"`\n  - `NODE_BLOOM`            → `\"BLOOM\"`\n  - `NODE_WITNESS`          → `\"WITNESS\"`\n  - `NODE_COMPACT_FILTERS`  → `\"COMPACT_FILTERS\"`\n  - `NODE_NETWORK_LIMITED`  → `\"NETWORK_LIMITED\"`\n- For unknown bits, returns `\"UNKNOWN[2^{n}]\"` exactly in the C++ style.\n\nRender a **full mask** to a list of strings:\n\n```rust\nuse bitcoin_service_flags::{service_flags_to_str, ServiceFlags};\n\nlet flags = (ServiceFlags::NODE_NETWORK | ServiceFlags::NODE_WITNESS).bits();\nlet labels = service_flags_to_str(flags);\n\nassert_eq!(labels, vec![\"NETWORK\", \"WITNESS\"]);\n```\n\n`service_flags_to_str(flags: u64) -> Vec<String>`:\n\n- Iterates from LSB to MSB over all 64 bits.\n- For each bit set in `flags`, calls `service_flag_to_str` and collects the result.\n- The output order is deterministic and bit-ordered, matching Bitcoin Core's loop.\n\n---\n\n## Mathematical / logical structure\n\nWhile the crate operates on simple bitfields, thinking in algebraic terms clarifies the API:\n\n- The set of service flags forms a **Boolean algebra** over a 64-dimensional binary vector space:\n  - Each basis vector corresponds to a distinct service bit.\n  - The usual operations (`|`, `&`, `!`) correspond to vector-space operations over `GF(2)` if restricted to linear combinations, but for interpretive semantics we treat them as set union, intersection, and complement over a finite set of bits.\n\nKey derived constructs:\n\n- **Desirability mask** `D(services, ibd_done)`:\n\n  - If `ibd_done == false` or `!services.contains(NODE_NETWORK_LIMITED)`:\n\n    \\[\n    D = \\{NODE\\_NETWORK, NODE\\_WITNESS\\}\n    \\]\n\n  - Else (post-IBD and peer supports limited networking):\n\n    \\[\n    D = \\{NODE\\_NETWORK\\_LIMITED, NODE\\_WITNESS\\}\n    \\]\n\n- **Satisfaction predicate** `S(services)`:\n\n  \\[\n  S(services) := (services \\land D(services, ibd\\_done)) = D(services, ibd\\_done)\n  \\]\n\n- **Address DB capability predicate** `A(services)`:\n\n  \\[\n  A(services) := (services \\land (NODE\\_NETWORK \\lor NODE\\_NETWORK\\_LIMITED)) \\neq 0\n  \\]\n\nThis formalisation is useful if you integrate the crate into more sophisticated peer-scoring or optimisation logic.\n\n---\n\n## Usage examples\n\n### Basic integration with a P2P handshake\n\n```rust\nuse bitcoin_service_flags::{\n    ServiceFlags,\n    get_desirable_service_flags,\n    has_all_desirable_service_flags,\n    may_have_useful_addressdb,\n};\n\nfn on_version_message(services_raw: u64) {\n    let services = ServiceFlags::from(services_raw);\n\n    // Decide if we want to keep this peer long-term.\n    let desirable = get_desirable_service_flags(services);\n\n    if has_all_desirable_service_flags(services) {\n        // high-value peer: reserve outbound slot, prioritise keep-alive\n    } else {\n        // optional: degrade to lower priority or schedule disconnect\n    }\n\n    if may_have_useful_addressdb(services) {\n        // peer is a good candidate for addrman and address gossip\n    }\n\n    // Log human-readable view\n    let labels = bitcoin_service_flags::service_flags_to_str(services.bits());\n    tracing::info!(?services_raw, ?labels, \"Peer services evaluated\");\n}\n```\n\n### Logging and metrics\n\nYou can feed the label list to metrics systems:\n\n```rust\nuse bitcoin_service_flags::{service_flags_to_str, ServiceFlags};\n\nfn describe_services_for_metrics(raw: u64) -> String {\n    let flags = ServiceFlags::from(raw);\n    service_flags_to_str(flags.bits()).join(\",\")\n}\n```\n\n---\n\n## Crate metadata\n\n- **Name**: `bitcoin-service-flags`\n- **Version**: `0.1.19`\n- **Edition**: `2021`\n- **License**: `MIT`\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\n- **Authors**: `klebs <none>`\n\nThis crate is part of the `bitcoin-rs` repository and is designed to be small, composable, and focused.\n\n---\n\n## Feature flags\n\nThis README does not enumerate additional Cargo feature flags; consult `Cargo.toml` in the repository if features are added later.\n\nDependencies of note (at time of writing):\n\n- [`bitflags`](https://crates.io/crates/bitflags) for `ServiceFlags`.\n- [`serde`](https://crates.io/crates/serde) for serialisation.\n- [`tracing`](https://crates.io/crates/tracing) for structured logging.\n- [`lazy_static`](https://crates.io/crates/lazy_static) for the global IBD flag.\n\n---\n\n## Safety and correctness notes\n\n- `From<u64> for ServiceFlags` intentionally uses `unsafe { from_bits_unchecked(raw) }` to preserve all bits, including unknown/experimental ones. This is safe because the domain is the full `u64` space and the type is a transparent wrapper; there are no invariants violated by arbitrary bit patterns.\n- Callers must not assume that `ServiceFlags` only ever contains known bits; code should be written to be robust against future service flags.\n- All global state is confined to `INITIAL_BLOCK_DOWNLOAD_COMPLETED`. Concurrency is handled via `AtomicBool` with relaxed semantics, appropriate for a latch-like state that is monotonic from `false` to `true`.\n\n---\n\n## License\n\nMIT License. See the repository for the full license text.\n",
  "package_categories": [
    "network-programming",
    "cryptography",
    "science",
    "algorithms",
    "development-tools"
  ],
  "package_description": "Bitcoin P2P nServices flag model and utilities: typed bitflags, desirability evaluation based on IBD state, addrman capability checks, and human-readable rendering matching Bitcoin Core semantics.",
  "package_keywords": [
    "bitcoin",
    "p2p",
    "network",
    "service-flags",
    "protocol"
  ]
}