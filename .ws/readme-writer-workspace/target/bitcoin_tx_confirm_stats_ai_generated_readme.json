{
  "crate_name": "bitcoin-tx-confirm-stats",
  "full_readme_markdown": "# bitcoin-tx-confirm-stats\n\nA direct, bit-for-bit-portable implementation of Bitcoin Core-style transaction confirmation statistics and feerate estimation in Rust.\n\nThis crate maintains exponentially decayed statistics for how long transactions with a given feerate take to confirm, and uses those statistics (plus current mempool state) to estimate the feerate required to achieve a target confirmation horizon with a desired probability.\n\n> NOTE: This README was generated by an AI model. It may not perfectly describe every API or nuance, but it should be a very good approximation of the crate's design and usage. Please inspect the source for canonical behavior.\n\n---\n\n## Design overview\n\nAt a high level, the crate implements the same conceptual estimator as Bitcoin Core's `TxConfirmStats` and related classes:\n\n1. **Bucketization of feerates**\n   - The feerate domain is partitioned into monotonically increasing buckets (e.g. `[0–1] sat/vB, [1–2] sat/vB, ..., [N-1–N]`).\n   - Each transaction is assigned to exactly one bucket based on its feerate.\n\n2. **Exponential moving averages**\n   - For each bucket and for each *confirmation period* (a contiguous range of block counts), the estimator maintains exponentially decayed counts of:\n     - Transactions that confirmed within that period.\n     - Transactions that *failed* to confirm quickly enough (left the mempool without confirmation after some horizon).\n   - This provides a robust estimate of the probability that a transaction in a given bucket will confirm within a target number of blocks, while reacting adaptively to recent history.\n\n3. **Mempool tracking**\n   - Independently of the historical confirmation stats, the estimator tracks transactions currently in the mempool:\n     - A circular buffer indexed by block height age records, for each bucket, how many txs have been unconfirmed for `k` blocks.\n     - A separate vector tracks *old* unconfirmed transactions that have been in the mempool longer than the circular buffer depth.\n   - These live counts are incorporated into estimation as additional evidence (\"extra\" unconfirmed volume that has not yet confirmed), tightening the success-probability bounds.\n\n4. **Feerate estimation procedure**\n   - For a given confirmation target (e.g. `6` blocks), the estimator:\n     - Maps the target to a **period index** based on an integer scale factor (e.g. 2 blocks per period).\n     - Scans buckets from **highest** feerate to **lowest**, aggregating statistics over contiguous bucket ranges.\n     - For each candidate range with sufficient sample size, it computes the **success ratio**:\n       \\[\n       p_{\\text{success}} = \\frac{n_\\text{conf}}{n_\\text{total} + n_\\text{fail} + n_\\text{extra}}\n       \\]\n       where:\n       - `n_conf` is the decayed count of transactions that confirmed within the target.\n       - `n_total` is the decayed count of transactions observed in the range.\n       - `n_fail` is the decayed count of transactions that did not confirm quickly enough (left mempool late).\n       - `n_extra` is the number of currently unconfirmed transactions at or beyond the target age.\n     - Once it finds the *lowest-feerate* range whose `p_success` exceeds a configurable threshold (e.g. 0.95), it reports a **median feerate** from within that bucket range.\n\n5. **Persistence**\n   - Historical state can be serialized and deserialized in a sanity-checked binary format using helper formatters.\n   - Corrupted or logically inconsistent files trigger panics, mirroring the behavior in the original C++ implementation.\n\nThis architecture is engineered to:\n- Avoid overfitting to recent blocks while still adapting to regime changes through exponential decay.\n- Provide stable, monotone-in-fee estimates: higher feerates should not yield worse estimated confirmation probabilities.\n- Be computationally efficient enough to run continuously on each new block.\n\n---\n\n## Crate features and APIs\n\n### Core types\n\n#### `TxConfirmStats`\n\n```rust\npub struct TxConfirmStats {\n    buckets:        Arc<Vec<f64>>,          // bucket boundaries (upper limits)\n    bucket_map:     Arc<HashMap<f64, u32>>, // mapping from bucket upper-bound to index\n    tx_ct_avg:      Vec<f64>,               // decayed total tx count per bucket\n    conf_avg:       Vec<Vec<f64>>,          // [period][bucket] decayed count confirming within period\n    fail_avg:       Vec<Vec<f64>>,          // [period][bucket] decayed count failing within period\n    feerate_avg:    Vec<f64>,               // decayed sum of feerates per bucket\n    decay:          f64,                    // per-block exponential decay factor in (0, 1)\n    scale:          u32,                    // blocks per period (e.g. 2 => 1 \"period\" = 2 blocks)\n    unconf_txs:     Vec<Vec<i32>>,          // circular buffer of unconfirmed tx counts [age][bucket]\n    old_unconf_txs: Vec<i32>,               // long-lived unconfirmed txs per bucket\n}\n```\n\nA `TxConfirmStats` instance is the central object. You typically allocate one instance per “policy context” (e.g. per asset or per network) and feed it new data as blocks and mempool transitions occur.\n\nKey characteristics:\n\n- **Thread-sharing**: `buckets` and `bucket_map` are `Arc<_>` so multiple estimators can share immutable bucket definitions.\n- **Time scaling**: `scale` lets you discretize confirmation horizons coarser than single blocks, reducing state dimensionality.\n- **Exponential decay**: `decay` controls the half-life of historical data. After each block, you call `update_moving_averages` to apply decay.\n\n#### `FeeRateEstimatorBucket`\n\n```rust\npub struct FeeRateEstimatorBucket {\n    start:           f64,\n    end:             f64,\n    within_target:   f64,\n    total_confirmed: f64,\n    in_mempool:      f64,\n    left_mempool:    f64,\n}\n```\n\nRepresents aggregated statistics for a contiguous range of feerate buckets.\n\nFields:\n- `start`, `end`: feerate interval `[start, end]` for this aggregated bucket range.\n- `within_target`: count of transactions in this range that confirmed within the target horizon.\n- `total_confirmed`: total number of observed transactions contributing to this range.\n- `in_mempool`: number of still-unconfirmed transactions at or beyond the target (\"extra\" evidence against faster confirmation).\n- `left_mempool`: number of transactions that left the mempool (e.g. eviction, replacement) without confirming within the horizon.\n\nUtility methods:\n\n```rust\nimpl FeeRateEstimatorBucket {\n    pub fn calc_within_target_percentage(&self) -> f64;\n    pub fn record_failure_bucket(&mut self, ...);\n    pub fn record_passing_bucket(&mut self, ...);\n}\n```\n\n`calc_within_target_percentage` returns a percentage (0–100). It is used for logging and diagnostics.\n\n#### `FeeRateEstimationResult`\n\n```rust\n#[derive(Default)]\npub struct FeeRateEstimationResult {\n    pass:  FeeRateEstimatorBucket,\n    fail:  FeeRateEstimatorBucket,\n    decay: f64,\n    scale: u32,\n}\n```\n\nWhen you call `TxConfirmStats::estimate_median_val`, you can optionally pass a pointer to a `FeeRateEstimationResult`. If non-null, the estimator fills it with:\n- `pass`: the last range that satisfied the success probability target.\n- `fail`: the adjacent range that first failed the target (or a trailing failure window if the scan ran out of data).\n- `decay`, `scale`: for completeness and downstream debugging.\n\nThis gives you a structured, inspectable view of the estimator's decision boundary around the target feerate.\n\n---\n\n## Core functions and methods\n\n### Sample sufficiency and success ratio\n\nThe estimator uses two generic helper functions:\n\n```rust\npub fn has_sufficient_samples(total_num: f64, sufficient_tx_val: f64, decay: f64) -> bool {\n    total_num >= (sufficient_tx_val / (1.0 - decay))\n}\n\npub fn compute_success_ratio(\n    n_conf:    f64,\n    total_num: f64,\n    fail_num:  f64,\n    extra_num: i32,\n) -> f64 {\n    n_conf / (total_num + fail_num + (extra_num as f64))\n}\n```\n\n- `has_sufficient_samples` ensures that after applying exponential decay, the effective sample size is large enough: we scale the desired `sufficient_tx_val` by `1 / (1 - decay)` to approximate an infinite-horizon sum.\n- `compute_success_ratio` computes a probability-like ratio in `[0, 1]` used to compare against `success_break_point`.\n\n### Feerate median calculation\n\n```rust\nimpl TxConfirmStats {\n    pub fn find_median_feerate(\n        &self,\n        min_bucket: usize,\n        max_bucket: usize,\n        mut tx_sum: f64,\n    ) -> f64 { ... }\n}\n```\n\nGiven a bucket range `[min_bucket, max_bucket]` and the aggregate `tx_sum` over that range, this method:\n- Moves through buckets from `min_bucket` upward, subtracting per-bucket tx counts.\n- Locates the bucket where the cumulative count crosses `tx_sum / 2`, and returns:\n  \\[\n  \\text{median} \\approx \\frac{\\text{feerate\\_avg}[j]}{\\text{tx\\_ct\\_avg}[j]}\n  \\]\nwhich is the mean feerate of transactions in the median-containing bucket. This is consistent with Bitcoin Core's approximation.\n\n### Estimating a feerate\n\n```rust\nimpl TxConfirmStats {\n    pub fn estimate_median_val(\n        &self,\n        conf_target:         i32,\n        sufficient_tx_val:   f64,\n        success_break_point: f64,\n        n_block_height:      u32,\n        result:              *mut FeeRateEstimationResult,\n    ) -> f64 { ... }\n}\n```\n\nParameters:\n- `conf_target`: desired confirmation horizon in blocks (1-based).\n- `sufficient_tx_val`: minimum effective sample size per candidate range (in tx per block units).\n- `success_break_point`: minimum acceptable success probability, e.g. `0.95`.\n- `n_block_height`: current best chain height; used for indexing the unconfirmed circular buffer.\n- `result`: optional out-parameter (raw pointer) for detailed breakdown. Pass `std::ptr::null_mut()` if you do not care.\n\nReturn value:\n- Estimated median feerate for the chosen bucket range, or `-1.0` if:\n  - `conf_target` maps outside tracked periods, or\n  - the scan finds no bucket range with sufficient samples meeting the success threshold.\n\nAlgorithm sketch:\n\n1. Map `conf_target` to a period index via:\n   \\[\n   \\text{period\\_target} = \\left\\lceil \\frac{\\text{conf\\_target}}{\\text{scale}} \\right\\rceil\n   \\]\n   If `period_target` is zero or exceeds `conf_avg.len()`, the function returns `-1.0`.\n2. Call `scan_buckets` to walk buckets from highest feerate downward, accumulating:\n   - Confirmed counts within `period_target`;\n   - Total counts per bucket;\n   - Failures per bucket;\n   - Additional unconfirmed transactions via `calc_extra_unconfirmed`.\n3. `scan_buckets` tracks the best passing range in a `FeeRateEstimatorState`. Once finished, `estimate_median_val`:\n   - Extracts `(min_bucket, max_bucket)` from the state;\n   - Computes the total `tx_sum` via `sum_tx_ct_avg`;\n   - If an answer was found and `tx_sum > 0`, computes `median` via `find_median_feerate` and records the pass range into the state's `pass_bucket`.\n4. `finalize_trailing_failure` infers a trailing failure interval if the scan ended while still passing.\n5. If `result` is non-null, the method writes out the `pass` and `fail` buckets, along with `decay` and `scale`.\n\n### Sample accumulation helpers\n\n`TxConfirmStats` offers small helpers to isolate primitive operations:\n\n```rust\nimpl TxConfirmStats {\n    pub fn sum_tx_ct_avg(&self, min_bucket: usize, max_bucket: usize) -> f64;\n\n    pub fn accumulate_bucket_data(\n        &self,\n        period_target: usize,\n        bucket_index:  usize,\n        n_conf:        &mut f64,\n        total_num:     &mut f64,\n        fail_num:      &mut f64,\n    );\n}\n```\n\nThese are used both internally and by `FeeRateEstimatorState` to keep borrow lifetimes minimal while computing aggregate stats.\n\n### Unconfirmed transaction accounting\n\nThe estimator maintains a ring buffer of unconfirmed tx counts by age:\n\n```rust\nimpl TxConfirmStats {\n    pub fn get_max_confirms(&self) -> u32;\n    pub fn resize_in_memory_counters(&mut self, newbuckets: usize);\n    pub fn clear_current(&mut self, n_block_height: u32);\n    pub fn new_tx(&mut self, n_block_height: u32, val: f64) -> u32;\n    pub fn remove_tx(\n        &mut self,\n        entry_height:       u32,\n        n_best_seen_height: u32,\n        bucketindex:        u32,\n        in_block:           bool,\n    );\n\n    pub fn calc_extra_unconfirmed(\n        &self,\n        bucket_index:   usize,\n        conf_target:    usize,\n        n_block_height: u32,\n        bins:           usize,\n    ) -> i32;\n}\n```\n\n- `get_max_confirms()` returns `scale * conf_avg.len()`: the maximum number of blocks of confirmation horizons tracked.\n- `resize_in_memory_counters()` adjusts `unconf_txs` and `old_unconf_txs` after deserialization or bucket changes.\n- `clear_current(n_block_height)` rolls the circular buffer for the new block, transferring all unconfirmed counts at the current index into `old_unconf_txs`, and zeroing out that bin.\n- `new_tx(n_block_height, val)` records a newly-arriving mempool transaction at the current block height in the appropriate bucket.\n- `remove_tx(entry_height, n_best_seen_height, bucketindex, in_block)` is called when a transaction leaves the mempool:\n  - It decrements the relevant bucket count either from the circular buffer or from `old_unconf_txs` if older than the buffer window.\n  - If `in_block == false` and the transaction has been around for at least one `scale` period, it increments `fail_avg` for the periods which it has exceeded, modeling failure-to-confirm.\n- `calc_extra_unconfirmed` is used inside the estimator to quantify `n_extra` for success-ratio computation.\n\n### Bucket scanning state machine\n\n`FeeRateEstimatorState` is an internal helper that encapsulates the bucket scanning process.\n\n```rust\npub(crate) struct FeeRateEstimatorState {\n    n_conf:           f64,\n    total_num:        f64,\n    fail_num:         f64,\n    extra_num:        i32,\n    cur_near_bucket:  usize,\n    cur_far_bucket:   usize,\n    best_near_bucket: usize,\n    best_far_bucket:  usize,\n    new_bucket_range: bool,\n    passing:          bool,\n    found_answer:     bool,\n    pass_bucket:      FeeRateEstimatorBucket,\n    fail_bucket:      FeeRateEstimatorBucket,\n}\n```\n\nKey methods:\n\n- `new(max_bucket_index)` initializes the state at the highest bucket.\n- `begin_or_extend_range(b)` begins or extends the current contiguous bucket range.\n- `accumulate_from_stats(...)` and `add_extra_from_stats(...)` integrate stats from `TxConfirmStats`.\n- `has_sufficient(...)` and `cur_pct()` derive sample sufficiency and success ratio.\n- `on_first_failure(...)`, `on_passing_reset_and_remember()`, and `finalize_trailing_failure(...)` maintain `pass_bucket`/`fail_bucket` boundaries and track the best passing range.\n\nThe public `scan_buckets` method coordinates this logic:\n\n```rust\nimpl TxConfirmStats {\n    pub fn scan_buckets(\n        &self,\n        conf_target:         i32,\n        sufficient_tx_val:   f64,\n        success_break_point: f64,\n        n_block_height:      u32,\n        period_target:       usize,\n    ) -> FeeRateEstimatorState { ... }\n}\n```\n\nThis traverses the feerate domain from high to low, adjusting the candidate range as it encounters buckets whose success ratio crosses the threshold, and returns the final `FeeRateEstimatorState` from which `estimate_median_val` extracts its answer.\n\n---\n\n## Persistence\n\n`TxConfirmStats` supports reading and writing its decayed averages (not the live unconfirmed state) to an arbitrary I/O source implementing `Read` / `Write`.\n\n```rust\nimpl TxConfirmStats {\n    pub fn read<R: Read>(\n        &mut self,\n        filein:          &mut R,\n        _n_file_version: i32,\n        num_buckets:     usize,\n    );\n\n    pub fn write<W: Write>(&self, fileout: &mut W);\n}\n```\n\n- `read`:\n  - Deserializes `decay`, `scale`, `feerate_avg`, `tx_ct_avg`, `conf_avg`, and `fail_avg` using `EncodedDoubleFormatter` and `VectorFormatter` helpers.\n  - Performs a series of strong invariance checks, panicking on mismatches:\n    - `decay` must be in `(0, 1)`.\n    - `scale` must be non-zero.\n    - `feerate_avg.len()`, `tx_ct_avg.len()`, and each row of `conf_avg` / `fail_avg` must match `num_buckets`.\n    - `max_confirms = scale * conf_avg.len()` must be in `[1, 6 * 24 * 7]` (1–1008 blocks).\n  - Only after successful validation does it commit decoded data to `self` and resize `unconf_txs` / `old_unconf_txs` accordingly.\n\n- `write`:\n  - Serializes `decay`, `scale`, `feerate_avg`, `tx_ct_avg`, `conf_avg`, and `fail_avg` to `fileout`.\n  - Any I/O errors during `write_u32_le` are surfaced as panics, aligning with Bitcoin Core's behavior.\n\nThis separation between persistent historical state and in-memory rolling mempool state allows you to checkpoint estimators periodically without encoding the full mempool, which is typically volatile and reconstructible.\n\n---\n\n## Basic usage pattern\n\nBelow is a conceptual example (simplified, error-handling omitted) of how an application might employ the crate.\n\n```rust\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse bitcoin_tx_confirm_stats::{TxConfirmStats, FeeRateEstimationResult};\n\nfn make_default_buckets() -> (Vec<f64>, HashMap<f64, u32>) {\n    // Example: geometric progression from 1 sat/vB up to ~1024 sat/vB\n    let mut buckets = Vec::new();\n    let mut x = 1.0;\n    while x <= 1024.0 {\n        buckets.push(x);\n        x *= 1.2;\n    }\n\n    let mut bucket_map = HashMap::new();\n    for (i, &upper) in buckets.iter().enumerate() {\n        bucket_map.insert(upper, i as u32);\n    }\n\n    (buckets, bucket_map)\n}\n\nfn main() {\n    let (buckets, bucket_map) = make_default_buckets();\n\n    // Track up to 25 periods; with scale=2, that is up to 50 blocks of confirmation horizons\n    let max_periods = 25u32;\n    let decay = 0.998_f64; // about 1/(1-decay) ≈ 500 blocks effective window\n    let scale = 2u32;      // 2 blocks per period\n\n    let mut stats = TxConfirmStats::new(&buckets, &bucket_map, max_periods, decay, scale);\n\n    // Called when a tx enters the mempool\n    fn on_tx_added(stats: &mut TxConfirmStats, best_height: u32, feerate: f64) -> u32 {\n        stats.new_tx(best_height, feerate)\n    }\n\n    // Called when a tx leaves the mempool\n    fn on_tx_removed(\n        stats:             &mut TxConfirmStats,\n        entry_height:       u32,\n        best_seen_height:   u32,\n        bucket_index:       u32,\n        confirmed_in_block: bool,\n        blocks_to_confirm:  Option<i32>,\n        feerate:            f64,\n    ) {\n        // Update unconfirmed bookkeeping and failure stats\n        stats.remove_tx(entry_height, best_seen_height, bucket_index, confirmed_in_block);\n\n        if confirmed_in_block {\n            let blocks = blocks_to_confirm.expect(\"confirmed tx must have blocks_to_confirm\");\n            stats.record(blocks, feerate);\n        }\n    }\n\n    // Called once per new block\n    fn on_new_block(stats: &mut TxConfirmStats, new_height: u32) {\n        // Roll mempool age accounting\n        stats.clear_current(new_height);\n\n        // Apply exponential decay to historical stats\n        stats.update_moving_averages();\n    }\n\n    // Estimating a feerate for 6-block target, 95% success\n    let conf_target = 6;\n    let sufficient_tx_val = 1.0;     // tune for your tolerance\n    let success_break_point = 0.95;  // 95% probability\n    let current_height = 800_000u32; // example\n\n    let mut details = FeeRateEstimationResult::default();\n    let est = stats.estimate_median_val(\n        conf_target,\n        sufficient_tx_val,\n        success_break_point,\n        current_height,\n        &mut details as *mut _,\n    );\n\n    if est > 0.0 {\n        println!(\"Estimated feerate: {est:.2} sat/vB for confirmation within {conf_target} blocks\");\n        println!(\n            \"Passing bucket range: [{:.2}, {:.2}] sat/vB (within-target: {:.2}%)\",\n            details.pass().start(),\n            details.pass().end(),\n            details.pass().calc_within_target_percentage(),\n        );\n    } else {\n        println!(\"Insufficient data for a stable estimate\");\n    }\n}\n```\n\nThis example assumes that your surrounding system provides:\n- Correct tracking of `entry_height` for each mempool entry.\n- `best_seen_height` for the moment of removal or confirmation.\n- Accurate `blocks_to_confirm` and `feerate` for confirmed transactions.\n\n---\n\n## Mathematical notes\n\n1. **Exponential decay**\n\n   Each block, the estimator multiplies historical counts by a factor `decay` in `(0, 1)`:\n   \\[\n   x_{t+1} = \\text{decay} \\cdot x_t + \\Delta_t\n   \\]\n   where `Δ_t` is the new contribution from the current block.\n\n   The *effective* horizon of such an exponential moving average is approximately:\n   \\[\n   H_{\\text{eff}} \\approx \\frac{1}{1 - \\text{decay}}\\ \\text{blocks}\n   \\]\n\n   This informs the choice of `sufficient_tx_val` and sampling thresholds.\n\n2. **Success probability**\n\n   The success ratio deliberately includes both past failures and currently unconfirmed outliers:\n   \\[\n   p_{\\text{success}} = \\frac{n_\\text{conf}}{n_\\text{conf} + n_\\text{fail} + n_\\text{extra}}\n   \\]\n\n   - `n_conf`: decayed count of txs that did confirm within the target.\n   - `n_fail`: decayed count of txs that did not confirm in time and left the mempool.\n   - `n_extra`: current unconfirmed transactions whose age exceeds the target, a lower bound on additional failures if they keep not confirming.\n\n   This structure makes the estimator conservative: a large backlog of aged unconfirmed txs in a bucket reduces `p_success`, pushing the required feerate upward.\n\n3. **Bucket median approximation**\n\n   Instead of computing a fully continuous conditional distribution of confirmation times given feerate, the estimator uses bucketed histograms and approximates the median by the bucket mean at the halfway point. This is computationally cheap and sufficiently stable for fee policy.\n\n---\n\n## Safety and panics\n\n- Several methods (particularly `read`) perform strict invariance checks and panic on violations. This matches Bitcoin Core's philosophy that a corrupted fee-estimates file is a programmer/operator error, not an expected runtime condition.\n- The crate uses raw pointers for `FeeRateEstimationResult` in order to match C++-style ABI expectations. It is the caller's responsibility to:\n  - Pass a valid, non-null pointer if they want results, or\n  - Pass `std::ptr::null_mut()` if they do not.\n- Indices (bucket, period, buffer) are carefully range-checked in the implementation; nonetheless, misuse of public APIs with incorrect dimensions can still result in panics.\n\n---\n\n## When to use this crate\n\nThis crate is appropriate when you need:\n\n- **Bitcoin Core–compatible fee estimation behavior**: You want estimates that behave similarly to Core's `estimatesmartfee`, possibly for cross-implementation consistency.\n- **Long-lived, low-level fee policy infrastructure**: You are implementing a wallet, miner, or policy engine that directly interacts with mempool-level signals.\n- **Deterministic, inspectable fee analytics**: You want both the feerate and the underlying bucket statistics used to derive that number.\n\nIt is not a general-purpose statistical toolkit; it encodes a very specific model intended to mirror existing production systems.\n\n---\n\n## License and authorship\n\n- License: **MIT**\n- Authors: `YourName <you@example.com>`\n\nThis README was generated by an AI model and may not be 100% accurate; however, it aims to closely reflect the crate's source and intended behavior.",
  "package_categories": [
    "cryptography",
    "finance",
    "network-programming",
    "science",
    "mathematics"
  ],
  "package_description": "Rust implementation of Bitcoin Core-style transaction confirmation statistics and feerate estimation, combining exponentially decayed historical data with live mempool tracking to compute fee recommendations for target confirmation horizons.",
  "package_keywords": [
    "bitcoin",
    "fee-estimation",
    "mempool",
    "confirmation-time",
    "blockchain"
  ]
}