{
  "crate_name": "bitcoinleveldb-logtools",
  "full_readme_markdown": "# bitcoinleveldb-logtools\n\nLow-level logging and encoding utilities extracted from a LevelDB-style write-ahead log, adapted for use in Bitcoin-oriented storage stacks. This crate focuses on precise control of log record types, safe(ish) manipulation of raw byte slices via a `Slice` abstraction, and deterministic textual encoding/decoding of numeric and binary data.\n\n> **Note**: This README was generated by an AI model and may not be perfectly accurate, although it has been written to closely match the presented API.\n\n---\n\n## Overview\n\n`bitcoinleveldb-logtools` provides building blocks for implementing LevelDB-compatible log readers/writers and related tooling:\n\n- **Record typing primitives** matching LevelDB's physical log format:\n  - `LogRecordType` for base record kinds (`Full`, `First`, `Middle`, `Last`, `Zero`).\n  - `ExtendedRecordTypes` bitflags for synthetic states (`Eof`, `BadRecord`).\n- **Logging traits** that mirror the C++ LevelDB logging surface:\n  - `Logger` as a marker trait for log sinks.\n  - `Logv` for `printf`-style structured logging.\n- **Textual encoding helpers**\n  - `number_to_string` / `append_number_to` for fast, predictable integer formatting.\n  - `escape_string` / `append_escaped_string_to` for ASCII-safe string rendering with hex escapes for non-printables.\n  - `consume_decimal_number` for robust, overflow-aware parsing of decimal `u64` from a `Slice`.\n- **Binary utilities**\n  - `append_slice_bytes` for efficiently copying from a raw-pointer-backed `Slice` into a `Vec<u8>`.\n- **CRC precomputation**\n  - `init_type_crc` to precompute CRC32C values for each log record type, accelerating integrity checks.\n\nThe crate deliberately exposes low-level, pointer-driven operations to track the original LevelDB semantics. It is intended for developers implementing storage engines, Bitcoin database tooling, or compatibility layers that must replicate LevelDB's on-disk layout and error handling precisely.\n\n---\n\n## When to use this crate\n\nUse `bitcoinleveldb-logtools` if you need:\n\n- **Binary compatibility** with LevelDB-style logs, especially in Bitcoin Coreâ€“adjacent systems.\n- Tight control over **physical records** and their classification into `Full`/`First`/`Middle`/`Last` fragments.\n- Deterministic, allocation-conscious helpers for converting between bytes and human-readable monitoring/debugging output.\n- Precomputation of **CRC32C** for log record types at startup to reduce per-record hashing cost.\n\nIt is *not* a full log implementation; instead, it is an internal toolkit you would combine with your own I/O and higher-level record framing.\n\n---\n\n## Log record types\n\n```rust\n#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub enum LogRecordType {\n    Zero,\n    Full,\n    First,\n    Middle,\n    Last,\n}\n```\n\nThese correspond to the physical record types used in LevelDB's log file format:\n\n- `Full`: the logical record fits entirely within one physical record.\n- `First`: the first physical fragment of a multi-fragment logical record.\n- `Middle`: an intermediate fragment.\n- `Last`: the final fragment.\n- `Zero`: reserved; often treated as padding or invalid.\n\nThis classification allows a reader to reconstruct logical records across block boundaries.\n\n### Extended record types\n\n```rust\nbitflags! {\n    pub struct ExtendedRecordTypes: i32 {\n        const Eof       = LOG_MAX_RECORD_TYPE as i32 + 1;\n        const BadRecord = LOG_MAX_RECORD_TYPE as i32 + 2;\n    }\n}\n```\n\n`ExtendedRecordTypes` adds higher-level sentinel states used during scanning:\n\n- `Eof`: Logical end-of-file encountered.\n- `BadRecord`: A physically invalid record was found. The provided comment indicates three classes of invalid records:\n  - Invalid CRC.\n  - Zero-length record.\n  - Record earlier than the constructor's `initial_offset`.\n\nThese are useful in a log reader state machine to distinguish between *intentional termination* and *data corruption or protocol mismatch*.\n\n---\n\n## Logging traits\n\n### `Logger`\n\n```rust\n/// An interface for writing log messages.\npub trait Logger {}\n```\n\n`Logger` is currently a marker trait: it does not impose any methods. In practice you implement it for structs that represent a logging sink (file logger, stderr logger, in-memory collector, etc.). Other components can then be parameterized over `T: Logger` to remain abstract over the specific logging backend.\n\n### `Logv`\n\n```rust\npub trait Logv {\n    fn logv(&mut self, format: *const u8, ap: &[&str]);\n}\n```\n\n`Logv` models a variadic `printf`-style logging interface, keeping close fidelity with the original C++ implementation:\n\n- `format`: a raw `*const u8` pointer to a format string (typically a NUL-terminated C-style string).\n- `ap`: a slice of string parameters.\n\nThis trait is intentionally low-level. Callers should ensure that the `format` pointer is valid for the duration of the call and that the argument list semantically matches the format string. Implementations typically perform format string parsing and write to their underlying logger or sink.\n\n---\n\n## String and number utilities\n\n### `append_number_to` and `number_to_string`\n\n```rust\npub fn append_number_to(str_: *mut String, num: u64) { /* ... */ }\n\npub fn number_to_string(num: u64) -> String { /* ... */ }\n```\n\n- `append_number_to` appends the decimal representation of `num` to an existing `String` via a raw `*mut String` pointer. This is designed to mirror the original implementation's pointer-based API.\n- `number_to_string` constructs a new `String`, calls `append_number_to`, and returns it.\n\nUsage pattern:\n\n```rust\nuse bitcoinleveldb_logtools::{append_number_to, number_to_string};\n\nlet mut s = String::from(\"height=\");\nappend_number_to(&mut s as *mut String, 840_000);\nassert_eq!(s, \"height=840000\");\n\nlet s2 = number_to_string(42);\nassert_eq!(s2, \"42\");\n```\n\n**Safety note**: Only pass valid pointers to `append_number_to`. Passing a null or dangling pointer results in undefined behavior beyond the crate's explicit null check.\n\n### `append_escaped_string_to` and `escape_string`\n\n```rust\npub fn append_escaped_string_to(str_: *mut String, value: &Slice) { /* ... */ }\n\npub fn escape_string(value: &Slice) -> String { /* ... */ }\n```\n\nThese functions encode arbitrary bytes from a `Slice` into a printable ASCII representation:\n\n- Printable characters in the interval `[' ', '~']` are appended as-is.\n- All other bytes are appended as `\"\\\\xNN\"` hex escapes.\n\nThis is ideal for:\n\n- Logging keys/values that may contain non-UTF-8 data.\n- Emitting diagnostics for corrupted log entries or internal binary keys.\n\nExample (assuming a compatible `Slice` type):\n\n```rust\nuse bitcoinleveldb_logtools::escape_string;\nuse some_slice_crate::Slice; // Replace with your actual Slice implementation\n\nlet data = b\"hello\\nworld\";\nlet slice = Slice::from(data);\nlet escaped = escape_string(&slice);\nassert_eq!(escaped, \"hello\\\\x0aworld\");\n```\n\nAs with other pointer-heavy functions, `append_escaped_string_to` requires that `str_` is a valid, non-null pointer to a `String`.\n\n### `consume_decimal_number`\n\n```rust\npub fn consume_decimal_number(in_: *mut Slice, val: *mut u64) -> bool { /* ... */ }\n```\n\nThis function parses a non-negative decimal integer from the *beginning* of the `Slice` referenced by `in_` and writes the result to `*val`.\n\nSemantics:\n\n- On **success**:\n  - Leading decimal digits `[0-9]+` are consumed.\n  - The parsed value is stored into `*val`.\n  - The `Slice` is advanced by the number of consumed bytes (`remove_prefix(digits_consumed)`).\n  - Returns `true`.\n- On **overflow** or invalid state:\n  - If parsing would exceed `u64::MAX`, it logs a warning and returns `false`.\n  - If there are **no leading digits**, returns `false` and leaves the `Slice` unspecified.\n  - If `in_` or `val` is null, logs an error and returns `false`.\n\nAlgorithmically, this is a base-10 accumulation with explicit overflow checks:\n\n\\[\n\\text{value}_{n+1} = 10 \\cdot \\text{value}_n + d_{n+1}, \\quad d_{n+1} \\in \\{0,\\dots,9\\}\n\\]\n\nand it refuses to proceed once `value > u64::MAX / 10` or the final digit would exceed `u64::MAX % 10`.\n\nExample sketch:\n\n```rust\nuse bitcoinleveldb_logtools::consume_decimal_number;\nuse some_slice_crate::Slice; // Replace with your actual Slice implementation\n\nlet mut slice = Slice::from(b\"12345 rest\");\nlet mut value: u64 = 0;\nlet ok = consume_decimal_number(&mut slice as *mut Slice, &mut value as *mut u64);\nassert!(ok);\nassert_eq!(value, 12345);\n// `slice` now points at \" rest\"\n```\n\nThis function is especially appropriate for parsing configuration numbers or internal sequence counters encoded as ASCII in a LevelDB / log context.\n\n---\n\n## Binary helpers\n\n### `append_slice_bytes`\n\n```rust\npub fn append_slice_bytes(source: &Slice, destination: &mut Vec<u8>) { /* ... */ }\n```\n\nCopies the raw bytes referenced by `source` into `destination` using the `Slice`'s internal data pointer and length.\n\n- If the length is zero, it returns immediately.\n- If the `Slice`'s data pointer is null, it logs a warning and does nothing.\n- Otherwise it constructs a `from_raw_parts` view and `extend_from_slice`s into `destination`.\n\nUsage:\n\n```rust\nuse bitcoinleveldb_logtools::append_slice_bytes;\nuse some_slice_crate::Slice;\n\nlet slice = Slice::from(b\"block data\");\nlet mut buf = Vec::new();\nappend_slice_bytes(&slice, &mut buf);\nassert_eq!(&buf[..], b\"block data\");\n```\n\nThis is exactly what you want when re-materializing a logical record from multiple fragmented physical slices.\n\n---\n\n## CRC32C initialization\n\n### `init_type_crc`\n\n```rust\npub fn init_type_crc(type_crc: *mut u32) { /* ... */ }\n```\n\nPrecomputes CRC32C values for each valid log record type in `[0, LOG_MAX_RECORD_TYPE]` and stores them in a table at `type_crc`.\n\nFor each `i` in that range, the function computes:\n\n\\[\n\\text{crc}[i] = \\text{CRC32C}([i \\text{ as u8}])\n\\]\n\nand writes it to `*type_crc.add(i)`.\n\nAssumptions/requirements:\n\n- `type_crc` must point to an array of at least `LOG_MAX_RECORD_TYPE + 1` `u32` entries.\n- `LOG_MAX_RECORD_TYPE` is an external constant (likely equal to the largest `LogRecordType` discriminant).\n- `crc32c_value` is an external function, presumably providing the CRC32C primitive.\n\nUsage sketch:\n\n```rust\nuse bitcoinleveldb_logtools::init_type_crc;\n\nconst MAX_TYPE: usize = bitcoinleveldb_logtools::LOG_MAX_RECORD_TYPE as usize; // if exported\nlet mut table = vec![0u32; MAX_TYPE + 1];\n\ninit_type_crc(table.as_mut_ptr());\n// `table[i]` now holds the CRC32C of the i-th record type byte\n```\n\nThis table can then be combined with the CRC of the payload to construct or verify the complete record CRC in O(1) per record.\n\n---\n\n## Safety and invariants\n\nThis crate deliberately uses raw pointers (`*mut String`, `*mut Slice`, `*const u8`) to parallel a C++ codebase. Consequently:\n\n- Many functions are **memory-unsafe** if called with invalid pointers.\n- The crate performs some null checks and logs diagnostic messages but cannot defend against all misuse.\n\nWhen integrating:\n\n1. Ensure that all pointers passed into these functions are:\n   - Non-null.\n   - Properly aligned.\n   - Pointing to valid, mutable data for the duration of the call.\n2. Ensure that `Slice`'s `data()` and `size()` methods uphold their documented contracts:\n   - `size()` must return a pointer to a valid length `usize` or `usize`-compatible.\n   - `data()` must return a pointer to an inner data pointer that is either null or points to at least `size()` bytes of readable memory.\n3. Respect integer overflow checks in `consume_decimal_number`. Do not ignore its `false` return; treat it as parse failure.\n\nIf you require a safer abstraction, consider building a thin, fully safe wrapper around these primitives that validates invariants up front.\n\n---\n\n## Example: Implementing a simple log printer\n\nBelow is a conceptual sketch integrating several APIs from this crate. It assumes a `Slice` implementation compatible with the function signatures.\n\n```rust\nuse bitcoinleveldb_logtools::{\n    escape_string,\n    number_to_string,\n    append_slice_bytes,\n    LogRecordType,\n};\nuse some_slice_crate::Slice;\n\npub struct LogPrinter;\n\nimpl LogPrinter {\n    pub fn print_record(typ: LogRecordType, payload: &Slice) {\n        let human_type = format!(\"{:?}\", typ);\n        let human_payload = escape_string(payload);\n        println!(\"[type={}] payload=\\\"{}\\\"\", human_type, human_payload);\n    }\n\n    pub fn accumulate_payload(chunks: &[Slice]) -> Vec<u8> {\n        let mut buf = Vec::new();\n        for c in chunks {\n            append_slice_bytes(c, &mut buf);\n        }\n        buf\n    }\n}\n\n// Usage (assuming `Slice::from` and data):\n// let slice = Slice::from(b\"hello\\x00world\");\n// LogPrinter::print_record(LogRecordType::Full, &slice);\n```\n\nThis demonstrates how the crate's utilities help transform binary log payloads into something auditable and loggable while keeping control over the underlying binary representation.\n\n---\n\n## Crate metadata\n\n- **Name**: `bitcoinleveldb-logtools`\n- **Version**: `0.1.1`\n- **Edition**: `2024`\n- **License**: `MIT`\n- **Intended domain**: LevelDB-style logging, Bitcoin database/log tooling, low-level storage infrastructure.\n\n---\n\n## Status and caveats\n\n- The exposed API is low-level and mirrors an external codebase; it is primarily suitable as an **internal dependency** of a larger system that already uses a compatible `Slice` and CRC32C implementation.\n- The README intentionally describes only the components provided in the excerpt. Additional items in the crate (if any) may not be documented here.\n- Because this document was produced by an AI model from partial source context, verify semantics against the actual crate source before deploying in production-critical paths.\n",
  "package_categories": [
    "algorithms",
    "data-structures",
    "filesystem",
    "network-programming",
    "development-tools"
  ],
  "package_description": "Low-level LevelDB-style log utilities for Bitcoin-oriented storage stacks: record type enums, extended record flags, unsafe Slice-based string/number helpers, CRC32C precomputation, and binary slice manipulation.",
  "package_keywords": [
    "bitcoin",
    "leveldb",
    "logging",
    "wal",
    "storage"
  ]
}