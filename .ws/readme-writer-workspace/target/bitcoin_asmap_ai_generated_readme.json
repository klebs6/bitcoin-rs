{
  "crate_name": "bitcoin-asmap",
  "full_readme_markdown": "# bitcoin-asmap\n\nHigh‑fidelity Rust implementation of Bitcoin Core's ASMAP interpreter, decoder, and structural validator.\n\nThis crate provides a bit‑exact reimplementation of the Autonomous System (AS) mapping logic used by Bitcoin Core to probabilistically infer the AS number (ASN) associated with a peer's IP address. It is designed for:\n\n- Node operators and infrastructure providers who need deterministic ASMAP behavior in Rust services.\n- Researchers performing network topology or AS‑level analysis of the Bitcoin network.\n- Library authors integrating Bitcoin‑style AS‑based peer selection or routing policies into Rust applications.\n\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate, but it should be a close and useful description of the crate.\n\n---\n\n## Conceptual overview\n\n### ASMAP and ASN inference\n\nAn **ASMAP** file encodes a decision tree over IP address bits that maps each address to an **Autonomous System Number (ASN)**. In Bitcoin Core, this mapping is used to diversify peer selection by AS to reduce the risk that many peers are controlled by the same routing domain.\n\nKey ideas:\n\n- The ASMAP is a compact, prefix‑based program over bits of an IP address.\n- An IP address is represented as a boolean slice `[bool; 128]` (for IPv6) or appropriately padded for IPv4‑in‑IPv6.\n- The ASMAP is represented as a boolean program `asmap: &[bool]` which is **interpreted** to yield a final ASN.\n\nThis crate mirrors the C++ reference implementation used by Bitcoin Core, including its variable‑length integer coding, instruction set, and comprehensive structural sanity checks.\n\n---\n\n## Core data model\n\n### Instruction set\n\n```rust\n#[repr(u32)]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Instruction {\n    RETURN,\n    JUMP,\n    MATCH,\n    DEFAULT,\n}\n``\n\nThe instruction stream is encoded as bits and decoded via `decode_type`, which internally uses `decode_bits` and a compact opcode encoding.\n\n- **RETURN**: Decode and return an ASN; terminates the program if structurally valid.\n- **JUMP**: Conditionally jump forward in the instruction stream based on the next IP bit.\n- **MATCH**: Match a short bit pattern against the next IP bits; either continue or fall back to the current default ASN.\n- **DEFAULT**: Update the current default ASN used when a `MATCH` fails.\n\nThese instructions, combined with a stack of jump targets, implement a structured decision tree with compact representation.\n\n---\n\n## Public API\n\n### Reading and validating an ASMAP file\n\n```rust\nuse bitcoin_asmap::decode_asmap;\n\nlet asmap_bits = decode_asmap(\"/path/to/asmap.dat\");\nif asmap_bits.is_empty() {\n    // Failed to read or validate ASMAP\n}\n```\n\n`decode_asmap<P: AsRef<Path>>(path: P) -> Vec<bool>`:\n\n- Reads the raw ASMAP file from disk (little‑endian, LSB‑first, identical to C++).\n- Converts bytes into a `Vec<bool>` bit stream (bit 0 is the LSB of each byte).\n- Runs a **full structural sanity check** via `sanity_check_as_map`.\n- Returns the validated bit vector, or an **empty** vector on failure.\n\nThis is the entry point you usually want when consuming an ASMAP file shipped with Bitcoin Core or derived tools.\n\n### Interpreting an ASMAP for a given IP\n\n```rust\nuse bitcoin_asmap::{decode_asmap, interpret};\n\nlet asmap = decode_asmap(\"/path/to/asmap.dat\");\nif asmap.is_empty() {\n    panic!(\"Invalid ASMAP\");\n}\n\n// Example: represent an IPv4 address as 128 bits (IPv4‑mapped)\nfn ipv4_to_bits(addr: [u8; 4]) -> Vec<bool> {\n    // Very naive 32‑bit big‑endian; real usage should follow Bitcoin Core's\n    // IPv4‑in‑IPv6 representation and bit ordering.\n    let mut bits = Vec::with_capacity(32);\n    for byte in addr {\n        for offset in (0..8).rev() { // big‑endian per byte\n            bits.push(((byte >> offset) & 1) != 0);\n        }\n    }\n    bits\n}\n\nlet ip_bits = ipv4_to_bits([203, 0, 113, 1]);\nlet asn = interpret(&asmap, &ip_bits);\n\nif asn == 0 {\n    // 0 is not a valid ASN; indicates structural failure during interpret()\n}\n```\n\n`interpret(asmap: &[bool], ip: &[bool]) -> u32`:\n\n- Executes the ASMAP program over `ip`'s bits.\n- Returns the mapped ASN on success.\n- Returns `0` on structural failure (e.g., invalid jumps, truncated encodings), even if `sanity_check_as_map` should normally prevent such cases in production.\n\n> **Important**: This crate expects the same IP bit ordering and normalization that Bitcoin Core uses. If you want behavior identical to Core, ensure you pass in `ip` bits constructed according to its reference logic (e.g., IPv4 mapped into IPv6).\n\n### Structural sanity checking\n\n```rust\nuse bitcoin_asmap::{decode_asmap, sanity_check_as_map};\n\nlet asmap = decode_asmap(\"/path/to/asmap.dat\");\nif asmap.is_empty() {\n    // Already failed, but you can also explicitly check:\n}\n\nlet ok = sanity_check_as_map(&asmap, 128);\nassert!(ok);\n```\n\n`sanity_check_as_map(asmap: &[bool], bits: i32) -> bool`:\n\n- Performs **exhaustive structural validation** of the ASMAP program.\n- Mirrors Bitcoin Core's rules:\n  - No jumps into the middle of another instruction.\n  - No intersecting jumps.\n  - No consuming IP bits past the declared input width.\n  - No consecutive `DEFAULT`s.\n  - No `RETURN` immediately after `DEFAULT`.\n  - No unmatched trailing code after `RETURN`.\n  - Correct use of padding and zero padding bits.\n  - Constraints on sequences of short `MATCH` instructions.\n- Returns `true` iff the structure is valid.\n\nThis is useful if you:\n\n- Load ASMAPs from untrusted sources.\n- Mutate or generate ASMAPs programmatically.\n- Want defensive validation independent of `decode_asmap`.\n\n### Bit‑level primitives\n\nThese are low‑level helpers that directly mirror the C++ implementation and are usually not needed by typical users but are valuable for experimentation or custom tooling.\n\n#### `decodeasn`\n\n```rust\npub fn decodeasn(asmap: &[bool], pos: &mut usize) -> u32\n```\n\nDecodes an ASN value from `asmap` starting at `*pos` using a variable‑length integer scheme defined by `ASN_BIT_SIZES`.\n\n- `pos` is updated in‑place.\n- Returns the ASN, or an `INVALID` sentinel value (internal constant) on failure.\n\n#### `decode_jump`\n\n```rust\npub fn decode_jump(asmap: &[bool], pos: &mut usize) -> u32\n```\n\nDecodes a jump offset using `JUMP_BIT_SIZES`. The returned value is a **forward** offset from the current `pos`.\n\n#### `decode_match`\n\n```rust\npub fn decode_match(asmap: &[bool], pos: &mut usize) -> u32\n```\n\nDecodes a match pattern plus a sentinel bit using `MATCH_BIT_SIZES`. The number of data bits in the pattern is `count_bits(m) - 1`, where `m` is the decoded value.\n\n#### `decode_bits`\n\n```rust\npub fn decode_bits(\n    asmap:     &[bool],\n    pos:       &mut usize,\n    minval:    u8,\n    bit_sizes: &[u8],\n) -> u32\n```\n\nThis is the **core variable‑length integer decoder**, parameterized by:\n\n- `minval`: base value added to the final decoded integer.\n- `bit_sizes`: an increasing sequence of mantissa widths.\n\nThe decoding logic is exponential‑Golomb‑like:\n\n1. For each `bitsize` except the last, it reads an **exponent bit**.\n2. If the exponent bit is `1`, it increments `val` by `1 << bitsize` and continues to the next `bitsize`.\n3. If the exponent bit is `0`, it consumes `bitsize` mantissa bits into `val` and returns.\n4. For the last `bitsize`, no exponent bit is read; instead, the path falls through if all previous exponent bits were `1`.\n\nOn early EOF, returns `INVALID` and leaves an error trace.\n\n#### `decode_type`\n\n```rust\npub fn decode_type(asmap: &[bool], pos: &mut usize) -> Instruction\n```\n\nDecodes an instruction opcode using `TYPE_BIT_SIZES` and returns the corresponding `Instruction` variant.\n\n#### `count_bits`\n\n```rust\n#[inline]\npub fn count_bits(x: u32) -> u32 {\n    x.count_ones()\n}\n```\n\nHelper that wraps `u32::count_ones` for internal clarity.\n\n---\n\n## Logging and diagnostics\n\nThe implementation uses structured logging macros such as `trace!`, `debug!`, `info!`, and `error!` (typically from the `tracing` crate). These log at every decision point:\n\n- Early returns during decoding.\n- Invalid opcodes or truncated integers.\n- Sanity check violations including exact reason and offset.\n\nTo benefit from these diagnostics, configure a compatible subscriber in your application, for example:\n\n```rust\nuse tracing_subscriber::FmtSubscriber;\n\nfn main() {\n    let subscriber = FmtSubscriber::builder()\n        .with_max_level(tracing::Level::TRACE)\n        .finish();\n\n    tracing::subscriber::set_global_default(subscriber)\n        .expect(\"setting default subscriber failed\");\n\n    // use bitcoin_asmap here\n}\n```\n\n---\n\n## Error handling and invariants\n\n- `decode_asmap` returns an empty `Vec<bool>` on any I/O error or failed sanity check. Empty means **\"do not use\"**.\n- `interpret` returns `0` on structural failure; `0` is not a valid ASN by design.\n- Internally, decoding uses an `INVALID` sentinel (not exposed) to signal truncated encodings.\n- `sanity_check_as_map` should be run on any externally provided ASMAP before using `interpret` in production.\n\nIf you require stronger typing (e.g., non‑zero ASN newtypes) or richer error types, you can wrap this crate in a thin adapter layer.\n\n---\n\n## Performance considerations\n\n- Bit representation uses `Vec<bool>`, which is compact but may have non‑trivial overhead for heavy random access. This mirrors the reference C++ behavior but not necessarily the most optimal Rust representation.\n- The interpreter is single‑pass and operates in `O(|asmap| + |ip|)` time.\n- Sanity checking is more expensive (`O(|asmap|)` with additional structural invariants) and should be performed once per ASMAP file, not per lookup.\n\nFor workloads performing a large number of `interpret` calls against a static ASMAP, the typical pattern is:\n\n1. Load and validate the ASMAP once via `decode_asmap` (or manually reading the file and using `sanity_check_as_map`).\n2. Reuse the resulting `Vec<bool>` for all subsequent IP lookups.\n\n---\n\n## Intended use cases\n\n- **Bitcoin node infrastructure**: Implement AS‑aware peer selection or connection policies in Rust node software.\n- **Research and analysis**: Offline analysis of Bitcoin network AS distribution using the same mapping logic as Bitcoin Core.\n- **Monitoring and policy engines**: Integrate ASMAP‑based classification into monitoring agents or traffic policy components written in Rust.\n\n---\n\n## Repository, license, and edition\n\n- **Crate name**: `bitcoin-asmap`\n- **Version**: `0.1.19`\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\n- **License**: MIT\n- **Rust edition**: 2021\n\n---\n\n## Caveats and compatibility\n\n- Behavior is designed to be bit‑for‑bit compatible with the original Bitcoin Core C++ implementation. Nevertheless, you should validate against known test vectors when integrating into a critical system.\n- Ensure that the IP bit ordering and normalization (IPv4 vs IPv6) match Bitcoin Core if you seek identical outcomes.\n- This crate does not fetch or update ASMAP data itself; you must supply a valid ASMAP file.\n",
  "package_categories": [
    "network-programming",
    "cryptography",
    "parsing",
    "algorithms"
  ],
  "package_description": "Bit-exact Rust reimplementation of Bitcoin Core's ASMAP decoder, interpreter, and structural validator for mapping IP addresses to autonomous system numbers (ASNs).",
  "package_keywords": [
    "bitcoin",
    "asmap",
    "asn",
    "network",
    "routing"
  ]
}