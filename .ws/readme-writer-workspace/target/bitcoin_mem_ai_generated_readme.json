{
  "crate_name": "bitcoin-mem",
  "full_readme_markdown": "# bitcoin-mem\n\nPrecise, low‑overhead accounting of heap usage for Bitcoin-style data structures.\n\nThis crate is a small, focused port of Bitcoin Core's `memusage.h` logic to Rust. It exposes a family of traits for estimating dynamic (heap) memory consumption of values and containers, together with helpers that mirror the C++ allocator bucketing model.\n\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate or exhaustive, but it should be a strong starting point for understanding and using the crate.\n\n---\n\n## High-level overview\n\n`bitcoin-mem` is designed for systems where memory is a first‑class resource: nodes, indexers, and services whose correctness and robustness depend on staying within strict memory budgets. Instead of using coarse metrics like \"length of vector\" or \"number of map entries\", this crate estimates heap usage in **bytes**, closely following what would be charged by a `malloc`/`free` allocator with bucketed size classes, as done in Bitcoin Core.\n\nKey ideas:\n\n* **Dynamic vs. recursive usage**: distinguish between the bytes owned directly by a value/container and bytes owned by its transitive children.\n* **Incremental usage**: estimate the *marginal* allocation cost of inserting one additional element into a container.\n* **Allocator bucketing**: `malloc_usage` accounts for allocator rounding/overhead using fixed bucket sizes (8‑ or 16‑byte)\n  depending on pointer width.\n\nThis enables predictable memory profiling and budget enforcement for complex object graphs without requiring a global allocator hook.\n\n---\n\n## Core traits\n\n### `DynamicUsage`\n\n```rust\npub trait DynamicUsage {\n    fn dynamic_usage(&self) -> usize;\n}\n```\n\n`DynamicUsage` measures **owned heap memory directly associated with the value**, ignoring any children unless specified otherwise.\n\nExamples:\n\n* For primitive scalars (`i32`, `u64`, `f32`, etc.), `dynamic_usage` is always `0` (they live on the stack or inside other allocations).\n* For `Vec<T>`, `dynamic_usage` returns the heap capacity in bytes for the underlying buffer, accounting for allocator bucket rounding via `malloc_usage`.\n* For `HashMap`, `HashSet`, `Arc`, `Box`, `Option`, and various bitcoin-rs abstractions, `dynamic_usage` approximates the heap footprint of the container or handle, ignoring nested contents unless clearly part of the same allocation block.\n\nThis separation enforces that you think carefully about ownership and allocation boundaries.\n\n### `RecursiveDynamicUsage`\n\n```rust\npub trait RecursiveDynamicUsage {\n    fn recursive_dynamic_usage(&self) -> usize;\n}\n\npub fn recursive_dynamic_usage<T: RecursiveDynamicUsage>(x: &T) -> usize {\n    x.recursive_dynamic_usage()\n}\n```\n\n`RecursiveDynamicUsage` optionally walks into children to compute the **transitive** heap usage of a structure, according to semantics that match Bitcoin Core:\n\n* `Vec<T: DynamicUsage>` currently counts only the backing buffer (`self.dynamic_usage()`), not the elements. This mirrors the C++ implementation, which treats inner accounting as an opt‑in concern for clients.\n* `Arc<X: RecursiveDynamicUsage + DynamicUsage>` adds its own allocation cost (header + payload) and the recursive usage of the inner value.\n* `Option<T: RecursiveDynamicUsage>` recurses into `Some` and charges zero for `None`.\n* `Amo<T>` (a convenience alias in bitcoin-rs, modeled as `Arc<RwLock<Option<T>>>`) charges its own structure and recursively charges for the contained `T` when present.\n\nThis duality (`DynamicUsage` vs `RecursiveDynamicUsage`) lets you choose between fast, shallow accounting and more precise whole‑object accounting.\n\n### `IncrementalDynamicUsage`\n\n```rust\npub trait IncrementalDynamicUsage {\n    fn incremental_dynamic_usage(&self) -> usize;\n}\n```\n\n`IncrementalDynamicUsage` estimates **the additional heap allocation caused by inserting one more element** into a container, holding everything else fixed. This is particularly useful for admission control and cache policies:\n\n* `StdHashMap<K, V, S>` and `StdHashSet<T, S>` approximate the cost of one more node (`StlTreeNode<..>`), passed through `malloc_usage`.\n* For `Arc<T> where T: IncrementalDynamicUsage`, the incremental cost is delegated to the inner value, assuming the `Arc` itself is already allocated.\n\nThis closely mirrors the C++ `memusage::IncrementalDynamicUsage` logic used in Bitcoin Core to evaluate incremental memory impact of map and set insertions.\n\n---\n\n## Allocator model: `malloc_usage`\n\n```rust\n#[inline]\npub fn malloc_usage(alloc: usize) -> usize {\n    if alloc == 0 {\n        trace!(\"malloc_usage(0) -> 0\");\n        return 0;\n    }\n    let ptr_sz = core::mem::size_of::<*const ()>();\n    let result = match ptr_sz {\n        8 => ((alloc + 31) >> 4) << 4, // 16‑byte buckets on 64‑bit\n        4 => ((alloc + 15) >> 3) << 3, // 8‑byte buckets on 32‑bit\n        _ => panic!(\"Unsupported pointer size: {}\", ptr_sz),\n    };\n    trace!(\"malloc_usage({}) -> {} (ptr_sz={})\", alloc, result, ptr_sz);\n    result\n}\n```\n\n`malloc_usage` models allocator behavior instead of just returning `alloc`:\n\n* On 64‑bit platforms, requested sizes are rounded up to multiples of 16 bytes.\n* On 32‑bit platforms, they are rounded up to multiples of 8 bytes.\n\nThis reflects the bucketed allocation strategy assumed in Bitcoin Core's memory accounting, making your Rust numbers comparable to C++ node metrics.\n\nYou generally do not call `malloc_usage` directly; the provided `DynamicUsage` / `IncrementalDynamicUsage` implementations invoke it for you when computing container costs.\n\n---\n\n## Important helper types\n\nThese internal structs approximate the layout of C++ STL nodes used by Bitcoin Core for its accounting logic:\n\n```rust\npub struct UnorderedNode<X>  {\n    base: X,\n    ptr:  *mut c_void,\n}\n\npub struct StlTreeNode<X>  {\n    color:  i32,\n    parent: *mut c_void,\n    left:   *mut c_void,\n    right:  *mut c_void,\n    x:      X,\n}\n\npub struct StlSharedCounter  {\n    class_type: *mut c_void,\n    use_count:  usize,\n    weak_count: usize,\n}\n```\n\nThey are not intended as generic data structures; they exist to approximate per‑node overhead for `HashMap`, `HashSet`, and reference‑counting objects in a way that is consistent with the upstream C++ implementation.\n\n---\n\n## Provided trait implementations\n\nThe crate includes out‑of‑the‑box implementations for a range of standard and bitcoin-rs types:\n\n### Primitives and pointers\n\n```rust\nimpl DynamicUsage for i8    { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for u8    { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for i16   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for u16   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for i32   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for u32   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for i64   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for u64   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for f32   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl DynamicUsage for f64   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl<X> DynamicUsage for *mut X   { fn dynamic_usage(&self) -> usize { 0 } }\nimpl<X> DynamicUsage for *const X { fn dynamic_usage(&self) -> usize { 0 } }\n```\n\nAll primitives and raw pointers are treated as non‑owning with respect to heap memory.\n\nThe macro `impl_recursive_for_primitive!` also marks these as `RecursiveDynamicUsage`, delegating to `dynamic_usage`.\n\n### `Vec<T>`\n\n```rust\nimpl<X> DynamicUsage for Vec<X> {\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        let bytes = self.capacity() * core::mem::size_of::<X>();\n        malloc_usage(bytes)\n    }\n}\n\nimpl<T: DynamicUsage> RecursiveDynamicUsage for Vec<T> {\n    #[inline]\n    fn recursive_dynamic_usage(&self) -> usize {\n        // Matches C++: account for the buffer only, not the elements.\n        self.dynamic_usage()\n    }\n}\n```\n\nThis implementation uses `capacity()` rather than `len()`, which is crucial for tracking over‑allocation and future growth potential.\n\n### `PreVector<T, N>`\n\n`PreVector<T, N>` comes from bitcoin-rs and represents a small‑vector optimization where up to `N` elements are stored inline, and excess elements spill into a heap buffer.\n\n```rust\nimpl<T: Default, const N: usize> DynamicUsage for PreVector<T, N> {\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        let inline_cap = N;\n        let heap_cap   = self.capacity();\n\n        if heap_cap <= inline_cap {\n            0\n        } else {\n            let bytes = heap_cap * core::mem::size_of::<T>();\n            malloc_usage(bytes)\n        }\n    }\n}\n```\n\nThis allows precise accounting for structures that try to stay on the stack most of the time.\n\n### Hash maps and sets\n\nTwo families are supported:\n\n* `HashMap` / `HashSet` from `bitcoin-rs` (likely re‑exports with custom parameters)\n* `StdHashMap` / `StdHashSet` from `std::collections`\n\nEach has `DynamicUsage` and `IncrementalDynamicUsage` implemented in terms of an approximate `StlTreeNode` layout:\n\n```rust\nimpl<T, S> DynamicUsage for HashSet<T, S>\nwhere S: BuildHasher\n{\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        let node_sz = core::mem::size_of::<StlTreeNode<T>>();\n        let bytes   = self.len() * node_sz;\n        malloc_usage(bytes)\n    }\n}\n\nimpl<K, V, S> DynamicUsage for HashMap<K, V, S>\nwhere S: BuildHasher\n{\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        let node_sz = core::mem::size_of::<StlTreeNode<(K, V)>>();\n        let bytes   = self.len() * node_sz;\n        malloc_usage(bytes)\n    }\n}\n\nimpl<T, S> DynamicUsage for StdHashSet<T, S>\nwhere S: BuildHasher\n{\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        let node_sz = core::mem::size_of::<StlTreeNode<T>>();\n        let bytes   = self.len() * node_sz;\n        malloc_usage(bytes)\n    }\n}\n\nimpl<K, V, S> DynamicUsage for StdHashMap<K, V, S>\nwhere S: BuildHasher\n{\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        let node_sz = core::mem::size_of::<StlTreeNode<(K, V)>>();\n        let bytes   = self.len() * node_sz;\n        malloc_usage(bytes)\n    }\n}\n```\n\nIncremental costs:\n\n```rust\nimpl<K, S> IncrementalDynamicUsage for HashSet<K, S>\nwhere S: BuildHasher\n{\n    #[inline]\n    fn incremental_dynamic_usage(&self) -> usize {\n        malloc_usage(core::mem::size_of::<StlTreeNode<K>>())\n    }\n}\n\nimpl<K, V, S> IncrementalDynamicUsage for HashMap<K, V, S>\nwhere S: BuildHasher\n{\n    #[inline]\n    fn incremental_dynamic_usage(&self) -> usize {\n        malloc_usage(core::mem::size_of::<StlTreeNode<(K, V)>>())\n    }\n}\n\nimpl<T, S> IncrementalDynamicUsage for StdHashSet<T, S>\nwhere S: BuildHasher\n{\n    #[inline]\n    fn incremental_dynamic_usage(&self) -> usize {\n        malloc_usage(core::mem::size_of::<StlTreeNode<T>>())\n    }\n}\n\nimpl<K, V, S> IncrementalDynamicUsage for StdHashMap<K, V, S>\nwhere S: BuildHasher\n{\n    #[inline]\n    fn incremental_dynamic_usage(&self) -> usize {\n        malloc_usage(core::mem::size_of::<StlTreeNode<(K, V)>>())\n    }\n}\n```\n\nThe model is intentionally simple: one node per element, sized as `StlTreeNode<..>`.\n\n### `Box<T>`\n\n```rust\nimpl<X> DynamicUsage for Box<X> {\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        let bytes = core::mem::size_of::<X>();\n        malloc_usage(bytes)\n    }\n}\n```\n\n`Box<X>` is modeled as a single allocation big enough to hold `X`.\n\n### `Arc<T>`\n\n```rust\nimpl<X> DynamicUsage for Arc<X> {\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        // Arc allocates a single block containing a header (2×usize) and the payload.\n        let header_bytes = 2 * core::mem::size_of::<usize>();\n        let total = header_bytes + core::mem::size_of::<X>();\n        malloc_usage(total)\n    }\n}\n\nimpl<X> RecursiveDynamicUsage for Arc<X>\nwhere X: RecursiveDynamicUsage + DynamicUsage\n{\n    fn recursive_dynamic_usage(&self) -> usize {\n        let own   = DynamicUsage::dynamic_usage(self);\n        let inner = recursive_dynamic_usage(&**self);\n        own + inner\n    }\n}\n\nimpl<T> IncrementalDynamicUsage for Arc<T>\nwhere T: IncrementalDynamicUsage + ?Sized\n{\n    #[inline]\n    fn incremental_dynamic_usage(&self) -> usize {\n        (**self).incremental_dynamic_usage()\n    }\n}\n```\n\nThis reflects a consolidated allocation that stores both reference counts and the payload.\n\n### `Option<T>`\n\n```rust\nimpl<T> DynamicUsage for Option<T> {\n    #[inline]\n    fn dynamic_usage(&self) -> usize { 0 }\n}\n\nimpl<T: RecursiveDynamicUsage> RecursiveDynamicUsage for Option<T> {\n    fn recursive_dynamic_usage(&self) -> usize {\n        match self {\n            Some(inner) => recursive_dynamic_usage(inner),\n            None        => 0,\n        }\n    }\n}\n```\n\n`Option<T>` does not own additional heap memory beyond what `T` would already own; recursive accounting still walks into `Some` values if requested.\n\n### `Amo<T>` (Arc + RwLock + Option)\n\n`Amo<T>` is an alias defined elsewhere in `bitcoin-rs` as:\n\n```rust\n// conceptual form\npub type Amo<T> = Arc<parking_lot::RwLock<Option<T>>>;\n```\n\n`bitcoin-mem` provides memory accounting tailored to this pattern:\n\n```rust\nimpl<T> DynamicUsage for Amo<T> {\n    #[inline]\n    fn dynamic_usage(&self) -> usize {\n        let header_bytes = 2 * core::mem::size_of::<usize>(); // Arc header\n        let payload      = core::mem::size_of::<parking_lot::RwLock<Option<T>>>();\n        let total        = header_bytes + payload;\n        malloc_usage(total)\n    }\n}\n\nimpl<X> RecursiveDynamicUsage for Amo<X>\nwhere X: RecursiveDynamicUsage + DynamicUsage\n{\n    fn recursive_dynamic_usage(&self) -> usize {\n        let own = DynamicUsage::dynamic_usage(self);\n\n        let inner = {\n            // work with the outer `Option<X>`\n            let guard = self.getopt();       // &Option<X>\n            guard.as_ref()\n                 .map(recursive_dynamic_usage)\n                 .unwrap_or(0)\n        };\n\n        own + inner\n    }\n}\n```\n\nThe result is a robust estimate for shared, locked state with optional payload.\n\n---\n\n## Usage examples\n\n### Basic usage with `Vec` and maps\n\n```rust\nuse bitcoin_mem::{DynamicUsage, RecursiveDynamicUsage, IncrementalDynamicUsage};\nuse std::collections::HashMap as StdHashMap;\n\nfn main() {\n    let v: Vec<u8> = vec![0; 1024];\n    let v_bytes = v.dynamic_usage();\n    println!(\"Vec<u8> dynamic bytes (approx alloc): {}\", v_bytes);\n\n    let mut m: StdHashMap<u64, u64> = StdHashMap::new();\n    m.insert(1, 2);\n    m.insert(3, 4);\n\n    let map_bytes = m.dynamic_usage();\n    let map_inc   = m.incremental_dynamic_usage();\n\n    println!(\"map dynamic bytes: {}\", map_bytes);\n    println!(\"map incremental bytes for next insert: {}\", map_inc);\n}\n```\n\n### Recursive accounting with `Arc` and `Amo`\n\n```rust\nuse bitcoin_mem::{DynamicUsage, RecursiveDynamicUsage};\nuse std::sync::Arc;\n\n#[derive(Default)]\nstruct Node {\n    data: Vec<u8>,\n}\n\nimpl DynamicUsage for Node {\n    fn dynamic_usage(&self) -> usize {\n        self.data.dynamic_usage()\n    }\n}\n\nimpl RecursiveDynamicUsage for Node {\n    fn recursive_dynamic_usage(&self) -> usize {\n        // Here we treat the Vec as the only child; we could extend this easily.\n        self.data.recursive_dynamic_usage()\n    }\n}\n\nfn main() {\n    let node = Arc::new(Node { data: vec![0; 2048] });\n\n    let shallow = node.dynamic_usage();          // Arc header + Node payload\n    let deep    = node.recursive_dynamic_usage(); // header + payload + transitive children\n\n    println!(\"shallow bytes: {}\", shallow);\n    println!(\"deep bytes: {}\", deep);\n}\n```\n\n### Enforcing a memory budget\n\n```rust\nuse bitcoin_mem::{DynamicUsage, IncrementalDynamicUsage};\nuse std::collections::HashMap;\n\nfn insert_with_budget<K, V>(\n    map: &mut HashMap<K, V>,\n    key: K,\n    value: V,\n    budget_bytes: usize,\n) -> Result<(), &'static str>\nwhere\n    K: std::hash::Hash + Eq,\n{\n    let current = map.dynamic_usage();\n    let delta   = map.incremental_dynamic_usage();\n\n    if current + delta > budget_bytes {\n        return Err(\"memory budget exceeded\");\n    }\n\n    map.insert(key, value);\n    Ok(())\n}\n```\n\nThis pattern can be applied to mempool admission, cache growth, and other budget‑sensitive subsystems.\n\n---\n\n## Design notes and caveats\n\n* **Approximation**: The accounting is intentionally approximate. It is calibrated to match Bitcoin Core's expectations, not any particular Rust allocator implementation.\n* **Non‑recursive defaults**: For containers like `Vec<T>`, recursive behavior intentionally does *not* traverse elements by default, for performance and consistency with C++. If you need fully recursive accounting, implement `RecursiveDynamicUsage` for your own types and compose as needed.\n* **Ownership semantics**: Traits measure memory that is *owned* (or effectively reserved) by the value, not arbitrary pointers it may reference. For example, `*const T` is charged as zero.\n* **No global allocator hooks**: All accounting is based on type‑level layout and container state (`len`, `capacity`). No runtime allocator instrumentation is used.\n\n---\n\n## Integration in `bitcoin-rs`\n\n`bitcoin-mem` is part of the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) project and is intended to be consumed primarily by other crates in that workspace. You can still depend on it standalone:\n\n```toml\n[dependencies]\nbitcoin-mem = \"0.1.19\"\n```\n\nThen import and extend the traits for your own domain types:\n\n```rust\nuse bitcoin_mem::{DynamicUsage, RecursiveDynamicUsage};\n\nstruct BlockIndex {\n    txids: Vec<[u8; 32]>,\n}\n\nimpl DynamicUsage for BlockIndex {\n    fn dynamic_usage(&self) -> usize {\n        self.txids.dynamic_usage()\n    }\n}\n\nimpl RecursiveDynamicUsage for BlockIndex {\n    fn recursive_dynamic_usage(&self) -> usize {\n        self.txids.recursive_dynamic_usage()\n    }\n}\n```\n\nThis makes your custom index objects participate in the same accounting framework as core data structures.\n\n---\n\n## License\n\nThis crate is licensed under the MIT license.\n\nSee the repository for details:\n\n<https://github.com/klebs6/bitcoin-rs>\n",
  "package_categories": [
    "cryptography",
    "finance",
    "data-structures",
    "development-tools",
    "science"
  ],
  "package_description": "Bitcoin Core–style heap memory usage accounting for Rust values and containers, providing DynamicUsage, RecursiveDynamicUsage, and IncrementalDynamicUsage traits plus allocator-bucketed sizing via malloc_usage.",
  "package_keywords": [
    "bitcoin",
    "memory",
    "profiling",
    "heap",
    "accounting"
  ]
}