{
  "crate_name": "bitcoin-indirectmap",
  "full_readme_markdown": "# bitcoin-indirectmap\n\nA thin, well‑typed façade around `BTreeMap` that stores `Arc<K>` keys but orders and queries them **by the dereferenced `K` value**. This mirrors the `indirectmap` pattern used in the Bitcoin Core C++ code‑base and provides explicit iterator and size types via a trait abstraction.\n\n> Note: This README.md was generated by an AI model. It may not be perfectly accurate or exhaustive, but it should be a close and practically useful description of the crate.\n\n---\n\n## Overview\n\n`bitcoin-indirectmap` implements an *indirection‑aware* ordered map:\n\n- Keys are stored as `Arc<K>` for shared ownership and cheap cloning.\n- Ordering and lookup are performed by `K: Ord` on the **underlying value**, not on pointer identity.\n- The internal data structure is a `BTreeMap<IndirectKey<K>, V>` where `IndirectKey<K>` is a wrapper that defines ordering on `K` while physically storing `Arc<K>`.\n- A `HasIndirectMapTypes` trait abstracts over iterator and size types, allowing consumers (notably a Bitcoin Core style code‑base) to depend on a stable façade instead of concrete container types.\n\nThis is useful when you want:\n\n- Deterministic ordered maps keyed by complex, heap‑allocated objects shared across the system via `Arc`.\n- Map semantics defined by **value equality** (`K: Ord + Eq`) rather than pointer identity, while still benefiting from shared ownership.\n- A Rust analogue of Bitcoin Core’s C++ `indirectmap`, to ease porting and keep conceptual parity.\n\n---\n\n## Core Types\n\n### `HasIndirectMapTypes<'a>`\n\n```rust\npub trait HasIndirectMapTypes<'a> {\n    type Iterator:      Iterator<Item = (&'a Arc<Self::Key>, &'a Self::Value)> + 'a;\n    type ConstIterator: Iterator<Item = (&'a Arc<Self::Key>, &'a Self::Value)> + 'a;\n    type SizeType;\n    type Key;\n    type Value;\n}\n```\n\nA trait used to expose associated iterator and size types without committing to a specific container implementation. For `IndirectMap<K, V>`:\n\n- `Iterator` / `ConstIterator` are boxed trait objects over iterators yielding `(&Arc<K>, &V)`.\n- `SizeType` is `usize`.\n- `Key` and `Value` are `K` and `V` respectively.\n\nThis abstraction is useful in a large, modular code‑base that wishes to hide container implementation details while still exposing a rich iterator API.\n\n### `IndirectKey<K>`\n\n```rust\n#[derive(Clone)]\npub struct IndirectKey<K: Ord>(Arc<K>);\n```\n\n`IndirectKey<K>` is a small wrapper around `Arc<K>` that implements:\n\n- `Borrow<K>`\n- `PartialEq`, `Eq`\n- `PartialOrd`, `Ord`\n\nAll comparisons and ordering operations are defined on the **dereferenced `K`**. Consequently:\n\n- The map treats two `Arc<K>` values as equal if their underlying `K` values compare equal, even if they are distinct heap allocations.\n- `Borrow<K>` lets `BTreeMap` perform lookups by `&K`, not just by `IndirectKey<K>`.\n\nKey invariants:\n\n- `K: Ord` must define a **total order** over keys.\n- Once inserted into the map, a `K` **must not be mutated** in any way that changes its ordering; otherwise the `BTreeMap` invariants are violated. This is the standard constraint for ordered maps with interior mutability.\n\n### `IndirectMap<K, V>`\n\n```rust\n#[derive(Builder, Getters, MutGetters)]\n#[builder(pattern = \"owned\")]\npub struct IndirectMap<K, V>\nwhere\n    K: Ord,\n{\n    map: BTreeMap<IndirectKey<K>, V>,\n}\n```\n\n`IndirectMap<K, V>` is the primary public type:\n\n- Internally: `BTreeMap<IndirectKey<K>, V>`.\n- Externally: operations keyed by `Arc<K>` for insertion and by `&K` for lookup and removal.\n- Deterministic order defined by `Ord` on `K`.\n\nThe crate also implements memory‑accounting traits:\n\n```rust\nimpl<K: Ord, V> DynamicUsage for IndirectMap<K, V> {\n    fn dynamic_usage(&self) -> usize { /* ... */ }\n}\n\nimpl<K: Ord, V> IncrementalDynamicUsage for IndirectMap<K, V> {\n    fn incremental_dynamic_usage(&self) -> usize { /* ... */ }\n}\n```\n\nThese provide coarse estimates of dynamic memory usage per map and per entry using `mem::size_of::<IndirectKey<K>>()` and `mem::size_of::<V>()`, making it easier to reason about memory footprints in environments where memory usage needs to be budgeted explicitly (as is common in Bitcoin Core).\n\n---\n\n## API Summary\n\nBelow is the principal surface of `IndirectMap<K, V>` (simplified to highlight behavior):\n\n```rust\nimpl<K: Ord, V> IndirectMap<K, V> {\n    pub fn insert(&mut self, key: Arc<K>, value: V) -> bool;\n    pub fn find(&self, k: &K) -> Option<(&Arc<K>, &V)>;\n    pub fn find_mut(&mut self, k: &K) -> Option<(Arc<K>, &mut V)>;\n\n    pub fn get(&self, k: &K) -> Option<(&Arc<K>, &V)>;\n    pub fn get_mut(&mut self, k: &K) -> Option<(Arc<K>, &mut V)>;\n\n    pub fn erase(&mut self, k: &K) -> bool;\n    pub fn count(&self, k: &K) -> usize; // 0 or 1\n\n    pub fn lower_bound<'a>(&'a self, k: &K)\n        -> Box<dyn Iterator<Item = (&'a Arc<K>, &'a V)> + 'a>;\n\n    pub fn is_empty(&self) -> bool;\n    pub fn size(&self) -> usize;\n    pub fn clear(&mut self);\n\n    pub fn iter<'a>(&'a self)\n        -> Box<dyn Iterator<Item = (&'a Arc<K>, &'a V)> + 'a>;\n\n    pub fn iter_mut<'a>(&'a mut self)\n        -> Box<dyn Iterator<Item = (&'a Arc<K>, &'a mut V)> + 'a>;\n\n    pub fn max_size(&self) -> usize; // == usize::MAX\n}\n```\n\n### Insert\n\n```rust\npub fn insert(&mut self, key: Arc<K>, value: V) -> bool\n```\n\n- Inserts `(Arc<K>, V)` into the map.\n- Returns `true` if the key (by value) was **newly** inserted.\n- Returns `false` if a value with the same underlying `K` already existed and was overwritten.\n\n### Lookup by `&K`\n\nAll lookup operations take a `&K` and operate on the ordering of `K`:\n\n- `find(&self, k: &K) -> Option<(&Arc<K>, &V)>`\n- `get(&self, k: &K) -> Option<(&Arc<K>, &V)>`\n\nThese are semantically similar; `find` is the more explicit API.\n\n`find_mut` and `get_mut` are the mutable counterparts:\n\n```rust\npub fn find_mut(&mut self, k: &K) -> Option<(Arc<K>, &mut V)>;\npub fn get_mut(&mut self, k: &K) -> Option<(Arc<K>, &mut V)>; // convenience wrapper\n```\n\nImplementation detail:\n\n- `find_mut` performs a two‑phase operation:\n  1. It obtains an immutable reference to the internal key, clones the `Arc<K>`.\n  2. It then acquires a mutable reference to the value, avoiding aliasing a mutable reference with a live immutable reference to the same entry.\n\nYou get back:\n\n- A cloned `Arc<K>` that you may hold freely.\n- A `&mut V` allowing you to mutate the mapped value.\n\n### Erase and Count\n\n```rust\npub fn erase(&mut self, k: &K) -> bool;\npub fn count(&self, k: &K) -> usize; // ∈ {0,1}\n```\n\n- `erase` removes an entry by key value and returns `true` if something was removed.\n- `count` returns `1` if an entry exists and `0` otherwise, mirroring the C++ `std::map` API.\n\n### Ordered Iteration and `lower_bound`\n\n```rust\npub fn lower_bound<'a>(&'a self, k: &K)\n    -> Box<dyn Iterator<Item = (&'a Arc<K>, &'a V)> + 'a>;\n```\n\n- Returns an iterator starting at the first element whose key is **not less than** `k` (i.e., `k' >= k` under `Ord` on `K`).\n- This is directly analogous to C++ `std::map::lower_bound`.\n\nRegular iteration:\n\n```rust\npub fn iter<'a>(&'a self)\n    -> Box<dyn Iterator<Item = (&'a Arc<K>, &'a V)> + 'a>;\n\npub fn iter_mut<'a>(&'a mut self)\n    -> Box<dyn Iterator<Item = (&'a Arc<K>, &'a mut V)> + 'a>;\n```\n\nBoth preserve the underlying `BTreeMap` order (ascending according to `K: Ord`).\n\n---\n\n## Example Usage\n\n```rust\nuse std::sync::Arc;\nuse bitcoin_indirectmap::IndirectMap; // adjust if the actual module path differs\n\nfn main() {\n    let mut map: IndirectMap<String, u64> = IndirectMap::default();\n\n    let k1 = Arc::new(\"alice\".to_owned());\n    let k2 = Arc::new(\"bob\".to_owned());\n\n    assert!(map.insert(k1.clone(), 10)); // new\n    assert!(map.insert(k2.clone(), 42)); // new\n    assert!(!map.insert(Arc::new(\"alice\".to_owned()), 11)); // same logical key, overwritten\n\n    // Lookup by &K\n    if let Some((key_arc, value)) = map.find(&\"alice\".to_owned()) {\n        assert!(Arc::ptr_eq(key_arc, &k1) || **key_arc == \"alice\".to_string());\n        assert_eq!(*value, 11);\n    }\n\n    // Mutable lookup\n    if let Some((_key_arc, value_mut)) = map.get_mut(&\"bob\".to_owned()) {\n        *value_mut += 1;\n    }\n\n    // Ordered iteration\n    for (key, value) in map.iter() {\n        println!(\"{} => {}\", key, value);\n    }\n\n    // Erase\n    assert!(map.erase(&\"alice\".to_owned()));\n    assert_eq!(map.count(&\"alice\".to_owned()), 0);\n}\n```\n\n### Using `lower_bound`\n\n```rust\nuse std::sync::Arc;\nuse bitcoin_indirectmap::IndirectMap;\n\nfn demo_lower_bound() {\n    let mut map: IndirectMap<i32, &'static str> = IndirectMap::default();\n\n    map.insert(Arc::new(1), \"one\");\n    map.insert(Arc::new(3), \"three\");\n    map.insert(Arc::new(5), \"five\");\n\n    // Iterate starting from the first key >= 3\n    let from_three: Vec<_> = map\n        .lower_bound(&3)\n        .map(|(k, v)| (**k, *v))\n        .collect();\n\n    assert_eq!(from_three, vec![(3, \"three\"), (5, \"five\")]);\n}\n```\n\n---\n\n## Design Rationale\n\n### Value‑Based Ordering with Shared Ownership\n\nThe central idea is to decouple **storage** from **semantic identity**:\n\n- Storage: `Arc<K>` allows multiple subsystems to share ownership of complex keys (e.g., Bitcoin transactions, block headers, or script descriptors) with minimal cloning cost.\n- Semantic identity: ordering and equality are defined on the logical key `K`, not on the pointer.\n\nThis avoids pathologies where two distinct `Arc<K>` instances holding equal `K` values are treated as different keys. Instead, the map behaves as if you keyed directly on `K`, but lends out `Arc<K>` on iteration and lookup, improving ergonomics and efficiency for consumers that expect shared ownership.\n\n### Safety and Invariants\n\nBecause the underlying container is a `BTreeMap`, the usual invariant applies:\n\n- `K` must not be mutated in a way that affects `Ord` after insertion. Doing so would break the ordering invariants of the tree.\n\nIn practice, this usually means that `K` is either:\n\n- An immutable data structure (e.g., hash digests, heights, identifiers), or\n- Mutated only in fields that do not participate in the `Ord` implementation.\n\nThe Rust type system enforces many of these constraints, but any interior mutability (`Cell`, `RefCell`, `Mutex`, etc.) inside `K` must be used judiciously.\n\n### Trait‑Driven Indirection (`HasIndirectMapTypes`)\n\nThe `HasIndirectMapTypes<'a>` trait formalizes the iterator and size types associated with the map. This promotes decoupling by allowing higher‑level components to program against a stable interface without committing to a specific container type.\n\nConceptually, this is analogous to using C++ typedefs and container concepts while keeping open the possibility of changing the underlying container in the future.\n\n---\n\n## Memory Accounting\n\n`DynamicUsage` and `IncrementalDynamicUsage` provide simple, composable estimates:\n\n- `dynamic_usage(&self)` computes an approximate total dynamic usage as:\n\n  ```text\n  (size_of::<IndirectKey<K>>() + size_of::<V>()) * self.len()\n  ```\n\n- `incremental_dynamic_usage(&self)` returns the per‑entry incremental usage:\n\n  ```text\n  size_of::<IndirectKey<K>>() + size_of::<V>()\n  ```\n\nThis ignores allocator overhead and certain internal `BTreeMap` details but is predictable and cheap to compute. It is appropriate for coarse budget enforcement and telemetry.\n\n---\n\n## Integration Notes\n\n- **Crate name:** `bitcoin-indirectmap`\n- **Repository:** <https://github.com/klebs6/bitcoin-rs>\n- **License:** MIT\n- **Rust edition:** 2021\n\nThis crate is intended to integrate into a larger Bitcoin‑oriented Rust code‑base and mirrors data‑structure patterns from Bitcoin Core. It should also be generally usable for any project that wants ordered maps keyed by `Arc<K>` with value‑based ordering semantics.\n\n---\n\n## Caveats and Limitations\n\n- The map is not thread‑safe by itself; it is a standard `BTreeMap`‑backed structure. Wrap it in synchronization primitives (`Mutex`, `RwLock`) if shared across threads.\n- `DynamicUsage` is an estimate; do not treat it as a precise byte‑accurate measurement.\n- Be careful not to mutate `K` in a way that changes ordering after insertion.\n\n---\n\n## Contributing\n\nContributions to improve ergonomics, coverage of Bitcoin Core idioms, and documentation are welcome. Please open issues and pull requests in the upstream repository:\n\n<https://github.com/klebs6/bitcoin-rs>\n",
  "package_categories": [
    "data-structures",
    "cryptography",
    "finance",
    "algorithms"
  ],
  "package_description": "Ordered map keyed by Arc<K> but ordered and queried by the dereferenced K value, mirroring Bitcoin Core's indirectmap pattern and exposing iterator/size types via a trait façade.",
  "package_keywords": [
    "bitcoin",
    "indirectmap",
    "arc",
    "btree",
    "datastructure"
  ]
}