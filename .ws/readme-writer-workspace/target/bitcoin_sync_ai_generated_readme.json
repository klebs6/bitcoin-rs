{
  "crate_name": "bitcoin-sync",
  "full_readme_markdown": "# bitcoin-sync\n\nHigh‑fidelity Rust reimplementation of Bitcoin Core’s low‑level synchronization and threading primitives.\n\nThis crate mirrors the semantics of Bitcoin Core’s C++ locking, semaphore, and thread‑interrupt machinery while exposing an idiomatic Rust API built on top of `parking_lot` and `tracing`. It is intended for building Bitcoin‑style concurrent runtimes, particularly where lock‑order correctness and deterministic behaviour matter more than maximal abstraction.\n\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate, but it is designed to be a close, technically detailed approximation of the crate’s intent and usage.\n\n---\n\n## Design goals\n\n- **Semantic compatibility with Bitcoin Core**\n  - Similar behaviour to `CCriticalSection`, `CThreadInterrupt`, `TraceThread`, and related helpers.\n  - No poisoning semantics on mutex failure, matching Core’s model (panic ≠ permanent lock poisoning).\n- **Strong debugging & lock‑order diagnostics**\n  - Optional early deadlock detection via a global lock‑graph (when compiled with `DEBUG_LOCKORDER`).\n  - Assertions that verify which locks are held/not‑held at specific call sites.\n- **Minimal, explicit primitives**\n  - Thin wrappers around `parking_lot` raw mutexes and condition variables.\n  - RAII helpers (`UniqueLock`, `ReverseLock`, `SemaphoreGrant`, etc.) instead of opaque higher‑level frameworks.\n- **Predictable threading behaviour**\n  - Structured thread launch wrapper that logs lifecycle and propagates panics.\n  - Interruptible sleeper abstraction (`ThreadInterrupt`) with well‑defined timing semantics.\n\nThis crate is deliberately low level. It is intended for experts who need precise control over lock ordering and cross‑thread coordination rather than generic application‑level concurrency.\n\n---\n\n## Features overview\n\n### 1. Lock abstraction: `LockApi` and `AnnotatedMixin`\n\n```rust\npub trait LockApi {\n    fn lock(&self);\n    fn unlock(&self);\n    fn try_lock(&self) -> bool;\n}\n```\n\n`LockApi` represents the minimal interface expected from a raw, **non‑poisoning** mutex. Any type implementing this trait can plug into the higher‑level RAII guards provided by this crate.\n\n`AnnotatedMixin<Parent>` wraps a `Parent: LockApi` and:\n\n- Forwards all lock operations.\n- Provides a stable address and hook point for lock‑order tracking and future instrumentation.\n\n```rust\npub struct AnnotatedMixin<Parent: LockApi> {\n    parent: Parent,\n}\n\nimpl<Parent: LockApi> LockApi for AnnotatedMixin<Parent> { /* forwards */ }\n```\n\nThe primary concrete aliases are:\n\n```rust\n/// Recursive lock (reentrant), no waiting (raw mutex semantics).\npub type RecursiveMutex<T> = AnnotatedMixin<parking_lot::ReentrantMutex<T>>;\n\n/// Non‑recursive raw mutex supporting waiting.\npub type Mutex = AnnotatedMixin<parking_lot::RawMutex>;\n```\n\n`AnnotatedMixin<parking_lot::RawMutex>` implements `Default` with `RawMutex::INIT` so it can be used as a field with default construction.\n\n### 2. RAII locking: `UniqueLock` and `ReverseLock`\n\n#### `UniqueLock`\n\n`UniqueLock<'a, M>` is a RAII guard analogous to C++ `std::unique_lock` specialized for `M: LockApi + ?Sized`:\n\n```rust\npub struct UniqueLock<'a, M: LockApi + ?Sized> {\n    mutex: &'a M,\n    owns:  bool,\n    name:  &'static str,\n    file:  &'static str,\n    line:  u32,\n}\n```\n\nKey operations:\n\n- `new(mutex, name, file, line, try_: Option<bool>)` – constructs and either blocks (`lock`) or attempts `try_lock` depending on `try_`.\n- `enter()` – acquire the lock if not already owned.\n- `try_enter() -> bool` – try to acquire; returns whether ownership was gained.\n- `unlock()` – explicitly release if currently owned.\n- `owns_lock() -> bool` – mirror of C++’s `owns_lock`.\n- `Drop` – automatically unlocks if still owned.\n\nIt also implements `From<&UniqueLock<…>> for bool`, so you can write:\n\n```rust\nlet locked: bool = (&guard).into();\n```\n\nThe struct records `name`, `file`, and `line`, allowing detailed logging of lock acquisition and release events via `tracing` macros inside the implementation.\n\n#### `ReverseLock`\n\n`ReverseLock` is a scoped inversion helper:\n\n```rust\npub struct ReverseLock<'guard, 'lock, M: LockApi + ?Sized> {\n    guard:    &'guard mut UniqueLock<'lock, M>,\n    relocked: bool,\n}\n```\n\n- `ReverseLock::new(&mut guard)` unlocks the underlying mutex immediately.\n- On `Drop`, it re‑enters the lock (if not already re‑locked).\n\nThis pattern is essential in Core’s codebase for temporarily releasing a lock around a potentially blocking or re‑entrant operation without losing the association with the guard variable.\n\n### 3. Macros for critical sections and lock assertions\n\nThe crate exposes several macros to express critical sections, multi‑lock scopes, and assertions that a lock is (or is not) held.\n\n#### Scope guards\n\n```rust\nlock!(cs);      // creates an unnamed UniqueLock bound to `cs`\nlock2!(cs1, cs2); // lock two mutexes in sequence\n\ntry_lock!(cs, guard);  // guard: UniqueLock with try=Some(true)\nwait_lock!(cs, guard); // guard: UniqueLock with blocking lock\n\nwith_lock!(cs, {\n    // critical region\n    do_something();\n});\n```\n\nThe `lock!` and `lock2!` macros use the `paste` crate to synthesize a unique guard name linked to the source line, ensuring RAII destruction at scope exit.\n\n`with_lock!` is syntactic sugar which:\n\n1. Acquires a `UniqueLock` on `$cs` via `lock!`.\n2. Executes `$code` while the lock is held.\n\n#### Critical section tracking\n\nTwo macros integrate with the lock‑order tracking internals (see the `debug_lockorder` module):\n\n```rust\nenter_critical_section!(cs);\nleave_critical_section!(cs);\n```\n\n- `enter_critical_section!(cs)` records metadata about the acquisition (name, file, line, address) and then calls `cs.lock()`.\n- `leave_critical_section!(cs)` verifies that `cs` is the most recent critical section lock before unlocking and notifying the lock‑order system.\n\nThese macros allow the `DEBUG_LOCKORDER` logic to build a global **partial order** on lock acquisition, enabling early detection of potential deadlocks by identifying cycles in the lock graph.\n\n#### Lock assertions\n\n```rust\nassert_lock_held!(cs);\nassert_lock_not_held!(cs);\n```\n\nThese macros call into `assert_lock_held_internal` / `assert_lock_not_held_internal`, which, under `DEBUG_LOCKORDER`, verify that `cs` is (or is not) present in the thread‑local lock stack. On failure they emit detailed diagnostics and either abort or panic depending on configuration.\n\n### 4. Semaphore & permits: `Semaphore` and `SemaphoreGrant`\n\n`Semaphore` is a simple counting semaphore built on top of a `Condvar` and a raw `Mutex<i32>`:\n\n```rust\n#[derive(Default)]\npub struct Semaphore {\n    cv:    Condvar,\n    count: Mutex<i32>,\n}\n``\n\nOperations:\n\n- `Semaphore::new(init: i32)` – create with an initial permit count (must be ≥ 0).\n- `wait(&self)` – block until `count > 0`, then decrement.\n- `try_wait(&self) -> bool` – non‑blocking attempt; `true` if a permit was consumed.\n- `post(&self)` – increment `count` and wake one waiter.\n\n`SemaphoreGrant` is a RAII wrapper around a single permit:\n\n```rust\n#[derive(Clone)]\npub struct SemaphoreGrant {\n    sem:        Arc<Semaphore>,\n    have_grant: bool,\n}\n```\n\nSemantics:\n\n- `SemaphoreGrant::new(sema: Arc<Semaphore>, try_: Option<bool>)` – constructs a grant and either blocks or tries to acquire immediately.\n- `acquire(&mut self)` – blocking acquisition if not already holding a permit.\n- `try_acquire(&mut self) -> bool` – attempt acquisition without blocking.\n- `release(&mut self)` – return the permit if currently held.\n- `move_to(&mut self, target: &mut SemaphoreGrant)` – transfer ownership of a permit to `target`.\n- `Drop` – automatically releases any held permit.\n\nLike `UniqueLock`, `SemaphoreGrant` implements `From<&SemaphoreGrant> for bool` so it can be treated as a truth value indicating permit ownership.\n\n`WaitTimedOut(bool)` is a thin wrapper with `.timed_out() -> bool` to express timeout results in a self‑documenting fashion.\n\n### 5. Thread management: `launch_traced_thread!` and `trace_thread`\n\n#### `launch_traced_thread!`\n\n```rust\nlaunch_traced_thread!(\"indexer\", || {\n    // your thread body\n});\n```\n\nExpands to `std::thread::Builder::new().name(...).spawn(...)` and delegates the body to `trace_thread`, panicking immediately if thread creation fails.\n\n#### `trace_thread`\n\n```rust\npub fn trace_thread<F>(thread_name: &str, thread_func: F)\nwhere\n    F: FnOnce() + Send + 'static,\n{ /* ... */ }\n```\n\n- Creates a `tracing` span named `\"thread\"` with field `name = thread_name`.\n- Logs `\"<name> thread start\"` and `\"<name> thread exit\"` at `INFO` level.\n- Wraps the user closure in `std::panic::catch_unwind`. If it panics, it logs the panic and re‑raises, preserving default Rust semantics while still emitting structured telemetry.\n\nThis is a direct analogue of Bitcoin Core’s `TraceThread` helper.\n\n### 6. Interruptible sleeping: `ThreadInterrupt`\n\n`ThreadInterrupt` models `CThreadInterrupt` from Bitcoin Core:\n\n```rust\n#[derive(Default)]\npub struct ThreadInterrupt {\n    cond: Condvar,\n    gate: Mutex<()>,\n    flag: AtomicBool,\n}\n```\n\nCore semantics:\n\n- `new()` – create with `flag = false`.\n- `as_bool() -> bool` – observe the interrupt flag with `Acquire` ordering.\n- `reset()` – clear any pending interrupt (`Release` ordering).\n- `invoke()` – set the flag true and `notify_all()` on the condition variable.\n- `sleep_for(rel_time: StdDuration) -> bool`:\n  - Returns `false` if an interrupt happens **before** the full timeout elapses.\n  - Returns `true` if the full `rel_time` passes without interruption.\n\nImplementation detail: `sleep_for` loops, computing the remaining time until a pre‑computed `deadline` and calling `Condvar::wait_for`. After each wakeup it re‑checks the interrupt flag and the clock.\n\nThis primitive is useful for threads that must be **cooperatively** cancellable while still respecting a bounded maximum sleep.\n\n### 7. Low‑level waiting: `wait_until`\n\n```rust\npub fn wait_until<T: ?Sized, P>(\n    cv:       &parking_lot::Condvar,\n    guard:    &mut parking_lot::MutexGuard<'_, T>,\n    deadline: std::time::Instant,\n    mut predicate: P,\n) -> bool\nwhere\n    P: FnMut() -> bool,\n{ /* ... */ }\n```\n\nThis helper repeatedly waits on `cv` until either:\n\n- `predicate()` becomes `true`, in which case it returns `true`, or\n- the `deadline` is reached and a final predicate check still fails, in which case it returns that final predicate result.\n\nThe pattern corresponds to the standard condition‑variable idiom:\n\n\\[\n  \\text{while } \\neg P \\text{ and } t < T_{\\text{deadline}}: \\text{ wait}.\n\\]\n\nMathematically, this implements a partial function `f: (P, T_deadline) -> bool` where the result is the final valuation of `P` at or after the deadline, ensuring **spurious wakeups** do not violate the semantics.\n\n### 8. Scoped raw mutex: `ScopedRawMutex` and `ScopedRawMutexGuard`\n\nFor scenarios requiring direct access to a raw `parking_lot::RawMutex` while still benefiting from RAII unlocking:\n\n```rust\npub struct ScopedRawMutex(RawMutex);\n\npub struct ScopedRawMutexGuard<'a> {\n    lock: &'a ScopedRawMutex,\n}\n```\n\n- `ScopedRawMutex::default()` – constructs with `RawMutex::INIT`.\n- `ScopedRawMutex::lock(&self) -> ScopedRawMutexGuard<'_>` – locks the underlying raw mutex, returning a guard.\n- On `Drop` of `ScopedRawMutexGuard`, `RawMutexTrait::unlock` is invoked.\n\nThis is intentionally minimal; it exists primarily as a bridge towards the C++‑style code generation and binding layers.\n\n### 9. Debug lock‑order analysis (`DEBUG_LOCKORDER`)\n\nWhen built with `DEBUG_LOCKORDER`, the crate enables an internal module that maintains a global lock‑graph to detect:\n\n- Double‑locking of non‑recursive mutexes on the same thread.\n- Lock order inversions across threads (potential deadlocks).\n\nKey concepts:\n\n- **LockLocation** – describes where a lock was acquired: mutex name, source file, line, thread name, and whether the acquisition was a try‑lock.\n- **LockStack** – per‑thread stack of `(mutex_ptr, LockLocation)` pairs.\n- **LockOrders** – a map from ordered pairs `(A, B)` to the stack snapshot when `B` was acquired after `A`.\n- **InvLockOrders** – set of the reversed pairs `(B, A)` for fast detection of inversions.\n\nAlgorithmically, each time a lock is pushed, the module:\n\n1. Checks for **double lock**: if the same pointer already appears in the stack, it reports a double lock.\n2. For each previously held lock `L` in the current stack, considers pair `(L, current)`:\n   - If `(current, L)` is already in `lockorders`, a cycle exists → **potential deadlock**.\n   - Otherwise inserts `(L, current)` into `lockorders` and `(current, L)` into `invlockorders`.\n\nIn both double‑lock and potential‑deadlock cases, a detailed textual dump of the involved lock stacks is produced, and `abort_or_panic` is called. A global `AtomicBool` `G_DEBUG_LOCKORDER_ABORT` determines whether to abort the process or panic.\n\nIn non‑debug builds (`cfg(not(DEBUG_LOCKORDER))`), the functions become no‑ops, so there is no runtime overhead beyond the macro calls themselves.\n\n---\n\n## Example usage\n\n### Basic mutex usage with RAII\n\n```rust\nuse bitcoin_sync::{Mutex, UniqueLock};\n\nstatic GLOBAL: Mutex = Mutex::default();\n\nfn critical_section() {\n    // Create a guard that locks immediately.\n    let mut guard = UniqueLock::new(&GLOBAL, \"GLOBAL\", file!(), line!(), None);\n\n    // do work while lock is held\n\n    // Optionally release early\n    guard.unlock();\n}\n``\n\n### Using the helper macros\n\n```rust\nuse bitcoin_sync::{Mutex};\nuse bitcoin_sync::{lock, with_lock};\n\nstatic COUNTER_LOCK: Mutex = Mutex::default();\nstatic mut COUNTER: i32 = 0;\n\nfn increment() {\n    with_lock!(COUNTER_LOCK, unsafe {\n        COUNTER += 1;\n    });\n}\n\nfn guarded_section() {\n    lock!(COUNTER_LOCK);\n    // RAII guard lives until end of scope\n}\n```\n\n### Semaphore and grants\n\n```rust\nuse std::sync::Arc;\nuse bitcoin_sync::{Semaphore, SemaphoreGrant};\n\nfn bounded_concurrency() {\n    let sem = Arc::new(Semaphore::new(3));\n\n    let mut grant = SemaphoreGrant::new(sem.clone(), None);\n    // we now hold one permit; scope exit will release automatically\n\n    // do limited‑concurrency work here\n\n    // explicit release is also possible\n    grant.release();\n}\n```\n\n### Interruptible worker thread\n\n```rust\nuse std::sync::Arc;\nuse std::time::Duration;\nuse bitcoin_sync::{ThreadInterrupt, launch_traced_thread};\n\nfn main() {\n    let ti = Arc::new(ThreadInterrupt::new());\n    let ti_worker = ti.clone();\n\n    let handle = launch_traced_thread!(\"worker\", move || {\n        while ti_worker.sleep_for(Duration::from_secs(5)) {\n            // periodic task; returns false if interrupted\n        }\n        // cleanup\n    });\n\n    // later\n    ti.invoke();    // request shutdown\n    handle.join().unwrap();\n}\n```\n\n---\n\n## Crate metadata\n\n- **Crate**: `bitcoin-sync`\n- **Version**: `0.1.19`\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\n- **License**: MIT\n- **Edition**: Rust 2021\n\nThis crate is designed as a building block within a larger Bitcoin reimplementation effort; its public API focuses on concurrency primitives, not high‑level Bitcoin logic.\n\n---\n\n## When to use this crate\n\nUse `bitcoin-sync` if you:\n\n- Are porting or closely emulating Bitcoin Core behaviour in Rust and need compatible synchronization primitives.\n- Need early deadlock detection and explicit lock‑order tracking similar to Core’s `DEBUG_LOCKORDER` tooling.\n- Prefer explicit, RAII‑based concurrency constructs over more abstract frameworks.\n\nIf you only need generic high‑level Rust concurrency, standard library types (`Mutex`, `RwLock`, `Condvar`) or `tokio`/`async` primitives may be more appropriate. `bitcoin-sync` is primarily for **systems programmers** who require tight control over lock semantics and diagnostics.\n",
  "package_categories": [
    "concurrency",
    "development-tools",
    "algorithms",
    "network-programming",
    "cryptography"
  ],
  "package_description": "Low-level synchronization, semaphore, lock-order debugging, and interruptible thread utilities modelled after Bitcoin Core, built on parking_lot and tracing.",
  "package_keywords": [
    "bitcoin",
    "concurrency",
    "mutex",
    "semaphore",
    "deadlock-detection"
  ]
}