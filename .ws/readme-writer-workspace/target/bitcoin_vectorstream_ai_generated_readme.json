{
  "crate_name": "bitcoin-vectorstream",
  "full_readme_markdown": "# bitcoin-vectorstream\n\nA minimal, allocation-conscious byte stream abstraction over existing `Vec<u8>` buffers, tailored for Bitcoin serialization pipelines.\n\nThis crate provides two core types:\n\n- `VectorReader`: an `std::io::Read` implementation over an immutable `Arc<Vec<u8>>` slice with an internal cursor.\n- `VectorWriter`: an `std::io::Write`-compatible sink that overwrites and/or appends into an `Rc<RefCell<Vec<u8>>>` buffer.\n\nBoth types are designed to integrate with the `bitcoin_serialize` traits (`BtcSerialize`, `BtcUnserialize`, `SerializeMany`, `UnserializeMany`) and to support type- and version-tagged wire formats (e.g., Bitcoin consensus and network encodings) without incidental allocations.\n\n> Note: This README was generated by an AI model based on the exposed interface. It may not be perfectly accurate or complete, but it should be a strong approximation of the crate's intent and usage.\n\n---\n\n## Features at a glance\n\n- Zero-copy **read** over an existing `Arc<Vec<u8>>` with bounds-checked cursor management.\n- In-place **write** into an `Rc<RefCell<Vec<u8>>>`, overwriting existing bytes and growing the vector only when needed.\n- `Read` / `Write` implementations for drop-in use with standard I/O traits.\n- Type and version parameters propagated through the stream, simplifying protocol negotiation and feature-flagged encodings.\n- `Builder` + `Getters` (via derive) for ergonomic construction and access.\n- Interoperability with `bitcoin_serialize` traits via `<<` / `>>` operators (`Shl` / `Shr` impls).\n\nThe design targets high-performance Bitcoin serialization where:\n\n- Ownership of the underlying buffer is **external** to the stream, and\n- The same buffer may be shared across multiple components or re-used for multiple encodings.\n\n---\n\n## Core concepts\n\n### VectorReader\n\n`VectorReader` acts as a lightweight, non-owning input stream over an `Arc<Vec<u8>>`:\n\n```rust\nuse std::io::Read;\nuse std::sync::Arc;\nuse bitcoin_vectorstream::VectorReader;\n\nlet data: Arc<Vec<u8>> = Arc::new(vec![0x01, 0x02, 0x03, 0x04]);\nlet mut reader = VectorReader::new(\n    /* ty      = */ 0,\n    /* version = */ 0,\n    data.clone(),\n    /* pos     = */ 0,\n);\n\nlet mut buf = [0u8; 2];\nreader.read(&mut buf).unwrap();\nassert_eq!(&buf, &[0x01, 0x02]);\nassert!(!reader.empty());\nassert_eq!(reader.size(), 2); // bytes remaining\n```\n\n#### Semantics\n\n- `new(ty, version, data, pos)`\n  - `ty`: Serialization type discriminator (e.g., network vs. disk format).\n  - `version`: Encoding version / flags (e.g., protocol version, segwit flags).\n  - `data`: Shared byte buffer (`Arc<Vec<u8>>`).\n  - `pos`: Initial cursor position. Must satisfy `pos <= data.len()`, otherwise the constructor **panics**.\n\n- `size(&self) -> usize`\n  - Returns the number of unread bytes: `data.len() - pos`.\n\n- `empty(&self) -> bool`\n  - Returns `true` when `pos == data.len()`.\n\n- `impl Read for VectorReader`\n  - `read(&mut self, buf: &mut [u8])`:\n    - Copies up to `buf.len()` bytes from the current cursor.\n    - Advances the internal position.\n    - Never allocates; uses `ptr::copy_nonoverlapping` under the hood.\n\n- `impl Default for VectorReader`\n  - Produces a trivially empty reader (`Arc<Vec<u8>>::new()`, cursor at `0`). Primarily intended for generic contexts that require a `Default` bound.\n\n#### Bitcoin integration via `>>`\n\n`VectorReader` implements `Shr<&mut T>` where `T: bitcoin_serialize::BtcUnserialize<VectorReader> + ?Sized`. This enables piping deserialization via `>>`:\n\n```rust\nuse std::sync::Arc;\nuse bitcoin_vectorstream::VectorReader;\n\nfn deserialize_message<T>(bytes: Arc<Vec<u8>>) -> T\nwhere\n    T: bitcoin_serialize::BtcUnserialize<VectorReader> + Default,\n{\n    let mut msg = T::default();\n    let reader = VectorReader::new(0, 0, bytes, 0);\n    let _ = reader >> &mut msg; // calls msg.unserialize(&mut reader)\n    msg\n}\n```\n\n### VectorWriter\n\n`VectorWriter` is a mutable output stream over `Rc<RefCell<Vec<u8>>>`, capable of overwriting existing bytes and appending beyond the current end.\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nuse std::io::Write;\nuse bitcoin_vectorstream::VectorWriter;\n\nlet backing = Rc::new(RefCell::new(Vec::<u8>::new()));\nlet mut writer = VectorWriter::new(\n    /* n_type    = */ 0,\n    /* n_version = */ 0,\n    backing.clone(),\n    /* n_pos     = */ 0,\n);\n\nwriter.write(&[0xAA, 0xBB]).unwrap();\nwriter.write(&[0xCC]).unwrap();\n\nassert_eq!(&*backing.borrow(), &[0xAA, 0xBB, 0xCC]);\n```\n\n#### Semantics\n\n- `new(n_type, n_version, vch_data, n_pos)`\n  - `n_type`: Serialization type discriminator.\n  - `n_version`: Encoding version / flags.\n  - `vch_data`: Shared, interior-mutable buffer (`Rc<RefCell<Vec<u8>>>`).\n  - `n_pos`: Initial write position.\n    - If `n_pos > vch_data.len()`, the underlying vector is resized to `n_pos` (filled with zeros) before any write.\n\n- Write behavior:\n  - Writing `n_size` bytes at `n_pos` performs:\n    - Overwrite up to `min(n_size, len - n_pos)` bytes in-place.\n    - If `n_size` exceeds available overwrite capacity, the excess is appended (the vector grows accordingly).\n  - Internal cursor `n_pos` is incremented by `n_size` for each call.\n\n- `impl Write for VectorWriter`\n  - `write(&mut self, buf: &[u8]) -> io::Result<usize>` forwards to the raw pointer-based `write` method.\n  - `flush(&mut self)` is a no-op (`Ok(())`), appropriate for in-memory buffers.\n\n- `impl Default for VectorWriter`\n  - Creates an empty `Rc<RefCell<Vec<u8>>>` with cursor at `0`, suitable for generic streaming code.\n\n- Raw write API:\n\n```rust\nimpl VectorWriter {\n    /// Write `n_size` bytes from `pch` into the stream.\n    pub fn write(&mut self, pch: *const u8, n_size: usize) {\n        // ...\n    }\n}\n```\n\nThis method is used internally and exposed explicitly for high-performance integrations where the caller already has raw pointers and lengths.\n\n#### Bitcoin integration via `<<`\n\n`VectorWriter` implements `Shl<&T>` for `T: bitcoin_serialize::BtcSerialize<VectorWriter> + ?Sized`, enabling expressive serialization pipelines:\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nuse bitcoin_vectorstream::VectorWriter;\n\nfn serialize_message<T>(msg: &T) -> Rc<RefCell<Vec<u8>>>\nwhere\n    T: bitcoin_serialize::BtcSerialize<VectorWriter>,\n{\n    let backing = Rc::new(RefCell::new(Vec::<u8>::new()));\n    let writer = VectorWriter::new(0, 0, backing.clone(), 0);\n    let _ = writer << msg; // calls msg.serialize(&mut writer)\n    backing\n}\n```\n\n### Batch (de)serialization helpers\n\nBoth reader and writer offer `*_with_args` constructors parameterized by `bitcoin_serialize::UnserializeMany` and `SerializeMany` respectively:\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nuse std::sync::Arc;\nuse bitcoin_vectorstream::{VectorReader, VectorWriter};\n\n// Deserialize multiple objects in one pass\nfn read_many<Args>(bytes: Arc<Vec<u8>>, args: Args)\nwhere\n    Args: bitcoin_serialize::UnserializeMany<VectorReader>,\n{\n    let _reader = VectorReader::new_with_args(0, 0, bytes, 0, args);\n}\n\n// Serialize multiple objects in one pass\nfn write_many<Args>(backing: Rc<RefCell<Vec<u8>>>, args: Args)\nwhere\n    Args: bitcoin_serialize::SerializeMany<VectorWriter>,\n{\n    let _writer = VectorWriter::new_with_args(0, 0, backing, 0, args);\n}\n```\n\nThese constructors encapsulate a common pattern in Bitcoin protocol code: construct the stream, immediately (de)serialize a set of fields, and then retain (or drop) the stream.\n\n---\n\n## Safety, invariants, and performance\n\n### Invariants\n\n- `VectorReader::new` panics if `pos > data.len()`. Callers must ensure the starting offset is within bounds.\n- `VectorWriter::new` ensures that after construction, `n_pos <= vch_data.len()` via a resize if needed.\n- `VectorWriter::write` asserts that `n_pos <= vec_ref.len()` before performing pointer arithmetic.\n\nThese invariants allow the implementations to safely employ `unsafe` pointer operations for maximal throughput while staying memory-safe at the API boundary.\n\n### Complexity\n\n- All operations are (O(n)) in the number of bytes copied; there is no additional per-byte overhead beyond the intrinsic cost of `ptr::copy_nonoverlapping`.\n- No extra allocations occur during reads.\n- Writes only allocate when growing the backing vector; overwrites are in-place and do not allocate.\n\n### Concurrency and sharing\n\n- `VectorReader` uses `Arc<Vec<u8>>`, enabling cheap cloning and safe cross-thread sharing of immutable data.\n- `VectorWriter` uses `Rc<RefCell<Vec<u8>>>`, which is strictly single-threaded but allows interior mutability and logical sharing within a thread or task.\n\nIn typical Bitcoin applications, large serialized messages are shared read-only across components (favoring `Arc`), while mutable buffers are confined to a single execution context (favoring `Rc<RefCell<_>>`).\n\n---\n\n## Integration with bitcoin-rs\n\nThis crate resides in the `bitcoin-rs` repository:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\nIt is likely used internally by higher-level modules implementing consensus serialization for blocks, transactions, P2P messages, and related structures.\n\nYou can treat `bitcoin-vectorstream` as the low-level streaming substrate and build your own domain-specific codecs on top of it, provided they implement the `bitcoin_serialize` traits.\n\n---\n\n## Usage examples\n\n### Appending to an existing buffer\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nuse std::io::Write;\nuse bitcoin_vectorstream::VectorWriter;\n\nlet backing = Rc::new(RefCell::new(vec![0x00, 0x11, 0x22]));\n// Start writing at the current end -> append\nlet start_pos = backing.borrow().len();\nlet mut writer = VectorWriter::new(0, 0, backing.clone(), start_pos);\n\nwriter.write(&[0x33, 0x44]).unwrap();\nassert_eq!(&*backing.borrow(), &[0x00, 0x11, 0x22, 0x33, 0x44]);\n```\n\n### Overwriting part of a buffer in-place\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nuse std::io::Write;\nuse bitcoin_vectorstream::VectorWriter;\n\nlet backing = Rc::new(RefCell::new(vec![0xDE, 0xAD, 0xBE, 0xEF]));\n// Overwrite the middle two bytes\nlet mut writer = VectorWriter::new(0, 0, backing.clone(), 1);\nwriter.write(&[0x01, 0x02]).unwrap();\n\nassert_eq!(&*backing.borrow(), &[0xDE, 0x01, 0x02, 0xEF]);\n```\n\n### Partial reads without slicing\n\n```rust\nuse std::sync::Arc;\nuse std::io::Read;\nuse bitcoin_vectorstream::VectorReader;\n\nlet data = Arc::new(vec![10u8, 20, 30, 40, 50]);\nlet mut reader = VectorReader::new(0, 0, data.clone(), 2); // start at index 2\n\nlet mut buf = [0u8; 3];\nlet n = reader.read(&mut buf).unwrap();\nassert_eq!(n, 3);\nassert_eq!(&buf, &[30, 40, 50]);\nassert!(reader.empty());\n```\n\n---\n\n## Error handling and panics\n\n- Constructors and write operations may panic when invariants are violated (e.g., inconsistent cursor vs. buffer length). These conditions typically indicate bugs at the call site and are not expected in well-formed protocol code.\n- `Read`/`Write` trait methods themselves return `io::Result<usize>` / `io::Result<()>` but currently perform no fallible I/O beyond the bounds and invariants enforced by the constructors and internal logic.\n\nIn performance-critical serialization code, panics on invariant violation are often preferable to silently truncated or corrupted messages.\n\n---\n\n## Logging\n\nThe code uses macros such as `trace!`, `debug!`, and `error!` to instrument stream construction and raw writes. These are typically provided by a logging facade like `tracing` or `log` in the parent crate. Consult `bitcoin-rs` for the concrete logging backend and configuration.\n\n---\n\n## License\n\nThis crate is distributed under the MIT License.\n\nSee the root repository for full licensing details:\n\n- <https://github.com/klebs6/bitcoin-rs>\n",
  "package_categories": [
    "cryptography network-programming parsing algorithms science"
  ],
  "package_description": "Minimal zero-copy reader and writer streams over shared Vec<u8> buffers, designed for high-performance Bitcoin serialization using Arc/Rc-backed byte vectors.",
  "package_keywords": [
    "bitcoin serialization byte-stream vector io"
  ]
}