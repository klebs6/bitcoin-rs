{
  "crate_name": "bitcoin-sha256",
  "full_readme_markdown": "# bitcoin-sha256\n\nAn aggressively optimized, Bitcoin-Core–compatible SHA‑256 implementation in Rust, with explicit control over compression rounds, FFI‑oriented entry points, and CPU‑feature–aware backend selection.\n\n> NOTE: This README.md was generated by an AI model. It may not perfectly describe the crate, but it should be a close and reasonably accurate approximation.\n\n---\n\n## Overview\n\n`bitcoin-sha256` provides a low‑level, **bit‑for‑bit compatible** SHA‑256 implementation tuned for Bitcoin workloads:\n\n- Streaming hasher `Sha256` implementing `std::io::Write`.\n- A `ComputeSha256` trait for computing SHA‑256 on `u256` values.\n- Explicit, FIPS‑180‑4–accurate bitwise primitives for Σ/σ, Ch, Maj, and a canonical `sha256_round` implementation.\n- Single‑block and batched compression entry points that mirror Bitcoin Core’s C++ layout.\n- Auto‑detected CPU backends (scalar, SHANI, AVX2) for double‑SHA‑256 on 64‑byte blocks.\n- FFI‑compatible pointer APIs for integration with C/C++ or other runtime systems.\n\nThe design goal is **mechanical fidelity** to Bitcoin Core’s SHA‑256 logic while leveraging Rust’s type system and tooling (e.g., `tracing`) for observability and safety where it does not interfere with performance.\n\n---\n\n## Features at a Glance\n\n- **Canonical SHA‑256 compression**\n  - `sha256_transform_block` implements the full 64‑round compression function on a single 64‑byte block, with explicit round scheduling and feed‑forward.\n  - `sha256_round` gives a pedagogical, round‑by‑round view of the inner operation, matching the original C++ macro semantics.\n\n- **Streaming hasher**\n  - `Sha256` struct represents a stateful hasher:\n    - `s: [u32; 8]` – internal state words.\n    - `buf: [u8; 64]` – 64‑byte block buffer.\n    - `bytes: u64` – total bytes consumed.\n  - Implements `Default`, `Write`, and convenient helpers like `new`, `reset`, `finalize`, and `finalize_wipe`.\n\n- **Bitcoin‑style double‑SHA‑256**\n  - Scalar reference path: `transform_d64_scalar(out32, in64)` computes `SHA256(SHA256(message))` for a single 64‑byte message.\n  - Backend abstraction (`Sha256Backend`) supports optimized 2‑way, 4‑way, and 8‑way double‑SHA‑256 transforms.\n\n- **Backend auto‑detection**\n  - `sha256auto_detect()` inspects CPU features (e.g., `sha`, `avx2`) and configures the best implementation:\n    - Standard scalar backend.\n    - SHANI‑accelerated backend (`enable-shani` feature).\n    - AVX2 8‑way double‑SHA‑256 (`enable-avx2` feature).\n  - Returns a human‑readable description closely mirroring Bitcoin Core’s strings, e.g.:\n    - `\"standard\"`\n    - `\"shani(1way,2way)\"`\n    - `\"avx2(8way)\"`\n    - `\"shani(1way,2way),avx2(8way)\"`\n\n- **FFI‑friendly surface**\n  - Pointer‑based APIs such as `sha256_write`, `sha256_finalize`, `sha256_transform`, `transform_d64_scalar`, and the `TransformType` / `TransformD64Type` aliases allow direct integration with C ABI call sites.\n\n- **Internal validation**\n  - `self_test()` exhaustively validates compression states and double‑SHA‑256 helpers against canonical fixtures, including misaligned input cases used in Bitcoin Core.\n\n---\n\n## Cryptographic Background\n\nThe implementation is a direct encoding of FIPS 180‑4 (SHA‑256) semantics:\n\n- **State**: eight 32‑bit words \\( (a,b,c,d,e,f,g,h) \\).\n- **Message schedule** \\(w_0,\\dots,w_{63}\\):\n  - First 16 words are big‑endian decoded input.\n  - Remaining 48 words derive via:\n    \\[\n    w_t = w_{t-16} + \\sigma_0(w_{t-15}) + w_{t-7} + \\sigma_1(w_{t-2}) \\pmod{2^{32}}\n    \\]\n- **Round function** for round \\(t\\):\n  - `Ch` (choice): \\( \\operatorname{Ch}(x,y,z) = z \\oplus (x \\land (y \\oplus z)) \\)\n  - `Maj` (majority): \\( \\operatorname{Maj}(x,y,z) = (x \\land y) \\lor (z \\land (x \\lor y)) \\)\n  - Uppercase sigmas:\n    - \\(\\Sigma_0(x) = x\\rotateRight{2} \\oplus x\\rotateRight{13} \\oplus x\\rotateRight{22}\\)\n    - \\(\\Sigma_1(x) = x\\rotateRight{6} \\oplus x\\rotateRight{11} \\oplus x\\rotateRight{25}\\)\n  - Lowercase sigmas for schedule:\n    - \\(\\sigma_0(x) = x\\rotateRight{7} \\oplus x\\rotateRight{18} \\oplus (x \\gg 3)\\)\n    - \\(\\sigma_1(x) = x\\rotateRight{17} \\oplus x\\rotateRight{19} \\oplus (x \\gg 10)\\)\n\nThe crate explicitly exposes these functions (`big_sigma0`, `big_sigma1`, `sha256_sigma0`, `sha256_sigma1`, `sha256_ch`, `sha256_maj`, `sha256_round`) to let advanced users audit, instrument, or swap specific components while preserving algebraic correctness.\n\nFor Bitcoin applications, **double‑SHA‑256** on fixed 64‑byte inputs is a first‑class workload (block headers, transaction IDs). This crate’s `transform_d64_scalar` and the `TransformD64Type` family are designed specifically for that regime, enabling tight vectorization and multi‑lane execution.\n\n---\n\n## Installation\n\nAdd to your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoin-sha256 = \"0.1.20\"\n```\n\nOptional CPU‑specific features:\n\n```toml\n[dependencies.bitcoin-sha256]\nversion = \"0.1.20\"\nfeatures = [\"enable-shani\", \"enable-avx2\"]\n```\n\n> Note: exact feature names and combinations should be verified against the published crate metadata.\n\n---\n\n## Core Types and Traits\n\n### `Sha256`\n\nStreaming hasher for SHA‑256. Internally equivalent to the FIPS 180‑4 reference with Bitcoin Core–style block handling.\n\nKey capabilities:\n\n- `Sha256::new() -> Sha256` – construct a freshly initialized hasher.\n- `Sha256::reset(&mut self)` – reset to IV, zeroing buffer and counters.\n- `Sha256::finalize(&mut self, &mut [u8; 32])` – finalize without wiping internal state words.\n- `Sha256::finalize_wipe(&mut self, &mut [u8; 32])` – finalize and zero state words for better key‑material hygiene.\n- `Sha256::initialize(&mut self)` – (re)initialize internal state from IV.\n- `Sha256::write_ptr(&mut self, data: *const u8, len: usize)` – low‑level pointer writer.\n- `Sha256::write_from_iterator(&mut self, iter: Box<dyn Iterator<Item = u8>>, len: usize)` – drive from a byte iterator of known length.\n\n`Sha256` also implements `std::io::Write`, making it straightforward to integrate into existing I/O paths.\n\n#### Example: Hashing arbitrary data\n\n```rust\nuse bitcoin_sha256::Sha256; // path may differ depending on crate layout\n\nfn sha256_bytes(data: &[u8]) -> [u8; 32] {\n    let mut hasher = Sha256::new();\n    use std::io::Write;\n\n    hasher.write_all(data).expect(\"write to Sha256\");\n\n    let mut out = [0u8; 32];\n    hasher.finalize(&mut out);\n    out\n}\n```\n\n### `ComputeSha256`\n\nTrait for computing SHA‑256 on types that can be treated as a 32‑byte value.\n\n```rust\npub trait ComputeSha256 {\n    fn sha256(&self) -> u256;\n}\n```\n\nThe crate provides an implementation for `u256`:\n\n```rust\nimpl ComputeSha256 for u256 {\n    fn sha256(&self) -> u256 {\n        let mut result = u256::zero();\n        let mut sha = Sha256::new();\n        sha.write(self.as_ref());\n        sha.finalize(result.as_mut_slice_exact());\n        result\n    }\n}\n```\n\nThis is particularly convenient for Bitcoin transaction IDs and block hashes.\n\n#### Example: Hashing a `u256`\n\n```rust\nuse bitcoin_sha256::ComputeSha256; // and a suitable u256 type from your stack\n\nfn double_sha256_u256(x: &u256) -> u256 {\n    x.sha256()\n}\n```\n\n> The exact `u256` type originates from the surrounding `bitcoin-rs` ecosystem; ensure you import the correct one.\n\n---\n\n## Low‑Level Compression API\n\nThe crate exposes the complete compression machinery for expert users.\n\n### IV initialization\n\n```rust\npub fn sha256_initialize(s: *mut u32)\n```\n\nWrites the standard FIPS 180‑4 IV into an 8‑word state array pointed to by `s`.\n\n### Single‑block compression\n\n```rust\npub fn sha256_transform_block(s: *mut u32, chunk: *const u8)\n```\n\n- `s`: pointer to 8 writable `u32` words.\n- `chunk`: pointer to exactly 64 bytes.\n- Performs one SHA‑256 compression on the block and feed‑forwards the result into `*s`.\n\n### Batched compression\n\n```rust\npub fn sha256_transform(s: *mut u32, chunk: *const u8, blocks: usize)\n```\n\nProcesses `blocks` consecutive 64‑byte chunks starting at `chunk`.\n\n### Big‑endian word API\n\n```rust\npub fn sha256_transform_one_block_be_words(s: *mut u32, chunk: *const u32)\n```\n\nProcesses a 64‑byte chunk represented as 16 big‑endian `u32` words.\n\n### Bitwise components\n\n```rust\npub fn big_sigma0(x: u32) -> u32\npub fn big_sigma1(x: u32) -> u32\npub fn sha256_sigma0(x: u32) -> u32\npub fn sha256_sigma1(x: u32) -> u32\npub fn sha256_ch(x: u32, y: u32, z: u32) -> u32\npub fn sha256_maj(x: u32, y: u32, z: u32) -> u32\n\npub fn sha256_round(\n    a: u32, b: u32, c: u32, d: &mut u32,\n    e: u32, f: u32, g: u32, h: &mut u32,\n    k: u32, w: u32,\n)\n```\n\nThese are useful for:\n\n- Writing alternative or instrumented compression loops.\n- Formal verification or symbolic execution environments.\n- Fine‑grained performance and microarchitectural analysis.\n\n---\n\n## Double‑SHA‑256 Helpers and Backends\n\n### Scalar reference path\n\n```rust\npub fn transform_d64_scalar(out32: *mut u8, in64: *const u8)\n```\n\nComputes `SHA256(SHA256(m))` for a single 64‑byte message `m`:\n\n1. Hashes the 64‑byte message with standard SHA‑256.\n2. Serializes the first digest to big‑endian bytes.\n3. Hashes that 32‑byte digest with SHA‑256 again.\n4. Writes the final 32‑byte result to `out32`.\n\nThis implementation is architecturally neutral and acts as the reference behavior against which vectorized backends are validated.\n\n### Backend abstraction\n\n```rust\npub type TransformType    = unsafe fn(*mut u32, *const u8, usize);\npub type TransformD64Type = unsafe fn(*mut u8,  *const u8);\n\npub(crate) struct Sha256Backend {\n    transform: TransformType,\n    d64:       TransformD64Type,\n    d64_2:     Option<TransformD64Type>,\n    d64_4:     Option<TransformD64Type>,\n    d64_8:     Option<TransformD64Type>,\n    desc:      &'static str,\n}\n```\n\nDispatch helpers:\n\n```rust\npub fn dispatch_transform(state: *mut u32, chunk: *const u8, blocks: usize)\npub fn dispatch_d64(out: *mut u8, inp: *const u8)\n```\n\nThey route through the globally selected backend configured by `sha256auto_detect()`.\n\n#### Auto‑detection\n\n```rust\npub fn sha256auto_detect() -> String\n```\n\n- Inspects `x86_64` CPU features using `std::arch::is_x86_feature_detected!`.\n- Conditionally enables SHANI and AVX2 double‑SHA‑256 implementations.\n- Publishes chosen function pointers into global `TRANSFORM*` slots.\n- Runs `self_test()` to guarantee that the chosen backend is bit‑exact.\n\nYou should call `sha256auto_detect()` early in your process if you intend to use the global function pointers or want deterministic logging of which backend was selected.\n\n#### Example: Explicit backend selection and use\n\n```rust\nfn init_and_use_backend(header: &[u8; 64]) -> [u8; 32] {\n    let desc = bitcoin_sha256::sha256auto_detect();\n    eprintln!(\"Selected SHA-256 backend: {desc}\");\n\n    let mut out = [0u8; 32];\n    unsafe {\n        bitcoin_sha256::dispatch_d64(out.as_mut_ptr(), header.as_ptr());\n    }\n    out\n}\n```\n\n> All pointer‑based functions are `unsafe` for a reason: you must uphold the documented size and aliasing constraints.\n\n---\n\n## Tagged Hash Initialization\n\nBitcoin uses **tagged hashes** of the form\n\n\\[\nH(\\text{tag} \\parallel \\text{tag} \\parallel m)\n\\]\n\nwhere \\(H\\) is SHA‑256 and \\(\\text{tag}\\) is a context string (e.g., `\"TapLeaf\"`).\n\nThe helper:\n\n```rust\npub fn sha256_initialize_tagged(hash: *mut Sha256, tag: *const u8, taglen: usize)\n```\n\nperforms:\n\n1. Initialize a `Sha256` context.\n2. Compute `SHA256(tag)` into a temporary 32‑byte buffer.\n3. Reset the context.\n4. Write `SHA256(tag) || SHA256(tag)` into the context.\n\nAfter calling this, `hash` is ready to receive the message `m` such that `finalize` yields `SHA256(SHA256(tag) || SHA256(tag) || m)`.\n\n---\n\n## FFI Surface and Safety Contracts\n\nA subset of functions is specifically shaped for FFI use:\n\n- `sha256_write(hash: *mut Sha256, data: *const u8, len: usize)`\n- `sha256_finalize(hash: *mut Sha256, out32: *mut u8)`\n- `sha256_transform(s: *mut u32, chunk: *const u8, blocks: usize)`\n- `transform_d64_scalar(out32: *mut u8, in64: *const u8)`\n\nTypical safety pre‑conditions:\n\n- Pointers must be valid for reads/writes of the documented length.\n- Pointers must obey Rust’s aliasing rules (i.e., do not create mutable aliases that overlap with other live references).\n- Regions must not overlap when the API says so.\n\nUse these from C or C++ by exposing C‑ABI wrappers in your Rust crate that depend on `bitcoin-sha256`.\n\n---\n\n## Self‑Testing\n\n```rust\npub fn self_test() -> bool\n```\n\nRuns an internal suite that checks:\n\n1. Multiple‑block compression states against precomputed fixtures.\n2. Double‑SHA‑256 helpers (scalar and available vectorized variants) against canonical outputs.\n\nIf any mismatch is detected, diagnostic information is printed to `stderr`. `sha256auto_detect()` calls `self_test()` and panics on failure to avoid silently running with an incorrect backend.\n\nYou can also integrate `self_test()` into your own startup checks if you manage backends manually.\n\n---\n\n## Logging and Instrumentation\n\nThe crate uses the `tracing` ecosystem for internal observability under the `\"sha256\"` target. Functions such as `sha256_sigma0`, `sha256_sigma1`, `sha256_round`, `sha256_transform`, `Sha256::write_ptr`, and `self_test` emit trace‑level events.\n\nTo use this effectively, include a `tracing-subscriber` setup in your binary and enable the `sha256` target at the desired level (e.g., TRACE in dev builds, OFF or ERROR in production).\n\n---\n\n## Performance Considerations\n\n- Core hot paths are annotated with `#[inline(always)]` where it materially affects performance, matching Bitcoin Core’s expectations.\n- The internal buffering strategy in `Sha256::write_ptr` minimizes copying by:\n  - Topping up a partially filled internal 64‑byte buffer.\n  - Processing as many full blocks as possible directly from the caller’s memory.\n  - Buffering any trailing bytes < 64.\n- Double‑SHA‑256 backends are designed to maximize throughput on x86‑64 with SHANI and AVX2 by processing multiple 64‑byte lanes in parallel.\n\nYou should benchmark your specific workload with and without the SHANI/AVX2 features enabled to measure the impact on your deployment targets.\n\n---\n\n## License\n\nThis crate is distributed under the **MIT** license.\n\nSee the repository for full license text:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\n---\n\n## Disclaimer\n\nThis README was generated by an AI model and may not be perfectly synchronized with the actual crate version, public API surface, or feature flags. Always consult the source code and `Cargo.toml` of the published `bitcoin-sha256` crate for authoritative reference.\n",
  "package_categories": [
    "cryptography",
    "algorithms",
    "science",
    "mathematics",
    "performance"
  ],
  "package_description": "Bitcoin-Core–compatible SHA-256 and double-SHA-256 implementation in Rust with streaming hasher, explicit compression rounds, FFI-ready APIs, and CPU-feature-aware backend selection (scalar, SHANI, AVX2).",
  "package_keywords": [
    "bitcoin",
    "sha256",
    "double-sha256",
    "cryptography",
    "hashing"
  ]
}