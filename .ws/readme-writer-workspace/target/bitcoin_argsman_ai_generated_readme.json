{
  "crate_name": "bitcoin-argsman",
  "full_readme_markdown": "# bitcoin-argsman\n\nRobust argument, configuration, and network-parameter management for Bitcoin-style Rust applications.\n\nThis crate is an idiomatic Rust port of Bitcoin Core's `ArgsManager` subsystem. It provides a high-fidelity, network-aware configuration layer for CLIs and daemons that follow Bitcoin's conventions:\n\n- `-foo`, `-foo=bar`, `-nofoo`, and double-negatives (`-nofoo=0`) with Bitcoin-compatible semantics\n- Layered configuration resolution: forced settings, command line, network-scoped config, default section\n- Chain selection and base parameters (`main`, `testnet`, `signet`, `regtest`)\n- Network-specific datadirs and blocks directories\n- Config-file parsing with sections, `includeconf`, and error reporting\n- Automatic help message generation grouped by option category\n\nThe design goal is behavioral equivalence with Bitcoin Core, enabling Rust-based tooling to interoperate with existing `bitcoin.conf` files and operational practices.\n\n> **Note**\n> This README was generated by an AI model based on the public interface. It may not be perfectly accurate in every detail, but it should be substantially correct and useful as a starting point.\n\n---\n\n## Features\n\n- **Typed argument descriptors** via `ArgDescriptor` and `ArgsManagerFlags`\n- **Global argument manager** (`G_ARGS`) mirroring Bitcoin Core's singleton\n- **Config-file support** with sections, `includeconf`, and detection of unrecognized sections\n- **Per-network datadirs** and chain parameters via `BaseChainParams`\n- **Sensitive argument redaction** in logs (`SENSITIVE` flag)\n- **Command-style arguments** and subcommands (`COMMAND` flag, `add_command`/`get_command`)\n- **Help text formatting** with hard-wrapped paragraphs and grouped sections\n- **Settings file** (dynamic rw-settings) with atomic write / rename semantics\n\nIf you already know Bitcoin Core's `ArgsManager`, this crate is intentionally familiar: type names, flag behavior, and configuration precedence are kept aligned so that operational reasoning transfers directly.\n\n---\n\n## Installation\n\nIn your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoin-argsman = \"0.1.22\"\n```\n\nRequires Rust **1.56+** (edition 2021).\n\n---\n\n## Core Types and Concepts\n\n### `OptionsCategory`\n\nOptions are grouped into semantic categories, used to structure help output:\n\n```rust\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]\n#[allow(non_camel_case_types)]\npub enum OptionsCategory {\n    OPTIONS,\n    CONNECTION,\n    WALLET,\n    WALLET_DEBUG_TEST,\n    ZMQ,\n    DEBUG_TEST,\n    CHAINPARAMS,\n    NODE_RELAY,\n    BLOCK_CREATION,\n    RPC,\n    GUI,\n    COMMANDS,\n    REGISTER_COMMANDS,\n    HIDDEN,\n}\n```\n\nHidden options are parsed but not printed in normal help output.\n\n### `ArgsManagerFlags`\n\nFlags describe admissible value types, security properties, and special behavior:\n\n```rust\nbitflags::bitflags! {\n    pub struct ArgsManagerFlags: u32 {\n        const ALLOW_BOOL   = 0x01;\n        const ALLOW_INT    = 0x02;\n        const ALLOW_STRING = 0x04;\n        const ALLOW_ANY    = Self::ALLOW_BOOL.bits\n                            | Self::ALLOW_INT.bits\n                            | Self::ALLOW_STRING.bits;\n\n        const DEBUG_ONLY   = 0x100;\n        const NETWORK_ONLY = 0x200; // values must not leak across networks\n        const SENSITIVE    = 0x400; // masked in logs\n        const COMMAND      = 0x800; // command-style (non -foo) arguments\n    }\n}\n```\n\nKey behavioral guarantees:\n\n- `ALLOW_BOOL` governs legality of `-nofoo` negation.\n- `NETWORK_ONLY` marks options whose values are scoped to a specific chain (`main`, `testnet`, etc.) and must not be accidentally shared via an unqualified config section.\n- `SENSITIVE` options are printed as `****` in logs.\n\n### `ArgDescriptor`\n\n`ArgDescriptor` is the declarative definition of an option:\n\n```rust\npub struct ArgDescriptor {\n    pub name:     &'static str,   // e.g. \"-rpcuser=<user>\"\n    pub help:     String,         // human-readable text\n    pub flags:    ArgsManagerFlags,\n    pub category: OptionsCategory,\n}\n```\n\nYou register descriptors on `ArgsManager` (or `ArgsManagerInner`) to make options available.\n\n### `ArgsManager` and `G_ARGS`\n\n`ArgsManager` is the main façade; internally it wraps `ArgsManagerInner` with `Arc<Mutex<_>>` and exposes a synchronous API appropriate for startup configuration parsing:\n\n```rust\n#[derive(Default)]\npub struct ArgsManager {\n    cs_args: Arc<Mutex<ArgsManagerInner>>, // configuration state\n}\n\nlazy_static::lazy_static! {\n    pub static ref G_ARGS: Mutex<ArgsManager> = Mutex::new(ArgsManager::default());\n}\n```\n\nBoth `ArgsManager` and `ArgsManagerInner` provide methods for:\n\n- Defining available arguments (`add_arg`, `add_command`, `add_hidden_args`, `setup_cli_args`, `setup_chain_params_base_options`)\n- Parsing command line and config (`parse_parameters`, `read_config_files`, `read_config_stream`)\n- Querying values (`get_arg`, `get_int_arg`, `get_bool_arg`, `get_args`, `get_setting`, `get_settings_list`)\n- Accessing derived paths (`get_data_dir_base`, `get_data_dir_net`, `get_blocks_dir_path`, `get_settings_path`)\n- Producing diagnostics (`get_help_message`, `log_args`, `get_unrecognized_sections`, `get_unsuitable_section_only_args`)\n\nAll public methods on `ArgsManager` are thin, inlined lock-and-delegate wrappers around the inner type.\n\n### Network and Chain Parameters\n\n`BaseChainParams` models base properties of the selected Bitcoin network:\n\n```rust\n#[derive(Default)]\npub struct BaseChainParams {\n    rpc_port:                  u16,\n    onion_service_target_port: u16,\n    str_data_dir:              String, // relative chain datadir (\"\", \"testnet3\", ...)\n}\n```\n\nKey functions and statics:\n\n- `create_base_chain_params(chain: &str) -> Result<Box<BaseChainParams>, StdException>`\n- `select_base_params(chain: &str)` – updates the global `BaseChainParams` and network selection in `G_ARGS`.\n- Statics for the canonical networks:\n  - `DEFAULT_BASE_PARAMS` (main)\n  - `TESTNET_BASE_PARAMS`\n  - `SIGNET_BASE_PARAMS`\n  - `REGTEST_BASE_PARAMS`\n\n`ArgsManagerInner::get_chain_name` inspects `-regtest`, `-signet`, `-testnet`, and `-chain` flags to determine the active chain, enforcing mutual exclusivity.\n\n### Datadirs and Path Semantics\n\nThe crate reproduces Bitcoin Core's datadir rules across platforms:\n\n- Windows: `C:\\Users\\<Username>\\AppData\\Roaming\\Bitcoin`\n- macOS: `~/Library/Application Support/Bitcoin`\n- Unix-like: `~/.bitcoin`\n\nFunctions:\n\n- `get_default_data_dir() -> PathBuf`\n- `get_home_dir() -> PathBuf`\n- `strip_redundant_last_elements_of_path(path: &mut PathBuf)` – normalizes trailing `.` components; ensures idempotence via `same-file` checks.\n- `abs_path_for_config_val(path: &Path, net_specific: Option<bool>) -> PathBuf` – resolves relative paths against network-specific or base datadir.\n- `ArgsManagerInner::get_data_dir_base` / `get_data_dir_net` / `get_data_dir(net_specific: bool)` – create the datadir and `wallets/` subdir on first use, cache the result, and respect a user-specified `-datadir`.\n- `ArgsManagerInner::get_blocks_dir_path()` – detects optional `-blocksdir`, falls back to `datadir/<chain>/blocks`, ensures the directory exists, and caches the result.\n\n### Settings Resolution Model\n\nThe crate implements a deterministic, layered settings model analogous to a constrained lattice:\n\n1. **Command line options** – most recent occurrence wins (`self.settings.command_line_options()`), including `force_set_arg` injections.\n2. **Forced settings** – via `force_set_arg`, held in `settings.forced_settings()`. They also reflect into the command-line layer to unify resolution semantics.\n3. **Config file (ro_config)** – potentially sectioned by network and by default section.\n4. **Dynamic settings file (rw_settings)** – read and written by `init_settings`, subject to argument recognition.\n5. **Defaults** – provided by callers of `get_*_arg` or by the absence of a setting.\n\nUtility methods:\n\n- `get_setting(&self, arg: &str) -> SettingsValue` – returns a `UniValue`-backed wrapper which may be null, bool, string, or numeric, following the Bitcoin Core precedence rules.\n- `get_settings_list(&self, arg: &str) -> Vec<SettingsValue>` – returns all values (e.g. for options that may appear multiple times).\n- `is_arg_set`, `is_arg_negated` – semantic presence and negation checks.\n- `use_default_section(&self, arg: &str) -> bool` – determines whether default-section config applies, depending on network and `NETWORK_ONLY` marking.\n\nThis model ensures that configuration from `bitcoin.conf`, dynamic settings, and CLI overrides are combined safely and predictably.\n\n### Boolean Semantics and Parsing Logic\n\nThe crate mirrors Bitcoin Core's nuanced handling of boolean and numeric options:\n\n- `interpret_bool(str_value: &str) -> bool`:\n  - Empty string => `true`\n  - Non-empty string => parsed via `locale_independent_atoi::<i32>`; value `!= 0` means `true`.\n  - Non-numeric strings produce `0` and therefore `false`.\n- `interpret_option(section: &mut String, key: &mut String, value: &String) -> SettingsValue`:\n  - Recognizes `no` prefix: `-nofoo=1` becomes `foo=false`; `-nofoo=0` becomes `foo=true` and emits a warning.\n  - Parses dotted keys like `regtest.foo` into `section=\"regtest\"`, `key=\"foo\"`.\n\nThis behavior is critical for backward compatibility with existing deployments that rely on Core's somewhat intricate legacy semantics.\n\n---\n\n## Help and Documentation Generation\n\n### Paragraph Formatting\n\n`format_paragraph` implements a simple word-wrapping algorithm with explicit newlines treated as hard breaks:\n\n```rust\npub fn format_paragraph(\n    in_: &str,\n    width: Option<usize>,\n    indent: Option<usize>,\n) -> Result<String, FormatParagraphError> { /* ... */ }\n```\n\nBehavior:\n\n- Default `width` is 79 columns.\n- Default `indent` is 0 spaces for wrapped lines.\n- Each line is broken at the last space or tab before the width, or at `width` if no such break exists.\n- Explicit `\\n` in the input reset the line-length budget and are preserved as hard breaks.\n\nErrors are currently represented by `FormatParagraphError`, but for the provided implementation, all fallible paths are internal IO-like operations (e.g. via intermediate writers) and typical usage should just observe `Ok`.\n\n### Option Help Formatting\n\n`help_message_opt` formats an option line and its description for human-readable CLI output:\n\n```rust\npub fn help_message_opt(option: &str, message: &str) -> String {\n    let paragraph = format_paragraph(\n        message,\n        Some(SCREEN_WIDTH - MSG_INDENT),\n        Some(MSG_INDENT),\n    );\n\n    match paragraph {\n        Ok(paragraph) => {\n            format!(\n                \"{}{}\\n{}{}\\n\\n\",\n                \" \".repeat(OPT_INDENT),\n                option,\n                \" \".repeat(MSG_INDENT),\n                paragraph,\n            )\n        }\n        Err(e) => panic!(\"format_paragraph failed with error: {:?}\", e),\n    }\n}\n```\n\n`ArgsManagerInner::get_help_message` iterates all `available_args`, grouped by `OptionsCategory`, and produces the full help string. `DEBUG_ONLY` arguments only appear when `-help-debug` is set.\n\nThis allows you to build self-documenting CLIs with a single source of truth (your `ArgDescriptor` definitions).\n\n---\n\n## Config Files and Sections\n\n### Parsing `bitcoin.conf`-style Files\n\nConfig parsing is handled by `get_config_options` and `ArgsManagerInner::read_config_stream` / `read_config_files`.\n\nSupported syntax:\n\n- `name=value` key-value pairs\n- Section headers: `[section]`, where `section` typically matches a chain (e.g. `regtest`, `signet`, `testnet`, `main`)\n- `#` comments (with special treatment if they interact with `rpcpassword`)\n- Whitespace trimming around names and values\n\nKey behaviors:\n\n- Options **must not** be prefixed with `-` in the config file; that is an error (`-foo=bar` is invalid; use `foo=bar`).\n- When a section is seen, it is pushed to `config_sections` and used as a prefix for subsequent options (`[regtest] foo=1` becomes key `regtest.foo`).\n- Unknown options can be ignored or treated as errors depending on `ignore_invalid_keys`.\n- `includeconf` is supported in config files but **forbidden** at the command line except as `-noincludeconf`. Recursive `includeconf` from included files is warned about and ignored.\n\n### Recognized Sections\n\n`AVAILABLE_SECTIONS` defines valid chain sections:\n\n```rust\nlazy_static::lazy_static! {\n    static ref AVAILABLE_SECTIONS: std::collections::HashSet<String> = hashset! {\n        base_chain_params::REGTEST.to_string(),\n        base_chain_params::SIGNET.to_string(),\n        base_chain_params::TESTNET.to_string(),\n        base_chain_params::MAIN.to_string(),\n    };\n}\n```\n\n`ArgsManagerInner::get_unrecognized_sections` returns the list of `SectionInfo` (name, file, line) that do *not* appear in `AVAILABLE_SECTIONS`. This is valuable for catching mis-typed chain names or environment-specific configuration mistakes.\n\n### Network-Only Arguments\n\nSome options, if shared accidentally between mainnet and test/test-like networks, can cause operational hazards. `ArgsManagerFlags::NETWORK_ONLY` is used to mark such options, and `ArgsManager::get_unsuitable_section_only_args` computes which of them are only configured in the default section for a non-main network.\n\nThis is a static analysis step at startup that allows you to warn operators when a `NETWORK_ONLY` option should be moved into a specific `[regtest]`/`[test]`/`[signet]` section.\n\n---\n\n## Commands and Bitcoin-style Pseudo-Commands\n\nThere are two conceptually separate command styles supported:\n\n1. **Registered commands** via `add_command(cmd, help)` with `ArgsManagerFlags::COMMAND`.\n2. **Pseudo-commands** used for `bitcoin-tx`-like tools (e.g. `delin=N`, `outaddr=VALUE:ADDRESS`), which are registered via `add_arg` but placed in the `COMMANDS` or `REGISTER_COMMANDS` categories.\n\n`ArgsManagerInner::parse_parameters` enforces the following invariant:\n\n- Once a non-dash argument (not starting with `-`) is seen:\n  - If `accept_any_command` is `false`, that argument must correspond to a known command (have `COMMAND` flag) or parsing fails.\n  - That first non-dash argument becomes the `command` part of `ArgsManagerCommand`, with all remaining arguments collected into `args`.\n\n`get_command()` exposes this structured view:\n\n```rust\npub struct ArgsManagerCommand {\n    pub command: Option<String>,\n    pub args:    Vec<String>,\n}\n```\n\nIf no command is present, `get_command()` returns `None`.\n\n`setup_bitcoin_tx_args` shows a canonical usage pattern for a `bitcoin-tx`-analog in Rust: it registers a rich set of transaction-editing pseudo-commands and necessary chain-parameter options.\n\n---\n\n## Settings File (Dynamic RW Settings)\n\nBeyond statically-parsed config files and CLI arguments, the crate supports a *dynamic settings file* whose path is derived from `-settings` and the network datadir. This mechanism is useful for GUIs or long-running processes that need to persist configuration changes without rewriting the entire `bitcoin.conf`.\n\nKey methods:\n\n- `get_settings_path(&self, filepath: Option<&mut Box<Path>>, temp: Option<bool>) -> bool`\n  - Honors `-nosettings` (by checking if `-settings` is negated).\n  - Derives the final path under `get_data_dir_net()` and resolves both the canonical and temporary (`.tmp`) names.\n- `init_settings(&mut self, error: &mut String) -> Result<(), String>`\n  - Reads the settings file via `read_settings_file`.\n  - Then writes it back via `write_settings_file`, gathering and surfacing errors.\n- `read_settings_file(&mut self, errors: Option<&mut Vec<String>>) -> bool`\n  - Clears existing `rw_settings`.\n  - Reads into a map and validates that keys correspond to known arguments; unknown keys are logged.\n- `write_settings_file(&self, errors: Option<&mut Vec<String>>) -> Result<bool, StdException>`\n  - Writes to a temporary file and atomically renames it into place using `rename_over`.\n\nThis is designed to be safe under concurrent readers and robust against intermediate failures.\n\n---\n\n## Usage Examples\n\n### 1. Basic CLI Setup and Parsing\n\n```rust\nuse bitcoin_argsman::{ArgsManager, ArgsManagerFlags, OptionsCategory, ArgDescriptor};\n\nfn build_args() -> ArgsManager {\n    let mut am = ArgsManager::default();\n\n    // Standard help options (-?, -h, -help, -help-debug)\n    am.setup_help_options();\n\n    // Add a custom boolean option: -verbose / -noverbose\n    let verbose_desc = ArgDescriptor {\n        name:     \"-verbose\",\n        help:     \"Enable verbose logging\".to_string(),\n        flags:    ArgsManagerFlags::ALLOW_BOOL,\n        category: OptionsCategory::OPTIONS,\n    };\n    am.add_arg(&verbose_desc);\n\n    am\n}\n\nfn main() {\n    let mut argsman = build_args();\n\n    let argv: Vec<String> = std::env::args().collect();\n    let mut error = String::new();\n\n    if !argsman.parse_parameters(&argv, &mut error) {\n        eprintln!(\"error: {}\", error);\n        std::process::exit(1);\n    }\n\n    if argsman.help_requested() {\n        println!(\"{}\", argsman.get_help_message());\n        return;\n    }\n\n    let verbose = argsman.get_bool_arg(\"-verbose\", false);\n    println!(\"verbose = {}\", verbose);\n}\n```\n\n### 2. Chain Selection and Network-Specific Paths\n\n```rust\nuse bitcoin_argsman::{select_base_params, G_ARGS};\n\nfn main() {\n    // Example: assume CLI parsing has already populated G_ARGS.\n    {\n        // Determine network from arguments and configure global base params\n        let mut guard = G_ARGS.lock().unwrap();\n        let mut error = String::new();\n        let argv: Vec<String> = std::env::args().collect();\n        guard.parse_parameters(&argv, &mut error);\n        let chain_name = guard.get_chain_name().expect(\"invalid chain\");\n        select_base_params(&chain_name);\n    }\n\n    // Later, obtain a network-specific datadir\n    let datadir = G_ARGS.lock().unwrap().get_data_dir_net();\n    println!(\"network datadir: {}\", datadir.display());\n}\n```\n\n### 3. Logging Effective Configuration\n\n```rust\nuse bitcoin_argsman::G_ARGS;\n\nfn log_effective_config() {\n    let guard = G_ARGS.lock().unwrap();\n    guard.log_args(); // will mask SENSITIVE args\n}\n```\n\n### 4. Parsing a Custom Config Stream\n\n```rust\nuse std::io::Cursor;\nuse std::io::BufReader;\nuse bitcoin_argsman::ArgsManager;\n\nfn load_inline_conf(am: &mut ArgsManager) {\n    let config_text = r#\"\n[regtest]\nrpcport=18443\n\n[testnet]\nrpcport=18332\n\"#;\n\n    let cursor = Cursor::new(config_text.as_bytes());\n    let mut reader = BufReader::new(cursor);\n    let mut error = String::new();\n\n    if !am.read_config_stream(&mut reader, \"<inline>\", &mut error, Some(false)) {\n        panic!(\"config parse error: {}\", error);\n    }\n}\n```\n\n---\n\n## Error Handling\n\n`format_paragraph` uses a dedicated error type:\n\n```rust\n#[derive(thiserror::Error, Debug)]\npub enum FormatParagraphError {\n    IoError(std::io::Error),\n    FromUtf8Error(std::string::FromUtf8Error),\n    IntoInnerError(std::io::IntoInnerError<std::io::BufWriter<Vec<u8>>>),\n}\n```\n\nMost other operations in this crate either:\n\n- Return `bool` with an out-parameter `&mut String` for error messages (e.g. parsing functions), or\n- Return `Result<_, StdException>` for failures modeled on C++ exceptions, or\n- Panic in invariants expected never to fail (e.g. internal IO in help formatting).\n\nIn a production integration you are expected to:\n\n- Treat a `false` return with a non-empty error string as fatal at startup.\n- Use `get_unsuitable_section_only_args` and `get_unrecognized_sections` for soft warnings.\n\n---\n\n## Mathematical / Algorithmic Notes\n\nThe crate is primarily concerned with configuration logic rather than heavy numerical computation. Still, several minor algorithmic properties are worth noting:\n\n- **Word-wrapping**: `format_paragraph` performs a greedy line-breaking algorithm. Its time complexity is linear in the input length, with each character visited at most a constant number of times.\n- **Configuration section validation**: `get_unrecognized_sections` filters section appearances against a hash set of known names; the complexity is linear in the number of seen sections, with constant-time expected lookups.\n- **Settings precedence**: `get_setting` and `get_settings_list` are O(1) expected time due to direct hash-map lookups.\n- **Datadir normalization**: `strip_redundant_last_elements_of_path` iteratively removes trailing `.` segments and validates the path equality via `same-file`; this is linear in the number of path segments, with I/O-bound checks.\n\nThese properties make the crate suitable for early-initialization usage even under large and complex configurations.\n\n---\n\n## Repository, License, and Authorship\n\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\n- **Crate**: `bitcoin-argsman`\n- **Edition**: Rust 2021\n- **License**: MIT\n- **Authors**: `klebs <none>`\n\nThe crate is part of a broader effort to provide a Rust reimplementation of Bitcoin Core components. Behavioral compatibility with Bitcoin Core is a guiding constraint; when in doubt, cross-check against the upstream C++ `ArgsManager`.\n\n---\n\n## Caveats\n\n- The public interface may expose types (`Settings`, `SettingsSpan`, `UniValue`, `StdException`, etc.) whose definitions are in sibling modules or crates within `bitcoin-rs`. Consult the repository for their details.\n- I/O paths, error messages, and some internal invariants are designed to match Core's behavior and tests; altering them may break cross-compatibility.\n- This README is AI-generated and may lag behind the latest code; when precision is critical, inspect the actual source implementation.\n",
  "package_categories": [
    "network-programming",
    "config",
    "cryptography",
    "finance",
    "development-tools"
  ],
  "package_description": "Bitcoin Core-compatible argument, configuration, and network-parameter manager for Rust CLIs and daemons, including chain selection, datadir handling, and bitcoin.conf-style parsing.",
  "package_keywords": [
    "bitcoin",
    "configuration",
    "cli",
    "args",
    "network"
  ]
}