{
  "crate_name": "bitcoinleveldb-hash",
  "full_readme_markdown": "# bitcoinleveldb-hash\n\nA minimal, `no_std`-friendly implementation of LevelDB's 32‑bit hash primitive, extracted for use in Bitcoin-related and embedded contexts.\n\n> **Note**: This README was generated by an AI model and may not be 100% accurate, but it should be a close and useful description of the crate.\n\n---\n\n## Overview\n\n`bitcoinleveldb-hash` implements the 32‑bit hash function used internally by Google's LevelDB, exposed as a single low‑level function that operates on raw pointers. This hash is used by LevelDB for:\n\n- Hash table bucketing\n- Bloom filter key hashing\n- Lightweight checksumming / sharding logic\n\nThe implementation in this crate is a faithful Rust port of the original C++ routine, preserving:\n\n- Exact 32‑bit wrapping arithmetic\n- Little‑endian decoding semantics\n- Tail‑byte mixing behavior\n- Seed‑dependent initialization\n\nThe function signature:\n\n```rust\npub fn leveldb_hash(data: *const u8, n: usize, seed: u32) -> u32\n```\n\nThis is intentionally low level and unsafe‑adjacent (raw address, explicit length). The interface is suitable for high‑performance code where you already manipulate buffers as `(ptr, len)` pairs (e.g. database internals, FFI, or custom allocators).\n\nThe algorithm is structurally similar to a 32‑bit Murmur‑style hash: it performs block‑wise mixing using a fixed multiplier and shift, then folds remaining bytes with a small tail routine. Specifically, it uses constant `M = 0xc6a4a793` and a right shift `R = 24` during finalization, closely mirroring LevelDB's original implementation.\n\n---\n\n## Features\n\n- **Deterministic LevelDB‑compatible hash**: Intended to produce the same output as LevelDB's C++ `Hash()` function for identical inputs and seed.\n- **Low‑level pointer interface**: Accepts `*const u8` and a byte length; ideal where copying or slice conversion would be overhead.\n- **`no_std` friendly core**: The fundamental logic relies only on `core` and raw pointers; logging uses macros from the `log` ecosystem but can be compiled out.\n- **Seeded hashing**: The `seed` parameter allows domain separation and mitigation of trivial collision patterns.\n\n---\n\n## Safety model\n\nThe function is declared `pub fn` (not `unsafe fn`), but *internally* uses `unsafe` blocks to read from `data`. As a user, you **must** uphold the following invariants:\n\n1. `data` must be a valid, non‑null pointer to at least `n` bytes of readable memory.\n2. The region `[data, data.add(n))` must be fully initialized.\n3. The memory region may be aliased, but only read (no concurrent mutation that would cause undefined behavior with raw reads).\n\nViolating these invariants results in undefined behavior. If you prefer a safe, slice‑based wrapper, add one in your own crate, for example:\n\n```rust\nuse bitcoinleveldb_hash::leveldb_hash;\n\npub fn leveldb_hash_slice(data: &[u8], seed: u32) -> u32 {\n    // Safety: &[u8] guarantees a contiguous, initialized region.\n    unsafe { leveldb_hash(data.as_ptr(), data.len(), seed) }\n}\n```\n\n---\n\n## Usage\n\nAdd to `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoinleveldb-hash = \"0.1.19\"\n```\n\n### Basic example\n\n```rust\nuse bitcoinleveldb_hash::leveldb_hash;\n\nfn main() {\n    let key = b\"example-key\";\n    let seed: u32 = 0x1234_5678;\n\n    let hash = unsafe { leveldb_hash(key.as_ptr(), key.len(), seed) };\n\n    println!(\"hash = 0x{hash:08x}\");\n}\n```\n\n### Using as a bucket index\n\n```rust\nuse bitcoinleveldb_hash::leveldb_hash;\n\nfn bucket_index(key: &[u8], seed: u32, buckets: usize) -> usize {\n    assert!(buckets.is_power_of_two(), \"buckets should be a power of two\");\n\n    let h = unsafe { leveldb_hash(key.as_ptr(), key.len(), seed) };\n    (h as usize) & (buckets - 1)\n}\n```\n\nThis mirrors LevelDB's use of a 32‑bit hash for indexing into small hash tables.\n\n### Bloom‑filter style application\n\nFor a Bloom filter, one can derive multiple indices from a single hash by simple linear transformations:\n\n```rust\nuse bitcoinleveldb_hash::leveldb_hash;\n\nfn bloom_positions(key: &[u8], seed: u32, bits: u32, k: usize) -> Vec<u32> {\n    let base = unsafe { leveldb_hash(key.as_ptr(), key.len(), seed) };\n    let delta = (base >> 17) | (base << 15); // simple rotation\n\n    (0..k)\n        .map(|i| base.wrapping_add((i as u32).wrapping_mul(delta)) & (bits - 1))\n        .collect()\n}\n```\n\nThis pattern parallels the construction used in LevelDB's own Bloom filter implementation.\n\n---\n\n## Algorithmic notes\n\nThe internal structure of `leveldb_hash` is:\n\n1. **Initialization**\n   ```rust\n   const M: u32 = 0xc6a4a793;\n   const R: u32 = 24;\n\n   let mut h: u32 = seed ^ ((n as u32).wrapping_mul(M));\n   ```\n   The input length is mixed with a fixed multiplier and XORed with the seed. This introduces sensitivity to both size and seed at the beginning of the chain.\n\n2. **Block processing** (4 bytes at a time, little‑endian):\n   ```rust\n   while offset + 4 <= n {\n       let mut word_bytes = [0u8; 4];\n       unsafe {\n           let chunk_ptr = data.add(offset);\n           core::ptr::copy_nonoverlapping(chunk_ptr, word_bytes.as_mut_ptr(), 4);\n       }\n       let w = u32::from_le_bytes(word_bytes);\n\n       h = h.wrapping_add(w);\n       h = h.wrapping_mul(M);\n       h ^= h >> 16;\n\n       offset += 4;\n   }\n   ```\n   Each 32‑bit word is added, multiplied by `M`, and subjected to a right‑shift XOR. This creates diffusion and avalanche behavior typical of non‑cryptographic hash functions.\n\n3. **Tail processing** (1–3 bytes):\n   Remaining bytes are folded into `h` with left shifts by 8 and 16, then multiplied and mixed again:\n   ```rust\n   match remaining {\n       3 => { /* add bytes << 16, 8, 0; mul M; h ^= h >> R; */ }\n       2 => { /* add bytes << 8, 0;  mul M; h ^= h >> R; */ }\n       1 => { /* add byte;        mul M; h ^= h >> R; */ }\n       _ => unreachable!(),\n   }\n   ```\n\nAll arithmetic uses `wrapping_*` operations to match the C++ semantics on 32‑bit unsigned integers.\n\nThis hash is **not cryptographically secure**. It is suitable for internal indexing, partitioning, and approximate data structures (Bloom filters, count‑min sketches), but **not** for adversarial settings where second‑preimage or collision resistance is required.\n\n---\n\n## Logging and diagnostics\n\nThe implementation calls `trace!`, `debug!`, and `error!` macros. If you enable the `log` crate in your application and configure a logger (e.g. `env_logger`), you can observe the internal processing for debugging or verification:\n\n```rust\nfn main() {\n    env_logger::init();\n\n    let data = b\"debug-hash\";\n    let seed = 0xdead_beef;\n\n    let _ = unsafe { bitcoinleveldb_hash::leveldb_hash(data.as_ptr(), data.len(), seed) };\n}\n```\n\nWith `RUST_LOG=trace`, you will see per‑chunk trace output, including offsets and intermediate hash values.\n\nIn production builds, you can disable logging or set higher log levels to eliminate runtime logging overhead.\n\n---\n\n## Interoperability with LevelDB and Bitcoin code\n\nBecause this crate targets bit‑for‑bit compatibility with LevelDB's C++ hash algorithm, it can be used to:\n\n- Reproduce LevelDB hash table indices computed by other implementations.\n- Port filter policies (e.g. Bloom filters) from C++ LevelDB / Bitcoin Core to Rust.\n- Validate that a Rust reimplementation of storage logic produces identical layout to an existing LevelDB store.\n\nWhen interoperating, ensure you:\n\n- Use the same byte order (little‑endian, as encoded in LevelDB keys/values).\n- Match the seed exactly.\n- Hash the same serialized key representation, including prefixes and varint‑encoded fields if present.\n\n---\n\n## Repository and maintenance\n\nThis crate lives inside the `bitcoin-rs` repository:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n\nIssues and pull requests should be filed there, under the appropriate module or crate directory.\n\n---\n\n## License\n\n`bitcoinleveldb-hash` is distributed under the MIT license.\n\nSee the `LICENSE` file in the repository for full terms.\n",
  "package_categories": [
    "algorithms",
    "data-structures",
    "database",
    "parsing",
    "science"
  ],
  "package_description": "LevelDB-compatible 32-bit non-cryptographic hash function for raw byte buffers, suitable for hash tables, Bloom filters, and database internals.",
  "package_keywords": [
    "leveldb",
    "hash",
    "bloom-filter",
    "database",
    "bitcoin"
  ]
}