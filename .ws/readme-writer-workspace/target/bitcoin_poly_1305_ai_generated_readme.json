{
  "crate_name": "bitcoin-poly1305",
  "full_readme_markdown": "# bitcoin-poly1305\n\nA constant-time, trace-instrumented Poly1305 one-time authenticator used by Bitcoin Core, implemented as a small, focused Rust crate. The code is a close structural translation of the original `poly1305-donna-unrolled.c` routine, with the carry, clamping, and reduction behavior preserved to maintain bit-for-bit compatibility.\n\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate or complete, but it should be a very good approximation of the crate's intent and usage. Always consult the source for security-critical decisions.\n\n---\n\n## Overview\n\n`bitcoin-poly1305` exposes a low-level, allocation-free Poly1305 MAC implementation tuned for correctness and auditability in cryptographic contexts (notably Bitcoin-related tooling). It:\n\n- Implements Poly1305 over the prime field \\( p = 2^{130} - 5 \\) using 5 radix-\\(2^{26}\\) limbs.\n- Preserves Donna's exact reduction, clamping, and carry propagation semantics to avoid subtle divergences from well-established test vectors.\n- Keeps the critical arithmetic constant-time with respect to secret data (no data-dependent branching on limb values).\n- Provides optional, structured tracing via the `tracing` ecosystem, allowing full inspection of intermediate states during testing or formal verification.\n\nThis crate is intentionally low-level. It exposes the raw arithmetic and a single top-level `poly1305_auth` function; it does not manage keys, nonces, or higher-level AEAD constructs.\n\n---\n\n## Cryptographic background\n\nPoly1305 computes a 16-byte authenticator (tag) for an arbitrary-length message `m` under a 32-byte one-time key `(r ‖ s)`:\n\n1. Interpret `r` as an element of \\( \\mathbb{Z} / (2^{130} - 5) \\), after *clamping* certain bits to enforce bounds crucial to security and correctness.\n2. Split the message `m` into 16-byte blocks; each block is interpreted as a 130-bit integer in little-endian form, with an implicit high bit.\n3. Maintain an accumulator `h` in radix-\\(2^{26}\\):\n   - Add each block into `h` (with the implicit high bit).\n   - Multiply by `r` and reduce modulo \\( 2^{130} - 5 \\).\n4. After processing all blocks, perform a final carry propagation and conditional subtraction of `p`.\n5. Add the 128-bit pad `s`, then output the least-significant 128 bits as the tag.\n\nInternally, this crate uses the standard 5-limb radix-\\(2^{26}\\) representation\n\n\\[\n  h = h_0 + h_1 2^{26} + h_2 2^{52} + h_3 2^{78} + h_4 2^{104}, \\quad 0 \\le h_i < 2^{26}.\n\\]\n\nThe reduction leverages the congruence \\( 2^{130} \\equiv 5 \\pmod p \\) so that overflow from the top limb can be folded back into lower limbs via multiplication by 5.\n\nAll field operations are designed to avoid branches on secret values, using bit masks and fixed sequences of operations instead.\n\n---\n\n## Features and design goals\n\n- **Constant-time arithmetic** for secret-dependent values (accumulators, limbs, keys).\n- **Exact Donna semantics**: replicate the reference implementation's order of operations and truncations, including non-obvious details like when not to mask `h[1]`.\n- **Fine-grained tracing hooks** via `tracing` and custom macros, permitting black-box debugging and side-channel analysis.\n- **No allocations / no_std-ready core**: only relies on the Rust core primitives; you can integrate it into constrained environments (subject to your own `tracing` setup).\n- **Bitcoin-aligned behavior**: suitable for downstream code that must match Bitcoin Core's Poly1305 behavior exactly.\n\n---\n\n## Crate layout and public API\n\nThe crate primarily exposes:\n\n- **Types**\n  - `pub type LimbArr5 = [u32; 5];` – five 26-bit limbs (radix-\\(2^{26}\\))\n  - `pub type LimbArr4 = [u32; 4];` – multipliers \\(r_i \\cdot 5\\) for \\( i = 1..4 \\)\n\n- **Macros**\n  - `mul32x32_64!(a, b)` – 32×32→64-bit multiplication as `u64`, mirroring C's `((uint64_t)a * (b))` with `wrapping_mul`.\n  - `trace_step!(step, { fields... })` – helper for emitting structured `TRACE` events with a fixed `step` label.\n\n- **Core functions**\n  - `pub fn poly1305_auth(out: &mut [u8; POLY1305_TAGLEN], msg: &[u8], key: &[u8; POLY1305_KEYLEN])`\n    - Top-level, constant-time Poly1305 authenticator.\n    - Uses: `expand_key`, `accumulate_block`, `multiply_and_reduce`, `final_carry_and_sub_p`, and `add_pad_serialize`.\n\n- **Key expansion**\n  - `pub fn expand_key(key: &[u8; POLY1305_KEYLEN]) -> (LimbArr5, LimbArr4)`\n    - Parses and clamps the 32-byte key into five 26-bit limbs `r` and their associated \\(5\\times\\) multipliers `s`.\n\n- **Arithmetic primitives** (primarily used internally, but public where appropriate for verification / reuse):\n  - `pub fn propagate_26bit_carries_once(h: &mut [u32; 5])`\n  - `pub fn accumulate_block(h: &mut LimbArr5, block: &[u8; 16], add_high_bit: bool)`\n  - `pub fn multiply_and_reduce(h: &mut LimbArr5, r: &LimbArr5, s: &LimbArr4)`\n  - `pub fn ct_select_limbs(h: &mut LimbArr5, g: &LimbArr5, select_mask: u32)`\n\nLower-level helpers like `read_le32`, `write_le32`, `final_carry_and_sub_p`, `add_pad_serialize`, and `compute_g_plus5_minus_p` are central to the reduction flow but may be crate-internal depending on the version and visibility choices.\n\n---\n\n## Usage\n\nAdd to your `Cargo.toml`:\n\n```toml\n[dependencies]\nbitcoin-poly1305 = \"0.1.19\"\ntracing = \"0.1\"       # optional but recommended for observability\n```\n\nCompute a Poly1305 tag for a message:\n\n```rust\nuse bitcoin_poly1305::poly1305_auth;\n\nconst KEY_LEN: usize = 32;  // POLY1305_KEYLEN\nconst TAG_LEN: usize = 16;  // POLY1305_TAGLEN\n\nfn compute_tag(msg: &[u8], key: &[u8; KEY_LEN]) -> [u8; TAG_LEN] {\n    let mut tag = [0u8; TAG_LEN];\n    poly1305_auth(&mut tag, msg, key);\n    tag\n}\n\nfn main() {\n    let key: [u8; KEY_LEN] = [0u8; KEY_LEN]; // never reuse in production\n    let message = b\"example message\";\n\n    let tag = compute_tag(message.as_ref(), &key);\n    println!(\"tag: {:02x?}\", tag);\n}\n```\n\n### Tracing and debugging\n\nThe crate uses `tracing` to emit structured events at various levels:\n\n- `trace_step!` for fine-grained arithmetic inspection.\n- `tracing::trace!` and `tracing::debug!` from internal routines.\n- `tracing::info!` around `poly1305_auth` entry/exit.\n\nExample setup:\n\n```rust\nuse bitcoin_poly1305::poly1305_auth;\nuse tracing_subscriber::FmtSubscriber;\n\nfn main() {\n    let subscriber = FmtSubscriber::builder()\n        .with_env_filter(\"bitcoin_poly1305=trace\")\n        .finish();\n    tracing::subscriber::set_global_default(subscriber).unwrap();\n\n    let key = [0u8; 32];\n    let msg = b\"trace me\";\n    let mut tag = [0u8; 16];\n\n    poly1305_auth(&mut tag, msg, &key);\n}\n```\n\nThen run with e.g. `RUST_LOG=trace` to obtain detailed logs of limb states, carries, and the final tag.\n\n---\n\n## Constant-time considerations\n\nThe arithmetic is structured to avoid secret-dependent branches:\n\n- Carry propagation uses fixed loops and bit operations.\n- Conditional subtraction of `p` in `final_carry_and_sub_p` is implemented with `ct_select_limbs`, which performs branchless selection using a 32-bit mask.\n- Multiplication uses `mul32x32_64!` with `wrapping_mul`, matching C's semantics and avoiding undefined behavior.\n\nNonetheless, constant-time behavior is highly environment-dependent. When integrating into a security-critical system:\n\n- Compile with optimizations enabled and avoid LTO configurations that may reintroduce secret-dependent behavior.\n- Disable debug assertions in production builds, as they may introduce branches tied to internal invariants.\n- Audit your `tracing` configuration for potential side-channel leakage if enabled in non-test environments.\n\n---\n\n## Key handling and security model\n\n- The key `(r ‖ s)` **must be unique per message**. Reusing a Poly1305 key with different messages catastrophically compromises security.\n- This crate **does not**:\n  - manage randomness, key derivation, or nonces;\n  - provide AEAD constructions (e.g., ChaCha20-Poly1305);\n  - zeroize keys or tags automatically.\n\nIt is intended to be composed inside a higher-level protocol or cryptographic library that enforces correct key usage, nonces, and lifecycle management.\n\n---\n\n## Integration in Bitcoin-related tools\n\nThe repository `https://github.com/klebs6/bitcoin-rs` groups Bitcoin-focused components. `bitcoin-poly1305` can be used wherever you need a Poly1305 implementation matching Bitcoin Core semantics:\n\n- custom or experimental transaction relay/authentication schemes,\n- protocol experimentation where deterministic, cross-language equivalence with Bitcoin Core is mandatory,\n- test harnesses that validate or differential-test against reference C implementations.\n\n---\n\n## Testing\n\nTo validate behavior against existing vectors (if included in the repository):\n\n```bash\ncargo test -p bitcoin-poly1305\n```\n\nYou can also enable detailed tracing during tests:\n\n```bash\nRUST_LOG=trace cargo test -p bitcoin-poly1305 -- --nocapture\n```\n\nThis is particularly useful when investigating mismatches against RFC 7539 or Bitcoin Core vectors, or when formally reasoning about the reduction procedure.\n\n---\n\n## License\n\nThis crate is licensed under the **MIT** license. See the repository for full license text.\n\n---\n\n## Caveats\n\n- This is a low-level, performance-oriented cryptographic primitive. Misuse (e.g., key reuse, incorrect protocol composition) will render it insecure.\n- The README is AI-generated; when in doubt, defer to the actual Rust source and accompanying tests.\n",
  "package_categories": [
    "cryptography",
    "algorithms",
    "science",
    "no-std",
    "development-tools"
  ],
  "package_description": "Constant-time, Donna-compatible Poly1305 authenticator for Bitcoin-related tooling, implemented in Rust with radix-2^26 limb arithmetic and detailed tracing support.",
  "package_keywords": [
    "poly1305",
    "bitcoin",
    "cryptography",
    "mac",
    "authenticator"
  ]
}