{
  "crate_name": "bitcoin-random",
  "full_readme_markdown": "# bitcoin-random\n\nA carefully ported subset of Bitcoin Core's entropy collection and pseudo‑random number generation, exposed as a reusable Rust crate.\n\nThis README was generated by an AI model and may not be 100% accurate, but it should be a close approximation of the crate's intent and API.\n\n## Overview\n\n`bitcoin-random` provides a layered randomness subsystem modeled on Bitcoin Core's production code. It combines OS entropy, CPU hardware RNG instructions, high‑resolution timers, environment snapshots, and an internal SHA‑512–based DRBG to supply both fast and cryptographically strong random bytes.\n\nYou typically want this crate if:\n\n- You are implementing or porting Bitcoin Core subsystems that expect the same RNG semantics (e.g. consensus‑relevant logic, wallet key generation, or P2P behavior).\n- You need a battle‑tested entropy aggregator with defensive mixing, strengthening, and hardware feature detection.\n- You want deterministic test RNGs with the same distributional properties as Bitcoin Core’s `FastRandomContext`.\n\nThe crate exposes:\n\n- **High‑level APIs** for fast and strong randomness:\n  - `get_rand_bytes`, `get_strong_rand_bytes`\n  - `get_rand`, `get_rand_int`, `get_rand_hash`\n  - `get_random_duration`\n- **An internal DRBG and state machine** (`RNGState`, `RNGInnerState`, `RNGStateEvents`) that maintains 256 bits of entropy and continuously mixes in new sources.\n- **FastRandomContext**: a deterministic, ChaCha20‑based PRNG implementing `rand_core::RngCore` and a custom `RandRange` trait.\n- **Environment entropy collectors** (`rand_add_dynamic_env`, `rand_add_static_env`, and several OS/CPU‑specific helpers) closely matching Bitcoin Core’s C++ implementation.\n- **Hardware RNG integration and reporting** for Intel/AMD `RDRAND` and `RDSEED`.\n- **Low‑level OS entropy backends** for Linux (`getrandom`/`/dev/urandom`), BSD (`getentropy`, `sysctl KERN_ARND`), macOS, Windows (CryptoAPI), and a `/dev/urandom` fallback.\n\nThe design emphasizes:\n\n- **Cryptographic robustness**: entropy is aggregated into a SHA‑512 DRBG which maintains at least 256 bits of internal state; additional entropy is mixed in on each call to strong RNG interfaces.\n- **Side‑channel resilience**: sensitive buffers are cleared via `memory_cleanse` after use where appropriate.\n- **Deterministic testing**: `FastRandomContext` can be seeded deterministically; a global flag `G_MOCK_DETERMINISTIC_TESTS` exists to route `get_rand` into deterministic mode.\n- **Close fidelity to Bitcoin Core**: structure, sequencing, and environment gathering paths are designed to be isomorphic to the upstream C++ implementation, preserving security properties and behavior.\n\n## Crate status and scope\n\nThis crate is derived from the `bitcoin-rs` project and is intended primarily to support that ecosystem. It is not a general‑purpose, standards‑audited cryptographic library; however, it is based on code that has undergone extensive real‑world scrutiny in the context of Bitcoin Core.\n\nUse for key generation and consensus‑relevant randomness should follow Bitcoin Core’s threat model and assumptions. If you need FIPS‑validated primitives or formal proofs, you may prefer a dedicated cryptographic RNG crate.\n\n## RNG layers and conceptual model\n\n### 1. OS entropy (`get_os_rand` and friends)\n\nThe lowest layer is direct OS entropy:\n\n- **Linux/Android**: `getrandom(2)` when available; falls back to reading `/dev/urandom`.\n- **OpenBSD**: `getentropy`.\n- **macOS**: `getentropy`.\n- **FreeBSD/NetBSD and similar**: `sysctl` with `KERN_ARND`.\n- **Windows**: CryptoAPI `CryptAcquireContextW` + `CryptGenRandom`.\n- **Portable fallback**: `/dev/urandom` where no specialized support is compiled in.\n\nThese backends always try to fill a 32‑byte buffer (`NUM_OS_RANDOM_BYTES`) and **fail hard** via `rand_failure()` if the OS cannot supply randomness.\n\n### 2. Internal DRBG (`RNGState` and `RNGInnerState`)\n\n`RNGInnerState` maintains:\n\n- `state: [u8; 32]` — 256 bits of internal entropy.\n- `counter: u64` — a monotonically increasing counter mixed into each extraction.\n- `strongly_seeded: bool` — indicates whether a strong (OS‑backed) seed has been mixed in at least once.\n\n`RNGState` wraps this inner state with mutexes and an event hasher (`Sha256`) used to mix in timing and application events.\n\nEntropy extraction and mixing is performed by:\n\n```rust\npub fn mix_extract(\n    &mut self,\n    out: &mut [u8],\n    num: usize,\n    hasher: Sha512,\n    strong_seed: bool,\n) -> bool\n```\n\nKey properties:\n\n- The current `state` and `counter` are appended to a `Sha512` hasher plus any external entropy provided by the caller.\n- `finalize()` of the hasher yields 64 bytes:\n  - The **last 32 bytes** become the new internal `state`.\n  - The **first 32 bytes** (optionally truncated to `num ≤ 32`) are returned as output.\n- If `strong_seed` is `true`, `strongly_seeded` is updated; the function returns the current `strongly_seeded` flag so callers (e.g. `proc_rand`) can determine whether strong seeding has ever happened.\n\nThis structure matches Bitcoin Core’s DRBG: the new state is a one‑way function of the old state, the counter, and new entropy. Compromise of a single output does not reveal prior state.\n\n### 3. Seeding strategies\n\nSeveral seeding functions, each with distinct cost and entropy assumptions, feed into the DRBG:\n\n- **`seed_fast`**: minimal latency seed for high‑frequency use.\n  - Uses stack pointer, optional hardware RNG (`seed_hardware_fast`), and a high‑resolution timestamp (`seed_timestamp`).\n- **`seed_slow`**: stronger reseed path.\n  - Calls `seed_fast`.\n  - Adds 32 bytes of OS randomness (`get_os_rand`).\n  - Incorporates event hash via `rng.seed_events`.\n  - Adds another high‑precision timestamp.\n- **`seed_hardware_slow`**: high‑quality hardware RNG (if available).\n  - Prefers `RDSEED` and collects 256 bits directly.\n  - Falls back to repeatedly XORed `RDRAND` results to obtain 256 bits with inter‑call reseeding.\n- **`seed_periodic`**: expensive reseed path intended to run periodically (e.g. once a minute).\n  - Includes `seed_fast` + `seed_timestamp` + `rng.seed_events`.\n  - Mixes a wide set of dynamic environment data via `rand_add_dynamic_env` (timers, `/proc` snapshots, resource usage, etc.).\n  - Strengthens the resulting seed with a `strengthen` loop over ~10 ms.\n- **`seed_startup`**: heavy startup seeding for first use.\n  - Uses `seed_hardware_slow`.\n  - Uses `seed_slow`.\n  - Mixes dynamic and static environment data (`rand_add_dynamic_env`, `rand_add_static_env`).\n  - Applies `strengthen` for ~100 ms.\n\nThe `strengthen` function repeatedly hashes an initial 32‑byte seed through `Sha512` for a configurable number of microseconds, periodically folding in high‑resolution performance counters. This is conceptually a time‑hardening step: it converts any partial entropy from noisy sources into pseudorandom bits while amortizing over CPU time.\n\n### 4. Hardware RNG integration (x86/x86_64)\n\nWhen compiled with `have_getcpuid` and on supported targets:\n\n- `init_hardware_rand` uses CPUID leaves to query `RDRAND` and `RDSEED` support, setting `G_RDRAND_SUPPORTED` and `G_RDSEED_SUPPORTED`.\n- `report_hardware_rand` logs which features are in use.\n- `get_rd_rand` and `get_rd_seed` use inline assembly to issue the corresponding instructions, including the recommended retry loops to handle transient failure.\n\nThe seeding functions (`seed_hardware_fast` / `seed_hardware_slow`) only use these instructions when the corresponding hardware support flags are set.\n\n### 5. Event and environment entropy\n\nTo defend against state compromise and to continuously add entropy, the RNG mixes in information from:\n\n- **Event timing**: `rand_add_event(event_info: u32)` writes the event identifier and low 32 bits of a high‑frequency performance counter into a `Sha256` hasher in `RNGStateEvents`. This is suitable for network packet arrivals, user input, or other external events.\n- **Dynamic environment** (`rand_add_dynamic_env`):\n  - System clocks: `CLOCK_REALTIME`, `CLOCK_MONOTONIC`, `CLOCK_BOOTTIME` (Linux), `gettimeofday`, C++‑style triple of `system_clock`, `steady_clock`, `high_resolution_clock` equivalents.\n  - Resource usage: `getrusage(RUSAGE_SELF)`.\n  - `/proc` snapshots: several small files on Linux (`diskstats`, `vmstat`, `schedstat`, `zoneinfo`, `meminfo`, `softirqs`, `stat`, `self/schedstat`, `self/status`).\n  - Heap/stack pointers: allocations via `malloc` and raw addresses.\n  - Network interfaces: `getifaddrs` enumeration, interface names, flags, and socket addresses.\n  - Hostname, uname fields, and key filesystem paths.\n- **Static environment** (`rand_add_static_env`):\n  - Sizes of fundamental types and signedness of `char`.\n  - Linux `getauxval` data (`AT_HWCAP`, `AT_HWCAP2`, `AT_RANDOM`, `AT_PLATFORM`, `AT_EXECFN`).\n  - CPU feature set via CPUID enumeration (`add_allcpuid`).\n  - Addresses of code and data symbols (e.g. function pointers, `malloc`, `errno`, `environ`).\n  - Full environment variables.\n  - Process and thread identifiers (`pid`, `ppid`, `sid`, `pgid`, `uid/gid`, `euid/egid`, and `pthread_self`).\n\nThese sources are not relied upon as primary entropy; instead, they hedge against partial compromise and OS RNG failures by adding unpredictability from system‑specific and timing‑dependent state.\n\n## Public API\n\n### Top‑level RNG functions\n\nThese are the main entry points most consumers should use.\n\n#### `get_rand_bytes`\n\n```rust\npub fn get_rand_bytes(buf: &mut [u8], num: i32)\n```\n\n- Fills `buf[..num]` with random bytes generated via the internal PRNG.\n- Uses `RNGLevel::FAST` seeding via `proc_rand`, so it is tuned for throughput rather than maximum entropy.\n- Thread‑safe.\n\nUsage:\n\n```rust\nuse bitcoin_random::get_rand_bytes;\n\nlet mut key = [0u8; 32];\nget_rand_bytes(&mut key, key.len() as i32);\n```\n\n#### `get_strong_rand_bytes`\n\n```rust\npub fn get_strong_rand_bytes(buf: &mut [u8], num: i32)\n```\n\n- Fills `buf[..num]` with random bytes using the **strong** seeding path (`RNGLevel::SLOW`).\n- This path always incorporates OS randomness and event information and will abort if the OS RNG fails.\n- Intended for security‑critical operations such as key generation.\n\nUsage:\n\n```rust\nuse bitcoin_random::get_strong_rand_bytes;\n\nlet mut secret = [0u8; 32];\nget_strong_rand_bytes(&mut secret, secret.len() as i32);\n```\n\n#### `get_rand`\n\n```rust\npub fn get_rand(n_max: u64) -> u64\n```\n\n- Returns a uniform random integer in `[0, n_max)` using `FastRandomContext::randrange`.\n- Preconditions: `n_max > 0`.\n- Uses the global `G_MOCK_DETERMINISTIC_TESTS` flag to optionally switch into deterministic mode for tests.\n\nExample:\n\n```rust\nuse bitcoin_random::get_rand;\n\nlet x = get_rand(1_000_000);\nassert!(x < 1_000_000);\n```\n\n#### `get_rand_int`\n\n```rust\npub fn get_rand_int(n_max: i32) -> i32\n```\n\n- Thin wrapper around `get_rand`, returning `i32` instead of `u64`.\n- Preconditions: `n_max > 0`.\n\n#### `get_rand_hash`\n\n```rust\npub fn get_rand_hash() -> u256\n```\n\n- Returns a random 256‑bit value as a `u256` type (from the surrounding Bitcoin numeric crate).\n- Backed by `get_rand_bytes` over the raw bytes of the `u256` structure.\n\nThis is the primitive used by `FastRandomContext::random_seed` to construct ChaCha20 keys.\n\n#### `get_random_duration`\n\n```rust\npub fn get_random_duration(max: Duration) -> Duration\n```\n\n- Returns a random `Duration` uniformly distributed in `[0, max)`.\n- Preconditions: `max.as_seconds_f64() > 0`.\n- Used to derive randomized timers or retry backoffs.\n\n### RNG lifecycle helpers\n\n#### `random_init`\n\n```rust\npub fn random_init()\n```\n\n- Optional explicit initialization step.\n- Internally calls `proc_rand(&mut [], 0, RNGLevel::FAST)` to trigger `RNGState` setup and hardware RNG detection.\n- Then calls `report_hardware_rand` to log discovered CPU RNG features.\n\nYou may call this early in process startup to ensure RNG initialization happens on your own schedule, instead of lazily on first use.\n\n#### `random_sanity_check`\n\n```rust\npub fn random_sanity_check() -> bool\n```\n\n- Performs a self‑test of the OS randomness backend and the performance counter:\n  - Repeatedly calls `get_os_rand` on a zeroed buffer and checks that each byte is overwritten at least once within a bounded number of attempts.\n  - Verifies that `get_performance_counter` increases across a call to `get_os_rand` + 1 ms sleep.\n  - Feeds the performance counter values back into the global `RNGState` as additional entropy.\n- Returns `false` if the OS RNG appears to misbehave or if the performance counter does not advance.\n\nThis is primarily a diagnostic / defensive primitive.\n\n#### `rand_add_periodic`\n\n```rust\npub fn rand_add_periodic()\n```\n\n- Invokes `proc_rand(&mut [], 0, RNGLevel::PERIODIC)`.\n- Intended to be called periodically (e.g. via a timer) to add slow, expensive environmental entropy (perfmon, `/proc`, network interfaces, etc.) and strengthen the state.\n\n#### `rand_add_event`\n\n```rust\npub fn rand_add_event(event_info: u32)\n```\n\n- Adds an event descriptor plus timing information into the RNG’s event hasher.\n- Thread‑safe.\n\nYou can use this to feed in application‑specific events that may provide extra entropy, such as network message arrivals, user actions, or I/O completions.\n\n### `FastRandomContext`\n\n`FastRandomContext` is a fast, non‑cryptographic PRNG seeded from strong randomness (unless explicitly configured as deterministic). It is conceptually similar to a C++ `UniformRandomBitGenerator` and implements both the custom `RandRange` trait and `rand_core::RngCore`.\n\nKey properties:\n\n- Underlying core: `ChaCha20` stream cipher.\n- Seed: 256‑bit `u256` key from `get_rand_hash()` when `requires_seed` is true.\n- Deterministic option: when constructed with `deterministic = true`, the context is seeded with a fixed all‑zero `u256` key.\n- Not thread‑safe; each instance is intended for single‑threaded use.\n\n#### Construction\n\n```rust\nimpl FastRandomContext {\n    pub fn new(deterministic: bool) -> Self { /* ... */ }\n}\n\nimpl Default for FastRandomContext { /* deterministic = false */ }\n\nimpl From<&u256> for FastRandomContext { /* seed from explicit u256 */ }\nimpl From<&mut FastRandomContext> for FastRandomContext { /* move semantics */ }\n```\n\nTypical usage:\n\n```rust\nuse bitcoin_random::FastRandomContext;\n\n// Non‑deterministic context, seeded from global RNG\nlet mut rng = FastRandomContext::default();\nlet x = rng.rand64();\n\n// Deterministic context for tests or simulations\nlet mut det_rng = FastRandomContext::new(true);\nlet a = det_rng.rand32();\nlet b = det_rng.rand32();\n```\n\nIf a `FastRandomContext` is moved using `From<&mut FastRandomContext>`, the original instance becomes logically invalid until it reseeds itself on next use (`requires_seed` is set back to `true`).\n\n#### Basic methods\n\n```rust\nimpl FastRandomContext {\n    pub fn rand64(&mut self) -> u64;\n    pub fn rand32(&mut self) -> u32;\n    pub fn randbits(&mut self, bits: i32) -> u64; // 0 ≤ bits ≤ 64\n    pub fn randbool(&mut self) -> bool;\n    pub fn rand256(&mut self) -> u256;\n    pub fn randbytes(&mut self, len: usize) -> Vec<u8>;\n\n    pub fn min() -> u64 { 0 }\n    pub fn max() -> u64 { u64::MAX }\n    #[inline]\n    pub fn invoke(&mut self) -> u64 { self.rand64() }\n}\n```\n\n`randbits` uses an internal bit buffer (`bitbuf`) to collect and reuse entropy at bit‑level granularity, avoiding waste when many small random values are needed.\n\n`randbytes` uses the underlying ChaCha20 keystream directly and is efficient for filling large buffers.\n\n#### Integration with `rand_core`\n\n`FastRandomContext` implements `rand_core::RngCore`:\n\n```rust\nimpl rand_core::RngCore for FastRandomContext {\n    fn next_u32(&mut self) -> u32;\n    fn next_u64(&mut self) -> u64;\n    fn fill_bytes(&mut self, dest: &mut [u8]);\n    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand::Error>;\n}\n```\n\nThis allows you to plug it into consumers that expect a `RngCore` implementation.\n\n#### `RandRange` trait\n\nThe crate defines a minimal trait for generating uniform integers in a given range:\n\n```rust\npub trait RandRange {\n    fn randrange(&mut self, range: u64) -> u64;\n}\n\nimpl RandRange for FastRandomContext { /* rejection sampling */ }\n```\n\n`randrange` implements rejection sampling:\n\n- Let `range > 0`; compute `bits = count_bits(range - 1)`.\n- Draw `bits` random bits via `randbits(bits)`.\n- If the sample is ≤ `range - 1`, accept; otherwise, retry.\n\nThis ensures uniform distribution in `[0, range)` for any range not necessarily a power of two.\n\n### Shuffling utilities\n\nThe crate offers a highly specialized shuffle function optimized to minimize entropy waste and avoid specific issues with `std::shuffle` in some C++ standard libraries. The Rust port uses a generic iterator/index model constrained by several traits.\n\n```rust\npub fn shuffle<'a, I: 'a, R>(mut first: I, last: I, mut rng: R)\nwhere\n    I: PartialEq + Copy + Sub<Output = I> + AddAssign<u64> + Add<Output = u64>,\n    I: Deref<Target = &'a mut I> + DerefMut<Target = &'a mut I>,\n    I: Add<u64>,\n    R: RandRange,\n    <I as Add<u64>>::Output: Deref<Target = &'a mut I>,\n    <I as Add<u64>>::Output: DerefMut<Target = &'a mut I>,\n    u64: From<I>,\n```\n\nThis is a direct structural translation of the C++ `shuffle` used in Bitcoin Core's container utilities, which assumes a pointer‑like index type. It is not intended as a general drop‑in replacement for typical Rust iterators and may require custom wrapper types; in many Rust codebases you will prefer `rand::seq::SliceRandom` instead.\n\n`shuffle_all` is present but currently `todo!()`, mirroring an unimplemented C++ pattern.\n\n## Platform behavior and performance counters\n\n### `get_performance_counter`\n\n```rust\npub fn get_performance_counter() -> i64\n```\n\n- On x86/x86_64 Windows: uses `RDTSC` via `_rdtsc()` intrinsics.\n- On non‑Windows x86/x86_64: uses inline assembly `rdtsc`.\n- On other platforms: falls back to `quanta::Instant::now().as_u64()`.\n\nThe counter is used for:\n\n- Event timing in `rand_add_event`.\n- Strengthening loops (`strengthen`).\n- Periodic sanity checks.\n\nIt is treated as an entropy source only in combination with other inputs; alone it is not assumed to be unpredictable.\n\n## Example: generating keys and nonces\n\n```rust\nuse bitcoin_random::{\n    random_init,\n    random_sanity_check,\n    get_strong_rand_bytes,\n    get_rand_bytes,\n    FastRandomContext,\n};\n\nfn main() {\n    // Optional: ensure RNG is initialized early and hardware RNG reported.\n    random_init();\n\n    // Optional: run a one‑time self‑test.\n    assert!(random_sanity_check(), \"OS RNG failed sanity check\");\n\n    // Generate a 32‑byte secret (e.g. for an EC private key).\n    let mut sk = [0u8; 32];\n    get_strong_rand_bytes(&mut sk, sk.len() as i32);\n\n    // Generate a non‑cryptographic nonce using the fast path.\n    let mut nonce = [0u8; 16];\n    get_rand_bytes(&mut nonce, nonce.len() as i32);\n\n    // Use a dedicated, fast context for many draws.\n    let mut ctx = FastRandomContext::default();\n    let session_id = ctx.rand64();\n\n    println!(\"secret key: {:02x?}\", sk);\n    println!(\"nonce: {:02x?}\", nonce);\n    println!(\"session id: {}\", session_id);\n}\n```\n\n## Safety and correctness notes\n\n- Many functions marked `unsafe` in the implementation are strictly internal; the public API is safe, but relies heavily on FFI and OS behavior.\n- Misconfigured `cfg` flags can change which backend is used for `get_os_rand`; link errors or runtime aborts typically indicate such misconfiguration.\n- `G_MOCK_DETERMINISTIC_TESTS` is a global `AtomicBool` that affects `get_rand`; it is intended for tests and should not be enabled in production.\n- Functions like `rand_add_dynamic_env` and `rand_add_static_env` may read a substantial amount of system state. They are not cheap and should be used via the seeding interfaces (`seed_startup`, `seed_periodic`) rather than directly in hot paths.\n\n## Integration with the rest of `bitcoin-rs`\n\nThis crate is designed to be used by other crates in the `bitcoin-rs` repository, sharing:\n\n- The `u256` type for 256‑bit values.\n- Common logging macros (`log_print!`, `log_printf!`).\n- Shared cryptographic primitives (`Sha256`, `Sha512`, `ChaCha20`, `SecureAllocator`).\n\nWhen using `bitcoin-random` in isolation, be aware that some items (numeric types, logging, memory allocators) come from sibling crates in the same repository.\n\n## License\n\nThis crate is licensed under the **MIT License**, consistent with the rest of the `bitcoin-rs` repository.\n\n## Repository\n\nThe source for this crate lives in:\n\n- GitHub: <https://github.com/klebs6/bitcoin-rs>\n\nThe RNG implementation here is intended to be kept structurally close to its C++ counterpart. When in doubt about behavior or security properties, consult the corresponding Bitcoin Core source files and documentation.\n",
  "package_categories": [
    "cryptography",
    "network-programming",
    "algorithms",
    "science",
    "development-tools"
  ],
  "package_description": "Bitcoin Core-style entropy collection and pseudo-random number generation for Rust, including OS entropy backends, x86 hardware RNG integration, a SHA-512-based DRBG, and a ChaCha20 FastRandomContext compatible with Bitcoin Core semantics.",
  "package_keywords": [
    "bitcoin",
    "rng",
    "entropy",
    "cryptography",
    "chacha20"
  ]
}