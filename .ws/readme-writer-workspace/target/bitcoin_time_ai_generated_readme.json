{
  "crate_name": "bitcoin-time",
  "full_readme_markdown": "# bitcoin-time\n\nHigh‑fidelity time utilities and ISO‑8601 formatting/parsing for Bitcoin‑style systems, ported from Bitcoin Core's C++ `std::chrono` and time logic.\n\n> This README was generated by an AI model. It may not be perfectly accurate, but it should be a good, reasonably faithful description of the crate.\n\n---\n\n## Overview\n\n`bitcoin-time` provides a small, focused toolkit for dealing with time in Bitcoin‑like nodes and services:\n\n- Strongly‑typed duration aliases mirroring C++ `std::chrono` typedefs.\n- Conversion utilities between Rust `Duration` and C `timeval` for `select()`/FFI.\n- Helpers to extract seconds/milliseconds/microseconds as integers or `f64`.\n- ISO‑8601 date/time formatting and parsing around Unix timestamps.\n- A **mockable** notion of \"current time\" for deterministic testing.\n- A generic **median filter** for time offset consensus, modeled on Bitcoin Core's time adjustment logic.\n\nThe design goal is *deterministic, debuggable, and testable time behavior* suitable for consensus‑sensitive or protocol‑sensitive code.\n\n---\n\n## Features at a Glance\n\n- `MillisToTimeval` trait to convert millisecond values into `libc::timeval` (for e.g. `select`, `poll`, or other C APIs).\n- Duration typedefs:\n  - `Milliseconds`, `Microseconds`, `Seconds`, `SecondsDouble` (all `StdDuration`)\n  - `Minutes` (wrapper newtype over `Duration` preserving upstream semantics).\n- Global mock time and time offset:\n  - `MOCK_TIME: AtomicI64` – mock time in **seconds since Unix epoch**;\n  - `TIME_OFFSET: Mutex<i64>` – P2P time offset in seconds.\n- Helpers:\n  - `count_seconds` / `count_milliseconds` / `count_microseconds` / `count_seconds_double`.\n  - `get_time_since_epoch<T>()` – mock‑aware, generic over `From<StdDuration>`.\n  - `get_system_time_since_epoch<T>()` – never mockable.\n  - `get_time_millis_since_epoch`, `get_time_micros_since_epoch`, `get_time_seconds_since_epoch`.\n  - `uninterruptible_sleep` – panic on negative durations, otherwise sleep fully.\n- ISO‑8601 conversion:\n  - `format_iso8601date_time` – `YYYY‑MM‑DDTHH:MM:SSZ`.\n  - `format_iso8601date` – `YYYY‑MM‑DD`.\n  - `parse_iso8601date_time` – string → epoch seconds, fall back to `0`.\n- `MedianFilter<T>` – generic streaming median over the last `N` values.\n\nAll functions are instrumented with structured logging (via tracing macros in upstream code) and are intended to be safe, simple building blocks for higher‑level protocols.\n\n---\n\n## Installation\n\n```toml\n[dependencies]\nbitcoin-time = \"0.1.19\"\n```\n\nThis crate targets Rust **2021 edition**.\n\n---\n\n## Duration Typedefs\n\nThe crate mirrors Bitcoin Core's `std::chrono` typedefs so that ported logic can be left structurally intact:\n\n```rust\nuse bitcoin_time::{Milliseconds, Microseconds, Seconds, SecondsDouble, Minutes};\n\nfn demo(d: Seconds) {\n    let s: i64 = bitcoin_time::count_seconds(d);\n    let ms: i64 = bitcoin_time::count_milliseconds(d as Milliseconds);\n    let us: i64 = bitcoin_time::count_microseconds(d as Microseconds);\n    let s_f64: f64 = bitcoin_time::count_seconds_double(d as SecondsDouble);\n    println!(\"s={s}, ms={ms}, us={us}, s_f64={s_f64}\");\n}\n```\n\nInternally these are `std::time::Duration` (or a thin wrapper for `Minutes`), but the explicit aliases encode intent and protect call‑sites from relying on particular underlying units.\n\n---\n\n## Milliseconds → `timeval`\n\n`MillisToTimeval` abstracts conversion from millisecond counts into a `libc::timeval`, suitable for `select()` or other C APIs:\n\n```rust\nuse bitcoin_time::MillisToTimeval;\n\nfn poll_timeout(ms: i64) -> libc::timeval {\n    ms.millis_to_timeval()\n}\n\nfn from_duration(d: std::time::Duration) -> libc::timeval {\n    d.millis_to_timeval()\n}\n```\n\nThe implementation splits milliseconds into `tv_sec` and `tv_usec` with integer arithmetic, preserving full microsecond resolution up to the limits of `i64` and `libc::time_t`.\n\n---\n\n## ISO‑8601 Formatting and Parsing\n\nFor interoperable logs, RPC, and on‑wire protocols, `bitcoin-time` provides deterministic conversion between Unix timestamps and ISO‑8601 strings.\n\n### Formatting\n\n```rust\nuse bitcoin_time::{format_iso8601date_time, format_iso8601date};\n\nlet epoch: i64 = 1_609_459_200; // 2020‑12‑31T00:00:00Z\nlet ts = format_iso8601date_time(epoch);\nlet d = format_iso8601date(epoch);\n\nassert_eq!(ts, \"2020-12-31T00:00:00Z\");\nassert_eq!(d,  \"2020-12-31\");\n```\n\nFormatting is total: invalid timestamps (e.g. out of range for the underlying library) degrade to `\"\"` rather than panicking.\n\n### Parsing\n\n```rust\nuse bitcoin_time::parse_iso8601date_time;\n\nlet epoch = parse_iso8601date_time(\"2020-12-31T00:00:00Z\");\nassert_eq!(epoch, 1_609_459_200);\n\n// On parse failure we get 0.\nassert_eq!(parse_iso8601date_time(\"nonsense\"), 0);\n```\n\nParsing is strict with respect to the `YYYY‑MM‑DDTHH:MM:SSZ` grammar and returns `0` on failure so protocol layers can treat invalid timestamps as sentinel values without panics.\n\n---\n\n## Mock Time and Time Offset\n\nConsensus‑critical systems often differentiate between:\n\n- **Physical time** – OS clock, never overridden.\n- **Mock time** – controlled value for tests and simulations.\n- **P2P time offset** – correction derived from peers' clocks.\n\n`bitcoin-time` encodes exactly these three:\n\n### Mock Time\n\n```rust\nuse bitcoin_time::{set_mock_time, get_mock_time_since_epoch};\nuse std::time::Instant;\n\n// Set mock time (seconds since epoch) relative to an `Instant`.\nset_mock_time(Instant::now());\n\n// Read it back as a Duration since epoch.\nlet mock = get_mock_time_since_epoch();\nassert!(mock.as_secs() > 0);\n```\n\n`MOCK_TIME` is **global** and expressed as seconds since Unix epoch. A value of `0` denotes \"no mock time\" and triggers fallback to real system time.\n\n### Time Since Epoch\n\n```rust\nuse bitcoin_time::{\n    get_time_since_epoch,\n    get_system_time_since_epoch,\n    get_time_millis_since_epoch,\n    get_time_micros_since_epoch,\n    get_time_seconds_since_epoch,\n};\nuse std::time::Duration as StdDuration;\n\n// Mock‑aware time since epoch.\nlet d: StdDuration = get_time_since_epoch();\n\n// Real (non‑mockable) time.\nlet real_d: StdDuration = get_system_time_since_epoch();\n\nlet ms: i64 = get_time_millis_since_epoch();\nlet us: i64 = get_time_micros_since_epoch();\nlet s:  i64 = get_time_seconds_since_epoch();\n```\n\n`get_time_since_epoch<T>()` and `get_system_time_since_epoch<T>()` are generic over `T: From<StdDuration>`, letting you choose your own duration wrapper or fixed‑point representation.\n\n### P2P Time Offset and Adjusted Time\n\n```rust\nuse bitcoin_time::{get_time_offset, get_adjusted_time, get_adjusted_datetime};\n\nlet offset_s: i64 = get_time_offset();\nlet adjusted_epoch: i64 = get_adjusted_time();\nlet adjusted_dt = get_adjusted_datetime();\n```\n\nThe **time offset** is usually derived from the median of peer clocks and is meant to be small (on the order of seconds). `get_adjusted_time()` adds this offset to the current physical time to produce P2P time.\n\n---\n\n## MedianFilter\n\n`MedianFilter<T>` implements a sliding window median over the last `N` observations. This is used in Bitcoin Core to robustly estimate clock offsets under adversarial or noisy peer behavior.\n\nMathematically, for a multiset \\( S = \\{x_1, \\dots, x_n\\} \\) sorted in nondecreasing order, the median is:\n\n- \\( x_{(n+1)/2} \\) if \\( n \\) is odd;\n- \\( \\frac{1}{2}(x_{n/2} + x_{n/2+1}) \\) if \\( n \\) is even.\n\n`MedianFilter` realizes this definition on a bounded window by retaining at most `n_size` values, copying and sorting them for each update.\n\n### Type Bounds\n\n```rust\nimpl<T> MedianFilter<T>\nwhere\n    T: Copy\n        + PartialOrd\n        + Add<Output = T>\n        + Div<Output = T>\n        + From<u8>\n```\n\nThe constraints enable ordering and arithmetic on `T`, and allow division by `2` for the even‑length case (`T::from(2u8)`). Typical choices are `i32`, `i64`, `f32`, `f64`.\n\n### Usage Example\n\n```rust\nuse bitcoin_time::MedianFilter;\n\nlet mut f = MedianFilter::new(5, 0_i64);\n\nfor v in [1, 100, 2, 3, 1000] {\n    f.input(v);\n}\n\nlet m = f.median();\nassert_eq!(m, 3); // median of [1, 2, 3, 100, 1000]\nassert_eq!(f.size(), 5);\n```\n\nThe implementation characteristics:\n\n- Bounded memory: stores at most `n_size` items.\n- On insertion, if full, drops the oldest element (FIFO).\n- Complexity is `O(n log n)` per insertion due to sorting; this is entirely adequate for small `n` (typical P2P consensus windows are <= a few hundred elements).\n\n---\n\n## Chrono Sanity Check\n\n`chrono_sanity_check()` validates that Rust's `UNIX_EPOCH` constant aligns with the Unix epoch (time `0`) by verifying that `UNIX_EPOCH.duration_since(UNIX_EPOCH)` equals `Duration::ZERO`.\n\n```rust\nlet ok = bitcoin_time::chrono_sanity_check();\nassert!(ok);\n```\n\nThis function is intended as a defensive assertion for environments with potentially misconfigured or exotic time bases.\n\n---\n\n## Uninterruptible Sleep\n\n`uninterruptible_sleep` enforces a non‑negative duration and sleeps once for the full period:\n\n```rust\nuse std::time::Duration;\nuse bitcoin_time::uninterruptible_sleep;\n\nuninterruptible_sleep(Duration::from_millis(250));\n```\n\nInternally this:\n\n- Rejects negative durations (`try_into()` on the underlying type will panic).\n- Delegates to `std::thread::sleep`.\n\nThis is useful when the semantics require that a sleep either completes fully or aborts the program rather than returning early.\n\n---\n\n## Design Notes\n\n- **Epoch alignment** – All epoch computations assume the Unix epoch and are checked via `chrono_sanity_check()`.\n- **Mock vs physical** – Functions are explicit about whether they obey `MOCK_TIME` (`get_time_since_epoch`) or bypass it (`get_system_time_since_epoch`, `get_time_millis_since_epoch`, etc.).\n- **Integer conversions** – Conversions from `Duration` to `i64` intentionally truncate toward zero (`as_secs`, `as_millis`, `as_micros`), as required by consensus code ports.\n- **Error handling** – Parsing and formatting favor *total* behavior without panics, returning sentinel values (`0`, empty strings) on failure, while logging through the tracing infrastructure in the original codebase.\n\n---\n\n## Repository and License\n\nThis crate is part of the `bitcoin-rs` project:\n\n- Repository: <https://github.com/klebs6/bitcoin-rs>\n- License: MIT\n\nContributions should preserve deterministic behavior and compatibility with the upstream Bitcoin Core time semantics.\n",
  "package_categories": [
    "date-and-time",
    "cryptography",
    "network-programming",
    "science"
  ],
  "package_description": "Bitcoin Core-inspired time utilities: Unix-epoch conversions, ISO-8601 formatting/parsing, mockable system time, timeval conversion, and a generic median filter for P2P time offset estimation.",
  "package_keywords": [
    "bitcoin",
    "time",
    "chrono",
    "iso8601",
    "mock-time"
  ]
}