{
  "crate_name": "bitcoin-sha256-hkdf",
  "full_readme_markdown": "# bitcoin-sha256-hkdf\n\nA compact, single‑purpose HKDF (RFC 5869) implementation specialized for:\n\n- HMAC-SHA256 as the underlying PRF\n- A fixed output length of 32 bytes (L = 32)\n- Compatibility with Bitcoin-style codebases and key-derivation workflows\n\nThis crate is intentionally narrow in scope: it exists to derive *exactly one* 32‑byte key from an input keying material (IKM), with a salt and an info string, using the expand step of HKDF with a single block.\n\n> **Note:** This README was generated by an AI model. It may not be perfectly accurate in every detail, but it is designed to be directionally correct and practically useful.\n\n---\n\n## Motivating use case\n\nMany Bitcoin and cryptocurrency systems need a simple, auditable, deterministic key-derivation mechanism built from SHA‑256 primitives. Typical scenarios include:\n\n- Deriving per‑channel keys or per‑session secrets from a long‑term KDF root key\n- Generating context‑scoped 32‑byte secrets (e.g., for protocol instances, channels, or peers)\n- Avoiding ad‑hoc derivation constructions while still staying very close to Bitcoin’s low‑level SHA‑256/HMAC style\n\nThis crate encapsulates that pattern behind a small, predictable API, without depending on large cryptographic frameworks.\n\n---\n\n## Cryptographic background (HKDF + HMAC-SHA256)\n\nHKDF, specified in [RFC 5869](https://datatracker.ietf.org/doc/html/rfc5869), is a key derivation function built on top of a pseudorandom function (PRF), typically HMAC. It has two logical phases:\n\n1. **Extract**: `PRK = HMAC(salt, IKM)`\n2. **Expand**: `OKM = T(1) || T(2) || ... || T(n)`, where each block is derived inductively.\n\nWhere:\n- `IKM` — input keying material (possibly high‑entropy secret)\n- `salt` — non‑secret randomizer (can be public; recommended to be at least hash length)\n- `info` — optional context string to bind derived keys to a domain or usage\n\nFor HMAC-SHA256, the hash output length is 32 bytes. When you derive only a single 32‑byte key, `n = 1`, and the expand step reduces to:\n\n\\[\n\\text{OKM} = \\text{HMAC-SHA256}(\\text{PRK}, \\text{info} \\Vert 0x01)\n\\]\n\nThis crate implements exactly this pattern:\n\n- `Extract`: performed once in `CHKDF_HMAC_SHA256_L32::new` to compute `prk`\n- `Expand`: performed once in `expand32`, for a single 32‑byte block\n\nThe design is intentionally minimal to align with deterministic protocols, auditability, and constant 32‑byte secret sizes (Bitcoin keys, scalar fields, etc.).\n\n---\n\n## Crate goals and non‑goals\n\n**Goals**\n\n- Provide a small, easily inspectable HKDF-SHA256 implementation with fixed 32‑byte output\n- Mirror Bitcoin‑style usage patterns, where 32‑byte secrets are the canonical primitive\n- Avoid configuration overhead: no dynamic output lengths, no algorithm switching\n\n**Non‑goals**\n\n- General HKDF implementation for arbitrary lengths or multiple blocks\n- Pluggable PRFs or hash functions\n- High‑level protocol logic; this crate just performs a single HKDF extract+expand\n\n---\n\n## Security notes\n\n- HKDF is a standard, well‑analyzed KDF construction. This crate adheres to the canonical HMAC-SHA256 variant with L=32.\n- The **salt** and **info** parameters are caller‑supplied. Proper choice of these parameters (e.g., domain separation via `info`) is your responsibility.\n- `info` length is typically bounded (the C++ reference code asserts `info.size() <= 128`). Enforcing such a bound helps match existing deployments and avoid misuse.\n- All cryptographic assumptions reduce to the usual properties of HMAC-SHA256: pseudorandomness and collision resistance of SHA‑256 and the unforgeability of HMAC.\n\nThis crate does **not** attempt to be side‑channel hardened beyond what the underlying HMAC-SHA256 implementation provides. For highly adversarial environments, review the implementation with a security engineer.\n\n---\n\n## API overview\n\nPublic interface (simplified):\n\n```rust\n/// RFC 5869 HKDF using HMAC-SHA256 with fixed 32-byte output (L = 32).\npub struct CHKDF_HMAC_SHA256_L32 {\n    prk: [u8; 32],\n}\n\nimpl CHKDF_HMAC_SHA256_L32 {\n    /// Perform HKDF-Extract: PRK = HMAC_SHA256(salt, ikm).\n    pub fn new(ikm: *const u8, ikmlen: usize, salt: &String) -> Self;\n\n    /// Perform HKDF-Expand for a single 32-byte block.\n    /// Writes exactly 32 bytes to `hash`.\n    pub fn expand32(&mut self, info: &String, hash: [u8; CHKDF_HMAC_SHA256_L32_OUTPUT_SIZE]);\n}\n```\n\nThe naming follows the originating C++ implementation. Internally, `new` computes the pseudorandom key (`prk`), and `expand32` uses it to derive a single 32‑byte output.\n\n> **Note:** The pointer‑based `ikm` interface (`*const u8`, `ikmlen`) mirrors C/C++ FFI style. In higher‑level Rust code, you will typically want your own safe wrapper that operates on slices.\n\n---\n\n## Usage\n\n### Adding the dependency\n\n```toml\n[dependencies]\nbitcoin-sha256-hkdf = \"0.1.1\"\n```\n\n### Basic example (unsafe pointer interface)\n\n```rust\nuse bitcoin_sha256_hkdf::CHKDF_HMAC_SHA256_L32;\n\nfn derive_key_example() {\n    // Input keying material (IKM): could be an ECDH shared secret, master key, etc.\n    let ikm: [u8; 32] = [0x11; 32];\n\n    // Salt: non-secret randomizer; can be zero or protocol-specific\n    let salt = String::from(\"bitcoin-hkdf-salt\");\n\n    let mut hkdf = unsafe {\n        CHKDF_HMAC_SHA256_L32::new(ikm.as_ptr(), ikm.len(), &salt)\n    };\n\n    // Info: domain separation tag / context string\n    let info = String::from(\"channel-key-derivation:v1\");\n\n    const CHKDF_HMAC_SHA256_L32_OUTPUT_SIZE: usize = 32;\n    let mut out = [0u8; CHKDF_HMAC_SHA256_L32_OUTPUT_SIZE];\n\n    hkdf.expand32(&info, out);\n\n    // `out` now holds a derived 32-byte key\n    // Use `out` as a symmetric key, scalar seed, or similar.\n}\n```\n\nIn production code you would typically encapsulate this pattern in a safe wrapper that:\n\n- Accepts `&[u8]` for `ikm`\n- Accepts `&[u8]` or `&str` for salt and info\n- Returns `[u8; 32]` instead of handling raw pointers\n\nThis crate keeps the core primitive faithful to its origin; you can build ergonomic layers on top as needed.\n\n---\n\n## Design alignment with Bitcoin ecosystems\n\nBitcoin and related systems often:\n\n- Use 32‑byte secrets ubiquitously (private keys, chain codes, seeds)\n- Favor SHA‑256 and HMAC-SHA256 as cryptographic primitives\n- Prefer minimal, reviewable cryptographic code without runtime configurability\n\n`CHKDF_HMAC_SHA256_L32` fits directly into that model:\n\n- Output is always `[u8; 32]`\n- Hash function is always SHA‑256\n- Key derivation is standardized by RFC 5869 and easy to audit\n\nThis makes it a natural building block for Bitcoin‑centric Rust libraries that want HKDF’s standard guarantees while maintaining familiarity with existing C++ / C codebases.\n\n---\n\n## Error handling and constraints\n\nThe underlying C++ reference includes an assertion like:\n\n```c++\nassert(info.size() <= 128);\n```\n\nIf the Rust implementation keeps the same constraint, `expand32` will panic when `info` exceeds the allowed length. This is not a cryptographic requirement of HKDF, but rather a protocol policy to:\n\n- Keep info fields small and predictable\n- Match historical deployment constraints\n\nWhen designing protocols on top of this crate, treat `info` as a short, structured label rather than an arbitrary blob.\n\n---\n\n## FFI and interoperability\n\nBecause `new` takes `ikm` as `*const u8` with a separate length, and both `salt` and `info` are `String`, the type signature is suitable for binding to C/C++ style APIs or for embedding in larger, FFI‑heavy systems.\n\nIf you are integrating with an existing C++ codebase that already uses `CHMAC_SHA256` and `CHKDF_HMAC_SHA256_L32`, this crate gives you a Rust side that is conceptually isomorphic:\n\n- `ikm` and `ikmlen` match typical C `uint8_t*` + length pairs\n- `salt` and `info` mirror `std::string` payloads\n- The internal `prk` and derived 32‑byte `hash` are binary‑compatible sequences of bytes\n\n---\n\n## License\n\nThis crate is distributed under the **MIT** license.\n\n---\n\n## Caveats\n\n- This README is generated by an AI model. Verify the exact function signatures and behavioral details against the actual source code.\n- Do not treat this documentation as a security review. If you are using this crate in a high‑value system, commission an expert cryptographic review of the implementation and its usage patterns.\n",
  "package_categories": [
    "cryptography",
    "mathematics",
    "algorithms",
    "development-tools",
    "science"
  ],
  "package_description": "RFC 5869 HKDF implementation specialized for HMAC-SHA256 with a fixed 32-byte output, designed for Bitcoin-style key derivation workflows.",
  "package_keywords": [
    "hkdf",
    "hmac-sha256",
    "key-derivation",
    "bitcoin",
    "cryptography"
  ]
}