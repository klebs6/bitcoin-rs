{"id": "batch_req_692cdbfbb0ac81908a5daf209c09fbbd", "custom_id": "bitcoin-version-ai-readme-request", "response": {"status_code": 200, "request_id": "b66c2c4492f4bfa391433a3daeb811c8", "body": {"id": "chatcmpl-ChliTl7rPc1rIeplPCClB7V8qNBxU", "object": "chat.completion", "created": 1764547561, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-version\",\n    \"full_readme_markdown\": \"# bitcoin-version\\n\\nVersioning and BIP14-compliant sub-version formatting utilities for Bitcoin node and wallet implementations in Rust.\\n\\n> NOTE: This README.md file was generated by an AI model and may not be 100% accurate, although it is intended to be technically close and practically useful.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-version` provides small, focused primitives for constructing version strings used in Bitcoin software, closely mirroring the behavior and conventions of Bitcoin Core:\\n\\n- Canonical **semantic-like version formatting** from a packed integer (`i32`) representation.\\n- **Full version string assembly** that incorporates git tags, commit hashes, and release/dev status at compile time.\\n- **BIP14-compliant sub-version strings** for the `User-Agent` field in the Bitcoin P2P protocol.\\n- A compile-time **copyright macro** driven by environment variables.\\n\\nThe crate is intended for applications that:\\n\\n- Implement a Bitcoin node, wallet, indexer, or related service.\\n- Need to report accurate, reproducible version information over the network (e.g., P2P `version` messages or HTTP APIs).\\n- Want build metadata (release vs. dev, git commit, tag) wired into the binary in a deterministic way.\\n\\nThe design follows the conventions of upstream Bitcoin Core, which uses an integer-encoded client version and BIP14-defined sub-version format (`/Name:major.minor.revision(optional-comments)/`).\\n\\n---\\n\\n## Encoding of Versions\\n\\n### `format_version(n_version: i32) -> String`\\n\\n`format_version` interprets `n_version` as a packed integer and renders it as `MAJOR.MINOR.REVISION`:\\n\\n```text\\nmajor    = n_version / 10000\\nminor    = (n_version / 100) % 100\\nrevision = n_version % 100\\n``\\n\\nFor example:\\n\\n- `format_version(10000)` \u2192 `\\\"1.0.0\\\"`\\n- `format_version(10100)` \u2192 `\\\"1.1.0\\\"`\\n- `format_version(10102)` \u2192 `\\\"1.1.2\\\"`\\n\\nThis encoding is historically used in Bitcoin Core so that\\n\\n```text\\nn_version = 10000 * major + 100 * minor + revision\\n```\\n\\nwhich preserves lexicographic and numeric ordering across common version progressions.\\n\\n### Example\\n\\n```rust\\nuse bitcoin_version::format_version;\\n\\nlet n_version = 10102; // 1.1.2\\nassert_eq!(format_version(n_version), \\\"1.1.2\\\");\\n```\\n\\n---\\n\\n## Full Version Strings\\n\\n### `format_full_version() -> String`\\n\\n`format_full_version` constructs a complete version string, potentially including git metadata, depending on compile-time configuration.\\n\\nThe function is gated behind `#[cfg(not(WINDRES_PREPROC))]` and uses a combination of constants or environment-driven values such as:\\n\\n- `PACKAGE_VERSION` \u2013 the crate/package version (e.g., `0.1.19`).\\n- `BUILD_GIT_TAG` \u2013 indicates a tagged build.\\n- `BUILD_GIT_COMMIT` \u2013 an abbreviated git commit hash.\\n- `GIT_COMMIT_ID` \u2013 a commit identifier from `git archive`.\\n- `CLIENT_VERSION_IS_RELEASE` \u2013 discriminates release vs. dev builds.\\n\\nThe logic (simplified):\\n\\n- **Tagged builds** (`BUILD_GIT_TAG`) typically yield something like:\\n  - `v0.1.19`\\n  - or `v0.1.19-rc1` depending on configuration.\\n- **Untagged dev builds with commit hash**:\\n  - `v0.1.19-<commit>`\\n- **Untagged dev builds with archive commit ID**:\\n  - `v0.1.19-g<id>`\\n\\nExample (conceptual):\\n\\n```rust\\n#[cfg(not(WINDRES_PREPROC))]\\nuse bitcoin_version::format_full_version;\\n\\n#[cfg(not(WINDRES_PREPROC))]\\nfn print_version_banner() {\\n    let full = format_full_version();\\n    println!(\\\"bitcoin-rs node {}\\\", full);\\n}\\n```\\n\\nBecause this function relies on `lazy_static!` and build-time configuration symbols, you typically consume it as-is from your application without needing to manage those details directly (they are usually wired in by your build system or a higher-level crate in the `bitcoin-rs` workspace).\\n\\n---\\n\\n## BIP14 Sub-Version Strings\\n\\n### Background: BIP14\\n\\n[BIP14](https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki) standardizes the user agent string (\\\"sub-version\\\") included in the Bitcoin P2P `version` message. A compliant sub-version string has the form:\\n\\n```text\\n/Name:major.minor.revision(optional;comments;here)/\\n```\\n\\nExamples:\\n\\n- `/Satoshi:0.21.0/`\\n- `/MyNode:1.3.2(beta;custom-patch)/`\\n\\nThis string is used in network-level analytics, compatibility logic, and sometimes feature-gating behavior in other nodes.\\n\\n### `format_sub_version(name: &String, n_client_version: i32, comments: &Vec<String>) -> String`\\n\\n`format_sub_version` builds a BIP14-compliant sub-version string:\\n\\n1. Prefix `/`.\\n2. Append the client `name`.\\n3. Append `:`.\\n4. Append the formatted version from `format_version(n_client_version)`.\\n5. Optionally append `(` `comments.join(\\\"; \\\")` `)` if any comments exist.\\n6. Suffix `/`.\\n\\nThe `comments` field is designed for optional qualifiers like `\\\"beta\\\"`, `\\\"pruned\\\"`, `\\\"experimental\\\"`, or deployment-specific tags.\\n\\n#### Example\\n\\n```rust\\n#[cfg(not(WINDRES_PREPROC))]\\nuse bitcoin_version::format_sub_version;\\n\\n#[cfg(not(WINDRES_PREPROC))]\\nfn user_agent() -> String {\\n    let name = \\\"bitcoin-rs-node\\\".to_string();\\n    let n_client_version = 10102; // -> 1.1.2\\n    let comments = vec![\\n        \\\"beta\\\".to_string(),\\n        \\\"x86_64-linux\\\".to_string(),\\n    ];\\n\\n    format_sub_version(&name, n_client_version, &comments)\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n    #[test]\\n    #[cfg(not(WINDRES_PREPROC))]\\n    fn sub_version_is_bip14_like() {\\n        let ua = user_agent();\\n        assert!(ua.starts_with('/'));\\n        assert!(ua.ends_with('/'));\\n        assert!(ua.contains(\\\":1.1.2\\\"));\\n        assert!(ua.contains(\\\"(beta; x86_64-linux)\\\"));\\n    }\\n}\\n```\\n\\nThe resulting string will be:\\n\\n```text\\n/bitcoin-rs-node:1.1.2(beta; x86_64-linux)/\\n```\\n\\n---\\n\\n## Copyright Macro\\n\\n### `copyright_str!()`\\n\\nThe crate exposes a macro that expands at compile time to a copyright string driven by environment variables:\\n\\n```rust\\nlet c = bitcoin_version::copyright_str!();\\nprintln!(\\\"{}\\\", c);\\n```\\n\\nThe expansion is effectively:\\n\\n```text\\n\\\"2009-<COPYRIGHT_YEAR> <COPYRIGHT_HOLDERS_FINAL>\\\"\\n```\\n\\nYou must provide the following environment variables at compile time (e.g., via `build.rs` or `RUSTFLAGS`):\\n\\n- `COPYRIGHT_YEAR` \u2013 last year in the copyright range, e.g. `2024`.\\n- `COPYRIGHT_HOLDERS_FINAL` \u2013 holder name, e.g. `bitcoin-rs developers`.\\n\\nThis is useful for producing headers or banners that closely match Bitcoin Core\u2019s legal attributions.\\n\\n---\\n\\n## Logging\\n\\nSeveral functions use structured logging macros like `trace!` and `debug!`. In most setups these originate from the `tracing` crate or a similar logging framework.\\n\\nTo benefit from these logs, ensure that your binary has appropriate logging initialization, for example:\\n\\n```rust\\nfn main() {\\n    // Example with `tracing-subscriber`\\n    tracing_subscriber::fmt::init();\\n\\n    // Use bitcoin-version functionality\\n    #[cfg(not(WINDRES_PREPROC))]\\n    {\\n        let full = bitcoin_version::format_full_version();\\n        tracing::info!(%full, \\\"starting node\\\");\\n    }\\n}\\n```\\n\\nIf you do not initialize logging, the functions still behave correctly; you just lose the diagnostic output.\\n\\n---\\n\\n## Build Configuration and Conditional Compilation\\n\\nSeveral pieces of functionality are gated by `cfg` flags that mirror the C++/Autotools configuration of Bitcoin Core:\\n\\n- `BUILD_GIT_TAG`\\n- `BUILD_GIT_COMMIT`\\n- `GIT_COMMIT_ID`\\n- `CLIENT_VERSION_IS_RELEASE`\\n- `WINDRES_PREPROC`\\n\\nIn a simple standalone usage, you can ignore these and rely on the defaults provided by the crate or workspace. In a more advanced integration, you can define them via `build.rs` and `cargo:rustc-cfg` outputs or via custom build systems to precisely control how version strings are constructed.\\n\\nConceptually:\\n\\n- **Release build**: define `CLIENT_VERSION_IS_RELEASE`, possibly `BUILD_GIT_TAG`, and omit commit IDs.\\n- **Dev build**: do *not* define `CLIENT_VERSION_IS_RELEASE`, but provide `BUILD_GIT_COMMIT` or `GIT_COMMIT_ID`.\\n\\nThe `WINDRES_PREPROC` flag is used to avoid emitting Rust-only constructs into Windows resource preprocessing; when set, the corresponding functions are simply not compiled.\\n\\n---\\n\\n## Integration Pattern\\n\\nA typical integration into a Bitcoin-related Rust binary might look like:\\n\\n```rust\\nuse bitcoin_version::{format_version, copyright_str};\\n\\n#[cfg(not(WINDRES_PREPROC))]\\nuse bitcoin_version::{format_full_version, format_sub_version};\\n\\nfn main() {\\n    #[cfg(not(WINDRES_PREPROC))]\\n    {\\n        let full_version = format_full_version();\\n        let name = \\\"bitcoin-rs-node\\\".to_string();\\n        let n_client_version = 10102;\\n        let comments = vec![\\\"release\\\".to_string()];\\n\\n        let user_agent = format_sub_version(&name, n_client_version, &comments);\\n\\n        println!(\\\"version: {}\\\", full_version);\\n        println!(\\\"user agent: {}\\\", user_agent);\\n    }\\n\\n    let c = copyright_str!();\\n    println!(\\\"copyright: {}\\\", c);\\n}\\n```\\n\\n---\\n\\n## Repository and License\\n\\nThis crate lives in the [`bitcoin-rs` repository](https://github.com/klebs6/bitcoin-rs) and is licensed under the MIT license.\\n\\n---\\n\\n## Caveats\\n\\n- The crate design and behavior are closely tied to the surrounding `bitcoin-rs` workspace and build system. When used outside of that context, ensure your build configuration provides the necessary environment variables and cfg flags, or accept the default behavior.\\n- This documentation has been generated by an AI model. While it is intended to be faithful to the exposed interface and semantics, always consult the source code in the repository as the definitive reference.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"network-programming\",\n      \"development-tools\",\n      \"parsing\",\n      \"mathematics\"\n    ],\n    \"package_description\": \"Versioning utilities and BIP14-compliant sub-version formatting for Bitcoin-related Rust applications, including packed integer version encoding, build metadata integration, and a copyright macro wired to environment variables.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"versioning\",\n      \"bip14\",\n      \"user-agent\",\n      \"build-metadata\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 2622, "completion_tokens": 2776, "total_tokens": 5398, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
