{"id": "batch_req_692cd64169ac8190bae338790f748383", "custom_id": "bitcoin-support-ai-readme-request", "response": {"status_code": 200, "request_id": "b2e493f46f5503865e4c9a6573dad157", "body": {"id": "chatcmpl-ChlKot100K9ZhcZ91wOd8uIx2QtOn", "object": "chat.completion", "created": 1764546094, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-support\",\n    \"full_readme_markdown\": \"# bitcoin-support\\n\\nLow-level support primitives for a Bitcoin node implementation, focusing on:\\n\\n- **Secure memory allocation** for secrets and serialization buffers\\n- **Libevent-compatible opaque handles** with lifetime tracking and zeroization\\n- **Utility functions** for alignment, path uniqueness, and memory cleansing\\n\\nThis crate is a small, security-oriented substrate used by `bitcoin-rs`. It exposes allocators, type aliases, and helper functions rather than a full protocol implementation.\\n\\n> **Note**: This README was generated by an AI model and may not be perfectly synchronized with the current codebase. It should, however, be a close and technically faithful description.\\n\\n---\\n\\n## Design goals\\n\\n- **Security first**: Minimize secret retention in memory by zeroizing on free, and by using `mlock(2)` where available to keep pages resident in RAM.\\n- **Deterministic lifetimes**: Opaque handle types track live instances via `AtomicUsize` counters and overwrite their own representation on drop.\\n- **Interop**: Preserve C ABI signatures where interoperation with `libevent` or C shims is required.\\n- **Portability**: Avoid binding directly to platform-specific networking types; use simple Rust aliases (`EvutilSocket = i32`) and dummy event constructors for higher-level testing and integration.\\n\\n---\\n\\n## Features at a glance\\n\\n### Secure memory allocators\\n\\nTwo primary allocator types are provided:\\n\\n- `SecureAllocator`\\n  - Intended for **long\u2011lived secrets** (keys, passwords, private material).\\n  - Uses `std::alloc::Global` underneath, but on Unix:\\n    - Calls `mlock(2)` to prevent the mapped pages from being swapped out.\\n    - Calls `munlock(2)` on deallocation.\\n  - Calls `memory_cleanse` before returning memory to the global allocator.\\n\\n- `ZeroAfterFreeAllocator`\\n  - Lightweight allocator for general byte buffers.\\n  - Uses the global allocator for allocation, but **securely wipes** contents (via `memory_cleanse`) before free.\\n  - Intended for structs like `SerializeData` that may transiently contain sensitive or protocol\u2011critical bytes.\\n\\nThese allocators implement `std::alloc::Allocator` and can therefore be used with any allocator\u2011aware standard container.\\n\\n#### Provided type aliases\\n\\n```rust\\n/// String stored on a `SecureAllocator` heap.\\npub type SecureString = Box<String, SecureAllocator>;\\n\\n/// Canonical serialization buffer that zeroizes on drop.\\npub type SerializeData = Vec<u8, ZeroAfterFreeAllocator>;\\n```\\n\\n- `SecureString` is functionally analogous to `std::string` with a custom allocator in C++ Bitcoin Core.\\n- `SerializeData` is the canonical buffer type for the bit\u2011stream / serialization layer. When dropped, its underlying allocation is wiped with an optimizer\u2011resistant zeroing routine.\\n\\n### Optimizer\u2011resistant memory cleansing\\n\\n```rust\\n#[instrument(level = \\\"trace\\\", skip(ptr))]\\npub fn memory_cleanse(ptr: *mut c_void, len: usize)\\n```\\n\\n- Performs a byte\u2011wise `write_volatile` loop followed by a `compiler_fence` with `SeqCst` ordering.\\n- Goal: prevent the compiler from eliding apparent dead stores or reordering them such that the buffer is not fully cleared.\\n- This is relevant when handling material such as private keys, HD seeds, or authentication tokens.\\n\\nFrom a memory\u2011model perspective, the combination of `volatile` writes and a fence provides a strong guarantee to the optimizer that the stores are observable side effects and cannot be removed by dead\u2011store elimination.\\n\\n### Libevent\u2011style opaque handles\\n\\nThe crate defines a macro, `declare_event_type!`, which generates opaque, RAII\u2011style event types with:\\n\\n- A unique `id: usize` per instance.\\n- Global live\u2011instance counters (`AtomicUsize`).\\n- Logging on creation and drop using the `tracing` crate.\\n- `Drop` implementations that:\\n  - Log the drop event.\\n  - Call `memory_cleanse` on the struct's memory representation.\\n  - Decrement the live counter.\\n\\nGenerated types include:\\n\\n```rust\\npub struct EventBase { /* opaque */ }\\npub struct LibEvent { /* opaque */ }\\npub struct EvHttp { /* opaque */ }\\npub struct EvHttpRequest { /* opaque */ }\\npub struct EvHttpConnection { /* opaque */ }\\n```\\n\\nAssociated helper functions create boxed instances with tracing instrumentation:\\n\\n```rust\\npub fn obtain_event_base() -> Box<EventBase>;\\n\\npub fn obtain_event(\\n    base:   *mut EventBase,\\n    s:      EvutilSocket,\\n    events: i16,\\n    cb:     Option<EventCallback>,\\n    arg:    *mut c_void,\\n) -> Box<LibEvent>;\\n\\npub fn obtain_evhttp(base: *mut EventBase) -> Box<EvHttp>;\\n\\npub fn obtain_evhttp_request(\\n    cb:  Option<EvHttpRequestCallback>,\\n    arg: *mut c_void,\\n) -> Box<EvHttpRequest>;\\n\\npub fn obtain_evhttp_connection_base(\\n    base: *mut EventBase,\\n    host: &str,\\n    port: u16,\\n) -> Box<EvHttpConnection>;\\n```\\n\\nAt present these constructors largely behave as pure Rust stand\u2011ins (they don't yet drive a real event loop), but they preserve the shape and semantics necessary to plug into or emulate `libevent`\u2011based networking stacks.\\n\\n### Libevent compatibility aliases\\n\\n```rust\\n/// Platform\u2011independent alias for a socket descriptor in libevent.\\npub type EvutilSocket = i32;\\n\\n/// Event callback with C ABI parity.\\npub type EventCallback = unsafe extern \\\"C\\\" fn(*mut LibEvent, *mut c_void);\\n\\npub type EvHttpRequestCallback = unsafe extern \\\"C\\\" fn(*mut EvHttpRequest, *mut c_void);\\n```\\n\\nThese retain exact ABI compatibility with C\u2011side callbacks, which is crucial when linking into an existing `libevent`\u2011driven network reactor or for building FFI shims.\\n\\n### Utility functions\\n\\n#### Alignment\\n\\n```rust\\n#[inline]\\npub fn align_up(x: usize, align: usize) -> usize\\n```\\n\\n- Asserts that `align` is a power of two.\\n- Returns the smallest multiple of `align` greater than or equal to `x`:\\n  \\\\[\\n  \\\\text{align\\\\_up}(x, a) = (x + a - 1) \\\\& \\\\neg(a - 1)\\n  \\\\]\\n- Useful for arena allocators, custom memory pools, and any low\u2011level component that must align blocks to cache line or page boundaries.\\n\\n#### Unique paths\\n\\n```rust\\npub fn get_unique_path(base: &Path) -> PathBuf\\n```\\n\\n- Produces a path of the form `base/<8-hex-chars>`.\\n- Derives the hex component by mixing:\\n  - `SystemTime::now().duration_since(UNIX_EPOCH).as_nanos()`\\n  - The function's own address `get_unique_path as usize` (cast to `u128`)\\n\\nThis is not intended as cryptographically strong randomness, but it provides extremely low collision probability for ephemeral filesystem paths (e.g., temporary directories, per\u2011test scratch areas) without invoking a full PRNG.\\n\\n---\\n\\n## Example usage\\n\\n### Secure strings and serialization buffers\\n\\n```rust\\nuse bitcoin_support::{SecureString, SerializeData};\\n\\nfn handle_secret_input(passphrase: &str) {\\n    // Store secret in RAM backed by SecureAllocator (mlocked on Unix).\\n    let mut s: SecureString = SecureString::default();\\n    s.push_str(passphrase);\\n\\n    // Use SerializeData for transient protocol buffers.\\n    let mut buf: SerializeData = SerializeData::new_in(\\n        bitcoin_support::ZeroAfterFreeAllocator::default(),\\n    );\\n    buf.extend_from_slice(b\\\"some serialized data\\\");\\n\\n    // When `s` and `buf` drop, their memory gets wiped and (on Unix) unlocked.\\n}\\n```\\n\\n### Event handle lifecycle\\n\\n```rust\\nuse bitcoin_support::{\\n    obtain_event_base,\\n    obtain_event,\\n    EvutilSocket,\\n    EventCallback,\\n};\\nuse std::os::raw::c_void;\\n\\nunsafe extern \\\"C\\\" fn on_event(_ev: *mut bitcoin_support::LibEvent, _arg: *mut c_void) {\\n    // handle I/O readiness here\\n}\\n\\nfn setup_dummy_event(sock: EvutilSocket) {\\n    let mut base = obtain_event_base();\\n\\n    let _event = obtain_event(\\n        &mut *base,\\n        sock,\\n        /* events: e.g., EV_READ | EV_PERSIST */ 0,\\n        Some(on_event as EventCallback),\\n        std::ptr::null_mut(),\\n    );\\n\\n    // When `_event` and `base` go out of scope, they are logged and scrubbed.\\n}\\n```\\n\\n### Unique temporary paths\\n\\n```rust\\nuse bitcoin_support::get_unique_path;\\nuse std::path::Path;\\n\\nfn create_temp_dir() {\\n    let base = Path::new(\\\"/tmp/bitcoin-rs-tests\\\");\\n    let unique = get_unique_path(base);\\n    std::fs::create_dir_all(&unique).expect(\\\"failed to create temp dir\\\");\\n\\n    // ... perform I/O in `unique` ...\\n}\\n```\\n\\n---\\n\\n## Tracing and diagnostics\\n\\nThe crate integrates with the `tracing` ecosystem:\\n\\n- Constructors and destructors for event types are instrumented with `#[instrument]` and log via targets such as `\\\"events\\\"` and `\\\"secure_alloc\\\"`.\\n- `memory_cleanse` and allocator methods emit trace\u2011level diagnostics.\\n\\nTo leverage this, install a subscriber, for example:\\n\\n```rust\\nuse tracing_subscriber::FmtSubscriber;\\n\\nfn init_tracing() {\\n    let subscriber = FmtSubscriber::builder()\\n        .with_env_filter(\\\"bitcoin_support=trace\\\")\\n        .finish();\\n    tracing::subscriber::set_global_default(subscriber)\\n        .expect(\\\"setting default subscriber failed\\\");\\n}\\n```\\n\\nThis provides deep visibility into allocation, deallocation, and event handle lifetimes, which is valuable when hunting down resource leaks or verifying that secret data is not being retained unexpectedly.\\n\\n---\\n\\n## Safety and threat model\\n\\n- **Zeroization**: `memory_cleanse` uses volatile stores and fences to mitigate compiler optimizations. It does *not* attempt to defeat all forms of microarchitectural data remanence.\\n- **Locking**: `SecureAllocator` uses `mlock/munlock` on Unix, but failure to lock does not abort allocations; instead it logs a warning, preserving API infallibility while signaling a potential degradation of protection.\\n- **Callbacks**: `EventCallback` and `EvHttpRequestCallback` are `unsafe extern \\\"C\\\"` and must obey C ABI rules. Callers are responsible for ensuring pointer validity and correct lifetime discipline.\\n\\nThis crate should be considered a **building block**: it reduces certain classes of accidental data retention and mis\u2011lifetime, but does not by itself guarantee end\u2011to\u2011end privacy or resistance against powerful physical adversaries.\\n\\n---\\n\\n## License\\n\\nThis crate is distributed under the **MIT** license, as part of the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) project.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"network-programming\",\n      \"memory-management\",\n      \"filesystem\",\n      \"development-tools\"\n    ],\n    \"package_description\": \"Low-level support primitives for bitcoin-rs: secure allocators with mlock+zeroization, libevent-compatible opaque event handles, optimizer-resistant memory cleansing, alignment and unique-path utilities.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"secure-memory\",\n      \"libevent\",\n      \"allocator\",\n      \"serialization\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 4098, "completion_tokens": 2771, "total_tokens": 6869, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
