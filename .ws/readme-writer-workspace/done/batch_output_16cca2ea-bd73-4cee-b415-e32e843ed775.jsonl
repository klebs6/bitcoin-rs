{"id": "batch_req_692cd7264a288190b0077f759706c6d8", "custom_id": "bitcoin-u256-ai-readme-request", "response": {"status_code": 200, "request_id": "dfae64d85fc973564f604c4da3e865b3", "body": {"id": "chatcmpl-ChlOQFMw2aNRq2syrd0VLXHJJPWHR", "object": "chat.completion", "created": 1764546318, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-u256\",\n    \"full_readme_markdown\": \"# bitcoin-u256\\n\\nA minimal, Bitcoin-core\u2013faithful implementation of 256\u2011bit integers and blobs, extracted from the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) project. It provides:\\n\\n* `u256`: an **opaque 256\u2011bit blob** used for block / tx hashes and IDs\\n* `ArithU256`: a **256\u2011bit unsigned big integer** with full arithmetic and bit\u2011ops\\n* Conversions between the two, matching Bitcoin Core\u2019s limb layout and semantics\\n* Bitcoin\u2019s **compact difficulty** encoding/decoding (`nBits`) on top of `ArithU256`\\n* Serde serialization for `u256`\\n\\n> NOTE: This README was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful description of the crate.\\n\\n---\\n\\n## Design overview\\n\\nThis crate mirrors Bitcoin Core\u2019s split between:\\n\\n* `uint256` (here: `u256`): logically a 256\u2011bit **blob**. No arithmetic; just ordering, equality, hashing, byte access, and hex conversions. This corresponds to how block and transaction hashes are usually modelled: as 32\u2011byte identifiers rather than numeric values.\\n* `arith_uint256` (here: `ArithU256`): a 256\u2011bit **unsigned integer** represented internally as 8 32\u2011bit limbs with full arithmetic and bitwise operations. This is used for difficulty computations, work calculations, etc.\\n\\nThe separation keeps identifier semantics distinct from arithmetic semantics, which is important in Bitcoin where endianness and representation details frequently cause bugs.\\n\\nBoth types are thin wrappers around internal `BaseBlob256` / `BaseUInt256` primitives exposed by the parent project. The public API is intentionally close to Bitcoin Core\u2019s C++ interfaces so that porting logic from upstream is nearly mechanical.\\n\\n\\n## Endianness model\\n\\nThe key concept to internal correctness here is **limb endianness**.\\n\\n* `ArithU256` stores its value as 8 32\u2011bit limbs: `pn[0] .. pn[7]`.\\n* The conversion functions `arith_to_uint256` and `uint_to_arith256` write/read each 32\u2011bit limb in **little\u2011endian** order into/from the 32\u2011byte `u256` buffer.\\n\\nMathematically, a 256\u2011bit unsigned integer\\n\\n\\\\[\\nN = \\\\sum_{i=0}^{7} \\\\text{limb}_i \\\\cdot 2^{32 i}\\n\\\\]\\n\\nis represented internally by `BaseUInt256` as `limb_i = pn[i]`. The mapping to the 32\u2011byte `u256` is then:\\n\\n\\\\[\\n\\\\text{bytes}[4i..4i+4] = \\\\text{LE32}(\\\\text{limb}_i).\\n\\\\]\\n\\nThis exactly matches Bitcoin Core\u2019s encoding and is critical for correctness when computing difficulty or work from consensus data.\\n\\nAdditionally, `u256::from_le_bytes` performs a full 32\u2011byte reversal before delegating to `from_bytes_32`, because `BaseBlob` uses a big\u2011endian internal representation of the hex string, while Bitcoin often publishes hashes as little\u2011endian numbers. This inversion matches upstream\u2019s behaviour.\\n\\n\\n## Core types\\n\\n### `u256`: 256\u2011bit opaque blob\\n\\n```rust\\n#[derive(Getters, Default, Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\\n#[getset(get = \\\"pub\\\")]\\n#[allow(non_camel_case_types)]\\npub struct u256 {\\n    blob: BaseBlob256,\\n}\\n``\\n\\n**Characteristics:**\\n\\n* Exactly 32 bytes\\n* Totally ordered (`Ord`), hashable (`Hash`), clonable (`Clone`), send + sync\\n* Implements `Default` (all zero), `Debug`, `Display` (hex), `Serialize`, and `Deserialize`\\n* Exposes multiple byte views:\\n  * `as_slice(&self) -> &[u8]`\\n  * `as_slice_mut(&mut self) -> &mut [u8]`\\n  * `as_slice_exact(&self) -> &[u8; 32]`\\n  * `as_mut_slice_exact(&mut self) -> &mut [u8; 32]`\\n\\n**Helpers / constructors:**\\n\\n```rust\\nimpl u256 {\\n    pub fn zero() -> Self;           // all 0s\\n    pub fn one() -> Self;            // least-significant byte = 1\\n    pub fn byte_len(&self) -> usize; // always 32\\n\\n    pub fn is_null(&self) -> bool;\\n    pub fn set_null(&mut self);\\n\\n    pub fn to_string(&self) -> String;        // hex (big-endian style)\\n    pub fn from_bytes_32(arr: [u8; 32]) -> Self;\\n    pub fn from_le_bytes(le: [u8; 32]) -> Self; // reverses before storing\\n\\n    pub fn get_uint64(&self, index: usize) -> u64; // 0 <= index < 4, little-endian limbs\\n    pub fn low64(&self) -> u64;                   // lower 64 bits, little-endian\\n}\\n\\nimpl From<&[u8; 32]> for u256 { /* via AsRef */ }\\nimpl From<&Vec<u8>> for u256;    // panics if len != 32\\nimpl From<u8> for u256;\\nimpl From<*const u8> for u256;   // hex-encoded C string\\nimpl From<&String> for u256;     // hex string\\nimpl From<&str> for u256;        // hex string\\n```\\n\\n### `ArithU256`: 256\u2011bit unsigned big integer\\n\\n```rust\\n#[derive(Default, Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]\\npub struct ArithU256 {\\n    base: BaseUInt256,\\n}\\n```\\n\\n`ArithU256` models a 256\u2011bit integer with full arithmetic and logic operations. It supports:\\n\\n* Addition, subtraction, multiplication, division:\\n  * `Add`, `AddAssign` with `&ArithU256` and `u64`\\n  * `Sub`, `SubAssign` with `&ArithU256` and `u64`\\n  * `Mul`, `MulAssign` with `u32`, `i64`, `u64`, `&ArithU256`\\n  * `Div`, `DivAssign` with `u32`, `i64`, `&ArithU256`\\n* Bitwise operations:\\n  * `BitAnd`, `BitAndAssign` with `ArithU256`, `&ArithU256`, `u64`\\n  * `BitOr`, `BitOrAssign` with `ArithU256`, `&ArithU256`, `u64`\\n  * `BitXor`, `BitXorAssign` with `ArithU256`, `&ArithU256`, `u64`\\n  * `Not` (bitwise complement)\\n* Shift operations:\\n  * `Shl<u32>`, `ShlAssign<u32>`\\n  * `Shr<u32>`, `ShrAssign<u32>`\\n* Negation:\\n  * `Neg` implemented as modular negation modulo 2\u00b2\u2075\u2076 via two\u2019s complement (`~x + 1`).\\n\\nAdditional helpers:\\n\\n```rust\\nimpl ArithU256 {\\n    pub fn low64(&self) -> u64;\\n    pub fn get_limb(&self, index: usize) -> u32;       // 0 <= index < limb_count\\n    pub fn get_hex(&self) -> String;                   // big-endian hex\\n    pub fn size_in_bytes(&self) -> usize;              // usually 32\\n    pub fn getdouble(&self) -> f64;                    // lossy > ~53 bits\\n\\n    pub fn set_compact(\\n        &mut self,\\n        n_compact: u32,\\n        pf_negative: *mut bool,\\n        pf_overflow: *mut bool,\\n    ) -> &mut ArithU256;\\n\\n    pub fn get_compact(&self, negative: Option<bool>) -> u32;\\n}\\n\\nimpl From<&BaseUInt256> for ArithU256;\\nimpl From<u64> for ArithU256;\\nimpl From<&str> for ArithU256;   // hex string\\n```\\n\\n#### Compact difficulty format\\n\\n`set_compact` and `get_compact` encode/decode Bitcoin\u2019s **compact target representation** as used in `nBits`:\\n\\n* `n_compact` is a 32\u2011bit unsigned integer with the layout:\\n  * `[31:24]` \u2013 exponent (number of bytes of the target)\\n  * `[23:0]`  \u2013 mantissa\\n  * bit 23 (0x0080_0000) \u2013 sign bit\\n\\nThe effective target `N` is:\\n\\n\\\\[\\nN = (-1)^{\\\\text{sign}} \\\\cdot \\\\text{mantissa} \\\\cdot 256^{\\\\text{exponent} - 3}.\\n\\\\]\\n\\nThis matches the C++ implementation in Bitcoin Core, including overflow rules and negative flag handling. The implementation avoids going through OpenSSL / MPI and instead manipulates limbs directly, which is both simpler and faster in pure Rust.\\n\\n\\n## Conversions between `u256` and `ArithU256`\\n\\nTwo conversion functions provide a precise bridge between the blob and arithmetic worlds:\\n\\n```rust\\npub fn arith_to_uint256(a: &ArithU256) -> u256;\\npub fn uint_to_arith256(a: &u256) -> ArithU256;\\n```\\n\\n* `arith_to_uint256`:\\n  * Takes each 32\u2011bit limb from `ArithU256::base` via `get_limb(i)`\\n  * Converts it to 4 little\u2011endian bytes and writes them into the `u256` slice at offset `4*i`\\n* `uint_to_arith256`:\\n  * Reads 4\u2011byte chunks from the `u256` slice, interprets them as little\u2011endian `u32`, and stores them as limbs via `set_limb(i, val)`\\n\\nIn pseudocode, for `i = 0..7`:\\n\\n```text\\nu256[4*i..4*i+4] = LE32(ArithU256.limb[i])\\n```\\n\\nThis is exactly the logic used in upstream Bitcoin Core. When porting any consensus or difficulty\u2011related code, you can assume this mapping.\\n\\n\\n## CheckpointData\\n\\n```rust\\npub type MapCheckpoints = HashMap<i32, u256>;\\n\\n#[derive(Default)]\\npub struct CheckpointData {\\n    map_checkpoints: MapCheckpoints,\\n}\\n\\nimpl CheckpointData {\\n    /// Return the highest (final) checkpoint height.\\n    pub fn get_height(&self) -> i32 { /* ... */ }\\n}\\n```\\n\\nThis struct models a simple mapping from block height to checkpoint hashes (`u256`). It supports:\\n\\n* `map_checkpoints`: `HashMap<i32, u256>` containing height \u2192 block hash\\n* `get_height()`: returns the maximum height present (0 if empty), mirroring C++ `mapCheckpoints.rbegin()->first`.\\n\\nThis is primarily useful when constructing chain parameters or validating that a given chain tip is beyond a known checkpoint.\\n\\n\\n## Serde integration\\n\\n`u256` implements `serde::Serialize` and `serde::Deserialize`:\\n\\n* Serialized as raw bytes (`serialize_bytes`) using the internal layout (32 bytes).\\n* Deserialized from a byte slice which must be exactly 32 bytes.\\n\\nThis is appropriate for binary protocols or persistence layers where you want the canonical fixed\u2011width representation. If you need hex string encoding, wrap `u256` in your own newtype with a custom serializer, or use `to_string()` / `From<&str>` at your API boundary.\\n\\n\\n## Trait implementations for `u256`\\n\\n`u256` is wired for ergonomic use as a low\u2011level blob:\\n\\n* `Default` \u2013 all zeros\\n* `Debug` \u2013 `u256(<hex>)`\\n* `Display` \u2013 hex string\\n* `Clone`, `Copy` (by manual clone), `Eq`, `Ord`, `Hash`\\n* `AsRef<[u8]>`, `AsMut<[u8]>` \u2013 borrow as `[u8]`\\n* `AsRef<[u8; 32]>`, `AsMut<[u8; 32]>` \u2013 exact length view\\n* `Send`, `Sync` \u2013 safe to move/share between threads\\n\\nThis makes `u256` suitable as a key in maps, inclusion in network messages, and use in any crypto or protocol\u2011level context that expects a 32\u2011byte identifier.\\n\\n\\n## Usage examples\\n\\nAdd to `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-u256 = \\\"0.1.19\\\"\\n```\\n\\n### Constructing and inspecting `u256`\\n\\n```rust\\nuse bitcoin_u256::u256;\\n\\n// From a hex string (big-endian representation)\\nlet h = u256::from(\\\"0000000000000000000b4d0d2c5b1f...\\\");\\n\\n// From literal bytes\\nlet raw: [u8; 32] = [0u8; 32];\\nlet id = u256::from_bytes_32(raw);\\n\\n// Check zero / one helpers\\nassert!(u256::zero().is_null());\\nassert_eq!(u256::one().low64(), 1);\\n\\n// Hex display\\nprintln!(\\\"block hash = {}\\\", h);\\n\\n// Access as bytes\\nlet bytes: &[u8] = h.as_ref();\\nassert_eq!(bytes.len(), 32);\\n```\\n\\n### Using `ArithU256` for difficulty math\\n\\n```rust\\nuse bitcoin_u256::{ArithU256, arith_to_uint256, uint_to_arith256};\\n\\n// From a hex target\\nlet mut target = ArithU256::from(\\\"00000000FFFF0000000000000000000000000000000000000000000000000000\\\");\\n\\n// Multiply by 2\\ntarget <<= 1;\\n\\n// Convert to blob for storage / wire format\\nlet target_blob = arith_to_uint256(&target);\\n\\n// Later, restore arithmetic form\\nlet target_again = uint_to_arith256(&target_blob);\\nassert_eq!(target, target_again);\\n```\\n\\n### Working with compact difficulty (`nBits`)\\n\\n```rust\\nuse bitcoin_u256::ArithU256;\\n\\n// Example compact representation from a block header\\nlet n_bits: u32 = 0x1d00ffff; // Bitcoin mainnet genesis\\n\\nlet mut target = ArithU256::default();\\nlet mut negative = false;\\nlet mut overflow = false;\\n\\n// SAFETY: we pass valid pointers to local flags\\nlet target_ref = unsafe {\\n    target.set_compact(\\n        n_bits,\\n        &mut negative as *mut bool,\\n        &mut overflow as *mut bool,\\n    )\\n};\\n\\nassert!(!negative);\\nassert!(!overflow);\\n\\n// Convert back to compact for round-trip check\\nlet n_bits_roundtrip = target_ref.get_compact(Some(false));\\nassert_eq!(n_bits_roundtrip, n_bits);\\n```\\n\\n### Checkpoints\\n\\n```rust\\nuse std::collections::HashMap;\\nuse bitcoin_u256::{u256, CheckpointData, MapCheckpoints};\\n\\nlet mut cps: MapCheckpoints = HashMap::new();\\n\\ncps.insert(11111, u256::from(\\\"0000000069e244f73c...\\\"));\\ncps.insert(33333, u256::from(\\\"00000000000291ce28...\\\"));\\n\\nlet data = CheckpointData { map_checkpoints: cps };\\n\\nassert_eq!(data.get_height(), 33333);\\n```\\n\\n\\n## Safety and panics\\n\\nThis crate is relatively low\u2011level and makes several assumptions:\\n\\n* `u256::from(&Vec<u8>)` panics if the input length is not exactly 32 bytes.\\n* Several operations use `assert!` to enforce index bounds (e.g., `get_uint64(index)` requires `index < 4`).\\n* Some conversions (e.g. `MulAssign<i64>`, `DivAssign<i64>`) assume non\u2011negative arguments and will panic if negative values are passed.\\n* `from_le_bytes` assumes the array is exactly 32 bytes (enforced by type system).\\n\\nIn performance\u2011sensitive or consensus\u2011critical code, you should validate inputs at API boundaries before invoking these operations.\\n\\n\\n## When to use this crate\\n\\nUse `bitcoin-u256` when you need:\\n\\n* A **Bitcoin\u2011compatible** 256\u2011bit integer layer for:\\n  * Difficulty / target computation\\n  * Work calculations\\n  * Compact target (`nBits`) encoding/decoding\\n* A faithful **translation of Bitcoin Core\u2019s `uint256` / `arith_uint256` semantics** in Rust\\n* Zero\u2011cost access to internal bytes with consistent endianness mechanics\\n\\nIf you only need a generic 256\u2011bit integer without Bitcoin\u2019s nuanced encoding/endianness rules, more general big\u2011integer crates might be more appropriate. This crate is tailored specifically to Bitcoin\u2011style 256\u2011bit operations.\\n\\n\\n## License\\n\\nThis crate is distributed under the MIT license, as declared in `Cargo.toml`.\\n\\nSource repository: <https://github.com/klebs6/bitcoin-rs>\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"mathematics\",\n      \"science\",\n      \"development-tools\"\n    ],\n    \"package_description\": \"Bitcoin-core\u2013compatible 256-bit blob (`u256`) and arithmetic integer (`ArithU256`) types with limb-level conversions, compact difficulty (nBits) encoding, checkpoints, and serde integration.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"u256\",\n      \"bigint\",\n      \"difficulty\",\n      \"crypto\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 9487, "completion_tokens": 4160, "total_tokens": 13647, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
