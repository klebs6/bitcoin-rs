{"id": "batch_req_692cddb975a88190835a1734ea9ffd7e", "custom_id": "bitcoin-sha256-sse41-ai-readme-request", "response": {"status_code": 200, "request_id": "081bfb792be07bfd297541df43fd5069", "body": {"id": "chatcmpl-Chlpapmk45JkM5zCMqcA2ziikSKZp", "object": "chat.completion", "created": 1764548002, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-sha256-sse41\",\n    \"full_readme_markdown\": \"# bitcoin-sha256-sse41\\n\\nHighly specialized SHA-256 double-hash (sha256d) transform for Bitcoin workloads, vectorized with SSE4.1 and designed to process four 64-byte message blocks in parallel.\\n\\n> Disclaimer: this README.md was generated by an AI model. It may not be perfectly accurate or complete, but it should be a solid starting point. Inspect the source and tests before using this crate in production.\\n\\n---\\n\\n## Overview\\n\\nThis crate exposes a low-level, `unsafe`-oriented implementation of the Bitcoin-style double SHA-256 compression function, tuned for x86-64 CPUs with SSE4.1.\\n\\nConceptually, the implementation follows the standard SHA-256 compression function as defined in FIPS 180-4, but organizes the state into 128-bit SIMD registers (`__m128i`) so that four independent message streams are processed in lockstep (\\\"4-way\\\" SIMD). This matches highly parallel Bitcoin mining or block verification workloads where the same midstate is reused across many candidate nonces.\\n\\nThe core entry point is:\\n\\n```rust\\npub fn sha256d64_sse41_transform_4way(out: *mut u8, in_: *const u8)\\n```\\n\\nThis performs:\\n\\n1. A first SHA-256 compression on 4 \u00d7 64-byte inputs.\\n2. A second SHA-256 compression over the resulting 4 \u00d7 32-byte digests plus padding (the standard Bitcoin `sha256d` construction).\\n\\nIt is intentionally close to a direct port of the corresponding C++ SSE4.1 routine used in high-performance Bitcoin implementations.\\n\\n**Important properties:**\\n\\n- **Throughput over ergonomics:** The API is pointer-based and expects preformatted input. There is no allocation, buffering, or incremental hasher abstraction.\\n- **SIMD parallelism:** Uses 128-bit SIMD lanes (`__m128i`) to process 4 parallel message blocks.\\n- **Deterministic arithmetic:** Operations are limited to bitwise logic and 32-bit integer arithmetic, which is deterministic across compliant x86-64 implementations.\\n- **SSE4.1 dependency:** The implementation relies on SSE4.1 intrinsics (`_mm_set1_epi32`, `_mm_shuffle_epi8`, etc.). Running this on hardware without SSE4.1 is undefined.\\n\\nThis crate targets expert consumers building custom Bitcoin mining kernels, high-throughput block/transaction verification engines, or cryptographic research prototypes where full control over layout and scheduling is desired.\\n\\n---\\n\\n## When should you use this crate?\\n\\nUse this crate if you:\\n\\n- Need **maximum throughput** for Bitcoin-style double SHA-256 on x86-64.\\n- Can orchestrate work in batches of 4 parallel inputs.\\n- Are comfortable managing `unsafe` pointers and CPU feature detection yourself.\\n\\nYou probably do *not* want this crate if you only need a conventional, ergonomic SHA-256 hash API. For that, see crates like `sha2` or `bitcoin_hashes`.\\n\\n---\\n\\n## Safety and prerequisites\\n\\nThis crate is fundamentally low-level. You must uphold the following invariants:\\n\\n- The CPU must support **SSE4.1**.\\n- Pointers passed to the API must be valid for the required number of bytes and correctly aligned for `u32` loads/stores (the code is written as if 32-bit loads/stores are safe).\\n- You must ensure that buffers do not alias in ways that break the algorithm's assumptions.\\n\\nA typical program should:\\n\\n1. Detect SSE4.1 support (e.g., via `is_x86_feature_detected!(\\\"sse4.1\\\")`).\\n2. Dispatch to `sha256d64_sse41_transform_4way` only when it is available.\\n3. Provide correctly sized and aligned input/output buffers.\\n\\n---\\n\\n## Cryptographic background\\n\\n### SHA-256 compression\\n\\nSHA-256 operates on 512-bit (64-byte) message blocks. For each block, it maintains eight 32-bit state words \\\\(a, b, c, d, e, f, g, h\\\\). Each compression consists of 64 rounds structured as\\n\\n\\\\[\\n\\\\begin{aligned}\\nT_1 &= h + \\\\Sigma_1(e) + \\\\operatorname{Ch}(e,f,g) + K_t + W_t,\\\\\\\\\\nT_2 &= \\\\Sigma_0(a) + \\\\operatorname{Maj}(a,b,c),\\n\\\\end{aligned}\\n\\\\]\\n\\nfollowed by a state rotation. Here:\\n\\n- `Ch(x,y,z) = (x \\\\land y) \\\\oplus (\\\\neg x \\\\land z)` (choose)\\n- `Maj(x,y,z) = (x \\\\land y) \\\\oplus (x \\\\land z) \\\\oplus (y \\\\land z)` (majority)\\n- \\\\(\\\\Sigma_0, \\\\Sigma_1\\\\) and the lower-case \\\\(\\\\sigma_0, \\\\sigma_1\\\\) are bitwise rotate/shift-based functions.\\n- `K_t` is a fixed round constant, and `W_t` is the message schedule.\\n\\n### Bitcoin `sha256d`\\n\\nBitcoin uses **double SHA-256** (`sha256d`):\\n\\n1. Compute \\\\(h_1 = \\\\text{SHA256}(m)\\\\).\\n2. Compute \\\\(h_2 = \\\\text{SHA256}(h_1)\\\\).\\n\\nThis crate implements a fused, batch-optimized variant of this composition, specialized to 4 parallel 64-byte input blocks and their 4 resulting 32-byte double-hashes.\\n\\n---\\n\\n## API\\n\\nThe public surface is deliberately minimal and low-level. It consists of two layers:\\n\\n1. **Top-level transform**: one function that performs the complete double SHA-256 on four 64-byte inputs.\\n2. **SIMD intrinsics wrappers**: a set of helper functions modeling the arithmetic and bitwise operations in terms of `__m128i`. These are useful if you want to extend or inspect the internal pipeline.\\n\\n### Core transform\\n\\n```rust\\npub fn sha256d64_sse41_transform_4way(out: *mut u8, in_: *const u8)\\n```\\n\\n#### Semantics\\n\\n- Interprets `in_` as a contiguous buffer of **4 \u00d7 64** bytes.\\n- Computes Bitcoin `sha256d` for each of the four 64-byte blocks in parallel.\\n- Writes the resulting 4 \u00d7 32-byte digests into `out`, laid out contiguously.\\n\\nA natural layout is:\\n\\n- Input: `[block0[0..64], block1[0..64], block2[0..64], block3[0..64]]` (256 bytes total).\\n- Output: `[hash0[0..32], hash1[0..32], hash2[0..32], hash3[0..32]]` (128 bytes total).\\n\\nThe actual endianness and layout should be verified against tests and the internal `read4`/`write4` routines, which use `_mm_shuffle_epi8` to normalize to big-endian word order as defined by SHA-256.\\n\\n#### Safety\\n\\nThis function is `unsafe`-equivalent even if not marked as such, because it accepts raw pointers. You must guarantee:\\n\\n- `in_` points to at least 4 \u00d7 64 = 256 readable bytes.\\n- `out` points to at least 4 \u00d7 32 = 128 writable bytes.\\n- Both buffers are valid for the duration of the call and correctly aligned for 32-bit access.\\n- The pointers do not alias in a way that violates Rust's aliasing rules for simultaneous read/write.\\n\\nIn idiomatic Rust, you would typically expose a safe wrapper in your own crate that internally calls this function via `unsafe`.\\n\\n---\\n\\n### SIMD helper functions\\n\\nAll helper functions operate on `__m128i`, where each lane represents a 32-bit word from one of the 4 parallel message streams.\\n\\n- `k(x: u32) -> __m128i`: Broadcast a 32-bit constant into all 4 lanes.\\n- `add(...) -> __m128i`: 2-, 3-, 4-, and 5-operand vector addition with 32-bit lanewise wraparound.\\n- `inc(x: &mut __m128i, ...) -> __m128i`: In-place increment of `x` by one or more other vectors; returns the updated value.\\n- `xor`, `or`, `and`: Standard bitwise operations on 4 lanes in parallel.\\n- `shr`, `shl`: Logical right/left shifts of each 32-bit lane.\\n- `ch(x, y, z) -> __m128i`: Implements the SHA-256 choose function in SIMD.\\n- `maj(x, y, z) -> __m128i`: Implements the SHA-256 majority function in SIMD.\\n\\nThere are two groups of sigma functions:\\n\\n- *Uppercase* `sigma0`, `sigma1` (often denoted \\\\(\\\\Sigma_0, \\\\Sigma_1\\\\) in the specification) defined via rotations at positions `(2, 13, 22)` and `(6, 11, 25)` respectively.\\n- *Lowercase* `sigma0`, `sigma1` (the message-schedule sigmas) defined via rotations and shifts at `(7,18)`/`>>3` and `(17,19)`/`>>10` respectively.\\n\\nThe transform uses these for:\\n\\n- Evolving the message schedule `W_t` via `Inc` calls.\\n- Computing `T1` and `T2` in each `round` step.\\n\\nThe `round` function implements one iteration of the SHA-256 main loop with eight state words distributed across SIMD lanes:\\n\\n```rust\\npub fn round(\\n    a: __m128i,\\n    b: __m128i,\\n    c: __m128i,\\n    d: &mut __m128i,\\n    e: __m128i,\\n    f: __m128i,\\n    g: __m128i,\\n    h: &mut __m128i,\\n    k: __m128i,\\n)\\n```\\n\\nHere each parameter represents 4 parallel values of the corresponding scalar variable.\\n\\n---\\n\\n### Input/output packing: `read4` and `write4`\\n\\n```rust\\npub fn read4(chunk: *const u8, offset: i32) -> __m128i\\n```\\n\\n- Loads 4 \u00d7 32-bit words from 4 different 64-byte blocks at the same byte offset.\\n- Uses `_mm_set_epi32` with `ReadLE32` on four locations, then `_mm_shuffle_epi8` to normalize endianness.\\n\\nConceptually:\\n\\n- Lane 0: word from block 0 at `offset`.\\n- Lane 1: word from block 1 at `64 + offset`.\\n- Lane 2: word from block 2 at `128 + offset`.\\n- Lane 3: word from block 3 at `192 + offset`.\\n\\n```rust\\npub fn write4(out: *mut u8, offset: i32, v: __m128i)\\n```\\n\\n- Inverse operation of `read4`: reorders bytes via `_mm_shuffle_epi8` and serializes each 32-bit lane to the appropriate output location using `WriteLE32`.\\n\\nThe effect is that `sha256d64_sse41_transform_4way` internally works in a layout optimized for 4-way SIMD while still presenting a straightforward contiguous layout at the API boundary.\\n\\n---\\n\\n## Example usage\\n\\nA minimal, *unsafe* example assuming you have four 64-byte pre-padded blocks (for illustration; real Bitcoin headers are not pre-padded like this):\\n\\n```rust\\nuse core::arch::x86_64::__m128i;\\n\\nextern \\\"Rust\\\" {\\n    fn sha256d64_sse41_transform_4way(out: *mut u8, in_: *const u8);\\n}\\n\\nfn main() {\\n    // 4 blocks \u00d7 64 bytes\\n    let mut input = [0u8; 4 * 64];\\n    // Fill input[0..64], input[64..128], input[128..192], input[192..256]\\n\\n    let mut output = [0u8; 4 * 32];\\n\\n    unsafe {\\n        // In production, check is_x86_feature_detected!(\\\"sse4.1\\\") first\\n        sha256d64_sse41_transform_4way(output.as_mut_ptr(), input.as_ptr());\\n    }\\n\\n    // output now contains 4 \u00d7 32-byte sha256d digests\\n}\\n```\\n\\nIn a real application you will typically:\\n\\n- Reuse the input and output buffers over many invocations to amortize allocation cost.\\n- Use a separate, scalar path for odd counts of inputs or for CPUs without SSE4.1.\\n- Integrate this into a higher-level Bitcoin hashing abstraction that deals with padding, endianness, and header construction.\\n\\n---\\n\\n## Performance considerations\\n\\n### Vectorization model\\n\\nBy mapping 4 independent SHA-256 streams into SIMD lanes, the implementation:\\n\\n- Avoids branch divergence: all four streams execute the same instruction sequence.\\n- Maximizes arithmetic intensity: multiple independent additions, rotates, and logical operations are carried out in single instructions.\\n- Exploits the fact that Bitcoin `sha256d` has very regular structure.\\n\\nThe cost is that you are constrained to work in multiples of 4 inputs per call, or accept that some SIMD lanes may be wasted if you pad with dummy data.\\n\\n### Microarchitectural notes\\n\\n- The implementation is intended for modern x86-64 cores with efficient SSE4.1 execution units.\\n- Register pressure is non-trivial. The staged organization into three transforms (first hash, midstate, second hash) reduces live state.\\n- The shuffles in `read4`/`write4` and the rotate emulation via shifts and ORs are designed to minimize latency while keeping dependencies manageable.\\n\\nFor precise performance characteristics, benchmark on your target CPUs with realistic workloads (e.g., candidate header sets for mining, or block/transaction verification pipelines).\\n\\n---\\n\\n## Integration guidance\\n\\n### CPU feature dispatch\\n\\nYou should gate use of this crate behind runtime feature detection, and optionally compile-time configuration:\\n\\n```rust\\n#[cfg(target_arch = \\\"x86_64\\\")]\\nfn sha256d64_4way(out: &mut [u8; 4 * 32], input: &[u8; 4 * 64]) {\\n    assert!(is_x86_feature_detected!(\\\"sse4.1\\\"));\\n    unsafe {\\n        bitcoin_sha256_sse41::sha256d64_sse41_transform_4way(\\n            out.as_mut_ptr(),\\n            input.as_ptr(),\\n        );\\n    }\\n}\\n```\\n\\nYou can then fall back to a portable implementation when SSE4.1 is not available.\\n\\n### Endianness and Bitcoin specifics\\n\\n- Bitcoin serializes block headers as little-endian fields, but SHA-256 operates on big-endian 32-bit words.\\n- This crate mirrors the standard Bitcoin C++ SSE4.1 path where `read4` and `write4` perform the necessary byte reordering.\\n\\nValidate correctness by comparing against a reference implementation on well-known test vectors (e.g., genesis block header hash, random headers, and adversarial patterns).\\n\\n---\\n\\n## Build, edition, license\\n\\n- **Edition:** Rust 2024\\n- **Minimum Rust:** The intent is to work with stable Rust for x86-64 with `core::arch::x86_64`, though actual MSRV may depend on your toolchain; validate in CI.\\n- **License:** MIT\\n\\nAdd to your `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-sha256-sse41 = \\\"0.1.1\\\"\\n```\\n\\nThen import and call the functions from your own higher-level abstractions.\\n\\n---\\n\\n## Status\\n\\nAt the time of writing, parts of the code are annotated with `todo!()` and the README is AI-generated. Treat the crate as **experimental**:\\n\\n- Audit the implementation carefully before deployment.\\n- Add comprehensive tests comparing against known-good scalar implementations for a broad corpus of inputs.\\n- Benchmark across your target CPUs and workloads.\\n\\nContributions that refine correctness proofs, extend tests, and provide measured performance data are particularly valuable.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"network-programming\",\n      \"science\",\n      \"performance\"\n    ],\n    \"package_description\": \"SSE4.1-accelerated 4-way Bitcoin-style double SHA-256 (sha256d) transform on x86-64, exposing low-level SIMD primitives for high-throughput hashing workloads.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"sha256\",\n      \"sse4.1\",\n      \"simd\",\n      \"hashing\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 11736, "completion_tokens": 3875, "total_tokens": 15611, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
