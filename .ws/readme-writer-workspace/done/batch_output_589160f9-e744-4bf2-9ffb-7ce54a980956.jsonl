{"id": "batch_req_692cd8de13548190968f116b4ea6b65b", "custom_id": "bitcoin-golombrice-ai-readme-request", "response": {"status_code": 200, "request_id": "fea748ee7aeadda97e82ccbd36c623f8", "body": {"id": "chatcmpl-ChlVXo3kE8vYQAjStTKCz1hiaoqAa", "object": "chat.completion", "created": 1764546759, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-golombrice\",\n    \"full_readme_markdown\": \"# bitcoin-golombrice\\n\\nA minimal, BIP\u2011158\u2013oriented implementation of Golomb\u2011Rice coding and Golomb\u2011coded sets (GCS) for Bitcoin compact block filters.\\n\\n> NOTE: This README was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful description of the crate.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-golombrice` implements the core primitives required for [BIP\u2011158](https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki) Golomb\u2011coded filters:\\n\\n- **Golomb\u2011Rice scalar codec**\\n  - `golomb_rice_encode` \u2013 bit\u2011level encoder over an arbitrary `Write`.\\n  - `golomb_rice_decode` \u2013 bit\u2011level decoder over an arbitrary `Read`.\\n- **GCSFilter** \u2013 a compact, probabilistic set representation for membership tests with tunable false\u2011positive rate.\\n- **GcsFilterParams** \u2013 filter parameterization (SipHash keys, Golomb parameter `p`, and scaling factor `m`).\\n\\nThe implementation is aimed at interoperability with Bitcoin Core\u2019s `GCSFilter` (parameterization and serialization layout), making it suitable for SPV/light\u2011client workflows and Bitcoin indexers.\\n\\nThe crate focuses on:\\n\\n- Close tracking of the BIP\u2011158 construction.\\n- Deterministic encoding/decoding via bit\u2011precise I/O.\\n- Efficient membership checks with predictable false\u2011positive bounds.\\n\\n## Core Concepts\\n\\n### Golomb\u2011Rice coding\\n\\nA non\u2011negative integer \\\\( x \\\\) is mapped to a pair \\\\((q, r)\\\\):\\n\\n- \\\\( q = \\\\lfloor x / 2^p \\\\rfloor \\\\) \u2013 quotient\\n- \\\\( r = x \\\\bmod 2^p \\\\) \u2013 remainder (\\\\(p\\\\) bits)\\n\\nEncoding:\\n\\n1. Write `q` as *unary* code: `q` ones followed by a zero.\\n2. Write `r` as `p` raw bits.\\n\\nDecoding inverts this process. This is exactly what\\n\\n```rust\\npub fn golomb_rice_encode<OStream>(\\n    bitwriter: &mut BitStreamWriter<OStream>,\\n    p: u8,\\n    x: u64,\\n) where\\n    OStream: Default + Write\\n{ /* \u2026 */ }\\n\\npub fn golomb_rice_decode<IStream>(\\n    bitreader: &mut BitStreamReader<IStream>,\\n    p: u8,\\n) -> u64\\nwhere\\n    IStream: Default + Read\\n{ /* \u2026 */ }\\n```\\n\\nimplements. The parameter `p` trades off code length and quotient distribution. BIP\u2011158 uses a fixed `p` per filter type.\\n\\n### Golomb\u2011coded sets (GCS)\\n\\nA GCS over domain elements \\\\(E\\\\) uses:\\n\\n- A keyed hash \\\\( h: E \\\\rightarrow [0, f) \\\\), implemented here via SipHash with keys `siphash_k0`, `siphash_k1`.\\n- Sorting of hashed values and Golomb\u2011Rice coding of their **deltas**.\\n\\nMembership queries are probabilistic:\\n\\n- If `match_` / `match_any` returns `false`, the element is *definitely not* in the set.\\n- If it returns `true`, the element is in the set **or** it is a false positive with probability bounded by \\\\(1/m\\\\).\\n\\nBIP\u2011158 chooses `m` to obtain a target false\u2011positive rate (e.g. \\\\(1/784931\\\\) for block filters).\\n\\n---\\n\\n## Data Types\\n\\n```rust\\npub type GcsFilterElement = Vec<u8>;\\n\\npub type GcsFilterElementSet = std::collections::HashSet<GcsFilterElement, ByteVectorHash>;\\n```\\n\\nElements are arbitrary byte vectors; the set requires a `ByteVectorHash` hasher (typically a byte\u2011wise hash over `Vec<u8>` to use as `HashSet` key).\\n\\n### `GcsFilterParams`\\n\\n```rust\\n#[derive(Debug, Clone, Getters, Builder)]\\n#[builder(setter(into), default)]\\n#[getset(get = \\\"pub\\\")]\\npub struct GcsFilterParams {\\n    siphash_k0: u64,\\n    siphash_k1: u64,\\n    p:          u8,\\n    m:          u32,\\n}\\n```\\n\\n- `siphash_k0`, `siphash_k1`: SipHash\u20112\u20114 keys used to hash elements to `[0, n * m)`.\\n- `p`: Golomb\u2011Rice parameter (number of remainder bits).\\n- `m`: scaling factor; false\u2011positive probability is ~`1 / m`.\\n\\nConstruction:\\n\\n```rust\\nimpl GcsFilterParams {\\n    pub fn new(\\n        siphash_k0: Option<u64>,\\n        siphash_k1: Option<u64>,\\n        p:          Option<u8>,\\n        m:          Option<u32>,\\n    ) -> Self { /* \u2026 */ }\\n}\\n\\nimpl Default for GcsFilterParams { /* \u2026 */ }\\n```\\n\\n`new` mirrors the C++ `GCSFilter::Params` constructor: each argument is optional, with defaults `(0, 0, 0, 1)` for `(k0, k1, p, m)`.\\n\\nUsing the derived builder:\\n\\n```rust\\nuse bitcoin_golombrice::GcsFilterParamsBuilder;\\n\\nlet params = GcsFilterParamsBuilder::default()\\n    .siphash_k0(0x1234_5678_9abc_def0)\\n    .siphash_k1(0xfedc_ba98_7654_3210)\\n    .p(20u8)\\n    .m(784_931u32)\\n    .build()\\n    .unwrap();\\n```\\n\\n### `GCSFilter`\\n\\n```rust\\n#[derive(Builder, Debug, Clone, Getters, Default)]\\n#[getset(get = \\\"pub\\\")]\\n#[builder(setter(into))]\\npub struct GCSFilter {\\n    params:  GcsFilterParams,\\n    n:       u32,\\n    f:       u64,\\n    encoded: Vec<u8>,\\n}\\n```\\n\\n- `params`: filter parameterization.\\n- `n`: element count in the set.\\n- `f`: equal to `n as u64 * m as u64`; hash range upper bound.\\n- `encoded`: serialized form, starting with Bitcoin CompactSize `n`, followed by Golomb\u2011Rice encoded deltas.\\n\\nHelper accessors:\\n\\n```rust\\nimpl GCSFilter {\\n    pub fn getn(&self) -> u32 { /* \u2026 */ }\\n    pub fn get_params(&self) -> &GcsFilterParams { /* \u2026 */ }\\n    pub fn get_encoded(&self) -> &Vec<u8> { /* \u2026 */ }\\n}\\n```\\n\\nA `From<Option<GcsFilterParams>>` implementation allows constructing an *empty* filter encoding `CompactSize(0)` with chosen or default parameters:\\n\\n```rust\\nlet filter: GCSFilter = None::<GcsFilterParams>.into();\\nassert_eq!(filter.getn(), 0);\\n```\\n\\n---\\n\\n## Creating Filters\\n\\n### From an element set\\n\\n```rust\\nimpl GCSFilter {\\n    /// Build a filter from a concrete element set.\\n    pub fn new_with_element_set(\\n        params: &GcsFilterParams,\\n        elements: &GcsFilterElementSet,\\n    ) -> Self { /* \u2026 */ }\\n}\\n```\\n\\nUsage example:\\n\\n```rust\\nuse std::collections::HashSet;\\nuse bitcoin_golombrice::{\\n    GCSFilter,\\n    GcsFilterParams,\\n    GcsFilterElement,\\n    GcsFilterElementSet,\\n};\\n\\nfn build_filter(params: &GcsFilterParams) -> GCSFilter {\\n    let mut set: GcsFilterElementSet = HashSet::default();\\n\\n    let key1: GcsFilterElement = b\\\"scriptpubkey-1\\\".to_vec();\\n    let key2: GcsFilterElement = b\\\"scriptpubkey-2\\\".to_vec();\\n\\n    set.insert(key1);\\n    set.insert(key2);\\n\\n    GCSFilter::new_with_element_set(params, &set)\\n}\\n```\\n\\nSemantics:\\n\\n1. Compute `n = elements.len()`, `f = n * m`.\\n2. Serialize `CompactSize(n)`.\\n3. Hash each element via SipHash with `siphash_k0`, `siphash_k1` into `[0, f)`.\\n4. Sort the hashed values, delta\u2011encode them, then Golomb\u2011Rice encode each delta with parameter `p`.\\n\\n### From an already\u2011encoded filter\\n\\n```rust\\nimpl GCSFilter {\\n    pub fn new_with_encoded_filter(\\n        params: &GcsFilterParams,\\n        encoded_filter: Vec<u8>,\\n    ) -> Self { /* \u2026 */ }\\n}\\n```\\n\\nThis constructor validates consistency:\\n\\n- Decodes `CompactSize(n)`.\\n- Replays Golomb\u2011Rice decoding for `n` values.\\n- Ensures no surplus bytes remain (`panic!`s otherwise).\\n\\nUseful when you obtain the encoded filter from the network or from Bitcoin Core and want a typed wrapper and query interface.\\n\\n---\\n\\n## Membership Queries\\n\\n### Hashing into the filter range\\n\\n```rust\\nimpl GCSFilter {\\n    /// Hash a data element to an integer in the range [0, N * M).\\n    pub fn hash_to_range(&self, element: &GcsFilterElement) -> u64 { /* \u2026 */ }\\n\\n    pub fn build_hashed_set(\\n        &self,\\n        elements: &GcsFilterElementSet,\\n    ) -> Vec<u64> { /* \u2026 */ }\\n}\\n```\\n\\n- `hash_to_range` applies keyed SipHash and projects into `[0, f)` via `map_into_range`.\\n- `build_hashed_set` hashes all elements, reserves capacity, and sorts.\\n\\n### Single\u2011element membership\\n\\n```rust\\nimpl GCSFilter {\\n    /// Checks if the element may be in the set.\\n    /// False positives are possible with probability 1/M.\\n    pub fn match_(&self, element: &GcsFilterElement) -> bool { /* \u2026 */ }\\n}\\n```\\n\\nUsage:\\n\\n```rust\\nlet element: GcsFilterElement = b\\\"scriptpubkey-1\\\".to_vec();\\nif filter.match_(&element) {\\n    // Element is either present or a false positive.\\n}\\n```\\n\\n### Multi\u2011element membership (batched)\\n\\n```rust\\nimpl GCSFilter {\\n    /// Checks if any of the given elements may be in the set.\\n    /// False positives are possible with probability 1/M per element.\\n    /// More efficient than calling `match_` repeatedly.\\n    pub fn match_any(&self, elements: &GcsFilterElementSet) -> bool { /* \u2026 */ }\\n}\\n```\\n\\nThis path hashes and sorts queries once, then streams through the encoded filter via `match_internal` using a classic two\u2011pointer merge technique.\\n\\nExample:\\n\\n```rust\\nlet mut queries: GcsFilterElementSet = HashSet::default();\\nqueries.insert(b\\\"candidate-1\\\".to_vec());\\nqueries.insert(b\\\"candidate-2\\\".to_vec());\\n\\nif filter.match_any(&queries) {\\n    // At least one query may match the filter.\\n}\\n```\\n\\n### Unsafe, pointer\u2011based core matcher\\n\\n```rust\\nimpl GCSFilter {\\n    pub fn match_internal(&self, element_hashes: *const u64, size: usize) -> bool { /* \u2026 */ }\\n}\\n```\\n\\n`match_internal` operates on a raw pointer to a sorted array of query hashes and performs a streaming comparison against the decoded delta sequence. It:\\n\\n- Reads `n` from the prefix.\\n- Iteratively decodes deltas using `golomb_rice_decode`.\\n- Maintains a cumulative `value` and an index `idx` into the query array.\\n- Returns early when it finds a match or when the query sequence is exhausted.\\n\\nFor most use cases, prefer `match_` and `match_any`, which wrap this safely.\\n\\n---\\n\\n## Serialization and Interop\\n\\nThe filter encoding layout matches Bitcoin Core\u2019s `GCSFilter`:\\n\\n1. `CompactSize(n)` \u2013 encoded with `write_compact_size` / `read_compact_size` helpers.\\n2. Golomb\u2011Rice encoded deltas of sorted hashes.\\n\\nThis makes the crate suitable for interoperating with:\\n\\n- Block filters (`basic`, `extended`) as defined in BIP\u2011158.\\n- External Bitcoin libraries that expect the exact same wire format.\\n\\nThe implementation uses `VectorReader` / `VectorWriter` and `BitStreamReader` / `BitStreamWriter` abstractions from the surrounding codebase (`bitcoin-rs`) to guarantee bit\u2011accurate encoding.\\n\\n---\\n\\n## Parameter Selection and False Positives\\n\\nLet:\\n\\n- \\\\( n \\\\) = number of elements in the filter\\n- \\\\( m \\\\) = scaling factor in `GcsFilterParams`\\n- \\\\( f = n \\\\cdot m \\\\) = hash range size\\n\\nThen:\\n\\n- Each element is hashed uniformly into `[0, f)` (modulo SipHash properties and `map_into_range`).\\n- BIP\u2011158\u2019s analysis shows a per\u2011query false\u2011positive probability approximately `1 / m`.\\n\\nOperational guidance:\\n\\n- Choose `m` large enough for your acceptable false\u2011positive rate.\\n- Choose `p` to balance:\\n  - Code length (larger `p` yields shorter unary quotient, longer remainder).\\n  - Decoding CPU cost (more bits per value vs more unary runs).\\n\\nFor exact Bitcoin filter parameters, mirror the constants from BIP\u2011158 or from Bitcoin Core\u2019s implementation and feed them into `GcsFilterParams`.\\n\\n---\\n\\n## Safety and Panics\\n\\nThis crate uses a few invariants:\\n\\n- `new_with_encoded_filter` will `panic!` if the encoded filter contains trailing data beyond what decoding `n` elements consumes.\\n- `new_with_element_set` and parameter constructors assume `n < 2^32` (enforced via `try_from`).\\n- `match_internal` is `unsafe` in spirit (raw pointer input), though its signature is safe; incorrect `element_hashes` / `size` will cause undefined behavior. Use the safe wrappers instead.\\n\\nWhen integrating into production systems, ensure that untrusted filters are validated at higher layers or handled with error propagation if you adapt this code.\\n\\n---\\n\\n## Example End\u2011to\u2011End Flow\\n\\n```rust\\nuse std::collections::HashSet;\\nuse bitcoin_golombrice::{\\n    GCSFilter,\\n    GcsFilterParams,\\n    GcsFilterElement,\\n    GcsFilterElementSet,\\n};\\n\\nfn main() {\\n    // 1. Define parameters (example values; use BIP\u2011158 constants for Bitcoin deployment).\\n    let params = GcsFilterParams::new(\\n        Some(0x1234_5678_9abc_def0),\\n        Some(0xfedc_ba98_7654_3210),\\n        Some(20),        // p\\n        Some(784_931),   // m \u2013 target false positive rate ~ 1/784931\\n    );\\n\\n    // 2. Build an element set.\\n    let mut elems: GcsFilterElementSet = HashSet::default();\\n    elems.insert(b\\\"elem-1\\\".to_vec());\\n    elems.insert(b\\\"elem-2\\\".to_vec());\\n\\n    // 3. Construct the filter.\\n    let filter = GCSFilter::new_with_element_set(&params, &elems);\\n\\n    // 4. Serialize to bytes (e.g., for network transmission or storage).\\n    let encoded = filter.get_encoded().clone();\\n\\n    // 5. Reconstruct a filter from bytes.\\n    let filter2 = GCSFilter::new_with_encoded_filter(&params, encoded);\\n\\n    // 6. Query membership.\\n    let q: GcsFilterElement = b\\\"elem-1\\\".to_vec();\\n    assert!(filter2.match_(&q));\\n}\\n```\\n\\n---\\n\\n## License and Repository\\n\\n- **License:** MIT\\n- **Repository:** <https://github.com/klebs6/bitcoin-rs>\\n\\nThis crate is part of a broader Bitcoin\u2011related Rust codebase. Consult the repository for example usage, integration points, and parameter constants matching Bitcoin Core.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"network-programming\",\n      \"science\"\n    ],\n    \"package_description\": \"BIP-158 compatible Golomb-Rice encoder/decoder and Golomb-coded set (GCS) implementation for Bitcoin compact block filters, with keyed SipHash-based hashing and bit-precise serialization.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"golomb-rice\",\n      \"bip158\",\n      \"compact-filters\",\n      \"gcs\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 4433, "completion_tokens": 3991, "total_tokens": 8424, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
