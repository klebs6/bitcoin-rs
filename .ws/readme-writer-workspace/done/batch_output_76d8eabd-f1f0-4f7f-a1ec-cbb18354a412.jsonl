{"id": "batch_req_692ce83a008c8190a6146dc365677806", "custom_id": "bitcoinleveldb-logwriter-ai-readme-request", "response": {"status_code": 200, "request_id": "daafd2d3a9a31a7686985ff3c13f8408", "body": {"id": "chatcmpl-ChmWvg9k7MUEtlypVEtT9ooFpzV6X", "object": "chat.completion", "created": 1764550689, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoinleveldb-logwriter\",\n    \"full_readme_markdown\": \"# bitcoinleveldb-logwriter\\n\\nA faithful, low-level implementation of the LevelDB log writer as used in Bitcoin-oriented storage backends. This crate focuses on deterministic fragmentation of logical records into physical log records, block-based layout, and CRC32C integrity, exposing a small but precise surface area suitable for consensus-critical environments.\\n\\n> NOTE: This README was generated by an AI model. It may not be perfectly accurate in every detail, but it should be a close, technically sensible description of the crate.\\n\\n## Overview\\n\\n`bitcoinleveldb-logwriter` implements the write half of the LevelDB log format. It is designed to be used as the append-only WAL (write-ahead log) layer for higher-level key\u2013value stores or state machines, particularly where reproducibility and binary compatibility with existing LevelDB-style logs is required.\\n\\nKey properties:\\n\\n- Fixed-size **blocks** of size `LOG_BLOCK_SIZE` bytes (typical LevelDB value: 32 KiB).\\n- Each physical record has a **7-byte header** (`LOG_HEADER_SIZE`), composed of:\\n  - 4 bytes: little-endian masked CRC32C of the record type and payload.\\n  - 2 bytes: little-endian payload length.\\n  - 1 byte: record type (FULL, FIRST, MIDDLE, LAST).\\n- Arbitrary-length logical records are **fragmented** across one or more physical records.\\n- CRC32C is computed with per-type seeds (`type_crc`) and then masked (as in upstream LevelDB) to reduce risk of embedded length/CRC confusion.\\n- Safe public API, with internal use of `unsafe` only for pointer-to-slice bridging and foreign CRC primitives.\\n\\nThe crate is intended primarily as a **building block**: a log writer that can be wired into a Bitcoin/LevelDB-compatible storage engine, custom databases, or replication layers.\\n\\n## Core Types\\n\\n### `LogWriter`\\n\\n```rust\\n#[derive(Builder)]\\n#[builder(setter(into))]\\npub struct LogWriter {\\n    dest:         Rc<RefCell<dyn WritableFile>>,\\n    block_offset: i32,\\n    type_crc:     [u32; LOG_MAX_RECORD_TYPE as usize + 1],\\n}\\n```\\n\\n`LogWriter` owns the logic for writing LevelDB-format log records into an abstract `WritableFile` sink. Block alignment, header construction, CRC computation, and record fragmentation are all handled internally.\\n\\nThe `dest` is reference-counted and interior-mutably borrowed using `Rc<RefCell<..>>` so that a single underlying file-like object can be shared across multiple components if desired.\\n\\n### `MockWritableFile*`\\n\\nThree mock file implementations are provided for testing and integration harnesses:\\n\\n- `MockWritableFileCore`\\n- `MockWritableFileAddRecord`\\n- `MockWritableFileEmit`\\n\\nAll of them store written bytes in an in-memory `Vec<u8>` and implement various `WritableFile*` traits (`WritableFileAppend`, `WritableFileFlush`, `WritableFileClose`, `WritableFileSync`, and the combined `WritableFile`).\\n\\n`MockWritableFileAddRecord` and `MockWritableFileEmit` additionally support deterministic fault injection via `fail_append_after`, allowing you to test error handling paths in `LogWriter`.\\n\\n## Public API\\n\\nBelow is a condensed guide to the major methods. Many functions are `pub` primarily to assist deterministic testing and allow explicit control in advanced users.\\n\\n### Construction\\n\\n```rust\\nimpl LogWriter {\\n    /// Create a writer that will append data to `*dest`.\\n    ///\\n    /// `*dest` must have initial length `dest_length`.\\n    /// `*dest` must remain live while this LogWriter is in use.\\n    pub fn new(dest: Rc<RefCell<dyn WritableFile>>, dest_length: u64) -> Self;\\n}\\n```\\n\\n`new` initializes the block offset based on the existing length of the destination file and precomputes the per-record-type CRC seeds:\\n\\n- `initial_block_offset_from_length(dest_length)` computes `dest_length % LOG_BLOCK_SIZE`.\\n- `build_type_crc_table()` invokes `init_type_crc` to fill `type_crc` with the CRC over the one-byte record type tags.\\n\\n### Adding logical records\\n\\n```rust\\nimpl LogWriter {\\n    /// Add a logical record, fragmenting it into one or more physical records.\\n    pub fn add_record(&mut self, slice: &Slice) -> Status;\\n}\\n```\\n\\n`add_record` is the main entry point. It accepts a `Slice` view of arbitrary length and writes it as one or more physical records:\\n\\n- If the record fits into the remaining space of the current block, a single `FULL` record is written.\\n- Otherwise, the record is split into a sequence of `FIRST`, zero or more `MIDDLE`, and a final `LAST` fragment.\\n\\nInternally, `add_record` delegates to:\\n\\n```rust\\npub fn add_record_internal(&mut self, slice: &Slice) -> Status;\\n```\\n\\n`add_record_internal` performs a loop that:\\n\\n1. Checks whether there is room left for at least a header using `should_start_new_block`.\\n2. If not, calls `write_trailer_padding_if_necessary` to emit zero-padding in the block trailer and resets the block offset.\\n3. Computes the available data capacity in the current block via `block_available_data_bytes`.\\n4. Determines the fragment length (`fragment_length`) and fragment record type using `choose_record_fragment_type(begin, end)`.\\n5. Calls `emit_physical_record` with the fragment.\\n\\nThe loop terminates once the payload has been fully consumed or a write error is returned.\\n\\n### Emitting physical records\\n\\n```rust\\nimpl LogWriter {\\n    pub fn emit_physical_record(\\n        &mut self,\\n        t:      LogRecordType,\\n        ptr:    *const u8,\\n        length: usize,\\n    ) -> Status;\\n}\\n```\\n\\n`emit_physical_record` is responsible for writing a single physical record into the current block:\\n\\n1. Validates the record length (`validate_record_length`) \u2014 must fit into a 16-bit field (`<= 0xffff`).\\n2. Ensures that the header + payload fits into the current block (`validate_record_fits_in_block`).\\n3. Computes CRC32C via `crc32c_for_record`.\\n4. Builds the header with `build_record_header`.\\n5. Delegates to `append_header_and_payload` to perform the actual writes and flush.\\n6. Advances `block_offset` by `LOG_HEADER_SIZE + length` using `advance_block_offset`.\\n\\n### Header construction & CRC\\n\\n```rust\\nimpl LogWriter {\\n    /// Compute the CRC32C for the given record type and payload, including masking.\\n    pub fn crc32c_for_record(\\n        &self,\\n        t:      LogRecordType,\\n        ptr:    *const u8,\\n        length: usize,\\n    ) -> u32;\\n\\n    /// Build the physical record header for the given type, length and CRC.\\n    pub fn build_record_header(\\n        &self,\\n        t:      LogRecordType,\\n        length: usize,\\n        crc:    u32,\\n    ) -> [u8; LOG_HEADER_SIZE as usize];\\n}\\n```\\n\\nThe CRC is computed as:\\n\\n```text\\nextended_crc = crc32c_extend(type_crc[t], payload_ptr, payload_len)\\nmasked_crc   = crc32c_mask(extended_crc)\\n```\\n\\nThis matches LevelDB\u2019s scheme, where `type_crc[t]` is the CRC of the single-byte record type tag, and `crc32c_mask` applies a bit-rotation and constant XOR to decorrelate the CRC space.\\n\\nThe header layout (indices are byte positions):\\n\\n- `buf[0..4]`: masked CRC32C, little-endian, written via `encode_fixed32`.\\n- `buf[4]`: low byte of length.\\n- `buf[5]`: high byte of length.\\n- `buf[6]`: `LogRecordType` discriminant as `u8`.\\n\\n### Block management\\n\\n```rust\\nimpl LogWriter {\\n    /// Remaining bytes in the current block.\\n    pub fn block_trailer_bytes_remaining(&self) -> i32;\\n\\n    /// Bytes available for payload in the current block, after accounting for the header.\\n    pub fn block_available_data_bytes(&self) -> usize;\\n\\n    /// Whether we need to start a new block because the remaining bytes are too\\n    /// small to hold a header.\\n    pub fn should_start_new_block(&self) -> bool;\\n\\n    /// Write zero-padding in the current block trailer if there are leftover bytes\\n    /// that are too small for a header, then reset the block offset to zero.\\n    pub fn write_trailer_padding_if_necessary(&mut self) -> Status;\\n}\\n```\\n\\nLevelDB\u2019s log format guarantees that there are never fewer than `LOG_HEADER_SIZE` bytes left unused in a block. If the remaining trailer is too short to hold a header, it is zero-padded and the next record begins at offset 0 of the next block.\\n\\n`write_trailer_padding_if_necessary` appends a small zero-filled trailer (up to 6 bytes in the provided implementation, due to `LOG_HEADER_SIZE == 7`) and then resets `block_offset` to 0.\\n\\n### Fragment type selection\\n\\n```rust\\nimpl LogWriter {\\n    /// Choose the physical record type for the current fragment.\\n    pub fn choose_record_fragment_type(begin: bool, end: bool) -> LogRecordType;\\n}\\n```\\n\\nMapping:\\n\\n- `(true, true)`   \u2192 `LogRecordType::Full`\\n- `(true, false)`  \u2192 `LogRecordType::First`\\n- `(false, false)` \u2192 `LogRecordType::Middle`\\n- `(false, true)`  \u2192 `LogRecordType::Last`\\n\\nThis logic is key for reconstructing logical records during replay.\\n\\n### Accessors & validation\\n\\n```rust\\nimpl LogWriter {\\n    pub fn type_crc_for(&self, record_type: LogRecordType) -> u32;\\n    pub fn dest_handle(&self) -> &Rc<RefCell<dyn WritableFile>>;\\n\\n    pub fn block_offset_value(&self) -> i32;\\n    pub fn set_block_offset_value(&mut self, value: i32);\\n    pub fn advance_block_offset(&mut self, delta: i32);\\n\\n    pub fn validate_record_length(&self, length: usize);\\n    pub fn validate_record_fits_in_block(&self, length: usize);\\n\\n    pub fn build_type_crc_table() -> [u32; LOG_MAX_RECORD_TYPE as usize + 1];\\n    pub fn initial_block_offset_from_length(dest_length: u64) -> i32;\\n}\\n```\\n\\nThese methods primarily exist to facilitate careful testing, custom integration, and invariant reasoning. `validate_record_fits_in_block` asserts that `block_offset + LOG_HEADER_SIZE + length <= LOG_BLOCK_SIZE` and panics if violated, which helps catch logic errors in block management.\\n\\n## Mock Writable Files\\n\\nAll mock files share a common pattern:\\n\\n```rust\\n#[derive(Getters)]\\n#[getset(get = \\\"pub\\\")]\\npub struct MockWritableFileCore {\\n    buffer: Vec<u8>,\\n}\\n\\nimpl MockWritableFileCore {\\n    pub fn new() -> Self { Self { buffer: Vec::new() } }\\n    pub fn recorded_bytes(&self) -> &[u8] { &self.buffer }\\n}\\n\\nimpl WritableFileAppend for MockWritableFileCore { /* append into buffer */ }\\nimpl WritableFileFlush  for MockWritableFileCore { /* no-op */ }\\nimpl WritableFileClose  for MockWritableFileCore { /* no-op */ }\\nimpl WritableFileSync   for MockWritableFileCore { /* no-op */ }\\nimpl WritableFile       for MockWritableFileCore {}\\n```\\n\\n`MockWritableFileAddRecord` and `MockWritableFileEmit` extend this with counters and fault injection:\\n\\n```rust\\npub struct MockWritableFileAddRecord {\\n    buffer:            Vec<u8>,\\n    fail_append_after: Option<usize>,\\n    append_call_count: usize,\\n    flush_call_count:  usize,\\n    close_call_count:  usize,\\n    sync_call_count:   usize,\\n}\\n\\nimpl MockWritableFileAddRecord {\\n    pub fn new() -> Self { /* ... */ }\\n    pub fn with_fail_append_after(call_index: usize) -> Self { /* ... */ }\\n    pub fn recorded_bytes(&self) -> &[u8] { &self.buffer }\\n}\\n```\\n\\nThe `append` implementation increments `append_call_count` and, if `fail_append_after` is set and the threshold is reached, returns a deterministic `Status::io_error`. This is extremely useful for verifying that `add_record` and `emit_physical_record` propagate I/O failures correctly without corrupting invariants.\\n\\nAll mocks also implement a `Named` trait, returning a stable identifier string (e.g. `\\\"mock_writable_file_add_record\\\"`), which simplifies logging and diagnostics.\\n\\n## Example Usage\\n\\n### Basic in-memory logging\\n\\n```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nuse bitcoinleveldb_logwriter::{\\n    LogWriter,\\n    MockWritableFileCore,\\n};\\nuse bitcoinleveldb_core::{Slice, WritableFile}; // hypothetical external traits\\n\\nfn main() {\\n    // Prepare an in-memory destination file.\\n    let dest = Rc::new(RefCell::new(MockWritableFileCore::new()));\\n\\n    // Existing file length is zero in this example.\\n    let mut writer = LogWriter::new(dest.clone(), 0);\\n\\n    // Construct a logical payload.\\n    let payload = b\\\"hello, leveldb-style log\\\";\\n    let slice   = Slice::from_ptr_len(payload.as_ptr(), payload.len());\\n\\n    // Append the logical record.\\n    let status = writer.add_record(&slice);\\n    assert!(status.is_ok());\\n\\n    // Inspect the on-disk (here: in-memory) bytes.\\n    let bytes = dest.borrow().recorded_bytes();\\n    println!(\\\"total bytes written: {}\\\", bytes.len());\\n}\\n```\\n\\n### Testing error handling with fault injection\\n\\n```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nuse bitcoinleveldb_logwriter::{\\n    LogWriter,\\n    MockWritableFileAddRecord,\\n};\\nuse bitcoinleveldb_core::Slice;\\n\\n#[test]\\nfn add_record_stops_on_append_error() {\\n    let dest = Rc::new(RefCell::new(\\n        MockWritableFileAddRecord::with_fail_append_after(1),\\n    ));\\n\\n    let mut writer = LogWriter::new(dest.clone(), 0);\\n\\n    let big_payload = vec![0u8; 64 * 1024]; // large enough to fragment\\n    let slice = Slice::from_ptr_len(big_payload.as_ptr(), big_payload.len());\\n\\n    let status = writer.add_record(&slice);\\n    assert!(!status.is_ok());\\n\\n    let dest_ref = dest.borrow();\\n    assert_eq!(dest_ref.append_call_count(), 1); // injection point\\n}\\n```\\n\\nThese examples assume an external crate or module that exposes `Slice`, `Status`, and the `WritableFile*` traits referenced by this crate. The patterns shown remain valid independent of their concrete definitions, as long as they match the interface used here.\\n\\n## Error Handling & Status\\n\\nAll write operations return a `Status` value, which is treated as a fallible result but not the standard `Result<T, E>` type. This matches the LevelDB lineage, where `Status` encodes I/O and corruption information compactly.\\n\\n- Methods such as `append_header_and_payload` and `write_trailer_padding_if_necessary` always propagate the `Status` they receive from `WritableFile::append` / `flush`.\\n- Logging calls (`trace!`, `debug!`, `info!`, `error!`) are used to annotate the path taken and aid in root-cause analysis; they do not affect control flow.\\n\\nWhen integrating into a larger system, you will typically map `Status` into your own error type or propagate it up unchanged.\\n\\n## Mathematical & Systems Considerations\\n\\n### Block arithmetic\\n\\nThe writer reasons about block boundaries using simple modular arithmetic:\\n\\n- For initial offsets:\\n\\n  ```text\\n  block_offset = (dest_length mod LOG_BLOCK_SIZE) as i32\\n  ```\\n\\n  This ensures that resumes from partially written files respect existing block boundaries without rewriting the prefix.\\n\\n- Available payload in the current block:\\n\\n  ```text\\n  available = LOG_BLOCK_SIZE - block_offset - LOG_HEADER_SIZE\\n  ```\\n\\n  This quantity is always non-negative when `should_start_new_block()` returns `false`, and it constitutes an invariant that is asserted in `validate_record_fits_in_block`.\\n\\n### Fragmentation invariants\\n\\nLet `L` be the length of a logical record and `B` be `block_available_data_bytes` at the start of a fragment. The loop in `add_record_internal` repeatedly sets:\\n\\n```text\\nfragment_len = min(left, B)\\n```\\n\\nand then updates:\\n\\n```text\\nleft := left - fragment_len\\n```\\n\\nso that across all fragments, the sum of payload lengths equals `L`. Combined with the header size and block capacity constraints, this yields a tiling of the log file into disjoint valid physical records and occasional zero-padded trailers.\\n\\n### CRC32C correctness\\n\\nThe CRC design follows the standard LevelDB approach:\\n\\n1. Precompute `type_crc[t] = CRC32C([t as u8])` for all `t`.\\n2. For each record, compute `extended = crc32c_extend(type_crc[t], payload)`, which is equivalent to CRC over `[t_byte || payload]` but more efficient.\\n3. Mask the final CRC using `crc32c_mask` to minimize accidental alignment of data and control information.\\n\\nThis allows a reader to recalculate the CRC for each record and detect bit flips or partial writes.\\n\\n## Integration Notes\\n\\n- **Threading model**: `LogWriter` uses `Rc<RefCell<..>>`, which fits single-threaded or externally synchronized contexts. For multi-threaded writers, wrap it in your own synchronization or adapt the internals to `Arc<Mutex<..>>` if you fork the crate.\\n- **Unsafe**: All `unsafe` operations are localized to `Slice` interop and FFI-backed CRC primitives. The public surface remains safe under the documented invariants (e.g., valid lifetimes of `Slice` and underlying memory).\\n- **Compatibility**: If your goal is binary compatibility with Bitcoin Core\u2019s LevelDB fork or upstream LevelDB, ensure that your constants (`LOG_BLOCK_SIZE`, `LOG_HEADER_SIZE`, record type enum) and CRC masking functions are identical.\\n\\n## License, Edition, and Metadata\\n\\n- **Crate name**: `bitcoinleveldb-logwriter`\\n- **Version**: `0.1.1`\\n- **Rust edition**: `2024`\\n- **License**: MIT\\n- **Authors**: `YourName <you@example.com>`\\n\\nThis crate is intended for production-grade systems that require precise control over log layout, but it is also suitable as a reference implementation or test fixture for any LevelDB-style log reader or storage engine.\\n\",\n    \"package_categories\": [\n      \"database\",\n      \"database-implementations\",\n      \"algorithms\",\n      \"science\",\n      \"development-tools\"\n    ],\n    \"package_description\": \"Low-level LevelDB-compatible log writer for Bitcoin-oriented storage engines, providing block-based fragmentation, CRC32C-protected physical records, and in-memory mock WritableFile implementations for deterministic testing.\",\n    \"package_keywords\": [\n      \"leveldb\",\n      \"bitcoin\",\n      \"log-writer\",\n      \"wal\",\n      \"storage\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 6878, "completion_tokens": 4535, "total_tokens": 11413, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
