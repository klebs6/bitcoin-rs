{"id": "batch_req_692cdb9332408190b6d8a42e0c8c3aab", "custom_id": "bitcoin-crc32c-ai-readme-request", "response": {"status_code": 200, "request_id": "e195cb2f4bc03ec1619eb4425bd8ce25", "body": {"id": "chatcmpl-ChlgnEjXJh4I1nm3h49c6jBqmcJhV", "object": "chat.completion", "created": 1764547457, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-crc32c\",\n    \"full_readme_markdown\": \"# bitcoin-crc32c\\n\\nHigh-performance CRC32C (Castagnoli polynomial) for Rust, with runtime-dispatched SIMD backends (x86_64 SSE4.2 and AArch64 CRC+PMULL) and a portable, bit-correct fallback. Designed for workloads that continuously validate or authenticate byte streams, such as blockchains, storage engines, and network protocols.\\n\\n> Note: This README.md was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful approximation of the crate's intent and API.\\n\\n---\\n\\n## Features\\n\\n- **CRC32C (Castagnoli) polynomial**: \\\\(0x1EDC6F41\\\\) with standard initialization/finalization (XOR with `0xFFFF_FFFF`).\\n- **Runtime CPU feature dispatch**:\\n  - x86_64: SSE4.2-accelerated implementation using `_mm_crc32_*` intrinsics.\\n  - AArch64: CRC32 + PMULL-accelerated implementation using `__crc32c*` and polynomial merging in GF(2).\\n  - All other targets: optimized portable scalar implementation.\\n- **Zero-copy pointer-based API** for maximal control and minimal overhead.\\n- **Safe convenience wrappers** for `&str` and for extending an existing CRC accumulator.\\n- **Cache-aware prefetching** and alignment helpers for high throughput on large buffers.\\n- **Deterministic, bit-exact output** across platforms.\\n\\nThis crate is particularly suitable for systems code (e.g., Bitcoin node implementations, storage/index structures) where CRC32C is used as a fast integrity check over large, frequently accessed byte ranges.\\n\\n---\\n\\n## Core concepts\\n\\nCRC32C computes a 32\u2011bit checksum over a byte sequence using arithmetic over the finite field \\\\(\\\\mathbb{F}_2\\\\). The implementation leverages the following principles:\\n\\n- **Polynomial representation**: A byte stream is viewed as coefficients of a polynomial over \\\\(\\\\mathbb{F}_2\\\\). Division by a fixed generator polynomial yields the CRC remainder.\\n- **Extension property**: Given CRC of prefix \\\\(P\\\\), one can efficiently compute the CRC of \\\\(P || S\\\\) without reprocessing \\\\(P\\\\). This crate exposes that extension primitive (`crc32c_extend`).\\n- **Vectorization and parallel segments**:\\n  - SSE4.2/AArch64-CRC instructions directly update the CRC state per 8/4/2/1 bytes.\\n  - Large buffers are partitioned into blocks that are processed in parallel (e.g., `crc0`\u2026`crc3`) and then merged using precomputed GF(2) multiplication tables and skip tables.\\n- **Alignment and prefetching**: The algorithms align to 8- or 4-byte boundaries and prefetch future data to hide memory latency.\\n\\nThese techniques converge to a design well-suited for sustained multi-GB/s CRC computation on modern CPUs.\\n\\n---\\n\\n## Installation\\n\\nAdd to your `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-crc32c = \\\"0.1.19\\\"\\n```\\n\\nThis crate targets Rust **2021** edition and is licensed under **MIT**.\\n\\n---\\n\\n## High-level API\\n\\nFor most use cases, you want the safe, dispatching helpers.\\n\\n### CRC of a raw buffer (unsafe)\\n\\n```rust\\nuse bitcoin_crc32c::crc32c_value;\\n\\nfn crc_of_slice(bytes: &[u8]) -> u32 {\\n    unsafe { crc32c_value(bytes.as_ptr(), bytes.len()) }\\n}\\n```\\n\\n- Uses the best available backend (SSE4.2, AArch64-CRC, or portable) chosen at runtime.\\n- `data` must be valid for `count` bytes; otherwise behavior is undefined.\\n\\n### CRC of a string (safe)\\n\\n```rust\\nuse bitcoin_crc32c::crc32c_with_str;\\n\\nlet checksum = crc32c_with_str(\\\"hello world\\\");\\n```\\n\\n- Computes CRC32C over the UTF\u20118 bytes of the string.\\n- Internally dispatches to the optimal backend.\\n\\n### Short-hand pointer API (unsafe)\\n\\n```rust\\nuse bitcoin_crc32c::crc32c;\\n\\nlet buf: &[u8] = b\\\"example\\\";\\nlet crc = unsafe { crc32c(buf.as_ptr(), buf.len()) };\\n```\\n\\n`crc32c` is equivalent to `crc32c_value` and exists primarily for parity with C-style interfaces.\\n\\n### Extending an existing CRC (streaming)\\n\\nThe extension API allows you to stream data in multiple chunks without re-hashing previous data.\\n\\n```rust\\nuse bitcoin_crc32c::crc32c_extend;\\n\\nfn crc_streaming(chunks: &[&[u8]]) -> u32 {\\n    let mut crc = 0u32; // initial accumulator\\n    for chunk in chunks {\\n        unsafe {\\n            crc = crc32c_extend(crc, chunk.as_ptr(), chunk.len());\\n        }\\n    }\\n    crc\\n}\\n```\\n\\n- Passing `crc = 0` and one single chunk is equivalent to `crc32c_value` of the concatenation.\\n- The function internally chooses the optimal backend based on CPU capabilities and compiled-in features.\\n\\n---\\n\\n## Backend selection and CPU feature detection\\n\\nThe crate uses a dispatcher that selects at runtime among the following backends:\\n\\n```rust\\nuse bitcoin_crc32c::{can_use_sse42, can_use_arm64_crc32};\\n\\nif can_use_sse42() {\\n    // SSE4.2 will be used by `crc32c_extend` on x86_64\\n}\\n\\nif can_use_arm64_crc32() {\\n    // AArch64 CRC+PMULL will be used by `crc32c_extend` on aarch64\\n}\\n```\\n\\n### Dispatch logic\\n\\n```rust\\nuse bitcoin_crc32c::crc32c_extend;\\n\\n// Pseudocode behavior:\\n// - if x86_64 and SSE4.2 available -> `crc32c_extend_sse42`\\n// - else if aarch64 and CRC available -> `crc32c_extend_arm64`\\n// - else -> `crc32c_extend_portable`\\n```\\n\\nThe detection functions internally use `std::arch::is_x86_feature_detected!(\\\"sse4.2\\\")` and `std::arch::is_aarch64_feature_detected!(\\\"crc\\\")`, cached via `OnceLock` to avoid repeated CPUID queries.\\n\\n---\\n\\n## Low-level building blocks\\n\\nFully general users rarely need these, but they are useful for systems-level integration, benchmarking, or experimentation.\\n\\n### Portable backend wrapper for testing\\n\\n```rust\\nuse bitcoin_crc32c::{PortableTestTraits, crc32c_extend_portable};\\n\\nlet buf = b\\\"test data\\\";\\nlet crc = unsafe { crc32c_extend_portable(0, buf.as_ptr(), buf.len()) };\\n\\n// Equivalent via traits wrapper (useful for generic tests):\\nlet crc2 = unsafe { PortableTestTraits::extend(0, buf.as_ptr(), buf.len()) };\\nassert_eq!(crc, crc2);\\n```\\n\\n`PortableTestTraits` provides a stable handle to the pure-Rust implementation, ensuring you can compare accelerated vs. non-accelerated paths in tests.\\n\\n### Alignment helpers\\n\\n```rust\\nuse bitcoin_crc32c::round_up_with_uintptr;\\n\\nlet ptr_value: usize = 0x1003;\\nlet aligned = round_up_with_uintptr::<8>(ptr_value);\\nassert_eq!(aligned, 0x1008);\\n```\\n\\n```rust\\nuse bitcoin_crc32c::round_up;\\n\\nlet buf = [0u8; 32];\\nlet p = buf.as_ptr();\\nlet aligned_ptr = round_up::<8>(p);\\n```\\n\\nThese helpers are used internally to align data to 4/8-byte boundaries before entering tight loops.\\n\\n### Unaligned little-endian loads\\n\\n```rust\\nuse bitcoin_crc32c::{read_uint32le, read_uint64le};\\n\\nlet buf = [1u8, 0, 0, 0, 2, 0, 0, 0];\\nlet x = read_uint32le(buf.as_ptr());      // 1\\nlet y = read_uint64le(buf.as_ptr());      // 2^32 + 1 on little-endian\\n```\\n\\nThey correctly handle both little- and big-endian hosts while assuming that `buffer` is valid for 4/8 bytes respectively.\\n\\n### Cache prefetching\\n\\n```rust\\nuse bitcoin_crc32c::request_prefetch;\\n\\nlet data = [0u8; 4096];\\nunsafe {\\n    request_prefetch(data.as_ptr().add(1024));\\n}\\n```\\n\\n- On x86_64 with SSE: uses `_mm_prefetch` with `_MM_HINT_NTA` (non-temporal), hinting that data will be read soon but not necessarily reused.\\n- On AArch64 with NEON: uses `prefetch_read_data` into L1.\\n- On other targets: becomes a no-op.\\n\\n---\\n\\n## Safety notes\\n\\nSeveral functions expose raw-pointer APIs for maximal performance and zero copies. The caller must uphold the documented contracts:\\n\\n- Pointers must be valid for at least `count` bytes.\\n- Pointers must either be non-null or only used in the `count == 0` case.\\n- There is no aliasing requirement for CRC computation, but the lifetime must cover the call duration.\\n\\nViolating these preconditions leads to undefined behavior at the Rust level.\\n\\nWhen in doubt, wrap your data in slices and call the unsafe functions in small, well-audited FFI or boundary modules.\\n\\n---\\n\\n## Example: incremental CRC over a file\\n\\n```rust\\nuse std::fs::File;\\nuse std::io::{self, Read};\\nuse bitcoin_crc32c::crc32c_extend;\\n\\nfn crc32c_of_file(path: &str) -> io::Result<u32> {\\n    let mut file = File::open(path)?;\\n    let mut buf = [0u8; 64 * 1024];\\n    let mut crc = 0u32;\\n\\n    loop {\\n        let n = file.read(&mut buf)?;\\n        if n == 0 { break; }\\n        let chunk = &buf[..n];\\n        unsafe {\\n            crc = crc32c_extend(crc, chunk.as_ptr(), chunk.len());\\n        }\\n    }\\n\\n    Ok(crc)\\n}\\n```\\n\\nThis pattern is ideal for very large inputs, as it avoids allocations and leverages streaming extension.\\n\\n---\\n\\n## Integration in Bitcoin / blockchain contexts\\n\\nThe crate resides in the `bitcoin-rs` repository and is tailored for high-throughput checksum computation in systems that:\\n\\n- Validate serialized blocks, transactions, or auxiliary indices.\\n- Maintain on-disk structures (e.g., UTXO sets, mempool journals) where cheap integrity checks are beneficial.\\n- Need a predictable, fast, low-level primitive instead of hashing with heavier cryptographic algorithms.\\n\\nWhile CRC32C is **not** a cryptographic hash and must not be used for adversarial collision resistance, it is extremely effective for catching random corruption, storage bit flips, and transmission errors.\\n\\n---\\n\\n## Performance considerations\\n\\n- Large inputs benefit most from the SSE4.2 and ARM CRC+PMULL backends.\\n- The algorithms aggressively use unrolled loops, 8-byte loads, and GF(2) skip tables to amortize overhead.\\n- Prefetch distance (`PREFETCH_HORIZON`) and block sizes (`BLOCK_0SIZE`, `BLOCK_1SIZE`, `BLOCK_2SIZE`) are chosen to balance instruction-level parallelism and cache behavior.\\n\\nFor maximum throughput in your application, prefer:\\n\\n- Large, contiguous buffers.\\n- Fewer function calls (batch data into larger chunks when possible).\\n- Reuse of the extension API (`crc32c_extend`) rather than recomputing from zero for concatenated streams.\\n\\n---\\n\\n## License and provenance\\n\\n- **License**: MIT\\n- **Edition**: Rust 2021\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n\\nThis crate is a component within a broader Bitcoin-related codebase, exposing a well-factored, standalone CRC32C implementation suitable for reuse in other high-performance Rust projects.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"network-programming\",\n      \"database\",\n      \"science\"\n    ],\n    \"package_description\": \"High-performance CRC32C (Castagnoli) implementation with runtime-dispatched SSE4.2 and AArch64 backends plus a portable fallback, suitable for streaming integrity checks in Bitcoin and other systems code.\",\n    \"package_keywords\": [\n      \"crc32c\",\n      \"checksum\",\n      \"bitcoin\",\n      \"simd\",\n      \"streaming\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 6773, "completion_tokens": 2991, "total_tokens": 9764, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
