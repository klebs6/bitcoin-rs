{"id": "batch_req_692ce18c11f08190b856c9ec96503662", "custom_id": "bitcoin-network-ai-readme-request", "response": {"status_code": 200, "request_id": "4924bfe30279beba82fa8dac0115c04b", "body": {"id": "chatcmpl-Chm5GrH8GO2WHiWxOtzSDhuFt9s36", "object": "chat.completion", "created": 1764548974, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-network\",\n    \"full_readme_markdown\": \"# bitcoin-network\\n\\nA low-level, Bitcoin Core\u2013compatible network address library for Rust. It focuses on precise modelling of Bitcoin's internal network addressing, serialization, reachability, and bucketing logic, including full support for ADDRv1/ADDRv2 (BIP155) and overlay networks (Tor v3, I2P, CJDNS).\\n\\n> This README.md was generated by an AI model based on the public interface you supplied. It may not be perfectly accurate or complete, but it should be a close and practically useful description of the crate.\\n\\n## Overview\\n\\n`bitcoin-network` provides a faithful Rust translation of Bitcoin Core's `CNetAddr` and associated logic. The crate is designed for systems that need to:\\n\\n- Parse, normalise, and classify network endpoints used in the Bitcoin P2P layer.\\n- Support both legacy ADDRv1 and modern ADDRv2/BIP155 address encodings.\\n- Reason about reachability across IPv4, IPv6, Tor v3, I2P, CJDNS, and internal pseudo\u2011addresses.\\n- Compute peer grouping and AS\u2011based bucketing identifiers compatible with Core's AddrMan.\\n- Interoperate with existing Bitcoin ecosystem crates (`bitcoin-bitstream`, `bitcoin-hash`, `bitcoin-asmap`, `bitcoin-string`, etc.).\\n\\nThe crate gives you the same semantics as Core for address validity, routability, reachability scoring, group identifiers, and overlay-encoding. This is essential if you want a Rust implementation to behave identically to Core peers on the public network.\\n\\n## Core Types\\n\\n### `Network`\\n\\n```rust\\n#[repr(u8)]\\n#[derive(Copy, Debug, Serialize, Deserialize, Hash, PartialEq, Eq, Clone)]\\npub enum Network {\\n    NET_UNROUTABLE,\\n    NET_IPV4,\\n    NET_IPV6,\\n    NET_ONION,\\n    NET_I2P,\\n    NET_CJDNS,\\n    NET_INTERNAL,\\n    NET_MAX,\\n}\\n```\\n\\n`Network` classifies addresses into high-level network classes. These are used for:\\n\\n- Reachability decisions (e.g. whether an address is considered publicly reachable).\\n- BIP155 network id mapping.\\n- AddrMan bucketing and group formation.\\n\\nSemantics mirror Bitcoin Core exactly:\\n\\n- `NET_UNROUTABLE` \u2013 invalid / unroutable / placeholder.\\n- `NET_IPV4`, `NET_IPV6` \u2013 global IP networks.\\n- `NET_ONION` \u2013 Tor v3 `.onion` services.\\n- `NET_I2P` \u2013 I2P `.b32.i2p` destinations.\\n- `NET_CJDNS` \u2013 CJDNS addresses (must start with `0xfc`).\\n- `NET_INTERNAL` \u2013 pseudo\u2011addresses used by AddrMan for DNS seeds, internal bookkeeping, etc.\\n- `NET_MAX` \u2013 sentinel (not a real network, used for sizing / iteration bounds in Core).\\n\\n### `BIP155Network`\\n\\n```rust\\n#[repr(u8)]\\npub enum BIP155Network {\\n    IPV4,\\n    IPV6,\\n    TORV2,\\n    TORV3,\\n    I2P,\\n    CJDNS,\\n}\\n```\\n\\nInternal representation of BIP155 network ids. TORv2 is kept only to validate/ignore legacy payloads; the crate enforces TORv3 addresses for new encodings.\\n\\n### `NetAddr`\\n\\n```rust\\n#[derive(Builder, Setters, Getters, MutGetters, Debug, Serialize, Deserialize, Clone, Hash)]\\n#[getset(get = \\\"pub\\\", set = \\\"pub\\\", get_mut = \\\"pub\\\")]\\n#[builder(setter(into))]\\npub struct NetAddr {\\n    addr:     PreVector<u8, ADDR_IPV6_SIZE>,\\n    net:      Network,\\n    scope_id: u32,\\n}\\n```\\n\\n`NetAddr` represents a single network address in the sense of Bitcoin Core:\\n\\n- `addr` holds the raw address bytes. Its interpretation depends on `net`.\\n- `net` is the high-level `Network` classification.\\n- `scope_id` is used for IPv6 scoped addresses (e.g. link\u2011local with an interface index).\\n\\nThe crate provides a large number of methods that match the C++ behaviour, including:\\n\\n- Construction and conversion from `InAddr` (IPv4) and `In6Addr` (IPv6).\\n- Parsing of Tor v3 `.onion` strings and I2P `.b32.i2p` strings.\\n- Mapping and unmapping of IPv4\u27f7IPv6 embeddings (RFC6052, RFC6145, 6to4, Teredo).\\n- BIP155 (ADDRv2) serialization / deserialization.\\n- Legacy ADDRv1 serialization / deserialization.\\n- Validity, routability, and classification according to a wide range of IANA/IETF registry ranges (RFC1918, RFC3927, RFC4193, RFC5737, RFC3849, RFC4843, RFC7343, etc.).\\n- AS\u2011based mapping with an `asmap` bitvector for AddrMan.\\n\\n## Features by Domain\\n\\n### 1. Address Formatting Helpers\\n\\nThe crate contains helpers to render addresses to canonical string representations with the same rules as Core:\\n\\n```rust\\npub fn ipv4_to_string(a: &[u8]) -> String;\\n\\npub fn ipv6_to_string(a: &[u8], scope_id: u32) -> String;\\n\\npub fn onion_to_string(addr: &[u8]) -> String;\\n```\\n\\n- `ipv4_to_string` renders a 4\u2011octet IPv4 address as `d.d.d.d`.\\n- `ipv6_to_string` uses `std::net::Ipv6Addr` and yields RFC 5952\u2013compliant compressed text forms, optionally with `%scope_id` suffix.\\n- `onion_to_string` computes the Tor v3 checksum and version, base32 encodes the 32\u2011byte public key and metadata, and appends `.onion`.\\n\\n### 2. BIP155 / ADDRv2 Support\\n\\n`NetAddr` can serialize and unserialize itself in both legacy ADDRv1 and modern ADDRv2 forms:\\n\\n```rust\\nimpl NetAddr {\\n    pub fn serialize<Stream>(&self, s: &mut Stream) where\\n        Stream: bitcoin_bitstream::GetVersion,\\n        for<'s> &'s mut Stream: core::ops::Shl<u8, Output = &'s mut Stream>\\n            + core::ops::Shl<u64, Output = &'s mut Stream>,\\n        for<'s, 'a> &'s mut Stream: core::ops::Shl<&'a [u8], Output = &'s mut Stream>;\\n\\n    pub fn unserialize<Stream>(&mut self, s: &mut Stream) where\\n        Stream: bitcoin_bitstream::GetVersion + bitcoin_bitstream::Backend,\\n        for<'s, 'a> &'s mut Stream:\\n            core::ops::Shr<&'a mut [u8], Output = &'s mut Stream>\\n            + core::ops::Shr<&'a mut u8, Output = &'s mut Stream>\\n            + core::ops::Shr<&'a mut u64, Output = &'s mut Stream>;\\n\\n    pub fn serialize_v1array(&self, arr: &mut [u8; NET_ADDR_V1_SERIALIZATION_SIZE]);\\n    pub fn serialize_v1stream<Stream>(&self, s: &mut Stream)\\n        where for<'s, 'a> &'s mut Stream: core::ops::Shl<&'a [u8], Output = &'s mut Stream>;\\n\\n    pub fn unserialize_v1array(&mut self, arr: &mut [u8; NET_ADDR_V1_SERIALIZATION_SIZE]);\\n    pub fn unserialize_v1stream<Stream>(&mut self, s: &mut Stream)\\n        where for<'s, 'a> &'s mut Stream: core::ops::Shr<&'a mut [u8], Output = &'s mut Stream>;\\n\\n    pub fn serialize_v2stream<Stream>(&self, s: &mut Stream) where\\n        for<'s> &'s mut Stream:\\n            core::ops::Shl<u8, Output = &'s mut Stream>\\n            + core::ops::Shl<u64, Output = &'s mut Stream>,\\n        for<'s, 'a> &'s mut Stream:\\n            core::ops::Shl<&'a [u8], Output = &'s mut Stream>;\\n\\n    pub fn unserialize_v2stream<Stream>(&mut self, s: &mut Stream) where\\n        Stream: bitcoin_bitstream::Backend,\\n        for<'s, 'a> &'s mut Stream:\\n            core::ops::Shr<&'a mut u8, Output = &'s mut Stream>\\n            + core::ops::Shr<&'a mut u64, Output = &'s mut Stream>\\n            + core::ops::Shr<&'a mut [u8], Output = &'s mut Stream>;\\n}\\n```\\n\\n`serialize` and `unserialize` automatically choose between v1 and v2 based on the stream's version flag (`ADDRV2_FORMAT` bit), exactly matching Core's feature gating. This makes the crate safe to use in mixed-version networks and when persisting AddrMan on disk.\\n\\nThe mapping between `Network` and `BIP155Network` is handled by:\\n\\n```rust\\nimpl NetAddr {\\n    pub fn get_bip155network(&self) -> BIP155Network;\\n    pub fn set_net_from_bip155network(&mut self, id: u8, address_size: usize) -> bool;\\n}\\n```\\n\\nUnknown future ids are ignored (payload skipped), while mismatched founding ids trigger panics, mimicking Core's behaviour.\\n\\n### 3. Validity, Routability, and Reachability\\n\\nThe crate encodes all of Core's validity and routing heuristics:\\n\\n```rust\\nimpl NetAddr {\\n    pub fn is_valid(&self) -> bool;\\n    pub fn is_routable(&self) -> bool;\\n    pub fn is_local(&self) -> bool;\\n    pub fn is_bind_any(&self) -> bool; // 0.0.0.0 / ::\\n\\n    pub fn is_ipv4(&self) -> bool;\\n    pub fn is_ipv6(&self) -> bool;\\n    pub fn is_tor(&self) -> bool;\\n    pub fn isi2p(&self) -> bool;\\n    pub fn iscjdns(&self) -> bool;\\n    pub fn is_internal(&self) -> bool;\\n\\n    pub fn isrfc1918(&self) -> bool;\\n    pub fn isrfc2544(&self) -> bool;\\n    pub fn isrfc3927(&self) -> bool;\\n    pub fn isrfc6598(&self) -> bool;\\n    pub fn isrfc5737(&self) -> bool;\\n    pub fn isrfc3849(&self) -> bool;\\n    pub fn isrfc3964(&self) -> bool;\\n    pub fn isrfc6052(&self) -> bool;\\n    pub fn isrfc4380(&self) -> bool;\\n    pub fn isrfc4862(&self) -> bool;\\n    pub fn isrfc4193(&self) -> bool;\\n    pub fn isrfc6145(&self) -> bool;\\n    pub fn isrfc4843(&self) -> bool;\\n    pub fn isrfc7343(&self) -> bool;\\n}\\n```\\n\\nThis allows you to reason at the same level of granularity as Core about whether an address should be gossiped, connected to, or deprioritised.\\n\\n#### Reachability Metrics\\n\\n`NetAddr` exposes the same integer reachability scale that Core uses in outbound peer selection and connection policy:\\n\\n```rust\\nimpl NetAddr {\\n    pub fn get_reachability_from(&self, paddr_partner: *const NetAddr) -> i32;\\n}\\n```\\n\\nThe metric differentiates between:\\n\\n- Direct IPv4\u2194IPv4 reachability.\\n- Native IPv6 vs. tunneled IPv6 (6to4, Teredo, etc.).\\n- Overlay networks (Tor, I2P) with special cases for private communication.\\n\\nThe helper trait `CheckIsReachable` provides a higher\u2011level boolean classification:\\n\\n```rust\\npub trait CheckIsReachable {\\n    fn is_reachable(&self) -> bool;\\n}\\n\\nimpl CheckIsReachable for Network { /* TODO in this crate; wired for Core semantics */ }\\nimpl CheckIsReachable for NetAddr {\\n    fn is_reachable(&self) -> bool {\\n        self.get_network().is_reachable()\\n    }\\n}\\n```\\n\\nCurrently `Network::is_reachable()` is a placeholder mirroring Core's `vfLimited` gating.\\n\\n### 4. Overlay Parsing: Tor and I2P\\n\\nTo correctly support overlay networks, `NetAddr` can parse and validate textual Tor/I2P destinations:\\n\\n```rust\\nimpl NetAddr {\\n    pub fn set_tor(&mut self, addr: &String) -> bool;\\n    pub fn seti2p(&mut self, addr: &String) -> bool;\\n    pub fn set_special(&mut self, addr: &String) -> bool; // Tor or I2P\\n\\n    pub fn to_stringip(&self) -> String;\\n    pub fn to_string(&self) -> String; // alias for to_stringip\\n}\\n```\\n\\nTor v3 handling matches spec:\\n\\n- Parses `*.onion` hostnames.\\n- Base32\u2011decodes payload without padding.\\n- Splits into `PUBKEY | CHECKSUM | VERSION`.\\n- Verifies version byte.\\n- Recomputes checksum as\\n  `SHA3_256(b\\\".onion checksum\\\" || PUBKEY || VERSION)[0..2]` and compares.\\n\\nI2P handling similarly enforces the `52`-char base32 + `.b32.i2p` suffix, then decodes via the shared `bitcoin_string` utilities.\\n\\n### 5. IPv4/IPv6 Embeddings and Legacy Encodings\\n\\n`NetAddr` provides precise handling of IPv4 mapped and translated addresses as used in legacy encodings and in IPv6 transition mechanisms:\\n\\n```rust\\nimpl NetAddr {\\n    pub fn has_linked_ipv4(&self) -> bool;\\n    pub fn get_linked_ipv4(&self) -> u32;\\n\\n    pub fn set_legacy_ipv6(&mut self, ipv6: &[u8]);\\n    pub fn is_addr_v1compatible(&self) -> bool;\\n}\\n```\\n\\n- `set_legacy_ipv6` decodes embedded IPv4, INTERNAL, and deprecated TORv2 prefixes into the appropriate `Network` variant and canonical `addr` bytes.\\n- `has_linked_ipv4` and `get_linked_ipv4` reconstruct the equivalent IPv4 address from IPv6 forms (6to4, SIIT translated, Teredo, etc.), always in network byte order.\\n- `is_addr_v1compatible` tests whether the address can be encoded in ADDRv1 (`NET_IPV4`, `NET_IPV6`, `NET_INTERNAL`).\\n\\n### 6. AS\u2011based Bucketing and Grouping\\n\\nFor peer selection and sybil resistance, Core uses an AS map (`asmap`) and group identifiers. This crate reproduces that behaviour exactly:\\n\\n```rust\\nimpl NetAddr {\\n    pub fn get_mappedas(&self, asmap: &Vec<bool>) -> u32;\\n    pub fn get_group(&self, asmap: &Vec<bool>) -> Vec<u8>;\\n}\\n```\\n\\n- `get_mappedas` interprets the IP as a 128\u2011bit bitstring, then uses `bitcoin_asmap::interpret` to map into an autonomous system number. If there is no mapping (or `asmap` is empty, or the address is non\u2011IPv4/IPv6), it returns `0`, which is reserved by RFC7607.\\n- `get_group` uses either the AS mapping or network\u2011specific prefix rules to return a canonical byte vector representing the address group. No two outbound connections are attempted to addresses with the same group, mirroring Core's design:\\n  - IPv4: /16 prefix buckets.\\n  - IPv6: /32 or /36 for HE.net, depending on address.\\n  - Tor/I2P/CJDNS: /4 prefix in their overlay space.\\n  - Internal: full 10\u2011byte prefix.\\n  - Local & unroutable: single shared group by network class.\\n\\n### 7. Hashing and Byte Representation\\n\\nFor indexing and deduplication, `NetAddr` provides deterministic, Core\u2011compatible hashing and raw byte extraction:\\n\\n```rust\\nimpl NetAddr {\\n    pub fn get_addr_bytes(&self) -> Vec<u8>;\\n    pub fn get_hash(&self) -> u64;\\n}\\n```\\n\\n- `get_addr_bytes` returns either the legacy ADDRv1 16\u2011byte representation or the raw `addr` payload, depending on `is_addr_v1compatible`.\\n- `get_hash` computes a 256\u2011bit hash (`bitcoin_hash::hash1`, double\u2011SHA256\u2011style) over the raw address bytes and returns the first 64 bits in little\u2011endian order as a `u64`, following Core's conventions.\\n\\n## Example Usage\\n\\n### Creating and Formatting Addresses\\n\\n```rust\\nuse bitcoin_network::{NetAddr, Network};\\n\\nfn basic_examples() {\\n    // IPv4: 1.2.3.4\\n    let ipv4_bytes = [1u8, 2, 3, 4];\\n    let mut ipv4 = NetAddr::default();\\n    *ipv4.net_mut()  = Network::NET_IPV4;\\n    *ipv4.addr_mut() = PreVector::from(&ipv4_bytes[..]);\\n\\n    assert!(ipv4.is_ipv4());\\n    assert!(ipv4.is_valid());\\n    assert_eq!(ipv4.to_string(), \\\"1.2.3.4\\\");\\n\\n    // A Tor v3 address\\n    let mut tor = NetAddr::default();\\n    let ok = tor.set_tor(&\\\"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion\\\".to_string());\\n    assert!(ok);\\n    assert!(tor.is_tor());\\n    println!(\\\"Tor address: {}\\\", tor.to_string());\\n}\\n```\\n\\n### Serializing with ADDRv2 / BIP155\\n\\n```rust\\nuse bitcoin_network::NetAddr;\\nuse bitcoin_bitstream::{MemoryStream, GetVersion};\\n\\nconst ADDRV2_FORMAT: u32 = 1 << 31; // Example feature bit; use the same as in your stack.\\n\\nfn roundtrip_bip155(addr: &NetAddr) {\\n    let mut stream = MemoryStream::new();\\n    stream.set_version(ADDRV2_FORMAT);\\n\\n    // Serialize in ADDRv2 format\\n    addr.serialize(&mut stream);\\n\\n    // Reset read cursor and unserialize\\n    let mut decoded = NetAddr::default();\\n    decoded.unserialize(&mut stream);\\n\\n    assert_eq!(addr.get_net_class(), decoded.get_net_class());\\n    assert_eq!(addr.get_addr_bytes(), decoded.get_addr_bytes());\\n}\\n```\\n\\n### Using AS Maps for Grouping\\n\\n```rust\\nuse bitcoin_network::NetAddr;\\n\\nfn bucket_key(addr: &NetAddr, asmap: &Vec<bool>) -> Vec<u8> {\\n    // Returns a stable identifier representing the AddrMan bucket/group.\\n    addr.get_group(asmap)\\n}\\n```\\n\\n## Algorithmic and Standards Background\\n\\nThe crate embeds a substantial amount of network\u2011theoretic and protocol knowledge:\\n\\n- **BIP155 / ADDRv2**: variable\u2011length address payloads tagged with network ids, enabling extensible support for non\u2011IP overlays without abusing IPv6 space.\\n- **IPv6 Text Representation**: RFC 5952 mandates canonical zero compression and lowercase hex; using `std::net::Ipv6Addr` ensures consistent formatting.\\n- **Transition Mechanisms**: 6to4 (RFC3964), Teredo (RFC4380), IPv4\u2011embedded formats (RFC6052, RFC6145), autoconfiguration (RFC4862) are used in reachability classification.\\n- **Private and Documentation Ranges**: RFC1918, RFC3927, RFC5737, RFC3849, RFC4193, RFC4843, RFC7343 are explicitly vetted in `is_valid` and `is_routable`.\\n- **Autonomous System Mapping**: `asmap` is a compressed DFA over IP bits. `get_mappedas` builds a 128\u2011bit boolean vector representation and feeds it into `bitcoin_asmap::interpret`, which yields a stable AS number used for bucket diversification.\\n\\nThis crate effectively exports the same policy surface that Core uses, allowing you to replicate its peer selection and address management logic precisely in Rust.\\n\\n## Safety and Panics\\n\\nMany methods are designed under the assumption of internal invariants, just as in Core:\\n\\n- Several functions `assert!` on address length (e.g., IPv4 must be 4 bytes, IPv6 must be 16 bytes, Tor v3 must be 32 bytes, etc.).\\n- Certain misconfigurations (e.g. founding BIP155 ids with incorrect payload sizes, `NET_UNROUTABLE`/`NET_MAX` used as actual network types) panic.\\n- Pointer\u2011based APIs (`get_in_addr`, `get_in_6addr`, `get_reachability_from`) use `unsafe` and assume the caller provides valid pointers.\\n\\nThis is intentional: the crate is engineered as a near drop\u2011in for Core internals, and invalid data is expected to be filtered or asserted away earlier in the call chain.\\n\\n## Integration Notes\\n\\n- **Rust Edition**: 2021.\\n- **License**: MIT.\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n- **Intended Consumers**: implementers of Bitcoin P2P stacks, alternative full node implementations, network simulators, asmap tooling, and research systems requiring bit\u2011exact compatibility with Bitcoin Core's address handling.\\n\\nTo use the crate in your project:\\n\\n```toml\\n[dependencies]\\nbitcoin-network = \\\"0.1.19\\\"\\n```\\n\\nThen import the relevant items:\\n\\n```rust\\nuse bitcoin_network::{NetAddr, Network, BIP155Network, CheckIsReachable};\\n```\\n\\nIf you integrate with other `bitcoin-rs` components, the dependency set and versions should be aligned with the `bitcoin-rs` workspace for maximum compatibility.\\n\",\n    \"package_categories\": [\n      \"network-programming\",\n      \"cryptography\",\n      \"parser-implementations\",\n      \"science\",\n      \"algorithms\"\n    ],\n    \"package_description\": \"Bitcoin Core\u2013compatible network address handling for Rust: IPv4/IPv6/Tor/I2P/CJDNS classification, BIP155 ADDRv2 and legacy ADDRv1 serialization, reachability metrics, AS-based bucketing, and overlay address parsing.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"networking\",\n      \"bip155\",\n      \"tor\",\n      \"addrman\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 17846, "completion_tokens": 5286, "total_tokens": 23132, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
