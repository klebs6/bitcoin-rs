{"id": "batch_req_692cda5e730c819083b9d7fa4ffbd131", "custom_id": "bitcoin-ripemd-ai-readme-request", "response": {"status_code": 200, "request_id": "7acf7a01e9d2a24ee1a24a066abc8661", "body": {"id": "chatcmpl-ChlbkPZu6pkScdJwG15D6EinyjT06", "object": "chat.completion", "created": 1764547144, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-ripemd\",\n    \"full_readme_markdown\": \"# bitcoin-ripemd\\n\\nA standalone, low-level RIPEMD\u2011160 implementation tuned for Bitcoin-style workloads.\\n\\nThis crate provides a small, `no_std`\u2011friendly core for computing RIPEMD\u2011160 message digests, with a focus on:\\n\\n- Exact replication of the canonical RIPEMD\u2011160 bit\u2011level behavior\\n- Efficient streaming over arbitrarily long byte sequences\\n- Transparent, inspectable implementation suitable for audit and reuse inside Bitcoin libraries\\n\\n> This README.md was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful description of the crate.\\n\\n---\\n\\n## Features at a glance\\n\\n- Pure Rust RIPEMD\u2011160 compression function and padding logic\\n- Stateful hasher type `Ripemd160` with `new`, `update`, `finalize`, and `reset`\\n- Carefully inlined bitwise round functions (`ripemd160_f1`\u2013`f5`) and per\u2011round helpers\\n- Deterministic, Bitcoin\u2011compatible outputs (e.g., for HASH160: `RIPEMD160(SHA256(x))`)\\n- Fine\u2011grained tracing via the `tracing` crate to inspect internal state evolution (optional at runtime)\\n\\nThis crate is extracted from, and maintained in sync with, the `bitcoin-rs` repository, and is intended to be usable independently when a minimal RIPEMD\u2011160 implementation is desired.\\n\\n---\\n\\n## Use cases\\n\\nTypical applications include:\\n\\n- Bitcoin address construction (P2PKH, P2SH) via HASH160\\n- Re\u2011implementing or auditing Bitcoin consensus code\\n- Cryptographic tooling that requires RIPEMD\u2011160 hashes for interoperability\\n- Verification harnesses and fuzzing against alternative RIPEMD\u2011160 implementations\\n\\nNote that RIPEMD\u2011160, while still widely used in Bitcoin, is not recommended for new generic cryptographic designs. Use this crate when *interoperability* with existing protocols explicitly demands RIPEMD\u2011160.\\n\\n---\\n\\n## Quick start\\n\\nAdd to your `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-ripemd = \\\"0.1.19\\\"\\n```\\n\\nHash a byte slice into a 20\u2011byte RIPEMD\u2011160 digest:\\n\\n```rust\\nuse bitcoin_ripemd::Ripemd160;\\n\\nfn ripemd160_hex(data: &[u8]) -> String {\\n    let mut hasher = Ripemd160::new();\\n    hasher.update(data);\\n\\n    let mut out = [0u8; 20]; // RIPEMD160_OUTPUT_SIZE\\n    hasher.finalize(&mut out);\\n\\n    // encode as lowercase hex (example, using `hex` crate)\\n    hex::encode(out)\\n}\\n\\nfn main() {\\n    let digest_hex = ripemd160_hex(b\\\"hello world\\\");\\n    println!(\\\"RIPEMD-160(\\\\\\\"hello world\\\\\\\") = {}\\\", digest_hex);\\n}\\n```\\n\\nStreaming large data is identical: call `update` repeatedly and `finalize` once at the end.\\n\\n```rust\\nuse bitcoin_ripemd::Ripemd160;\\n\\nfn hash_chunks(chunks: &[&[u8]]) -> [u8; 20] {\\n    let mut h = Ripemd160::new();\\n\\n    for &chunk in chunks {\\n        h.update(chunk);\\n    }\\n\\n    let mut out = [0u8; 20];\\n    h.finalize(&mut out);\\n    out\\n}\\n```\\n\\nIf you want to reuse the same hasher instance for multiple messages:\\n\\n```rust\\nlet mut h = Ripemd160::new();\\n\\nh.update(b\\\"message one\\\");\\nlet mut out1 = [0u8; 20];\\nh.finalize(&mut out1);\\n\\nh.reset();\\nh.update(b\\\"message two\\\");\\nlet mut out2 = [0u8; 20];\\nh.finalize(&mut out2);\\n```\\n\\n---\\n\\n## API overview\\n\\n### `struct Ripemd160`\\n\\n```rust\\npub struct Ripemd160  {\\n    s:     [u32; 5],   // internal state words (5 \u00d7 32 bits = 160 bits)\\n    buf:   [u8; 64],   // partial chunk buffer\\n    bytes: u64,        // total bytes ingested\\n}\\n```\\n\\nKey methods:\\n\\n- `Ripemd160::new() -> Self`\\n  - Constructs a new hasher with the standard RIPEMD\u2011160 IV.\\n- `Ripemd160::default() -> Self`\\n  - Alias for `new`, also initializes the state via `ripemd160_initialize`.\\n- `fn update(&mut self, data: &[u8]) -> &mut Self`\\n  - High\u2011level, safe ingestion of arbitrary byte slices.\\n  - Internally forwards to `write` and handles chunking into 64\u2011byte blocks.\\n- `fn finalize(&mut self, hash: &mut [u8; RIPEMD160_OUTPUT_SIZE])`\\n  - Completes the hash computation, writes the 20\u2011byte digest into `hash`.\\n  - Performs RIPEMD\u2011160 padding: appends `0x80`, then zeros, then the 64\u2011bit little\u2011endian bit length.\\n  - Encodes the final 5 \u00d7 32\u2011bit state words in little\u2011endian order into the caller buffer.\\n- `fn reset(&mut self) -> &mut Self`\\n  - Zeroes the byte counter and reinitializes the internal state to the RIPEMD\u2011160 IV, allowing reuse.\\n\\nThere is also a low\u2011level pointer interface:\\n\\n- `fn write(&mut self, data: *const u8, len: usize) -> &mut Self`\\n  - Unsafe, but tightly aligned with the internal buffering and transform logic.\\n  - Intended for performance\u2011sensitive code that already manipulates raw pointers.\\n\\nGenerated accessors (via `getset`):\\n\\n- `s()`, `s_mut()`: internal state array\\n- `buf()`, `buf_mut()`: internal buffer\\n- `bytes()`, `bytes_mut()`: total byte counter\\n\\nThese are mainly useful for diagnostics, testing or integrating with other low\u2011level primitives.\\n\\n---\\n\\n## Cryptographic core\\n\\nRIPEMD\u2011160 is a Merkle\u2013Damg\u00e5rd hash function operating on 512\u2011bit message blocks and maintaining a 160\u2011bit internal state. Each block is processed through five rounds of non\u2011linear mixing in *two parallel lanes*, followed by a feed\u2011forward with the previous state.\\n\\nThis crate exposes the internal round primitives explicitly, which is invaluable for verification and optimization work:\\n\\n### Boolean round functions\\n\\n```rust\\npub fn ripemd160_f1(x: u32, y: u32, z: u32) -> u32 { x ^ y ^ z }\\npub fn ripemd160_f2(x: u32, y: u32, z: u32) -> u32 { (x & y) | (!x & z) }\\npub fn ripemd160_f3(x: u32, y: u32, z: u32) -> u32 { (x | !y) ^ z }\\npub fn ripemd160_f4(x: u32, y: u32, z: u32) -> u32 { (x & z) | (y & !z) }\\npub fn ripemd160_f5(x: u32, y: u32, z: u32) -> u32 { x ^ (y | !z) }\\n```\\n\\nThese are the five canonical RIPEMD\u2011160 boolean functions. Each round uses one of them together with:\\n\\n- a message word `x`\\n- a round constant `k`\\n- a rotation amount `r`\\n\\n### One-round update\\n\\n```rust\\npub fn ripemd160_round(\\n    a: &mut u32,\\n    b: u32,\\n    c: &mut u32,\\n    d: u32,\\n    e: u32,\\n    f: u32,\\n    x: u32,\\n    k: u32,\\n    r: i32,\\n)\\n```\\n\\nMathematically, this performs (in 32\u2011bit arithmetic):\\n\\n\\\\[\\n\\\\begin{aligned}\\nA' &= \\\\mathrm{ROL}_{r}(A + f + x + k) + E \\\\\\\\\\nC' &= \\\\mathrm{ROL}_{10}(C)\\n\\\\end{aligned}\\n\\\\]\\n\\nwhere `ROL` is a left rotation modulo 2\u00b3\u00b2, implemented by `ripemd160_rol`.\\n\\n### Per\u2011round wrappers\\n\\nThe functions `ripemd160_rXY` (e.g., `ripemd160_r11`, `ripemd160_r22`, `ripemd160_r51`, etc.) bind in the appropriate boolean function, round constant, and rotation schedule for each phase. Their signatures are homogeneous:\\n\\n```rust\\npub fn ripemd160_r11(\\n    a: &mut u32,\\n    b: u32,\\n    c: &mut u32,\\n    d: u32,\\n    e: u32,\\n    x: u32,\\n    r: i32,\\n)\\n```\\n\\nEach wrapper computes the boolean function `f` for that round and delegates to `ripemd160_round` with its fixed constant `k`. This design keeps the top\u2011level compression loop (`ripemd160_transform`) legible while still being amenable to inlining and constant propagation.\\n\\n### Compression function\\n\\n```rust\\npub fn ripemd160_transform(s: *mut u32, chunk: *const u8)\\n```\\n\\n- Expects five 32\u2011bit state words at `s` and a 64\u2011byte block at `chunk`.\\n- Loads sixteen little\u2011endian message words `w0\u2026w15`.\\n- Initializes two parallel lanes `(a1\u2026e1)` and `(a2\u2026e2)` from the current state.\\n- Executes all 80 rounds in the canonical RIPEMD\u2011160 schedule using the `Rxy` helpers.\\n- Performs the final feed\u2011forward, mixing both lanes back into `s[0..5]`.\\n\\nThis function is the exact Merkle\u2013Damg\u00e5rd compression primitive; it is exposed for specialized applications that need tighter control or independent verification.\\n\\n### State initialization\\n\\n```rust\\npub fn ripemd160_initialize(s: *mut u32)\\n```\\n\\nWrites the standard RIPEMD\u2011160 IV into `s[0..5]`:\\n\\n```text\\nH0 = 0x67452301\\nH1 = 0xEFCDAB89\\nH2 = 0x98BADCFE\\nH3 = 0x10325476\\nH4 = 0xC3D2E1F0\\n```\\n\\nThese constants mirror those of SHA\u20111 up to endianness nuances and are part of the RIPEMD\u2011160 specification.\\n\\n---\\n\\n## Tracing and observability\\n\\nThe implementation is instrumented with `tracing` calls at various granularities:\\n\\n- `trace!` in boolean functions, rotation, and per\u2011round helpers\\n- `debug!` in `ripemd160_transform`\\n- `info!` in initialization, default construction, reset, and finalize paths\\n\\nTo exploit this, configure a `tracing` subscriber in your binary or test harness. For example:\\n\\n```rust\\nuse tracing_subscriber::EnvFilter;\\n\\nfn main() {\\n    tracing_subscriber::fmt()\\n        .with_env_filter(EnvFilter::from_default_env())\\n        .init();\\n\\n    // now use Ripemd160; internal state transitions will be logged\\n}\\n```\\n\\nYou can then enable detailed logs for a specific module, such as:\\n\\n```bash\\nRUST_LOG=debug,ripemd160=trace cargo test\\n```\\n\\nThis makes the crate useful not only as a hashing library but also as an educational and diagnostic tool when studying RIPEMD\u2011160.\\n\\n---\\n\\n## Safety and low-level behavior\\n\\n- The `update` API is fully safe and should be preferred for regular application code.\\n- The pointer\u2011based `write`, `ripemd160_transform`, and `ripemd160_initialize` APIs are `unsafe` and assume that the pointers are valid and aligned for the required sizes.\\n- All internal arithmetic is performed modulo 2\u00b3\u00b2 using `wrapping_add` and bit rotations, as required for deterministic RIPEMD\u2011160 semantics.\\n\\nIf you are integrating this crate into constant\u2011time critical code, note that RIPEMD\u2011160 is largely constructed from data\u2011independent operations (bitwise logic, rotations, and modular additions). However, the usual caveats apply: host/compiler behavior, logging side\u2011channels, and surrounding protocol choices still matter.\\n\\n---\\n\\n## Interoperability notes\\n\\n- Output size is always 20 bytes (`RIPEMD160_OUTPUT_SIZE`), encoded **little\u2011endian** word by word.\\n- Bitcoin's `HASH160` (RIPEMD\u2011160(SHA\u2011256(x))) is supported by composing this crate with a SHA\u2011256 implementation; this crate intentionally focuses only on RIPEMD\u2011160.\\n- The implementation is designed to be bit\u2011for\u2011bit compatible with the widely deployed RIPEMD\u2011160 reference algorithm.\\n\\n---\\n\\n## Repository and maintenance\\n\\nThis crate is developed and maintained within the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) repository and is versioned as an independent crate (`bitcoin-ripemd`). Issues and pull requests should be filed against that repository.\\n\\n---\\n\\n## License\\n\\nThis crate is licensed under the MIT license, matching the rest of `bitcoin-rs`.\\n\\nYou are free to use it in proprietary or open\u2011source software, subject to the terms of the MIT license.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"science\"\n    ],\n    \"package_description\": \"Low-level, auditable RIPEMD-160 implementation used by bitcoin-rs, providing a streaming hasher and explicit compression function suitable for Bitcoin HASH160 and interoperability use cases.\",\n    \"package_keywords\": [\n      \"ripemd160\",\n      \"bitcoin\",\n      \"hash\",\n      \"cryptography\",\n      \"digest\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 11091, "completion_tokens": 3266, "total_tokens": 14357, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
