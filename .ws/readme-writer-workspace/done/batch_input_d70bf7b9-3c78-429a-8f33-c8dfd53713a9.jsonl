{"custom_id":"bitcoin-network-ai-readme-request","method":"POST","url":"/v1/chat/completions","body":{"max_completion_tokens":8192,"messages":[{"content":"We would like you to write a README.md for a rust crate with maximally helpful content.\nAdditionally, we would like you to generate several fields from the Cargo.toml package section for this crate.\nWe will show you the strict json output format we would like you to provide.\nPlease tailor your response for an apex consumer of maximal intelligence.\nA reader of this README.md should have a good sense of what the crate does and how to use it after reading what you write.\nPlease include a messaage indicating that this README.md file was generated by an AI model and may not be 100% accurate however it should be pretty good.\n\n\nCarefully read and parse the information we sent you.\n\nWe want to generate all information items requested by our schema:\n\n- Read the description of each field. Use it, along with the content we sent you to generate an appropriate value for each.\n- Ensure that each generated field optimally serves its desired purpose.\n- Each item should be deep, detailed, and specific. Use optimally descriptive and useful language. Do not be too verbose.\n- Do not add any extra keys to the generated object. Generate precisely what we ask of you: no more, no less.\n- For fields which are of an enum type: pick *exactly one variant*. Do not generate any information for the unselected variants.\n- For array fields: supply a JSON list [ ... ] of items, each conforming to the correct item type.\n- For map fields: Provide a JSON object { \"key_as_string\": <value>, ... }. Keys must be valid JSON strings. Keys and Values must conform to the key and value schemas we provide to you. Fill all subfields of each and every map value.\n- If we ask you to justify a map field, provide your justification/confidence score for the entire map. Do not attempt to separately justify each map element.\n- Likewise, if we ask you to justify an array field, provide your justification/confidence score for the entire array. Do not attempt to separately justify each element.\n- Provide numeric fields as real JSON numbers (not strings).\n- For string fields: provide the value precisely as a string literal. If optional, you may set it to null.\n- If we ask you to justify or provide confidence scores for the fields of a structure, please do so carefully. For each field we ask you to justify, please explain or justify your choice clearly. Confidence scores must be specified as real JSON numbers in the range `[0..1]`.\n- If we ask to you generate an optional field, either fill it or set it to null.\n- If we ask you to justify your choice of an enum variant, please explain your choice clearly. Do not justify your decision to leave a variant unselected. Provide your justification as a JSON string. Provide your confidence score as a real JSON number in the range `[0..1]`.\n- In terms of the JSON format we would like you to provide, the object itself will be deserialied based on the following schema. \n- We begin exactly at the top: the data should not be nested under a parent named 'fields' or anything similar.\n\n## Here is the schema to use:\n\nObject {\n    \"fields\": Object {\n        \"crate_name\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be the name of our crate, *verbatim*, trimmed for use as a toml field\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"full_readme_markdown\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be valid markdown representing the readme for this crate.\\\\n\\\\n Please make it terse, useful, and designed for an industrious commercially savy consumer of industrious nature. \\\\n\\\\n Advanced vocabulary and concepts are welcome. \\\\n\\\\n If this crate involves concepts from mathematics and/or physics, please describe and document them here.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_categories\": Object {\n            \"generation_instructions\": String(\"\\\"These categories will be used in our Cargo.toml file.\\\\n\\\\n It is important that users of this crate can find it on crates.io.\\\\n\\\\n Choose maximum 5 categories and make sure they are actually meaningful for our crate.\\\\n\\\\n These categories should only be chosen from among the legal crates.io categories. \\\\n\\\\n The ONLY legal categoreis are:\\\\n\\\\n``\\\\n accessibility\\\\n aerospace\\\\n algorithms\\\\n api-bindings\\\\n asynchronous\\\\n authentication\\\\n caching\\\\n command-line-interface\\\\n command-line-utilities\\\\n compilers\\\\n compression\\\\n computer-vision\\\\n concurrency\\\\n config\\\\n cryptography\\\\n data-structures\\\\n database\\\\n database-implementations\\\\n date-and-time\\\\n development-tools\\\\n email\\\\n embedded\\\\n emulators\\\\n encoding\\\\n external-ffi-bindings\\\\n filesystem\\\\n finance\\\\n game-development\\\\n game-engines\\\\n games\\\\n graphics\\\\n gui\\\\n hardware-support\\\\n internationalization\\\\n localization\\\\n mathematics\\\\n memory-management\\\\n multimedia\\\\n network-programming\\\\n no-std\\\\n os\\\\n parser-implementations\\\\n parsing\\\\n rendering\\\\n rust-patterns\\\\n science\\\\n simulation\\\\n template-engine\\\\n text-editors\\\\n text-processing\\\\n value-formatting\\\\n virtualization\\\\n visualization\\\\n wasm\\\\n web-programming\\\\n ``\\\\n\\\\n DO NOT specify a category that is not on this list.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n        \"package_description\": Object {\n            \"generation_instructions\": String(\"\\\"We will place this package_description in our Cargo.toml file so the users of this crate\\\\n know what it does.\\\\n\\\\n The discription should be technical, clear, and useful. It should be terse.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_keywords\": Object {\n            \"generation_instructions\": String(\"\\\"These keywords will be used in our Cargo.toml file so the users of this crate can easily\\\\n find it in the package system. Keywords should be useful, varied, meaningful, and reflect\\\\n the contents of our crate. They should make it easy to find. Please provide exactly five.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n    },\n    \"struct_docs\": String(\" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\"),\n    \"struct_name\": String(\"AiReadmeWriterDesiredOutput\"),\n    \"type\": String(\"struct\"),\n}\n\n## Please keep the following in mind:\n\nEntry phrasing:\n\n- Ensure entries are concise and focused.\n- Ensure there are no vague phrases (e.g., avoid starting with \"Illustrates the something something...\"; instead, use direct details like \"The hanging green vines on the garden wall\").\n\nEnsure Clarity and Consistency:\n\n- Use clear, grammatically correct sentences.\n- Maintain a consistent tone and style throughout.\n\nEnrich Content:\n\n- Communicate additional information where appropriate to enhance depth and value.\n- If a mathematical, physical, or otherwise technical background is helpful, please provide it.\n- Ensure that the content is comprehensive and meets all requirements.\n\nFocus Language:\n\n- Use deliberate and precise language.\n- Avoid vague verbs and keep the maximally intelligent and detail oriented audience in mind. \n- We explicitly ban the words `hush`, `subtle`, `mythic`, and `aura`. Please keep your vocabulary choices rigorous.\n- Do not use modern cultural references \n- Do not generically reference ideas which do not belong in the global environment.\n\n## Present the Final JSON:\n\n- Format the output as a JSON object.\n- Include all fields properly named from the schema we sent you.\n\nEnsure Proper Formatting:\n\n- Use proper JSON syntax with keys and arrays.\n- Ensure that all entries are correctly placed in their respective places.\n\nProvide only the final JSON data as specified by the schema. \n\nDo not include any schema generation instructions, meta-fields, nested-templates (unless directly asked) or extraneous information. \n\nProvide only the populated fields and their values, conforming exactly to the required structure without embedding any intermediate annotations or placeholders.\n\nYour output should only consist of the JSON object. do *not* include a preamble or postamble to your response. \n\nWe seek to successfully parse your response directly as JSON.\n\nFor the final answer, output the result only as a valid JSON object, wrapped inside triple backticks with json immediately after the opening backticks.\nThe JSON must be parser-ready:\n– No additional text before or after the block\n– No markdown or prose outside the fenced block\n– No HTML escaping of quotes, slashes, or other characters\n– Indentation and whitespace preserved exactly as written\n– The content between the fences must be valid JSON as per RFC 8259","role":"system"},{"content":"We have a rust crate named 'bitcoin-network' 0.1.19. \n\nHere is the interface:\n/**\n| BIP155 network ids recognized by this\n| software.\n|\n*/\n#[repr(u8)]\npub enum BIP155Network {\n    IPV4,\n    IPV6,\n    TORV2,\n    TORV3,\n    I2P,\n    CJDNS,\n}\n\n\n/**\n| A network type.\n| \n| -----------\n| @note\n| An address may belong to more than one\n| network, for example `10.0.0.1` belongs\n| to both `NET_UNROUTABLE` and `NET_IPV4`.\n| Keep these sequential starting from\n| 0 and `NET_MAX` as the last entry.\n| We have loops like `for (int i = 0; i < NET_MAX;\n| ++i)` that expect to iterate over all\n| enum values and also `GetExtNetwork()`\n| \"extends\" this enum by introducing\n| standalone constants starting from\n| `NET_MAX`.\n|\n*/\n#[repr(u8)]\n#[derive(Copy,Debug,Serialize,Deserialize,Hash,PartialEq,Eq,Clone)]\npub enum Network {\n    NET_UNROUTABLE,\n    NET_IPV4,\n    NET_IPV6,\n    NET_ONION,\n    NET_I2P,\n    NET_CJDNS,\n    NET_INTERNAL,\n    NET_MAX,\n}\n\npub trait CheckIsReachable {\n    fn is_reachable(&self) -> bool;\n}\n\n/**\n| Network address.\n|\n*/\n#[derive(Builder,Setters,Getters,MutGetters,Debug,Serialize,Deserialize,Clone,Hash)]\n#[getset(get=\"pub\",set=\"pub\",get_mut=\"pub\")]\n#[builder(setter(into))]\npub struct NetAddr  {\n    addr:     PreVector<u8,ADDR_IPV6_SIZE>,\n    net:      Network,\n    scope_id: u32,\n}\n\npub fn torv3_checksum(addr_pubkey: &[u8], checksum: &mut [u8; TORV3_CHECKSUM_LEN]) {\n    // TORv3 CHECKSUM = H(\".onion checksum\" | PUBKEY | VERSION)[:2]\n    pub const PREFIX: &'static str = \".onion checksum\";\n\n    let mut hasher: SHA3_256 = SHA3_256::default();\n\n    hasher.write(PREFIX.as_bytes());\n    hasher.write(addr_pubkey);\n    hasher.write(TORV3_VERSION);\n\n    let mut checksum_full = [0_u8; SHA3_256_OUTPUT_SIZE];\n    hasher.finalize(&mut checksum_full);\n\n    checksum[0..TORV3_CHECKSUM_LEN].copy_from_slice(&checksum_full[0..TORV3_CHECKSUM_LEN]);\n}\n\n\n/**\n| @return\n| \n| The number of 1-bits in the prefix of\n| the specified subnet mask. If the specified\n| subnet mask is not a valid one, -1.\n|\n*/\n#[inline]\npub fn netmask_bits(x: u8) -> i32 {\n    match x {\n        0x00  =>  0,\n        0x80  =>  1,\n        0xc0  =>  2,\n        0xe0  =>  3,\n        0xf0  =>  4,\n        0xf8  =>  5,\n        0xfc  =>  6,\n        0xfe  =>  7,\n        0xff  =>  8,\n        _     => -1,\n    }\n}\n\n\npub fn onion_to_string(addr: &[u8]) -> String {\n    let mut checksum = [0_u8; TORV3_CHECKSUM_LEN];\n\n    torv3_checksum(addr, &mut checksum);\n\n    //  TORv3 onion_address = base32(PUBKEY | TORV3_CHECKSUM | TORV3_VERSION) + \".onion\"\n    let mut address: PreVector::<u8,{TORV3_TOTAL_LEN}> = PreVector::from(addr);\n\n    address.extend(checksum);\n    address.extend(TORV3_VERSION.iter().cloned());\n\n    format!(\n        \"{}.onion\", \n        encode_base32_bytes(\n            address.as_slice(),\n            Some(false)\n        )\n    )\n}\n\n\n/// Return an IPv6 address text representation with zero compression as described in RFC 5952 (\"A Recommendation for IPv6 Address Text Representation\").\n#[inline]\npub fn ipv6_to_string(a: &[u8], scope_id: u32) -> String {\n    debug!(target: \"netaddr\", bytes=?a, scope_id, \"Formatting IPv6 address\");\n    assert!(\n        a.len() == ADDR_IPV6_SIZE,\n        \"ipv6_to_string expects 16‑byte slice\"\n    );\n\n    let addr = std::net::Ipv6Addr::from(<[u8; 16]>::try_from(a).unwrap());\n    let mut s = addr.to_string(); // Rust's implementation follows RFC 5952\n\n    if scope_id != 0 {\n        s.push('%');\n        s.push_str(&scope_id.to_string());\n    }\n    s\n}\n\n\npub fn get_ext_network(maybe_addr: Option<&NetAddr>) -> i32 {\n    if maybe_addr.is_none() {\n        return NET_UNKNOWN;\n    }\n\n    let addr = maybe_addr.unwrap();\n\n    if addr.isrfc4380() {\n        return NET_TEREDO;\n    }\n\n    addr.get_network() as i32\n}\n\n\n/// Render an IPv4 address (`a[0]…a[3]`) as `d.d.d.d`.\n#[inline]\npub fn ipv4_to_string(a: &[u8]) -> String {\n    debug!(target: \"netaddr\", octets=?a, \"Formatting IPv4 address\");\n    assert!(a.len() == ADDR_IPV4_SIZE, \"ipv4_to_string expects 4 bytes\");\n    format!(\"{}.{}.{}.{}\", a[0], a[1], a[2], a[3])\n}\n\nimpl NetAddr {\n\n    /**\n    | Create an \"internal\" address that represents\n    | a name or FQDN. AddrMan uses these fake\n    | addresses to keep track of which DNS\n    | seeds were used.\n    | \n    | -----------\n    | @return\n    | Whether or not the operation was successful.\n    | @see NET_INTERNAL, INTERNAL_IN_IPV6_PREFIX,\n    | CNetAddr::IsInternal(), CNetAddr::IsRFC4193()\n    |\n    */\n    pub fn set_internal(&mut self, name: &str) -> bool {\n        trace!(target: \"netaddr\", \"SetInternal invoked\");\n        if name.is_empty() {\n            debug!(target: \"netaddr\", \"SetInternal: empty name rejected\");\n            return false;\n        }\n        *self.net_mut() = Network::NET_INTERNAL;\n    \n        // Derive the 10-byte internal key from a 32-byte digest of the name.\n        // We use the same digest carrier type (u256) as elsewhere for consistency.\n        let digest_u256: u256 = bitcoin_hash::hash1(name.as_bytes());\n        let digest_bytes: &[u8; 32] = digest_u256.as_ref();\n    \n        *self.addr_mut() = PreVector::from(&digest_bytes[..ADDR_INTERNAL_SIZE]);\n        debug!(target: \"netaddr\", \"SetInternal: derived INTERNAL address from name hash\");\n        true\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Whether this address has a linked IPv4\n    | address (see `get_linked_ipv4`).\n    |\n    */\n    #[inline]\n    pub fn has_linked_ipv4(&self) -> bool {\n        self.is_routable()\n            && (self.is_ipv4()\n                || self.isrfc6145()\n                || self.isrfc6052()\n                || self.isrfc3964()\n                || self.isrfc4380())\n    }\n\n    /// Extract the relevant IPv4 for mapped / tunnelled forms. Always returns\n    /// the address in network‑byte‑order.\n    /// \n    /// **Panics** if called when `has_linked_ipv4()` is false (same contract as\n    /// the C++ original).\n    ///\n    /// For IPv4, mapped IPv4, SIIT translated\n    /// IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address\n    /// as a uint32.\n    pub fn get_linked_ipv4(&self) -> u32 {\n        trace!(target: \"netaddr\", net = ?self.net(), \"Deriving linked IPv4\");\n        if self.is_ipv4() {\n            return read_be32(self.addr());\n        }\n    \n        if self.isrfc6052() || self.isrfc6145() {\n            // mapped IPv4, SIIT translated IPv4: the IPv4 address is the last 4 bytes of the address\n            return read_be32(&self.addr()[12..]);\n        }\n    \n        if self.isrfc3964() {\n            // 6to4 tunneled IPv4: the IPv4 address is in bytes 2-6\n            return read_be32(&self.addr()[2..6]);\n        }\n    \n        if self.isrfc4380() {\n            // Teredo tunneled IPv4: the IPv4 address is in the last 4 bytes of the address, but bitflipped\n            return !read_be32(&self.addr()[12..]);\n        }\n    \n        panic!(\"get_linked_ipv4() called on address without an embedded IPv4\");\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Serialize to a stream.\n    |\n    */\n    pub fn serialize<Stream>(&self, s: &mut Stream) where\n            Stream: bitcoin_bitstream::GetVersion,\n            for<'s> &'s mut Stream:\n                  core::ops::Shl<u8,  Output = &'s mut Stream>\n                + core::ops::Shl<u64, Output = &'s mut Stream>,\n            for<'s, 'a> &'s mut Stream:\n                  core::ops::Shl<&'a [u8], Output = &'s mut Stream>\n    {\n        trace!(target: \"netaddr\", \"NetAddr::serialize entry\");\n        // Preserve Core's feature-bit gate for ADDRv2 (BIP155).\n        let ver = s.get_version();\n        if (ver & ADDRV2_FORMAT) != 0 {\n            debug!(target: \"netaddr\", version = ver, \"Using ADDRv2 (BIP155) serialization\");\n            self.serialize_v2stream(s);\n        } else {\n            debug!(target: \"netaddr\", version = ver, \"Using legacy ADDRv1 serialization\");\n            self.serialize_v1stream(s);\n        }\n    }\n\n    /**\n    | Unserialize from a stream.\n    |\n    */\n    pub fn unserialize<Stream>(&mut self, s: &mut Stream) where\n            Stream: bitcoin_bitstream::GetVersion + bitcoin_bitstream::Backend,\n            for<'s, 'a> &'s mut Stream:\n                  core::ops::Shr<&'a mut [u8], Output = &'s mut Stream>\n                + core::ops::Shr<&'a mut u8,  Output = &'s mut Stream>\n                + core::ops::Shr<&'a mut u64, Output = &'s mut Stream>\n    {\n        trace!(target: \"netaddr\", \"NetAddr::unserialize entry\");\n        let ver = s.get_version();\n        if (ver & ADDRV2_FORMAT) != 0 {\n            debug!(target: \"netaddr\", version = ver, \"Using ADDRv2 (BIP155) unserialization\");\n            self.unserialize_v2stream(s);\n        } else {\n            debug!(target: \"netaddr\", version = ver, \"Using legacy ADDRv1 unserialization\");\n            self.unserialize_v1stream(s);\n        }\n    }\n\n    /**\n    | Serialize in pre-ADDRv2/BIP155 format\n    | to an array.\n    |\n    */\n    pub fn serialize_v1array(&self, arr: &mut [u8; NET_ADDR_V1_SERIALIZATION_SIZE]) {\n        trace!(target: \"netaddr\", net = ?self.get_net_class(), \"SerializeV1Array\");\n        match *self.net() {\n            Network::NET_IPV6 => {\n                assert_eq!(\n                    self.addr().len(),\n                    NET_ADDR_V1_SERIALIZATION_SIZE,\n                    \"IPv6 must be 16 bytes\"\n                );\n                arr.copy_from_slice(self.addr().as_slice());\n                debug!(target: \"netaddr\", \"V1 array: wrote bare IPv6\");\n                return;\n            }\n            Network::NET_IPV4 => {\n                let prefix_size = IPV4_IN_IPV6_PREFIX.len();\n                assert_eq!(\n                    prefix_size + self.addr().len(),\n                    NET_ADDR_V1_SERIALIZATION_SIZE,\n                    \"IPv4-in-IPv6 size mismatch\"\n                );\n                arr[..prefix_size].copy_from_slice(&IPV4_IN_IPV6_PREFIX);\n                arr[prefix_size..].copy_from_slice(self.addr().as_slice());\n                debug!(target: \"netaddr\", \"V1 array: wrote IPv4-in-IPv6\");\n                return;\n            }\n            Network::NET_INTERNAL => {\n                let prefix_size = INTERNAL_IN_IPV6_PREFIX.len();\n                assert_eq!(\n                    prefix_size + self.addr().len(),\n                    NET_ADDR_V1_SERIALIZATION_SIZE,\n                    \"INTERNAL-in-IPv6 size mismatch\"\n                );\n                arr[..prefix_size].copy_from_slice(&INTERNAL_IN_IPV6_PREFIX);\n                arr[prefix_size..].copy_from_slice(self.addr().as_slice());\n                debug!(target: \"netaddr\", \"V1 array: wrote INTERNAL-in-IPv6\");\n                return;\n            }\n            Network::NET_ONION | Network::NET_I2P | Network::NET_CJDNS => {\n                // fall-through to zero-fill below\n            }\n            Network::NET_UNROUTABLE | Network::NET_MAX => {\n                panic!(\"m_net is never and should not be set to NET_UNROUTABLE/NET_MAX\");\n            }\n        }\n    \n        // Serialize ONION, I2P and CJDNS as all-zeros.\n        arr.fill(0u8);\n        debug!(target: \"netaddr\", \"V1 array: wrote all-zeros for ONION/I2P/CJDNS\");\n    }\n\n    /**\n    | Serialize in pre-ADDRv2/BIP155 format\n    | to a stream.\n    |\n    */\n    pub fn serialize_v1stream<Stream>(&self, s: &mut Stream) where\n            for<'s, 'a> &'s mut Stream: core::ops::Shl<&'a [u8], Output = &'s mut Stream>\n    {\n        trace!(target: \"netaddr\", \"SerializeV1Stream\");\n        let mut serialized = [0u8; NET_ADDR_V1_SERIALIZATION_SIZE];\n        self.serialize_v1array(&mut serialized);\n        let _s = s << &serialized[..];\n        debug!(target: \"netaddr\", \"Wrote V1 array (16 bytes) to stream\");\n    }\n\n    /**\n    | Serialize as ADDRv2 / BIP155.\n    |\n    */\n    pub fn serialize_v2stream<Stream>(&self, s: &mut Stream) where\n            for<'s> &'s mut Stream:\n                  core::ops::Shl<u8,  Output = &'s mut Stream>\n                + core::ops::Shl<u64, Output = &'s mut Stream>,\n            for<'s, 'a> &'s mut Stream:\n                  core::ops::Shl<&'a [u8], Output = &'s mut Stream>\n    {\n        trace!(target: \"netaddr\", net = ?self.get_net_class(), \"SerializeV2Stream\");\n        if self.is_internal() {\n            // Serialize NET_INTERNAL as embedded in IPv6. We need to\n            // serialize such addresses from addrman.\n            let s = s << (BIP155Network::IPV6 as u8);\n            let s = s << (ADDR_IPV6_SIZE as u64); // CompactSize(16)\n            self.serialize_v1stream(s);           // writes the v1-encoded IPv6 payload\n            debug!(target: \"netaddr\", \"ADDRv2: wrote INTERNAL embedded as IPv6\");\n            return;\n        }\n    \n        let s = s << (self.get_bip155network() as u8);\n        // In ADDRv2, addresses are serialized as CompactSize length + raw bytes.\n        let s = s << (self.addr().len() as u64);\n        let _s = s << self.addr().as_slice();\n        debug!(\n            target: \"netaddr\",\n            addr_len = self.addr().len(),\n            \"ADDRv2: wrote (network id + varbytes)\"\n        );\n    }\n\n    /**\n    | Unserialize from a pre-ADDRv2/BIP155\n    | format from an array.\n    |\n    */\n    pub fn unserialize_v1array(&mut self, arr: &mut [u8; NET_ADDR_V1_SERIALIZATION_SIZE]) {\n        trace!(target: \"netaddr\", \"UnserializeV1Array\");\n        // Use SetLegacyIPv6() so that m_net is set correctly. For example\n        // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n        self.set_legacy_ipv6(arr);\n        debug!(target: \"netaddr\", net = ?self.get_net_class(), \"V1 array parsed via legacy IPv6 rules\");\n    }\n\n    /**\n    | Unserialize from a pre-ADDRv2/BIP155\n    | format from a stream.\n    |\n    */\n    pub fn unserialize_v1stream<Stream>(&mut self, s: &mut Stream) where\n            for<'s, 'a> &'s mut Stream: core::ops::Shr<&'a mut [u8], Output = &'s mut Stream>\n    {\n        trace!(target: \"netaddr\", \"UnserializeV1Stream\");\n        let mut serialized = [0u8; NET_ADDR_V1_SERIALIZATION_SIZE];\n        let _s = s >> &mut serialized[..];\n        self.unserialize_v1array(&mut serialized);\n        debug!(target: \"netaddr\", net = ?self.get_net_class(), \"V1 stream parsed\");\n    }\n\n    /**\n    | Unserialize from a ADDRv2 / BIP155 format.\n    |\n    */\n    pub fn unserialize_v2stream<Stream>(&mut self, s: &mut Stream) where\n            Stream: bitcoin_bitstream::Backend,\n            for<'s, 'a> &'s mut Stream:\n                  core::ops::Shr<&'a mut u8,  Output = &'s mut Stream>\n                + core::ops::Shr<&'a mut u64, Output = &'s mut Stream>\n                + core::ops::Shr<&'a mut [u8], Output = &'s mut Stream>\n    {\n        trace!(target: \"netaddr\", \"UnserializeV2Stream\");\n    \n        // Read network id (BIP155).\n        let mut bip155_net: u8 = 0;\n        let s = s >> &mut bip155_net;\n    \n        // Read CompactSize length into a u64, then convert.\n        let mut address_size_u64: u64 = 0;\n        let s = s >> &mut address_size_u64;\n    \n        let address_size_usize: usize = match usize::try_from(address_size_u64) {\n            Ok(v) => v,\n            Err(_) => {\n                error!(target: \"netaddr\", got = address_size_u64, \"ADDRv2 length does not fit in usize\");\n                panic!(\"Address too long to fit in usize: {}\", address_size_u64);\n            }\n        };\n    \n        if address_size_usize > BIP155_MAX_ADDRV2_SIZE {\n            error!(\n                target: \"netaddr\",\n                got = address_size_usize,\n                max = BIP155_MAX_ADDRV2_SIZE,\n                \"ADDRv2 address too long\"\n            );\n            panic!(\n                \"Address too long: {} > {}\",\n                address_size_usize, BIP155_MAX_ADDRV2_SIZE\n            );\n        }\n    \n        *self.scope_id_mut() = 0;\n    \n        if self.set_net_from_bip155network(bip155_net, address_size_usize) {\n            // Read exactly address_size bytes into m_addr.\n            let mut tmp = vec![0u8; address_size_usize];\n            let _s = s >> &mut tmp[..];\n            *self.addr_mut() = PreVector::from(tmp.as_slice());\n    \n            if *self.net() != Network::NET_IPV6 {\n                debug!(target: \"netaddr\", net = ?self.get_net_class(), \"Parsed non-IPv6 ADDRv2 address\");\n                return;\n            }\n    \n            // Do some special checks on IPv6 addresses.\n    \n            // Recognize NET_INTERNAL embedded in IPv6, such addresses are not\n            // gossiped but could be coming from addrman, when unserializing from\n            // disk.\n            if has_prefix(self.addr(), &INTERNAL_IN_IPV6_PREFIX) {\n                *self.net_mut() = Network::NET_INTERNAL;\n    \n                let prefix = INTERNAL_IN_IPV6_PREFIX.len();\n                let mut shrunk = [0u8; ADDR_INTERNAL_SIZE];\n                shrunk.copy_from_slice(&self.addr().as_slice()[prefix..prefix + ADDR_INTERNAL_SIZE]);\n                *self.addr_mut() = PreVector::from(&shrunk[..]);\n    \n                debug!(target: \"netaddr\", \"Detected INTERNAL-in-IPv6 and re-mapped to NET_INTERNAL\");\n                return;\n            }\n    \n            if !has_prefix(self.addr(), &IPV4_IN_IPV6_PREFIX)\n                && !has_prefix(self.addr(), &TORV2_IN_IPV6_PREFIX)\n            {\n                // Normal IPv6; keep as-is.\n                debug!(target: \"netaddr\", \"Parsed ordinary IPv6 ADDRv2 address\");\n                return;\n            }\n    \n            // IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1\n            // encoding). Unserialize as !IsValid(), thus ignoring them.\n            warn!(target: \"netaddr\", \"Found forbidden IPv4/TORv2 embedding in ADDRv2 IPv6 payload; marking invalid\");\n        } else {\n            // If we receive an unknown BIP155 network id (from the future?) then\n            // ignore the address - unserialize as !IsValid().\n            debug!(target: \"netaddr\", id = bip155_net, size = address_size_usize, \"Unknown BIP155 network id; skipping payload\");\n            s.ignore(address_size_usize);\n        }\n    \n        // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n        // will not be gossiped, but continue reading next addresses from the stream.\n        *self.net_mut() = Network::NET_IPV6;\n        *self.addr_mut() = PreVector::from(&[0u8; ADDR_IPV6_SIZE][..]);\n        debug!(target: \"netaddr\", \"Set NetAddr to !IsValid() placeholder (::)\");\n    }\n}\n\nimpl NetAddr {\n\n    pub fn setip(&mut self, ip_in: &NetAddr) {\n        trace!(target: \"netaddr\", src_net = ?ip_in.get_net_class(), \"Setting IP from another NetAddr\");\n        // Size check.\n        match *ip_in.net() {\n            Network::NET_IPV4 => {\n                assert_eq!(ip_in.addr().len(), ADDR_IPV4_SIZE, \"Expected 4-byte IPv4 address\");\n            }\n            Network::NET_IPV6 => {\n                assert_eq!(ip_in.addr().len(), ADDR_IPV6_SIZE, \"Expected 16-byte IPv6 address\");\n            }\n            Network::NET_ONION => {\n                assert_eq!(ip_in.addr().len(), ADDR_TORV3_SIZE, \"Expected 32-byte TORv3 address\");\n            }\n            Network::NET_I2P => {\n                assert_eq!(ip_in.addr().len(), ADDR_I2P_SIZE, \"Expected 32-byte I2P address\");\n            }\n            Network::NET_CJDNS => {\n                assert_eq!(ip_in.addr().len(), ADDR_CJDNS_SIZE, \"Expected 16-byte CJDNS address\");\n            }\n            Network::NET_INTERNAL => {\n                assert_eq!(ip_in.addr().len(), ADDR_INTERNAL_SIZE, \"Expected 10-byte INTERNAL address\");\n            }\n            Network::NET_UNROUTABLE | Network::NET_MAX => {\n                panic!(\"m_net is never and should not be set to NET_UNROUTABLE/NET_MAX\");\n            }\n        }\n    \n        *self.net_mut() = *ip_in.net();\n        *self.addr_mut() = PreVector::from(ip_in.addr().as_slice());\n        debug!(target: \"netaddr\", new_net = ?self.get_net_class(), \"IP set from source NetAddr\");\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Try to get our IPv4 address.\n    | \n    | -----------\n    | @param[out] pipv4Addr\n    | The in_addr struct to which to copy.\n    | @return\n    | Whether or not the operation was successful,\n    | in particular, whether or not our address\n    | was an IPv4 address. @see CNetAddr::IsIPv4()\n    |\n    */\n    #[inline]\n    pub fn get_in_addr(&self, pipv_4addr: *mut InAddr) -> bool {\n        trace!(target: \"netaddr\", \"Attempting IPv4 extraction via get_in_addr\");\n        if !self.is_ipv4() {\n            debug!(target: \"netaddr\", \"get_in_addr called on non‑IPv4 NetAddr\");\n            return false;\n        }\n        if pipv_4addr.is_null() {\n            error!(target: \"netaddr\", \"Null pointer passed to get_in_addr\");\n            return false;\n        }\n    \n        assert_eq!(\n            self.addr().len(),\n            ADDR_IPV4_SIZE,\n            \"IPv4 NetAddr must contain exactly four bytes\"\n        );\n    \n        // Safety: the caller guarantees that `pipv_4addr` points to valid, writable\n        //         memory large enough for four bytes.\n        unsafe {\n            std::ptr::copy_nonoverlapping(\n                self.addr().as_ptr(), \n                pipv_4addr as *mut u8, \n                ADDR_IPV4_SIZE\n            );\n        }\n        true\n    }\n\n    /**\n    | Try to get our IPv6 address.\n    | \n    | -----------\n    | @param[out] pipv6Addr\n    | The in6_addr struct to which to copy.\n    | @return\n    | Whether or not the operation was successful,\n    | in particular, whether or not our address\n    | was an IPv6 address. @see CNetAddr::IsIPv6()\n    |\n    */\n    #[inline]\n    pub fn get_in_6addr(&self, pipv_6addr: *mut In6Addr) -> bool {\n        trace!(target: \"netaddr\", \"Attempting IPv6 extraction via get_in_6addr\");\n        if !self.is_ipv6() {\n            debug!(target: \"netaddr\", \"get_in_6addr called on non‑IPv6 NetAddr\");\n            return false;\n        }\n        if pipv_6addr.is_null() {\n            error!(target: \"netaddr\", \"Null pointer passed to get_in_6addr\");\n            return false;\n        }\n    \n        assert_eq!(\n            self.addr().len(),\n            ADDR_IPV6_SIZE,\n            \"IPv6 NetAddr must contain exactly sixteen bytes\"\n        );\n    \n        // Safety: the caller guarantees that `pipv_6addr` points to valid, writable\n        //         memory large enough for sixteen bytes.\n        unsafe {\n            std::ptr::copy_nonoverlapping(\n                self.addr().as_ptr(), \n                pipv_6addr as *mut u8, \n                ADDR_IPV6_SIZE\n            );\n        }\n    \n        true\n    }\n}\n\nimpl Default for NetAddr {\n\n    /**\n    | Construct an unspecified IPv6 network\n    | address (::/128).\n    | \n    | -----------\n    | @note\n    | This address is considered invalid\n    | by\n    | CNetAddr::IsValid()\n    |\n    */\n    fn default() -> Self {\n        Self {\n            addr:     PreVector::with_capacity(ADDR_IPV6_SIZE),\n            net:      Network::NET_IPV6,\n            scope_id: 0,\n        }\n    }\n}\n\nimpl PartialEq<NetAddr> for NetAddr {\n\n    #[inline]\n    fn eq(&self, other: &NetAddr) -> bool {\n        trace!(\n            target: \"netaddr\",\n            ours  = ?self.net(),\n            theirs = ?other.net(),\n            \"Comparing NetAddr equality\"\n        );\n        *self.net() == *other.net() && self.addr() == other.addr()\n    }\n}\n\nimpl Eq for NetAddr {}\n\nimpl Ord for NetAddr {\n\n    #[inline]\n    fn cmp(&self, other: &NetAddr) -> std::cmp::Ordering {\n        use std::cmp::Ordering;\n    \n        // First compare the network type; if those are equal,\n        // fall back to a lexicographic comparison of the raw bytes.\n        let by_net = (*self.net() as u8).cmp(&(*other.net() as u8));\n        if by_net == Ordering::Equal {\n            self.addr().cmp(other.addr())\n        } else {\n            by_net\n        }\n    }\n}\n\nimpl PartialOrd<NetAddr> for NetAddr {\n\n    #[inline]\n    fn partial_cmp(&self, other: &NetAddr) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl From<&InAddr> for NetAddr {\n\n    fn from(ipv4_addr: &InAddr) -> Self {\n        trace!(target: \"netaddr\", \"Constructing NetAddr from InAddr (IPv4)\");\n        // Safety: an `InAddr` is exactly four bytes in network byte‑order.\n        let bytes = unsafe {\n            std::slice::from_raw_parts(ipv4_addr as *const _ as *const u8, ADDR_IPV4_SIZE)\n        };\n        NetAddrBuilder::default()\n            .addr(PreVector::from(bytes))\n            .net(Network::NET_IPV4)\n            .scope_id(0_u32)\n            .build()\n            .expect(\"building IPv4 NetAddr never fails\")\n    }\n}\n\nimpl NetAddr {\n\n    pub fn new(ipv_6addr: &In6Addr, scope: Option<u32>) -> Self {\n        trace!(target: \"netaddr\", scope = scope.unwrap_or(0), \"Constructing NetAddr from legacy IPv6\");\n        // Safety: In6Addr is exactly 16 bytes.\n        let bytes = unsafe {\n            std::slice::from_raw_parts(ipv_6addr as *const _ as *const u8, ADDR_IPV6_SIZE)\n        };\n    \n        let mut out = NetAddr::default();\n        out.set_legacy_ipv6(bytes);\n        *out.scope_id_mut() = scope.unwrap_or(0);\n        debug!(target: \"netaddr\", net = ?out.get_net_class(), \"Constructed NetAddr from IPv6 input\");\n        out\n    }\n\n    pub fn get_addr_bytes(&self) -> Vec<u8> {\n        trace!(target: \"netaddr\", net = ?self.get_net_class(), \"Computing NetAddr::get_addr_bytes\");\n        if self.is_addr_v1compatible() {\n            let mut serialized = [0u8; NET_ADDR_V1_SERIALIZATION_SIZE];\n            self.serialize_v1array(&mut serialized);\n            debug!(target: \"netaddr\", \"Serialized in legacy (v1) ADDR format\");\n            serialized.to_vec()\n        } else {\n            debug!(target: \"netaddr\", len = self.addr().len(), \"Returning raw address bytes\");\n            self.addr().as_slice().to_vec()\n        }\n    }\n\n    pub fn get_hash(&self) -> u64 {\n        trace!(target: \"netaddr\", \"Computing NetAddr::get_hash (Core-compatible double-SHA256)\");\n    \n        // Compute the 256-bit double-SHA256 of the raw address bytes.\n        let hash: u256 = bitcoin_hash::hash1(self.addr().as_slice());\n    \n        // Disambiguate the AsRef target so the compiler knows we're after the raw 32 bytes.\n        let bytes: &[u8; 32] = hash.as_ref();\n    \n        // Interpret the first 8 bytes of the hash as a little-endian u64.\n        let mut tmp = [0u8; 8];\n        tmp.copy_from_slice(&bytes[..8]);\n        let nret = u64::from_le_bytes(tmp);\n    \n        debug!(target: \"netaddr\", hash = ?hash, hash64 = nret, \"Derived 64-bit NetAddr hash\");\n        nret\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Parse an I2P address and set this object\n    | to it.\n    | \n    | -----------\n    | @param[in] addr\n    | Address to parse, must be a valid C string,\n    | for example ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n    | @return\n    | Whether the operation was successful.\n    | @see CNetAddr::IsI2P()\n    |\n    */\n    pub fn seti2p(&mut self, addr: &String) -> bool {\n        trace!(target: \"netaddr\", address = addr, \"SetI2P\");\n        // I2P addresses that we support consist of 52 base32 characters + \".b32.i2p\".\n        const B32_LEN: usize = 52;\n        const SUFFIX: &str = \".b32.i2p\";\n        const SUFFIX_LEN: usize = 8;\n    \n        if addr.len() != B32_LEN + SUFFIX_LEN || addr[B32_LEN..].to_ascii_lowercase() != SUFFIX {\n            debug!(target: \"netaddr\", \"SetI2P: length/suffix check failed\");\n            return false;\n        }\n    \n        let b32 = &addr[..B32_LEN];\n    \n        let mut invalid = false;\n        let address_bytes: Vec<u8> =\n            bitcoin_string::decode_base32_bytes_nopad_lower(b32, Some(&mut invalid as *mut bool));\n    \n        if invalid || address_bytes.len() != ADDR_I2P_SIZE {\n            debug!(target: \"netaddr\", invalid, got = address_bytes.len(), \"SetI2P: base32 decode failed or wrong length\");\n            return false;\n        }\n    \n        *self.net_mut() = Network::NET_I2P;\n        *self.addr_mut() = PreVector::from(address_bytes.as_slice());\n        debug!(target: \"netaddr\", \"SetI2P: parsed destination successfully\");\n        true\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Calculates a metric for how reachable\n    | (*this) is from a given partner\n    |\n    */\n    pub fn get_reachability_from(&self, paddr_partner: *const NetAddr) -> i32 {\n        trace!(\n            target: \"netaddr\", \n            ours_net = ?self.get_net_class(), \n            \"Computing reachability score from peer\"\n        );\n    \n        // Reachability categories (kept as integers to mirror the original control flow)\n        const REACH_UNREACHABLE: i32 = 0;\n        const REACH_DEFAULT:     i32 = 1;\n        const REACH_TEREDO:      i32 = 2;\n        const REACH_IPV6_WEAK:   i32 = 3;\n        const REACH_IPV4:        i32 = 4;\n        const REACH_IPV6_STRONG: i32 = 5;\n        const REACH_PRIVATE:     i32 = 6;\n    \n        if !self.is_routable() || self.is_internal() {\n            debug!(target: \"netaddr\", \"Our address is not routable or is internal → unreachable\");\n            return REACH_UNREACHABLE;\n        }\n    \n        let our_net  = get_ext_network(Some(self));\n    \n        let their_net = unsafe {\n            if paddr_partner.is_null() {\n                get_ext_network(None)\n            } else {\n                get_ext_network(Some(&*paddr_partner))\n            }\n        };\n    \n        let f_tunnel = self.isrfc3964() || self.isrfc6052() || self.isrfc6145();\n    \n        debug!(\n            target: \"netaddr\", \n            our_net, \n            their_net, \n            f_tunnel, \n            \"Extended networks and tunnel status\"\n        );\n    \n        match their_net {\n            x if x == Network::NET_IPV4 as i32 => {\n                match our_net {\n                    y if y == Network::NET_IPV4 as i32 => REACH_IPV4,\n                    _ => REACH_DEFAULT,\n                }\n            }\n            x if x == Network::NET_IPV6 as i32 => {\n                match our_net {\n                    y if y == NET_TEREDO => REACH_TEREDO,\n                    y if y == Network::NET_IPV4 as i32 => REACH_IPV4,\n                    y if y == Network::NET_IPV6 as i32 => {\n                        if f_tunnel { REACH_IPV6_WEAK } else { REACH_IPV6_STRONG }\n                    }\n                    _ => REACH_DEFAULT,\n                }\n            }\n            x if x == Network::NET_ONION as i32 => {\n                match our_net {\n                    y if y == Network::NET_IPV4 as i32 => REACH_IPV4, // Tor users can connect to IPv4 as well\n                    y if y == Network::NET_ONION as i32 => REACH_PRIVATE,\n                    _ => REACH_DEFAULT,\n                }\n            }\n            x if x == Network::NET_I2P as i32 => {\n                match our_net {\n                    y if y == Network::NET_I2P as i32 => REACH_PRIVATE,\n                    _ => REACH_DEFAULT,\n                }\n            }\n            x if x == NET_TEREDO => {\n                match our_net {\n                    y if y == NET_TEREDO => REACH_TEREDO,\n                    y if y == Network::NET_IPV6 as i32 => REACH_IPV6_WEAK,\n                    y if y == Network::NET_IPV4 as i32 => REACH_IPV4,\n                    _ => REACH_DEFAULT,\n                }\n            }\n            _ => {\n                // NET_UNKNOWN or NET_UNROUTABLE or any other\n                match our_net {\n                    y if y == NET_TEREDO => REACH_TEREDO,\n                    y if y == Network::NET_IPV6 as i32 => REACH_IPV6_WEAK,\n                    y if y == Network::NET_IPV4 as i32 => REACH_IPV4,\n                    y if y == Network::NET_ONION as i32 => REACH_PRIVATE, // either from Tor, or don't care about our address\n                    _ => REACH_DEFAULT,\n                }\n            }\n        }\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Parse a Tor or I2P address and set this\n    | object to it.\n    | \n    | -----------\n    | @param[in] addr\n    | Address to parse, for example pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion\n    | or ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.\n    | @return\n    | Whether the operation was successful.\n    | @see CNetAddr::IsTor(), CNetAddr::IsI2P()\n    |\n    */\n    pub fn set_special(&mut self, addr: &String) -> bool {\n        trace!(target: \"netaddr\", address = addr, \"SetSpecial\");\n        if !valid_as_cstring(addr) {\n            debug!(target: \"netaddr\", \"SetSpecial: not a valid C string\");\n            return false;\n        }\n    \n        if self.set_tor(addr) {\n            return true;\n        }\n    \n        if self.seti2p(addr) {\n            return true;\n        }\n    \n        false\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | The AS on the BGP path to the node we use\n    | to diversify peers in AddrMan bucketing\n    | based on the AS infrastructure.\n    |\n    | The ip->AS mapping depends on how asmap is\n    | constructed.\n    */\n    pub fn get_mappedas(&self, asmap: &Vec<bool>) -> u32 {\n        trace!(\n            target: \"netaddr\", \n            asmap_len = asmap.len(), \n            net = ?self.get_net_class(), \n            \"Deriving mapped AS number\"\n        );\n    \n        let net_class = self.get_net_class();\n    \n        if asmap.is_empty() || (net_class != Network::NET_IPV4 && net_class != Network::NET_IPV6) {\n            // Indicates not found, safe because AS0 is reserved per RFC7607.\n            debug!(target: \"netaddr\", \"No asmap or non-IPv4/IPv6 address → returning AS0\");\n            return 0;\n        }\n    \n        // Build 128-bit view of the IP per Bitcoin Core's Interpret() convention.\n        let mut ip_bits = vec![false; 128];\n    \n        if self.has_linked_ipv4() {\n            // Treat as if it was just an IPv4 address (IPV4_IN_IPV6_PREFIX + IPv4 bits)\n            for (byte_i, b) in IPV4_IN_IPV6_PREFIX.iter().enumerate() {\n                for bit_i in 0..8 {\n                    ip_bits[byte_i * 8 + bit_i] = ((b >> (7 - bit_i)) & 1) == 1;\n                }\n            }\n            let ipv4 = self.get_linked_ipv4();\n            for i in 0..32 {\n                ip_bits[96 + i] = ((ipv4 >> (31 - i)) & 1) == 1;\n            }\n        } else {\n            // Use all 128 bits of the IPv6 address otherwise\n            assert!(self.is_ipv6(), \"Expected IPv6 address when no linked IPv4 is present\");\n            for byte_i in 0..16 {\n                let cur = self.addr().as_slice()[byte_i];\n                for bit_i in 0..8 {\n                    ip_bits[byte_i * 8 + bit_i] = ((cur >> (7 - bit_i)) & 1) == 1;\n                }\n            }\n        }\n    \n        // Use the asmap interpreter from bitcoin-asmap.\n        let mapped_as: u32 = bitcoin_asmap::interpret(asmap.as_slice(), &ip_bits);\n        debug!(target: \"netaddr\", mapped_as, \"Mapped AS computed\");\n        mapped_as\n    }\n}\n\nimpl NetAddr {\n\n    /// “Reachability network” for outbound selection.\n    #[inline]\n    pub fn get_network(&self) -> Network {\n        if self.is_internal() {\n            return Network::NET_INTERNAL;\n        }\n        if !self.is_routable() {\n            return Network::NET_UNROUTABLE;\n        }\n        *self.net()\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Set from a legacy IPv6 address.\n    | \n    | Legacy IPv6 address may be a normal IPv6\n    | address, or another address (e.g. IPv4)\n    | disguised as IPv6.\n    | This encoding is used in the legacy `addr`\n    | encoding.\n    |\n    */\n    pub fn set_legacy_ipv6(&mut self, ipv6: &[u8]) {\n        trace!(target: \"netaddr\", input_len = ipv6.len(), \"Setting from legacy IPv6\");\n    \n        assert_eq!(ipv6.len(), ADDR_IPV6_SIZE, \"Legacy IPv6 input must be 16 bytes\");\n    \n        let mut skip: usize = 0;\n    \n        if ipv6.starts_with(&IPV4_IN_IPV6_PREFIX) {\n            // IPv4-in-IPv6\n            *self.net_mut() = Network::NET_IPV4;\n            skip = IPV4_IN_IPV6_PREFIX.len();\n            debug!(target: \"netaddr\", \"Detected IPv4-in-IPv6 mapping\");\n        } else if ipv6.starts_with(&TORV2_IN_IPV6_PREFIX) {\n            // TORv2-in-IPv6 (unsupported). Unserialize as !IsValid(), thus ignoring them.\n            // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n            // will not be gossiped, but continue reading next addresses from the stream.\n            *self.net_mut() = Network::NET_IPV6;\n            *self.addr_mut() = PreVector::from(&[0u8; ADDR_IPV6_SIZE][..]);\n            warn!(target: \"netaddr\", \"Detected deprecated TORv2-in-IPv6; setting to invalid IPv6 (::)\");\n            return;\n        } else if ipv6.starts_with(&INTERNAL_IN_IPV6_PREFIX) {\n            // Internal-in-IPv6\n            *self.net_mut() = Network::NET_INTERNAL;\n            skip = INTERNAL_IN_IPV6_PREFIX.len();\n            debug!(target: \"netaddr\", \"Detected INTERNAL-in-IPv6 mapping\");\n        } else {\n            // IPv6\n            *self.net_mut() = Network::NET_IPV6;\n            debug!(target: \"netaddr\", \"Detected plain IPv6 address\");\n        }\n    \n        *self.addr_mut() = PreVector::from(&ipv6[skip..]);\n        debug!(target: \"netaddr\", net = ?self.get_net_class(), addr_len = self.addr().len(), \"Legacy IPv6 set complete\");\n    }\n}\n\nimpl CheckIsReachable for Network {\n\n    /**\n    | @return\n    | \n    | true if the network is reachable, false\n    | otherwise\n    |\n    */\n    fn is_reachable(&self) -> bool {\n        todo!();\n        /*\n        LOCK(cs_mapLocalHost);\n        return !vfLimited[net];\n        */\n    }\n}\n\nimpl CheckIsReachable for NetAddr {\n\n    /**\n    | @return\n    | \n    | true if the address is in a reachable\n    | network, false otherwise\n    |\n    */\n    fn is_reachable(&self) -> bool {\n        self.get_network().is_reachable()\n    }\n}\n\nimpl NetAddr {\n\n    /// Categorise the address for AddrMan bucketing.\n    #[inline]\n    pub fn get_net_class(&self) -> Network {\n        // Make sure that if we return NET_IPV6, then IsIPv6() is true. The\n        // callers expect that.\n        //\n        // Check for \"internal\" first because such addresses are also\n        // !IsRoutable() and we don't want to return NET_UNROUTABLE in that\n        // case.\n        //\n        if self.is_internal() {\n            return Network::NET_INTERNAL;\n        }\n        if !self.is_routable() {\n            return Network::NET_UNROUTABLE;\n        }\n        if self.has_linked_ipv4() {\n            return Network::NET_IPV4; // treat mapped/tunnelled as IPv4\n        }\n        *self.net()\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Whether this address should be relayed\n    | to other peers even if we can't reach\n    | it ourselves.\n    */\n    #[inline]\n    pub fn is_relayable(&self) -> bool {\n        self.is_ipv4() || self.is_ipv6() || self.is_tor() || self.isi2p()\n    }\n\n    /**\n    | INADDR_ANY equivalent (`0.0.0.0` or `::`)\n    */\n    pub fn is_bind_any(&self) -> bool {\n        if !(self.is_ipv4() || self.is_ipv6()) {\n            return false;\n        }\n        self.addr().iter().all(|b| *b == 0)\n    }\n\n    /**\n    | IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n    */\n    #[inline]\n    pub fn is_ipv4(&self) -> bool {\n        trace!(\n            target: \"netaddr\",\n            net = ?self.net(),\n            \"Checking IPv4 network classification\"\n        );\n        *self.net() == Network::NET_IPV4\n    }\n\n    /**\n    | IPv6 address (not mapped IPv4, not Tor)\n    */\n    #[inline]\n    pub fn is_ipv6(&self) -> bool {\n        trace!(\n            target: \"netaddr\",\n            net = ?self.net(),\n            \"Checking IPv6 network classification\"\n        );\n        *self.net() == Network::NET_IPV6\n    }\n\n    /**\n    | IPv6 Hurricane Electric - https://he.net\n    | (2001:0470::/36)\n    |\n    */\n    #[inline]\n    pub fn is_he_net(&self) -> bool {\n        self.is_ipv6() && has_prefix(self.addr(), &[0x20, 0x01, 0x04, 0x70])\n    }\n\n    /**\n    | Check whether this object represents\n    | a TOR address. see `NetAddr::set_special`\n    */\n    #[inline]\n    pub fn is_tor(&self) -> bool {\n        trace!(\n            target: \"netaddr\",\n            net = ?self.net(),\n            \"Checking Tor network classification\"\n        );\n        *self.net() == Network::NET_ONION\n    }\n\n    /**\n    | True for IPv4 127/8, IPv4 0/8 and IPv6 ::1\n    */\n    pub fn is_local(&self) -> bool {\n        // IPv4 loopback (127.0.0.0/8 or 0.0.0.0/8)\n        if self.is_ipv4() {\n            let a = self.addr();\n            return a[0] == 127 || a[0] == 0;\n        }\n    \n        // IPv6 loopback (::1/128)\n        if self.is_ipv6() {\n            static LOOPBACK_V6: [u8; 16] =\n                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n            return **self.addr() == LOOPBACK_V6;\n        }\n        false\n    }\n\n    /**\n    | @note\n    | \n    | A valid address may or may not be publicly\n    | routable on the global internet. As\n    | in, the set of valid addresses is a superset\n    | of the set of publicly routable addresses.\n    | @see CNetAddr::IsRoutable()\n    | -----------\n    | @return\n    | Whether or not this network address\n    | is a valid address that @a could be used\n    | to refer to an actual host.\n    |\n    */\n    pub fn is_valid(&self) -> bool {\n        // ::/128 (all‑zero IPv6) is invalid\n        if self.is_ipv6() && self.addr().iter().all(|b| *b == 0) {\n            return false;\n        }\n    \n        // CJDNS must start with 0xFC\n        if self.iscjdns() && self.addr()[0] != 0xFC {\n            return false;\n        }\n    \n        // Documentation IPv6\n        if self.isrfc3849() {\n            return false;\n        }\n    \n        if self.is_internal() {\n            return false;\n        }\n    \n        if self.is_ipv4() {\n            let v = read_be32(self.addr());\n            const INADDR_ANY: u32 = 0x0000_0000;\n            const INADDR_NONE: u32 = 0xFFFF_FFFF;\n            if v == INADDR_ANY || v == INADDR_NONE {\n                return false;\n            }\n        }\n    \n        true\n    }\n\n    /**\n    | @note\n    | \n    | A routable address is always valid.\n    | As in, the set of routable addresses\n    | is a subset of the set of valid addresses.\n    | @see CNetAddr::IsValid()\n    | -----------\n    | @return\n    | Whether or not this network address\n    | is publicly routable on the global internet.\n    |\n    */\n    pub fn is_routable(&self) -> bool {\n        self.is_valid()\n            && !(self.isrfc1918()\n                || self.isrfc2544()\n                || self.isrfc3927()\n                || self.isrfc4862()\n                || self.isrfc6598()\n                || self.isrfc5737()\n                || self.isrfc4193()\n                || self.isrfc4843()\n                || self.isrfc7343()\n                || self.is_local()\n                || self.is_internal())\n    }\n\n    /**\n    | @return\n    | \n    | Whether or not this is a dummy address\n    | that represents a name. @see CNetAddr::SetInternal(const\n    | std::string &)\n    |\n    */\n    #[inline]\n    pub fn is_internal(&self) -> bool {\n        *self.net() == Network::NET_INTERNAL\n    }\n\n    /**\n    | Check if the current object can be serialized\n    | in pre-ADDRv2/BIP155 format.\n    |\n    */\n    pub fn is_addr_v1compatible(&self) -> bool {\n        if matches!(*self.net(), Network::NET_MAX | Network::NET_UNROUTABLE ) {\n            assert!(false, \"m_net is never and should not be set to NET_UNROUTABLE\");\n        }\n    \n        matches!(\n            *self.net(),\n            Network::NET_IPV4 | Network::NET_IPV6 | Network::NET_INTERNAL\n        )\n    }\n\n    /**\n    | IPv4 private networks (10.0.0.0/8,\n    | 192.168.0.0/16, 172.16.0.0/12)\n    |\n    */\n    #[inline]\n    pub fn isrfc1918(&self) -> bool {\n        self.is_ipv4()\n            && matches!(\n                (self.addr()[0], self.addr()[1]),\n                (10, _) | (192, 168) | (172, 16..=31)\n            )\n    }\n\n    /**\n    | IPv4 inter-network communications\n    | (198.18.0.0/15)\n    |\n    */\n    #[inline]\n    pub fn isrfc2544(&self) -> bool {\n        self.is_ipv4() && self.addr()[0] == 198 && matches!(self.addr()[1], 18 | 19)\n    }\n\n    /**\n    | IPv4 autoconfig (169.254.0.0/16)\n    |\n    */\n    #[inline]\n    pub fn isrfc3927(&self) -> bool {\n        self.is_ipv4() && has_prefix(self.addr(), &[169, 254])\n    }\n\n    /**\n    | IPv4 ISP-level NAT (100.64.0.0/10)\n    |\n    */\n    #[inline]\n    pub fn isrfc6598(&self) -> bool {\n        self.is_ipv4() && self.addr()[0] == 100 && (64..=127).contains(&self.addr()[1])\n    }\n\n    /**\n    | IPv4 documentation addresses (192.0.2.0/24,\n    | 198.51.100.0/24, 203.0.113.0/24)\n    |\n    */\n    #[inline]\n    pub fn isrfc5737(&self) -> bool {\n        self.is_ipv4()\n            && (has_prefix(self.addr(), &[192, 0, 2])\n                || has_prefix(self.addr(), &[198, 51, 100])\n                || has_prefix(self.addr(), &[203, 0, 113]))\n    }\n\n    /**\n    | IPv6 documentation address (2001:0DB8::/32)\n    |\n    */\n    #[inline]\n    pub fn isrfc3849(&self) -> bool {\n        self.is_ipv6() && has_prefix(self.addr(), &[0x20, 0x01, 0x0D, 0xB8])\n    }\n\n    /**\n    | IPv6 6to4 tunnelling (2002::/16)\n    |\n    */\n    #[inline]\n    pub fn isrfc3964(&self) -> bool {\n        self.is_ipv6() && has_prefix(self.addr(), &[0x20, 0x02])\n    }\n\n    /**\n    | IPv6 well-known prefix for IPv4-embedded\n    | address (64:FF9B::/96)\n    |\n    */\n    #[inline]\n    pub fn isrfc6052(&self) -> bool {\n        self.is_ipv6()\n            && has_prefix(\n                self.addr(),\n                &[0x00, 0x64, 0xFF, 0x9B, 0, 0, 0, 0, 0, 0, 0, 0],\n            )\n    }\n\n    /**\n    | IPv6 Teredo tunnelling (2001::/32)\n    |\n    */\n    #[inline]\n    pub fn isrfc4380(&self) -> bool {\n        self.is_ipv6() && has_prefix(self.addr(), &[0x20, 0x01, 0x00, 0x00])\n    }\n\n    /**\n    | IPv6 autoconfig (FE80::/64)\n    |\n    */\n    #[inline]\n    pub fn isrfc4862(&self) -> bool {\n        self.is_ipv6() && has_prefix(self.addr(), &[0xFE, 0x80, 0, 0, 0, 0, 0, 0])\n    }\n\n    /**\n    | IPv6 unique local (FC00::/7)\n    |\n    */\n    #[inline]\n    pub fn isrfc4193(&self) -> bool {\n        self.is_ipv6() && (self.addr()[0] & 0xFE) == 0xFC\n    }\n\n    /**\n    | IPv6 IPv4-translated address (::FFFF:0:0:0/96)\n    | (actually defined in RFC2765)\n    |\n    */\n    #[inline]\n    pub fn isrfc6145(&self) -> bool {\n        self.is_ipv6()\n            && has_prefix(\n                self.addr(),\n                &[0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0x00, 0x00],\n            )\n    }\n\n    /**\n    | IPv6 ORCHID (deprecated) (2001:10::/28)\n    |\n    */\n    #[inline]\n    pub fn isrfc4843(&self) -> bool {\n        self.is_ipv6()\n            && has_prefix(self.addr(), &[0x20, 0x01, 0x00])\n            && (self.addr()[3] & 0xF0) == 0x10\n    }\n\n    /**\n    | IPv6 ORCHIDv2 (2001:20::/28)\n    |\n    */\n    #[inline]\n    pub fn isrfc7343(&self) -> bool {\n        self.is_ipv6()\n            && has_prefix(self.addr(), &[0x20, 0x01, 0x00])\n            && (self.addr()[3] & 0xF0) == 0x20\n    }\n\n    /**\n    | Check whether this object represents\n    | an I2P address.\n    |\n    */\n    #[inline]\n    pub fn isi2p(&self) -> bool {\n        trace!(\n            target: \"netaddr\",\n            net = ?self.net(),\n            \"Checking I2P network classification\"\n        );\n        *self.net() == Network::NET_I2P\n    }\n\n    /**\n    | Check whether this object represents\n    | a CJDNS address.\n    |\n    */\n    #[inline]\n    pub fn iscjdns(&self) -> bool {\n        trace!(\n            target: \"netaddr\",\n            net = ?self.net(),\n            \"Checking CJDNS network classification\"\n        );\n        *self.net() == Network::NET_CJDNS\n    }\n}\n\nimpl NetAddr {\n\n    /// Get the BIP155 network id of this address.\n    /// \n    /// **Panics** if called for an `NET_INTERNAL` object (the caller must ensure that case never\n    /// happens – exactly like the original C++ code). @return\n    /// BIP155 network id, except TORV2 which is no longer supported.\n    ///\n    #[inline]\n    pub fn get_bip155network(&self) -> BIP155Network {\n        trace!(target: \"netaddr\", net = ?self.net(), \"Deriving BIP155 network id\");\n        match *self.net() {\n            Network::NET_IPV4     => BIP155Network::IPV4,\n            Network::NET_IPV6     => BIP155Network::IPV6,\n            Network::NET_ONION    => BIP155Network::TORV3,\n            Network::NET_I2P      => BIP155Network::I2P,\n            Network::NET_CJDNS    => BIP155Network::CJDNS,\n            Network::NET_INTERNAL | Network::NET_UNROUTABLE | Network::NET_MAX => {\n                panic!(\"get_bip155network() called for invalid network variant\")\n            }\n        }\n    }\n\n    /// Validate `(id,size)` and set `self.net` accordingly.\n    /// \n    /// Returns `true` for a *known* and *well‑sized* founding network id (1‥6).  \n    ///\n    /// Returns `false` for an *unknown* id (from the future).  \n    /// **Panics** on founding ids with a mismatching size – faithful to the C++\n    /// behaviour.\n    pub fn set_net_from_bip155network(&mut self, possible_bip155_net: u8, address_size: usize) -> bool {\n        debug!(\n            target: \"netaddr\",\n            id = possible_bip155_net,\n            size = address_size,\n            \"Mapping BIP155 id to internal Network\"\n        );\n        match possible_bip155_net {\n            x if x == BIP155Network::IPV4 as u8 => {\n                if address_size == ADDR_IPV4_SIZE {\n                    self.set_net(Network::NET_IPV4);\n                    true\n                } else {\n                    panic!(\n                        \"BIP155 IPv4 address with length {} (expected {})\",\n                        address_size, ADDR_IPV4_SIZE\n                    );\n                }\n            }\n            x if x == BIP155Network::IPV6 as u8 => {\n                if address_size == ADDR_IPV6_SIZE {\n                    self.set_net(Network::NET_IPV6);\n                    true\n                } else {\n                    panic!(\n                        \"BIP155 IPv6 address with length {} (expected {})\",\n                        address_size, ADDR_IPV6_SIZE\n                    );\n                }\n            }\n            x if x == BIP155Network::TORV3 as u8 => {\n                if address_size == ADDR_TORV3_SIZE {\n                    self.set_net(Network::NET_ONION);\n                    true\n                } else {\n                    panic!(\n                        \"BIP155 TORv3 address with length {} (expected {})\",\n                        address_size, ADDR_TORV3_SIZE\n                    );\n                }\n            }\n            x if x == BIP155Network::I2P as u8 => {\n                if address_size == ADDR_I2P_SIZE {\n                    self.set_net(Network::NET_I2P);\n                    true\n                } else {\n                    panic!(\n                        \"BIP155 I2P address with length {} (expected {})\",\n                        address_size, ADDR_I2P_SIZE\n                    );\n                }\n            }\n            x if x == BIP155Network::CJDNS as u8 => {\n                if address_size == ADDR_CJDNS_SIZE {\n                    self.set_net(Network::NET_CJDNS);\n                    true\n                } else {\n                    panic!(\n                        \"BIP155 CJDNS address with length {} (expected {})\",\n                        address_size, ADDR_CJDNS_SIZE\n                    );\n                }\n            }\n            // Unknown / future network id – silently ignore.\n            //\n            // Don't throw on addresses with unknown network ids (maybe from the future).\n            // Instead silently drop them and have the unserialization code consume\n            // subsequent ones which may be known to us.\n            _ => false,\n        }\n    }\n}\n\nimpl Default for Network {\n\n    fn default() -> Self {\n        Self::NET_UNROUTABLE\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Parse a Tor address and set this object\n    | to it.\n    | \n    | -----------\n    | @param[in] addr\n    | Address to parse, must be a valid C string,\n    | for example pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion.\n    | @return\n    | Whether the operation was successful.\n    | @see CNetAddr::IsTor()\n    |\n    */\n    pub fn set_tor(&mut self, addr: &String) -> bool {\n        trace!(target: \"netaddr\", address = addr, \"SetTor\");\n        const SUFFIX: &str = \".onion\";\n        let suffix_len = SUFFIX.len();\n    \n        if addr.len() <= suffix_len || !addr.ends_with(SUFFIX) {\n            debug!(target: \"netaddr\", \"SetTor: suffix check failed\");\n            return false;\n        }\n    \n        let b32 = &addr[..addr.len() - suffix_len];\n    \n        // Decode base32 (lowercase, no '=' padding) through the shared\n        // bitcoin-string helper.\n        let mut invalid = false;\n        let input: Vec<u8> =\n            bitcoin_string::decode_base32_bytes_nopad_lower(b32, Some(&mut invalid as *mut bool));\n        if invalid {\n            debug!(target: \"netaddr\", \"SetTor: invalid base32\");\n            return false;\n        }\n    \n        if input.len() != TORV3_TOTAL_LEN {\n            debug!(target: \"netaddr\", got = input.len(), want = TORV3_TOTAL_LEN, \"SetTor: payload length mismatch\");\n            return false;\n        }\n    \n        let pk_end = ADDR_TORV3_SIZE;\n        let cks_end = pk_end + TORV3_CHECKSUM_LEN;\n        let ver_end = cks_end + TORV3_VERSION.len();\n    \n        let input_pubkey = &input[..pk_end];\n        let input_checksum = &input[pk_end..cks_end];\n        let input_version  = &input[cks_end..ver_end];\n    \n        if input_version != TORV3_VERSION {\n            debug!(target: \"netaddr\", got = ?input_version, \"SetTor: wrong version byte\");\n            return false;\n        }\n    \n        let mut calculated = [0u8; TORV3_CHECKSUM_LEN];\n        torv3_checksum(input_pubkey, &mut calculated);\n    \n        if input_checksum != calculated {\n            debug!(target: \"netaddr\", \"SetTor: checksum mismatch\");\n            return false;\n        }\n    \n        *self.net_mut() = Network::NET_ONION;\n        *self.addr_mut() = PreVector::from(input_pubkey);\n        debug!(target: \"netaddr\", \"SetTor: parsed TORv3 address\");\n        true\n    }\n}\n\nimpl NetAddr {\n\n    pub fn to_stringip(&self) -> String {\n        trace!(target: \"netaddr\", net = ?self.get_net_class(), \"Formatting address as string (IP-style)\");\n        match *self.net() {\n            Network::NET_IPV4 => {\n                assert_eq!(self.addr().len(), ADDR_IPV4_SIZE, \"IPv4 address must be 4 bytes\");\n                ipv4_to_string(self.addr().as_slice())\n            }\n            Network::NET_IPV6 => {\n                assert_eq!(self.addr().len(), ADDR_IPV6_SIZE, \"IPv6 address must be 16 bytes\");\n                ipv6_to_string(self.addr().as_slice(), *self.scope_id())\n            }\n            Network::NET_ONION => {\n                assert_eq!(self.addr().len(), ADDR_TORV3_SIZE, \"TORv3 address must be 32 bytes\");\n                onion_to_string(self.addr().as_slice())\n            }\n            Network::NET_I2P => {\n                assert_eq!(self.addr().len(), ADDR_I2P_SIZE, \"I2P address must be 32 bytes\");\n                // Do not pad with '=' (encoding helper uses no padding when second arg is None).\n                let mut s = encode_base32(self.addr().as_slice(), Some(false));\n                s.push_str(\".b32.i2p\");\n                s\n            }\n            Network::NET_CJDNS => {\n                assert_eq!(self.addr().len(), ADDR_CJDNS_SIZE, \"CJDNS address must be 16 bytes\");\n                ipv6_to_string(self.addr().as_slice(), 0)\n            }\n            Network::NET_INTERNAL => {\n                assert_eq!(self.addr().len(), ADDR_INTERNAL_SIZE, \"INTERNAL address must be 10 bytes\");\n                let mut s = encode_base32(self.addr().as_slice(), Some(false));\n                s.push_str(\".internal\");\n                s\n            }\n            Network::NET_UNROUTABLE | Network::NET_MAX => {\n                panic!(\"m_net is never and should not be set to NET_UNROUTABLE/NET_MAX\");\n            }\n        }\n    }\n\n    pub fn to_string(&self) -> String {\n        trace!(target: \"netaddr\", \"Converting NetAddr to string\");\n        self.to_stringip()\n    }\n}\n\nimpl NetAddr {\n\n    /**\n    | Get the canonical identifier of our\n    | network group\n    | \n    | The groups are assigned in a way where\n    | it should be costly for an attacker to\n    | obtain addresses with many different\n    | group identifiers, even if it is cheap\n    | to obtain addresses with the same identifier.\n    | -----------\n    | @note\n    | No two connections will be attempted\n    | to addresses with the same network group.\n    |\n    */\n    pub fn get_group(&self, asmap: &Vec<bool>) -> Vec<u8> {\n        trace!(\n            target: \"netaddr\", \n            net = ?self.get_net_class(), \n            \"Computing address group identifier\"\n        );\n    \n        let mut vch_ret: Vec<u8> = Vec::with_capacity(1 + ADDR_IPV6_SIZE);\n    \n        let net_class: u8 = self.get_net_class() as u8;\n    \n        // If non-empty asmap is supplied and the address is IPv4/IPv6,\n        // return ASN to be used for bucketing.\n        let asn: u32 = self.get_mappedas(asmap);\n    \n        if asn != 0 {\n            // Either asmap was empty, or address has non-asmappable net class (e.g. TOR).\n    \n            // IPv4 and IPv6 with same ASN should be in the same bucket\n            vch_ret.push(Network::NET_IPV6 as u8);\n            for i in 0..4 {\n                vch_ret.push(((asn >> (8 * i)) & 0xFF) as u8);\n            }\n            debug!(target: \"netaddr\", asn, group = ?vch_ret, \"AS-mapped grouping applied\");\n            return vch_ret;\n        }\n    \n        vch_ret.push(net_class);\n        let mut n_bits: usize = 0;\n    \n        if self.is_local() {\n            // all local addresses belong to the same group\n            debug!(target: \"netaddr\", \"Local address → single-group by net class\");\n        } else if self.is_internal() {\n            // all internal-usage addresses get their own group\n            n_bits = ADDR_INTERNAL_SIZE * 8;\n            debug!(target: \"netaddr\", bits = n_bits, \"Internal address grouping\");\n        } else if !self.is_routable() {\n            // all other unroutable addresses belong to the same group\n            debug!(target: \"netaddr\", \"Unroutable address → single-group by net class\");\n        } else if self.has_linked_ipv4() {\n            // IPv4 addresses (and mapped IPv4 addresses) use /16 groups\n            let ipv4 = self.get_linked_ipv4();\n            vch_ret.push(((ipv4 >> 24) & 0xFF) as u8);\n            vch_ret.push(((ipv4 >> 16) & 0xFF) as u8);\n            debug!(target: \"netaddr\", octet1 = (ipv4 >> 24) & 0xFF, octet2 = (ipv4 >> 16) & 0xFF, \"IPv4-/16 grouping\");\n            return vch_ret;\n        } else if self.is_tor() || self.isi2p() || self.iscjdns() {\n            n_bits = 4;\n            debug!(target: \"netaddr\", bits = n_bits, \"Overlay network grouping (/4)\");\n        } else if self.is_he_net() {\n            // for he.net, use /36 groups\n            n_bits = 36;\n            debug!(target: \"netaddr\", bits = n_bits, \"HE.NET IPv6 grouping (/36)\");\n        } else {\n            // for the rest of the IPv6 network, use /32 groups\n            n_bits = 32;\n            debug!(target: \"netaddr\", bits = n_bits, \"Generic IPv6 grouping (/32)\");\n        }\n    \n        // Push our address bytes according to n_bits.\n        let num_bytes = n_bits / 8;\n        let addr_slice = self.addr().as_slice();\n    \n        if num_bytes > 0 {\n            let upto = num_bytes.min(addr_slice.len());\n            vch_ret.extend_from_slice(&addr_slice[..upto]);\n        }\n    \n        // ...for the last byte, push nBits and for the rest of the byte push 1's\n        let rem_bits = n_bits % 8;\n        if rem_bits > 0 {\n            assert!(num_bytes < addr_slice.len(), \"Address length shorter than expected for grouping\");\n            let last = addr_slice[num_bytes];\n            // Safe because rem_bits ∈ 1..=7 here\n            let mask: u8 = ((1u16 << (8 - rem_bits)) - 1) as u8;\n            vch_ret.push(last | mask);\n        }\n    \n        debug!(target: \"netaddr\", group = ?vch_ret, \"Computed group identifier\");\n        vch_ret\n    }\n}\n\n\nThis crate has the following authors:\n[\n    \"klebs <none>\",\n]\nThis crate has the following rust edition:\n2021\nThis crate has the following license:\nMIT\nThis crate is held in the following repository:\nhttps://github.com/klebs6/bitcoin-rs\n","role":"user"}],"model":"gpt-5.1"}}
