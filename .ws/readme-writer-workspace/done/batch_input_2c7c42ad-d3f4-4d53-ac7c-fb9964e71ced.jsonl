{"custom_id":"request-0","method":"POST","url":"/v1/chat/completions","body":{"max_completion_tokens":8192,"messages":[{"content":"We would like you to write a README.md for a rust crate with maximally helpful content.\nAdditionally, we would like you to generate several fields from the Cargo.toml package section for this crate.\nWe will show you the strict json output format we would like you to provide.\nPlease tailor your response for an apex consumer of maximal intelligence.\nA reader of this README.md should have a good sense of what the crate does and how to use it after reading what you write.\nPlease include a messaage indicating that this README.md file was generated by an AI model and may not be 100% accurate however it should be pretty good.\n\n\nCarefully read and parse the information we sent you.\nWe want to generate all information items requested by our schema:\n\n- Read the description of each field. Use it, along with the content we sent you to generate an appropriate value for each.\n- Ensure that each generated field optimally serves its desired purpose.\n- Each item should be deep, detailed, and specific. Use optimally descriptive and useful language. Do not be too verbose.\n- In terms of the JSON format we would like you to provide, all schema items should live at the top level of the json object. \n  The object itself will be deserialied based on the schema. \n  The fields should not be nested under a parent named 'fields' or anything similar.\n\nHere is the schema to Use:\n\n{\"fields\":{\"crate_name\":{\"generation_instructions\":\"This string should be the name of our crate, *verbatim*, trimmed for use as a toml field\",\"required\":true,\"type\":\"string\"},\"full_readme_markdown\":{\"generation_instructions\":\"This string should be valid markdown representing the readme for this crate.\\n\\n Please make it terse, useful, and designed for an industrious commercially savy consumer of industrious nature. \\n\\n Advanced vocabulary and concepts are welcome. \\n\\n If this crate involves concepts from mathematics and/or physics, please describe and document them here.\",\"required\":true,\"type\":\"string\"},\"package_categories\":{\"generation_instructions\":\"These categories will be used in our Cargo.toml file.\\n\\n It is important that users of this crate can find it on crates.io.\\n\\n Choose maximum 5 categories and make sure they are actually meaningful for our crate.\\n\\n These categories should only be chosen from among the legal crates.io categories. \\n\\n The ONLY legal categoreis are:\\n\\n``\\n accessibility\\n aerospace\\n algorithms\\n api-bindings\\n asynchronous\\n authentication\\n caching\\n command-line-interface\\n command-line-utilities\\n compilers\\n compression\\n computer-vision\\n concurrency\\n config\\n cryptography\\n data-structures\\n database\\n database-implementations\\n date-and-time\\n development-tools\\n email\\n embedded\\n emulators\\n encoding\\n external-ffi-bindings\\n filesystem\\n finance\\n game-development\\n game-engines\\n games\\n graphics\\n gui\\n hardware-support\\n internationalization\\n localization\\n mathematics\\n memory-management\\n multimedia\\n network-programming\\n no-std\\n os\\n parser-implementations\\n parsing\\n rendering\\n rust-patterns\\n science\\n simulation\\n template-engine\\n text-editors\\n text-processing\\n value-formatting\\n virtualization\\n visualization\\n wasm\\n web-programming\\n ``\\n\\n DO NOT specify a category that is not on this list.\",\"required\":true,\"type\":\"array_of_strings\"},\"package_description\":{\"generation_instructions\":\"We will place this package_description in our Cargo.toml file so the users of this crate\\n know what it does.\\n\\n The discription should be technical, clear, and useful. It should be terse.\",\"required\":true,\"type\":\"string\"},\"package_keywords\":{\"generation_instructions\":\"These keywords will be used in our Cargo.toml file so the users of this crate can easily\\n find it in the package system. Keywords should be useful, varied, meaningful, and reflect\\n the contents of our crate. They should make it easy to find. Please provide exactly five.\",\"required\":true,\"type\":\"array_of_strings\"}},\"struct_docs\":\" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\"struct_name\":\"AiReadmeWriterDesiredOutput\"}\nRephrase Entries:\n\n- Ensure entries are concise and focused.\n- Ensure there are no vague phrases (e.g., avoid starting with \"Illustrates the something something...\"; instead, use direct details like \"The hanging green vines on the garden wall\").\n\nEnsure Clarity and Consistency:\n\n- Use clear, grammatically correct sentences.\n- Maintain a consistent tone and style throughout.\n\nEnrich Content:\n\n- Communicate additional information where appropriate to enhance depth and value.\n- If a mathematical, physical, or otherwise technical background is helpful, please provide it.\n- Ensure that the content is comprehensive and meets all requirements.\nFocus Language:\n\n- Use deliberate and precise language.\n- Avoid vague verbs and keep the maximally intelligent and detail oriented audience in mind.\n- Do not use modern cultural references or generically reference ideas which do not fit the overall aura of our setting.\n\nPresent the Final JSON:\n\n- Format the output as a JSON object.\n- Include all fields properly named from the schema we sent you.\n\nEnsure Proper Formatting:\n\n- Use proper JSON syntax with keys and arrays.\n- Ensure that all entries are correctly placed in their respective places.\n\nYour output should only consist of the JSON object. do *not* include a preamble or postamble to your response. \nWe would like to be able to parse your response directly as JSON.\n\n","role":"system"},{"content":"We have a rust crate named 'bitcoin-blob' 0.1.18. \n\nHere is the interface:\n#[macro_export]\nmacro_rules! define_base_blob_iter { {\n    (\n        $blob_ty:ident,\n        $bits:expr,\n        $bytes:expr\n    ) => {\n\n        impl $blob_ty {\n            /// Return an iterator over the bytes (by reference).\n            pub fn iter(&self) -> core::slice::Iter<'_, u8> {\n                trace!(\"iter => returning an iterator over bytes for BaseBlob<{}>\", $bits);\n                self.data.iter()\n            }\n\n            /// Return a mutable iterator over the bytes.\n            pub fn iter_mut(&mut self) -> core::slice::IterMut<'_, u8> {\n                trace!(\"iter_mut => returning a mutable iterator over bytes for BaseBlob<{}>\", $bits);\n                self.data.iter_mut()\n            }\n        }\n\n        impl IntoIterator for $blob_ty {\n            type Item = u8;\n            type IntoIter = core::array::IntoIter<u8, $bytes>;\n\n            fn into_iter(self) -> Self::IntoIter {\n                trace!(\"IntoIterator (by value) => BaseBlob<{}>\", $bits);\n                core::array::IntoIter::new(self.data)\n            }\n        }\n\n        impl<'a> IntoIterator for &'a $blob_ty {\n            type Item = &'a u8;\n            type IntoIter = core::slice::Iter<'a, u8>;\n\n            fn into_iter(self) -> Self::IntoIter {\n                trace!(\"IntoIterator (by ref) => &BaseBlob<{}>\", $bits);\n                self.data.iter()\n            }\n        }\n\n        impl<'a> IntoIterator for &'a mut $blob_ty {\n            type Item = &'a mut u8;\n            type IntoIter = core::slice::IterMut<'a, u8>;\n\n            fn into_iter(self) -> Self::IntoIter {\n                trace!(\"IntoIterator (by mut ref) => &mut BaseBlob<{}>\", $bits);\n                self.data.iter_mut()\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_blob_serialization { {\n    (\n        $blob_ty:ident,\n        $bits:expr,\n        $bytes:expr\n    ) => {\n\n        impl $blob_ty {\n\n            pub fn get_u64(&self, pos: i32) -> u64 {\n                trace!(\n                    \"Entering get_u64(pos={}) on BaseBlob<{}>; data={:X?}\",\n                    pos,\n                    $bits,\n                    self.data\n                );\n\n                // Each position corresponds to an 8-byte chunk in little-endian.\n                // We'll do a simple bounds check: pos must be >=0 and within range.\n                let width = $bytes as i32;\n                let byte_start = pos.checked_mul(8).expect(\"pos*8 overflow\");\n                let byte_end = byte_start + 8;\n                assert!(\n                    byte_start >= 0 && (byte_end as usize) <= (width as usize),\n                    \"get_u64 out of range for BITS={}\",\n                    $bits\n                );\n\n                let start_usize = byte_start as usize;\n                let slice = &self.data[start_usize..start_usize + 8];\n                let result = slice[0] as u64\n                    | ((slice[1] as u64) << 8)\n                    | ((slice[2] as u64) << 16)\n                    | ((slice[3] as u64) << 24)\n                    | ((slice[4] as u64) << 32)\n                    | ((slice[5] as u64) << 40)\n                    | ((slice[6] as u64) << 48)\n                    | ((slice[7] as u64) << 56);\n\n                debug!(\"get_u64 => 0x{:016X}\", result);\n                result\n            }\n\n            pub fn serialize<Stream>(&self, s: &mut Stream)\n            where\n                Stream: std::io::Write,\n            {\n                trace!(\n                    \"serialize => writing {} bytes for BaseBlob<{}>\",\n                    $bytes,\n                    $bits\n                );\n                s.write_all(&self.data).expect(\"Failed to write BaseBlob data\");\n                debug!(\"serialize => finished writing.\");\n            }\n\n            pub fn unserialize<Stream>(&mut self, s: &mut Stream)\n            where\n                Stream: std::io::Read,\n            {\n                trace!(\n                    \"unserialize => reading {} bytes for BaseBlob<{}>\",\n                    $bytes,\n                    $bits\n                );\n                s.read_exact(&mut self.data).expect(\"Failed to read BaseBlob data\");\n                debug!(\"unserialize => finished reading => data={:X?}\", self.data);\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_blob_struct { {\n    (\n        $blob_ty:ident,\n        $bits:expr,\n        $bytes:expr\n    ) => {\n        /**\n          | Template base class for fixed-sized\n          | opaque blobs (concretized via macro).\n          |\n        */\n        #[derive(Getters,Clone,Debug,Hash)]\n        #[getset(get=\"pub\")]\n        pub struct $blob_ty {\n            data: [u8; $bytes],\n        }\n\n        // Safety as in the original code\n        unsafe impl Send for $blob_ty {}\n        unsafe impl Sync for $blob_ty {}\n\n        impl Default for $blob_ty {\n            fn default() -> Self {\n                Self {\n                    data: [0; $bytes],\n                }\n            }\n        }\n\n        impl $blob_ty {\n            /// A pure `const fn` constructor copying in `arr`.\n            pub const fn from_bytes(arr: [u8; $bytes]) -> Self {\n                Self { data: arr }\n            }\n\n            pub fn zero() -> Self {\n                Self {\n                    data: [0; $bytes],\n                }\n            }\n\n            pub fn one() -> Self {\n                let mut x = Self {\n                    data: [0; $bytes],\n                };\n                if $bytes > 0 {\n                    x.data[0] = 1;\n                }\n                x\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_blob_from_bytes { {\n\n    ($blob_ty:ident, $bits:expr, $bytes:expr) => {\n\n        impl From<u8> for $blob_ty {\n            fn from(v: u8) -> Self {\n                debug!(\n                    \"Constructing BaseBlob<{}> from u8=0x{:02X}; only the first byte is set to v\",\n                    $bits,\n                    v\n                );\n                let mut out = Self::default();\n                if $bytes > 0 {\n                    out.data[0] = v;\n                }\n                out\n            }\n        }\n\n        impl From<&Vec<u8>> for $blob_ty {\n            fn from(vch: &Vec<u8>) -> Self {\n                debug!(\n                    \"Constructing BaseBlob<{}> from &Vec<u8> of length={}\",\n                    $bits,\n                    vch.len()\n                );\n                assert_eq!(\n                    vch.len(),\n                    $bytes,\n                    \"Input Vec<u8> must match base_blob_width for BITS={}\",\n                    $bits\n                );\n                let mut out = Self::default();\n                out.data.copy_from_slice(&vch[..]);\n                out\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_blob_ord_eq { {\n    (\n        $blob_ty:ident,\n        $bits:expr,\n        $bytes:expr\n    ) => {\n\n        impl PartialEq<$blob_ty> for $blob_ty {\n            fn eq(&self, other: &$blob_ty) -> bool {\n                self.compare(other) == 0\n            }\n        }\n        impl Eq for $blob_ty {}\n\n        impl Ord for $blob_ty {\n            fn cmp(&self, other: &$blob_ty) -> Ordering {\n                let x = self.compare(other);\n                match x {\n                    _ if x < 0  => Ordering::Less,\n                    _ if x == 0 => Ordering::Equal,\n                    _ if x > 0  => Ordering::Greater,\n                    _ => unreachable!(),\n                }\n            }\n        }\n\n        impl PartialOrd<$blob_ty> for $blob_ty {\n            fn partial_cmp(&self, other: &$blob_ty) -> Option<Ordering> {\n                Some(self.cmp(other))\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_blob_hex { {\n    (\n        $blob_ty:ident,\n        $bits:expr,\n        $bytes:expr\n    ) => {\n\n        impl $blob_ty {\n\n            pub fn get_hex(&self) -> String {\n                trace!(\n                    \"get_hex => converting BaseBlob<{}> to hex string\",\n                    $bits\n                );\n                // Traditional Bitcoin/crypto convention: display highest-order byte first\n                let mut rev = self.data.clone();\n                rev.reverse();\n                let hex_str = rev\n                    .iter()\n                    .map(|byte| format!(\"{:02x}\", byte))\n                    .collect::<String>();\n                debug!(\"get_hex => {}\", hex_str);\n                hex_str\n            }\n\n            pub fn set_hex(&mut self, psz: *const u8) {\n                trace!(\"set_hex => parsing hex string into BaseBlob<{}>\", $bits);\n\n                let c_str = unsafe { std::ffi::CStr::from_ptr(psz as *const i8) };\n                let hex_str = c_str.to_string_lossy().to_string();\n                let trimmed = hex_str.trim_start();\n                let maybe_no_0x = if trimmed.len() >= 2 {\n                    let prefix = &trimmed[0..2];\n                    if prefix.eq_ignore_ascii_case(\"0x\") {\n                        &trimmed[2..]\n                    } else {\n                        trimmed\n                    }\n                } else {\n                    trimmed\n                };\n                self.data.fill(0);\n\n                let max_hex_len = $bytes * 2;\n                let full_hex = maybe_no_0x.trim_end();\n                let digit_count = full_hex\n                    .chars()\n                    .filter(|ch| ch.is_ascii_hexdigit())\n                    .count();\n                debug!(\n                    \"hex input='{}', digit_count={}, max_hex_len={}\",\n                    full_hex,\n                    digit_count,\n                    max_hex_len\n                );\n\n                let mut byte_index = 0;\n                let mut i = digit_count;\n                let hex_chars: Vec<char> = full_hex.chars().collect();\n\n                while i > 0 && byte_index < $bytes {\n                    i -= 1;\n                    let low_nibble_char = hex_chars[i];\n                    let low_val = nibble_from_hexchar(low_nibble_char);\n                    let mut val: u8 = low_val & 0xF;\n\n                    if i > 0 {\n                        i -= 1;\n                        let high_nibble_char = hex_chars[i];\n                        let high_val = nibble_from_hexchar(high_nibble_char);\n                        val |= (high_val & 0xF) << 4;\n                    }\n                    self.data[byte_index] = val;\n                    byte_index += 1;\n                }\n\n                debug!(\n                    \"set_hex => final data (little-end)={:X?}\",\n                    self.data\n                );\n            }\n\n            pub fn set_hex_from_str(&mut self, str_: &str) {\n                trace!(\n                    \"set_hex_from_str => converting Rust &str to BaseBlob<{}>\",\n                    $bits\n                );\n                let cstring = std::ffi::CString::new(str_).expect(\"CString::new failed?\");\n                self.set_hex(cstring.as_ptr() as *const u8);\n            }\n\n            pub fn to_string(&self) -> String {\n                trace!(\"to_string => same as get_hex for BaseBlob<{}>\", $bits);\n                self.get_hex()\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! base_blob { {\n    (\n        $blob_ty:ident,\n        $bits:expr,\n        $bytes:expr\n    ) => {\n\n        define_base_blob_struct!{\n            $blob_ty,    \n            $bits,   \n            $bytes\n        }\n\n        define_base_blob_iter!{\n            $blob_ty, \n            $bits, \n            $bytes \n        }\n\n        define_base_blob_serialization!{\n            $blob_ty, \n            $bits, \n            $bytes \n        }\n\n        define_base_blob_from_bytes!{\n            $blob_ty, \n            $bits, \n            $bytes \n        }\n\n        define_base_blob_ord_eq!{\n            $blob_ty, \n            $bits, \n            $bytes \n        }\n\n        define_base_blob_hex!{\n            $blob_ty, \n            $bits, \n            $bytes \n        }\n\n        define_base_blob_basic!{\n            $blob_ty, \n            $bits, \n            $bytes \n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_blob_basic { {\n    (\n        $blob_ty:ident,\n        $bits:expr,\n        $bytes:expr\n    ) => {\n\n        impl $blob_ty {\n\n            /// Returns a borrowed slice of all the bytes for read-only access.\n            pub fn as_slice(&self) -> &[u8] {\n                &self.data\n            }\n\n            pub fn as_slice_mut(&mut self) -> &mut [u8] {\n                &mut self.data\n            }\n\n            /// Returns a borrowed slice of all the bytes for mutable access.\n            pub fn as_mut_slice(&mut self) -> &mut [u8] {\n                &mut self.data\n            }\n\n            pub fn is_null(&self) -> bool {\n                trace!(\n                    \"Checking is_null() on BaseBlob<{}>; data={:X?}\",\n                    $bits,\n                    self.data\n                );\n                for &byte in self.data.iter() {\n                    if byte != 0 {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            pub fn set_null(&mut self) {\n                trace!(\n                    \"set_null() => filling BaseBlob<{}> with zeros.\",\n                    $bits\n                );\n                self.data.fill(0);\n            }\n\n            #[inline]\n            pub fn compare(&self, other: &$blob_ty) -> i32 {\n                trace!(\n                    \"compare() => comparing BaseBlob<{}> with another, by bytes.\",\n                    $bits\n                );\n                match self.data.cmp(&other.data) {\n                    Ordering::Less => -1,\n                    Ordering::Equal => 0,\n                    Ordering::Greater => 1,\n                }\n            }\n\n            pub fn data_ptr(&self) -> *const u8 {\n                trace!(\n                    \"Returning const pointer to BaseBlob<{}>.data()\",\n                    $bits\n                );\n                self.data.as_ptr()\n            }\n\n            pub fn data_ptr_mut(&mut self) -> *mut u8 {\n                trace!(\n                    \"Returning mut pointer to BaseBlob<{}>.data_mut()\",\n                    $bits\n                );\n                self.data.as_mut_ptr()\n            }\n\n            pub fn begin_mut(&mut self) -> *mut u8 {\n                trace!(\n                    \"begin_mut(): &mut self.data[0] for BaseBlob<{}>\",\n                    $bits\n                );\n                &mut self.data[0] as *mut _\n            }\n\n            pub fn end_mut(&mut self) -> *mut u8 {\n                trace!(\n                    \"end_mut(): pointer to one-past-last byte of BaseBlob<{}>\",\n                    $bits\n                );\n                unsafe { self.data.as_mut_ptr().add($bytes) }\n            }\n\n            pub fn begin(&self) -> *const u8 {\n                trace!(\n                    \"begin(): &self.data[0] for BaseBlob<{}>\",\n                    $bits\n                );\n                &self.data[0] as *const _\n            }\n\n            pub fn end(&self) -> *const u8 {\n                trace!(\n                    \"end(): pointer to one-past-last byte of BaseBlob<{}>\",\n                    $bits\n                );\n                unsafe { self.data.as_ptr().add($bytes) }\n            }\n\n            pub fn size(&self) -> u32 {\n                let sz = $bytes as u32;\n                trace!(\n                    \"size() => returning {} for BaseBlob<{}>\",\n                    sz,\n                    $bits\n                );\n                sz\n            }\n        }\n    }\n} }\n\nbase_blob!(BaseBlob8,    8,   1);\n\n\nbase_blob!(BaseBlob64,   64,  8);\n\n\nbase_blob!(BaseBlob128,  128, 16);\n\n\nbase_blob!(BaseBlob160,  160, 20);\n\n\nbase_blob!(BaseBlob256,  256, 32);\n\n/// A simple pseudo-random generator to test comparisons, etc.\n/// We can keep it predictable for reproducibility.\npub struct SimpleRng  (\n    u64,\n);\n\n/// Helper: convert a single hex char to nibble\npub fn nibble_from_hexchar(ch: char) -> u8 {\n    match ch {\n        '0'..='9' => ch as u8 - b'0',\n        'a'..='f' => ch as u8 - b'a' + 10,\n        'A'..='F' => ch as u8 - b'A' + 10,\n        _ => {\n            warn!(\"nibble_from_hexchar => non-hex input char={}\", ch);\n            0\n        }\n    }\n}\n\nimpl SimpleRng {\n\n    pub fn new(seed: u64) -> Self {\n        Self(seed)\n    }\n\n    pub fn next_u64(&mut self) -> u64 {\n        // linear congruential generator\n        self.0 = self\n            .0\n            .wrapping_mul(6364136223846793005)\n            .wrapping_add(1);\n        self.0\n    }\n\n    /// Fill a mutable buffer with pseudo-random bytes.\n    pub fn fill_bytes(&mut self, buf: &mut [u8]) {\n        for chunk in buf.chunks_mut(8) {\n            let rnd = self.next_u64().to_le_bytes();\n            let n = chunk.len();\n            chunk.copy_from_slice(&rnd[..n]);\n        }\n    }\n}\n\n\nThis crate has the following authors:\n[\n    \"klebs <none>\",\n]\nThis crate has the following rust edition:\n2021\nThis crate has the following license:\nMIT\nThis crate is held in the following repository:\nhttps://github.com/klebz/bitcoin-rs\n","role":"user"}],"model":"gpt-4o"}}
