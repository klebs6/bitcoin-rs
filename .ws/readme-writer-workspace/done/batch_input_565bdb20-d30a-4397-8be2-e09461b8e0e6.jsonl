{"custom_id":"bitcoin-argsman-ai-readme-request","method":"POST","url":"/v1/chat/completions","body":{"max_completion_tokens":8192,"messages":[{"content":"We would like you to write a README.md for a rust crate with maximally helpful content.\nAdditionally, we would like you to generate several fields from the Cargo.toml package section for this crate.\nWe will show you the strict json output format we would like you to provide.\nPlease tailor your response for an apex consumer of maximal intelligence.\nA reader of this README.md should have a good sense of what the crate does and how to use it after reading what you write.\nPlease include a messaage indicating that this README.md file was generated by an AI model and may not be 100% accurate however it should be pretty good.\n\n\nCarefully read and parse the information we sent you.\n\nWe want to generate all information items requested by our schema:\n\n- Read the description of each field. Use it, along with the content we sent you to generate an appropriate value for each.\n- Ensure that each generated field optimally serves its desired purpose.\n- Each item should be deep, detailed, and specific. Use optimally descriptive and useful language. Do not be too verbose.\n- Do not add any extra keys to the generated object. Generate precisely what we ask of you: no more, no less.\n- For fields which are of an enum type: pick *exactly one variant*. Do not generate any information for the unselected variants.\n- For array fields: supply a JSON list [ ... ] of items, each conforming to the correct item type.\n- For map fields: Provide a JSON object { \"key_as_string\": <value>, ... }. Keys must be valid JSON strings. Keys and Values must conform to the key and value schemas we provide to you. Fill all subfields of each and every map value.\n- If we ask you to justify a map field, provide your justification/confidence score for the entire map. Do not attempt to separately justify each map element.\n- Likewise, if we ask you to justify an array field, provide your justification/confidence score for the entire array. Do not attempt to separately justify each element.\n- Provide numeric fields as real JSON numbers (not strings).\n- For string fields: provide the value precisely as a string literal. If optional, you may set it to null.\n- If we ask you to justify or provide confidence scores for the fields of a structure, please do so carefully. For each field we ask you to justify, please explain or justify your choice clearly. Confidence scores must be specified as real JSON numbers in the range `[0..1]`.\n- If we ask to you generate an optional field, either fill it or set it to null.\n- If we ask you to justify your choice of an enum variant, please explain your choice clearly. Do not justify your decision to leave a variant unselected. Provide your justification as a JSON string. Provide your confidence score as a real JSON number in the range `[0..1]`.\n- In terms of the JSON format we would like you to provide, the object itself will be deserialied based on the following schema. \n- We begin exactly at the top: the data should not be nested under a parent named 'fields' or anything similar.\n\n## Here is the schema to use:\n\nObject {\n    \"fields\": Object {\n        \"crate_name\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be the name of our crate, *verbatim*, trimmed for use as a toml field\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"full_readme_markdown\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be valid markdown representing the readme for this crate.\\\\n\\\\n Please make it terse, useful, and designed for an industrious commercially savy consumer of industrious nature. \\\\n\\\\n Advanced vocabulary and concepts are welcome. \\\\n\\\\n If this crate involves concepts from mathematics and/or physics, please describe and document them here.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_categories\": Object {\n            \"generation_instructions\": String(\"\\\"These categories will be used in our Cargo.toml file.\\\\n\\\\n It is important that users of this crate can find it on crates.io.\\\\n\\\\n Choose maximum 5 categories and make sure they are actually meaningful for our crate.\\\\n\\\\n These categories should only be chosen from among the legal crates.io categories. \\\\n\\\\n The ONLY legal categoreis are:\\\\n\\\\n``\\\\n accessibility\\\\n aerospace\\\\n algorithms\\\\n api-bindings\\\\n asynchronous\\\\n authentication\\\\n caching\\\\n command-line-interface\\\\n command-line-utilities\\\\n compilers\\\\n compression\\\\n computer-vision\\\\n concurrency\\\\n config\\\\n cryptography\\\\n data-structures\\\\n database\\\\n database-implementations\\\\n date-and-time\\\\n development-tools\\\\n email\\\\n embedded\\\\n emulators\\\\n encoding\\\\n external-ffi-bindings\\\\n filesystem\\\\n finance\\\\n game-development\\\\n game-engines\\\\n games\\\\n graphics\\\\n gui\\\\n hardware-support\\\\n internationalization\\\\n localization\\\\n mathematics\\\\n memory-management\\\\n multimedia\\\\n network-programming\\\\n no-std\\\\n os\\\\n parser-implementations\\\\n parsing\\\\n rendering\\\\n rust-patterns\\\\n science\\\\n simulation\\\\n template-engine\\\\n text-editors\\\\n text-processing\\\\n value-formatting\\\\n virtualization\\\\n visualization\\\\n wasm\\\\n web-programming\\\\n ``\\\\n\\\\n DO NOT specify a category that is not on this list.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n        \"package_description\": Object {\n            \"generation_instructions\": String(\"\\\"We will place this package_description in our Cargo.toml file so the users of this crate\\\\n know what it does.\\\\n\\\\n The discription should be technical, clear, and useful. It should be terse.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_keywords\": Object {\n            \"generation_instructions\": String(\"\\\"These keywords will be used in our Cargo.toml file so the users of this crate can easily\\\\n find it in the package system. Keywords should be useful, varied, meaningful, and reflect\\\\n the contents of our crate. They should make it easy to find. Please provide exactly five.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n    },\n    \"struct_docs\": String(\" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\"),\n    \"struct_name\": String(\"AiReadmeWriterDesiredOutput\"),\n    \"type\": String(\"struct\"),\n}\n\n## Please keep the following in mind:\n\nEntry phrasing:\n\n- Ensure entries are concise and focused.\n- Ensure there are no vague phrases (e.g., avoid starting with \"Illustrates the something something...\"; instead, use direct details like \"The hanging green vines on the garden wall\").\n\nEnsure Clarity and Consistency:\n\n- Use clear, grammatically correct sentences.\n- Maintain a consistent tone and style throughout.\n\nEnrich Content:\n\n- Communicate additional information where appropriate to enhance depth and value.\n- If a mathematical, physical, or otherwise technical background is helpful, please provide it.\n- Ensure that the content is comprehensive and meets all requirements.\n\nFocus Language:\n\n- Use deliberate and precise language.\n- Avoid vague verbs and keep the maximally intelligent and detail oriented audience in mind. \n- We explicitly ban the words `hush`, `subtle`, `mythic`, and `aura`. Please keep your vocabulary choices rigorous.\n- Do not use modern cultural references \n- Do not generically reference ideas which do not belong in the global environment.\n\n## Present the Final JSON:\n\n- Format the output as a JSON object.\n- Include all fields properly named from the schema we sent you.\n\nEnsure Proper Formatting:\n\n- Use proper JSON syntax with keys and arrays.\n- Ensure that all entries are correctly placed in their respective places.\n\nProvide only the final JSON data as specified by the schema. \n\nDo not include any schema generation instructions, meta-fields, nested-templates (unless directly asked) or extraneous information. \n\nProvide only the populated fields and their values, conforming exactly to the required structure without embedding any intermediate annotations or placeholders.\n\nYour output should only consist of the JSON object. do *not* include a preamble or postamble to your response. \n\nWe seek to successfully parse your response directly as JSON.\n\nFor the final answer, output the result only as a valid JSON object, wrapped inside triple backticks with json immediately after the opening backticks.\nThe JSON must be parser-ready:\n– No additional text before or after the block\n– No markdown or prose outside the fenced block\n– No HTML escaping of quotes, slashes, or other characters\n– Indentation and whitespace preserved exactly as written\n– The content between the fences must be valid JSON as per RFC 8259","role":"system"},{"content":"We have a rust crate named 'bitcoin-argsman' 0.1.22. \n\nHere is the interface:\n#[derive(Error, Debug)]\npub enum FormatParagraphError {\n    IoError(std::io::Error),\n    FromUtf8Error(FromUtf8Error),\n    IntoInnerError(std::io::IntoInnerError<BufWriter<Vec<u8>>>),\n}\n\n\n#[derive(Debug,PartialEq,Eq,PartialOrd,Ord,Hash,Clone,Copy)]\n#[allow(non_camel_case_types)]\npub enum OptionsCategory {\n    OPTIONS,\n    CONNECTION,\n    WALLET,\n    WALLET_DEBUG_TEST,\n    ZMQ,\n    DEBUG_TEST,\n    CHAINPARAMS,\n    NODE_RELAY,\n    BLOCK_CREATION,\n    RPC,\n    GUI,\n    COMMANDS,\n    REGISTER_COMMANDS,\n    HIDDEN,\n}\n\nbitflags!{\n    pub struct ArgsManagerFlags: u32 {\n\n        /*\n          | Boolean options can accept negation\n          | syntax\n          | \n          | -noOPTION or -noOPTION=1\n          |\n          */\n        const ALLOW_BOOL   = 0x01;\n        const ALLOW_INT    = 0x02;\n        const ALLOW_STRING = 0x04;\n        const ALLOW_ANY    = \n            Self::ALLOW_BOOL.bits \n            | Self::ALLOW_INT.bits \n            | Self::ALLOW_STRING.bits;\n\n        const DEBUG_ONLY   = 0x100;\n\n        /*\n          | Some options would cause cross-contamination\n          | if values for mainnet were used while\n          | running on regtest/testnet (or vice-versa).\n          | \n          | Setting them as NETWORK_ONLY ensures\n          | that sharing a config file between mainnet\n          | and regtest/testnet won't cause problems\n          | due to these parameters by accident.\n          |\n          */\n        const NETWORK_ONLY = 0x200;\n\n        /*\n          | This argument's value is sensitive\n          | (such as a password).\n          |\n          */\n        const SENSITIVE = 0x400;\n        const COMMAND   = 0x800;\n    }\n}\n\n\nlazy_static!{\n    pub static ref G_ARGS: Mutex<ArgsManager> = Mutex::new(ArgsManager::default());\n}\n\n\n// Section names to be recognized in the config file.\nlazy_static!{\n    static ref AVAILABLE_SECTIONS: std::collections::HashSet<String> = hashset!{\n        base_chain_params::REGTEST.to_string(),\n        base_chain_params::SIGNET.to_string(),\n        base_chain_params::TESTNET.to_string(),\n        base_chain_params::MAIN.to_string()\n    };\n}\n\n\nlazy_static!{\n    static ref global_chain_base_params: Arc<Mutex<BaseChainParams>> = Arc::new(Mutex::new(BaseChainParams::default()));\n}\n\n\nlazy_static!{\n    pub static ref DEFAULT_BASE_PARAMS: BaseChainParams = *create_base_chain_params(&base_chain_params::MAIN).unwrap();\n    pub static ref TESTNET_BASE_PARAMS: BaseChainParams = *create_base_chain_params(&base_chain_params::TESTNET).unwrap();\n    pub static ref SIGNET_BASE_PARAMS:  BaseChainParams = *create_base_chain_params(&base_chain_params::SIGNET).unwrap();\n    pub static ref REGTEST_BASE_PARAMS: BaseChainParams = *create_base_chain_params(&base_chain_params::REGTEST).unwrap();\n}\n\n\nlazy_static!{\n\n    pub static ref ARG_HELP: ArgDescriptor = ArgDescriptor {\n        name:  \"-?\", \n        help:  formatdoc!{\n            \"Print this help message and exit\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_VERSION: ArgDescriptor = ArgDescriptor {\n        name:  \"-version\",\n        help:  formatdoc!{\n            \"Print version and exit\"\n        },\n        flags:    ArgsManagerFlags::ALLOW_ANY,\n        category: OptionsCategory::OPTIONS,\n    };\n\n    pub static ref ARG_SET_CONF_FILE: ArgDescriptor = ArgDescriptor {\n        name: \"-conf=<file>\", \n        help: formatdoc!{\n            \"Specify configuration file. Relative\n            paths will be prefixed by datadir\n            location. (default: {})\", \n            BITCOIN_CONF_FILENAME\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_DATADIR: ArgDescriptor = ArgDescriptor {\n        name:  \"-datadir=<dir>\", \n        help:  formatdoc!{\n            \"Specify data directory\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_GENERATE: ArgDescriptor = ArgDescriptor {\n        name: \"-generate\", \n        help: formatdoc!{\n            \"Generate blocks immediately, equivalent\n            to RPC getnewaddress followed by RPC\n            generatetoaddress. Optional positional integer\n            arguments are number of blocks to generate\n            (default: {}) and maximum iterations to try\n            (default: {}), equivalent to RPC generatetoaddress\n            nblocks and maxtries arguments. Example:\n            bitcoin-cli -generate 4 1000\", \n            DEFAULT_NBLOCKS, \n            DEFAULT_MAX_TRIES\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_ADDRINFO: ArgDescriptor = ArgDescriptor {\n        name: \"-addrinfo\", \n        help: formatdoc!{\n            \"Get the number of addresses known to\n            the node, per network and total.\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_GETINFO: ArgDescriptor = ArgDescriptor {\n        name: \"-getinfo\", \n        help: formatdoc!{\n            \"Get general information from the remote\n            server. Note that unlike server-side RPC calls,\n            the results of -getinfo is the result of multiple\n            non-atomic requests. Some entries in the result\n            may represent results from different states\n            (e.g. wallet balance may be as of a different\n            block from the chain state reported)\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_NETINFO: ArgDescriptor = ArgDescriptor {\n        name: \"-netinfo\", \n        help: formatdoc!{\n            \"Get network peer connection information\n            from the remote server. An optional\n            integer argument from 0 to 4 can be passed\n            for dif ferent peers listings (default:\n            0). Pass \\\"help\\\" for detailed help\n            documentation.\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_COLOR: ArgDescriptor = ArgDescriptor { \n        name: \"-color=<when>\", \n        help: formatdoc!{\n            \"Color setting for CLI output (default:\n            {}). Valid values: always, auto (add color codes\n            when standard output is connected to a terminal\n            and OS is not WIN32), never.\",\n            DEFAULT_COLOR_SETTING\n        }, \n        flags:    ArgsManagerFlags::ALLOW_STRING, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_NAMED: ArgDescriptor = ArgDescriptor { \n        name: \"-named\", \n        help: formatdoc!{\n            \"Pass named instead of positional\n            arguments (default: {})\",\n            DEFAULT_NAMED\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS,\n    };\n\n    pub static ref ARG_SET_RPC_CLIENTTIMEOUT: ArgDescriptor = ArgDescriptor { \n        name: \"-rpcclienttimeout=<n>\", \n        help: formatdoc!{\n            \"Timeout in seconds during HTTP requests,\n            or 0 for no timeout. (default: {})\",\n            DEFAULT_HTTP_CLIENT_TIMEOUT\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_RPC_COOKIEFILE: ArgDescriptor = ArgDescriptor { \n        name: \"-rpccookiefile=<loc>\", \n        help: formatdoc!{\n            \"Location of the auth cookie. Relative\n            paths will be prefixed by a net-specific datadir\n            location. (default: data dir)\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_RPC_CONNECT: ArgDescriptor = ArgDescriptor { \n        name: \"-rpcconnect=<ip>\", \n        help: formatdoc!{\n            \"Send commands to node running on <ip>\n            (default: {})\",\n            DEFAULT_RPCCONNECT\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_RPC_PASSWORD: ArgDescriptor = ArgDescriptor { \n        name: \"-rpcpassword=<pw>\", \n        help: formatdoc!{\n            \"Password for JSON-RPC connections\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_RPC_PORT: ArgDescriptor = ArgDescriptor { \n        name: \"-rpcport=<port>\", \n        help: formatdoc!{\n            \"Connect to JSON-RPC on <port> (default:\n            {}, testnet: {}, signet: {}, regtest: {})\",\n            DEFAULT_BASE_PARAMS.rpc_port(),\n            TESTNET_BASE_PARAMS.rpc_port(),\n            SIGNET_BASE_PARAMS.rpc_port(),\n            REGTEST_BASE_PARAMS.rpc_port()\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY | ArgsManagerFlags::NETWORK_ONLY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_RPC_USER: ArgDescriptor = ArgDescriptor { \n        name: \"-rpcuser=<user>\", \n        help: formatdoc!{\n            \"Username for JSON-RPC connections\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_RPC_WAIT: ArgDescriptor = ArgDescriptor { \n        name: \"-rpcwait\", \n        help: formatdoc!{\n            \"Wait for RPC server to start\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_RPC_WAITTIMEOUT: ArgDescriptor = ArgDescriptor { \n        name: \"-rpcwaittimeout=<n>\", \n        help: formatdoc!{\n            \"Timeout in seconds to wait for the RPC\n            server to start, or 0 for no timeout. (default:\n            {})\",\n            DEFAULT_WAIT_CLIENT_TIMEOUT\n        }, \n        flags:    ArgsManagerFlags::ALLOW_INT, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_SET_RPC_WALLET: ArgDescriptor = ArgDescriptor { \n        name: \"-rpcwallet=<walletname>\", \n        help: formatdoc!{\n            \"Send RPC for non-default wallet on RPC\n            server (needs to exactly match corresponding\n            -wallet option passed to bi tcoind). This changes\n            the RPC endpoint used,\n            e.g. http://127.0.0.1:8332/wallet/<walletname>\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_STDIN: ArgDescriptor = ArgDescriptor { \n        name: \"-stdin\", \n        help: formatdoc!{\n            \"Read extra arguments from standard input,\n            one per line until EOF/Ctrl-D (recommended for\n            sensitive information such as passphras es). When\n            combined with -stdinrpcpass, the first line from\n            standard input is used for the RPC password.\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_STDINRPCPASS: ArgDescriptor = ArgDescriptor { \n        name: \"-stdinrpcpass\", \n        help: formatdoc!{\n            \"Read RPC password from standard input as\n            a single line. When combined with -stdin, the\n            first line from standard input is used for the RPC\n            password. When combined with\n            -stdinwalletpassphrase, -stdinrpcpass consumes the\n            first line, and -stdinwalletpassphrase consumes\n            the second .\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n\n    pub static ref ARG_STDINWALLETPASSPHRASE: ArgDescriptor = ArgDescriptor { \n        name: \"-stdinwalletpassphrase\", \n        help: formatdoc!{\n            \"Read wallet passphrase from standard\n            input as a single line. When combined with -stdin,\n            the first line from stan dard input is used for\n            the wallet passphrase.\"\n        }, \n        flags:    ArgsManagerFlags::ALLOW_ANY, \n        category: OptionsCategory::OPTIONS\n    };\n}\n\n#[derive(Clone)]\npub struct SectionInfo  {\n    name: String,\n    file: String,\n    line: i32,\n}\n\n\n#[derive(Default)]\npub struct ArgsManagerCommand  {\n    command: Option<String>,\n    args:    Vec<String>,\n}\n\n\n#[derive(Default)]\npub struct ArgsManager  {\n    cs_args: Arc<Mutex<ArgsManagerInner>>,\n}\n\n\npub struct ArgsManagerInner  {\n    settings:                    Settings,\n    command:                     Vec<String>,\n    network:                     Option<String>,\n    network_only_args:           HashSet<String>,\n    available_args:              HashMap<OptionsCategory,HashMap<String,ArgsManagerArg>>,\n    accept_any_command:          bool,\n    config_sections:             LinkedList<SectionInfo>,\n    cached_blocks_path:          Option<Box<Path>>,\n    cached_datadir_path:         Option<Box<Path>>,\n    cached_network_datadir_path: Option<Box<Path>>,\n}\n\n\npub struct ArgDescriptor  {\n    name:     &'static str,\n    help:     String,\n    flags:    ArgsManagerFlags,\n    category: OptionsCategory,\n}\n\n\n#[derive(Default)]\npub struct ArgsManagerArg  {\n    help_param: String,\n    help_text:  String,\n    flags:      u32,\n}\n\n\n/**\n| BaseChainParams defines the base\n| parameters (shared between bitcoin-cli\n| and bitcoind) of a given instance of\n| the Bitcoin system.\n|\n*/\n#[derive(Default)]\npub struct BaseChainParams  {\n    rpc_port:                  u16,\n    onion_service_target_port: u16,\n    str_data_dir:              String,\n}\n\n/**\n| Windows: C:\\Users\\Username\\AppData\\Roaming\\Bitcoin\n|\n| macOS: ~/Library/Application Support/Bitcoin\n| \n| Unix-like: ~/.bitcoin\n*/\n#[cfg(target_os = \"windows\")]\npub fn get_default_data_dir() -> PathBuf {\n    let mut path: PathBuf = get_special_folder_path(csidl_appdata);\n    path.push(\"Bitcoin\");\n    path\n}\n\n\n#[cfg(target_os = \"macos\")]\npub fn get_default_data_dir() -> PathBuf {\n    let mut path_ret = get_home_dir();\n\n    path_ret.push(\"Library/Application Support/Bitcoin\");\n\n    path_ret\n}\n\n\n#[cfg(not(any(target_os = \"windows\", target_os = \"macos\")))]\npub fn get_default_data_dir() -> PathBuf {\n    let mut path_ret = get_home_dir();\n\n    //  Unix-like\n    path_ret.push(\".bitcoin\");\n\n    path_ret\n}\n\n\n#[cfg(not(target_os = \"windows\"))]\npub fn get_home_dir() -> PathBuf {\n    let psz_home = env::var(\"HOME\");\n\n    if psz_home.is_err() || psz_home.as_ref().unwrap().is_empty() {\n        PathBuf::from(\"/\")\n    } else {\n        PathBuf::from(psz_home.unwrap())\n    }\n}\n\n\npub fn strip_redundant_last_elements_of_path(path: &mut PathBuf) {\n    let mut result = path.clone();\n\n    while result.file_name() == Some(OsStr::new(\".\")) {\n        result.pop();\n    }\n\n    // If paths don't exist yet, is_same_file may return Err — don't crash.\n    match is_same_file(&result, &path) {\n        Ok(true) => { /* unchanged, great */ }\n        Ok(false) => {\n            // This should not happen (we only strip trailing \".\").\n            debug_assert!(false, \"strip_redundant_last_elements_of_path altered path\");\n        }\n        Err(_) => {\n            // Path may not exist yet; skip the identity check.\n        }\n    }\n\n    *path = result;\n}\n\n\n/**\n| Interpret a string argument as a boolean.\n| \n| The definition of LocaleIndependentAtoi<int>()\n| requires that non-numeric string values\n| like \"foo\", return 0. This means that\n| if a user unintentionally supplies\n| a non-integer argument here, the return\n| value is always false. This means that\n| -foo=false does what the user probably\n| expects, but -foo=true is well defined\n| but does not do what they probably expected.\n| The return value of LocaleIndependentAtoi<int>(...)\n| is zero when given input not representable\n| as an int.\n| For a more extensive discussion of this\n| topic (and a wide range of opinions on\n| the Right Way to change this code), see\n| PR12713.\n|\n*/\npub fn interpret_bool(str_value: &str) -> bool {\n    if str_value.is_empty() {\n        return true;\n    }\n\n    locale_independent_atoi::<i32>(str_value) != 0\n}\n\n\n/**\n| Interpret -nofoo as if the user supplied\n| -foo=0.\n| \n| This method also tracks when the -no\n| form was supplied, and if so, checks\n| whether there was a double-negative\n| (-nofoo=0 -> -foo=1).\n| If there was not a double negative, it\n| removes the \"no\" from the key and returns\n| false.\n| If there was a double negative, it removes\n| \"no\" from the key, and returns true.\n| If there was no \"no\", it returns the string\n| value untouched.\n| Where an option was negated can be later\n| checked using the\n| IsArgNegated() method. One use case\n| for this is to have a way to disable options\n| that are not normally boolean (e.g.\n| using -nodebuglogfile to request that\n| debug log output is not sent to any file\n| at all).\n|\n*/\npub fn interpret_option(section: &mut String, key: &mut String, value: &String) -> SettingsValue {\n    // Split section name from key name for keys\n    // like \"testnet.foo\" or \"regtest.bar\"\n    if let Some(option_index) = key.find('.') {\n        *section = key[0..option_index].to_string();\n        key.replace_range(0..option_index + 1, \"\");\n    }\n\n    if &key[0..2] == \"no\" {\n\n        key.replace_range(0..2, \"\");\n\n        // Double negatives like -nofoo=0 are\n        // supported (but discouraged)\n        if !interpret_bool(value) {\n            log_printf!(\n                \"Warning: parsed potentially confusing double-negative -{}={}\\n\", \n                key, \n                value\n            );\n            return SettingsValue(UniValue::from(true));\n        }\n\n        return SettingsValue(UniValue::from(false));\n    }\n\n    SettingsValue(UniValue::from(value.as_str()))\n}\n\n\n/**\n| Format a string to be used as group of\n| options in help messages\n| \n| -----------\n| @param message\n| Group name (e.g. \"RPC server options:\")\n| @return\n| the formatted string\n|\n*/\npub fn help_message_group(message: &str) -> String {\n    format!{\"{}\\n\\n\",message}\n}\n\n\n/**\n| Format a paragraph of text to a fixed\n| width, adding spaces for indentation\n| to any added line.\n|\n*/\npub fn format_paragraph(in_: &str, width: Option<usize>, indent: Option<usize>) -> Result<String,FormatParagraphError> {\n    let width  = width.unwrap_or(79);\n    let indent = indent.unwrap_or(0);\n\n    let mut out = String::new();\n    let mut start = 0;\n\n    while start < in_.len() {\n        // Handle explicit newlines as hard breaks\n        let nl = in_[start..].find('\\n').map(|i| start + i).unwrap_or(in_.len());\n        let mut line_start = start;\n\n        while line_start < nl {\n            let line_end_limit = (line_start + width).min(nl);\n            let segment = &in_[line_start..line_end_limit];\n\n            let break_at = segment.rfind(' ').or_else(|| segment.rfind('\\t'));\n\n            let cut = if line_end_limit == nl || break_at.is_none() {\n                line_end_limit\n            } else {\n                line_start + break_at.unwrap()\n            };\n\n            out.push_str(&in_[line_start..cut]);\n            out.push('\\n');\n\n            if cut < nl {\n                if indent > 0 { out.push_str(&\" \".repeat(indent)); }\n                line_start = cut + 1; // skip the space\n            } else {\n                line_start = cut;\n            }\n        }\n\n        start = if nl < in_.len() { nl + 1 } else { nl };\n        if start == in_.len() && !out.ends_with('\\n') {\n            out.push('\\n');\n        }\n    }\n\n    Ok(out)\n}\n\n\n/**\n| Format a string to be used as option description\n| in help messages\n| \n| -----------\n| @param option\n| Option message (e.g. \"-rpcuser=<user>\")\n| ----------\n| @param message\n| Option description (e.g. \"Username\n| for JSON-RPC connections\")\n| @return\n| the formatted string\n|\n*/\npub fn help_message_opt(option: &str, message: &str) -> String {\n    let paragraph = format_paragraph(\n        message,\n        Some(SCREEN_WIDTH - MSG_INDENT),\n        Some(MSG_INDENT)\n    );\n\n    match paragraph {\n        Ok(paragraph) => {\n            format!{\n                \"{}{}\\n{}{}\\n\\n\",\n                \" \".repeat(OPT_INDENT),\n                option,\n                \" \".repeat(MSG_INDENT),\n                paragraph\n            }\n        },\n        Err(e) => {\n            panic!{\"format_paragraph failed with error: {:?}\", e}\n        }\n    }\n}\n\n\n/**\n| Most paths passed as configuration\n| arguments are treated as relative to\n| the datadir if they are not absolute.\n| \n| -----------\n| @param path\n| The path to be conditionally prefixed\n| with datadir.\n| ----------\n| @param net_specific\n| Use network specific datadir variant\n| @return\n| The normalized path.\n|\n*/\npub fn abs_path_for_config_val(path: &Path, net_specific: Option<bool>) -> PathBuf {\n    let net_specific = net_specific.unwrap_or(true);\n\n    if path.is_absolute() {\n        return path.to_path_buf();\n    }\n\n    let base0 = if net_specific {\n        G_ARGS.lock().cs_args.lock().get_data_dir_net()\n    } else {\n        G_ARGS.lock().cs_args.lock().get_data_dir_base()\n    };\n\n    let base = std::fs::canonicalize(&base0).unwrap_or(base0); // best-effort\n\n    let mut builder = PathBuf::new();\n    builder.push(base);\n    builder.push(path); // do NOT canonicalize the target file (may not exist)\n    builder\n}\n\n\npub fn setup_bitcoin_tx_args(argsman: &mut ArgsManager) {\n    // Help options first\n    argsman.setup_help_options();\n\n    // Basic options\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"-version\",\n            help:     \"Print version and exit\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::OPTIONS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"-create\",\n            help:     \"Create new, empty TX.\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::OPTIONS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"-json\",\n            help:     \"Select JSON output\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::OPTIONS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"-txid\",\n            help:     \"Output only the hex-encoded transaction id of the resultant transaction.\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::OPTIONS,\n        }\n    );\n\n    // Chain params (same as C++ SetupChainParamsBaseOptions)\n    argsman.setup_chain_params_base_options();\n\n    // Command-style arguments (Category: COMMANDS). These are not subcommands\n    // in the ArgsManager sense (which would use add_command), but \"commands\"\n    // as bitcoin-tx style pseudo-ops. In Core they were registered with AddArg\n    // in the COMMANDS category, not AddCommand (so we mirror that).\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"delin=N\",\n            help:     \"Delete input N from TX\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"delout=N\",\n            help:     \"Delete output N from TX\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"in=TXID:VOUT(:SEQUENCE_NUMBER)\",\n            help:     \"Add input to TX\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"locktime=N\",\n            help:     \"Set TX lock time to N\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"nversion=N\",\n            help:     \"Set TX version to N\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"outaddr=VALUE:ADDRESS\",\n            help:     \"Add address-based output to TX\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"outdata=[VALUE:]DATA\",\n            help:     \"Add data-based output to TX\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\",\n            help:     concat!(\n                \"Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS. \",\n                \"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output. \",\n                \"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"\n            ).to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"outpubkey=VALUE:PUBKEY[:FLAGS]\",\n            help:     concat!(\n                \"Add pay-to-pubkey output to TX. \",\n                \"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output. \",\n                \"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"\n            ).to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"outscript=VALUE:SCRIPT[:FLAGS]\",\n            help:     concat!(\n                \"Add raw script output to TX. \",\n                \"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output. \",\n                \"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"\n            ).to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&ArgDescriptor {\n        name:     \"replaceable=<N>\",\n        help:     \"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\".to_string(),\n        flags:    ArgsManagerFlags::ALLOW_ANY,\n        category: OptionsCategory::COMMANDS,\n    });\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"sign=SIGHASH-FLAGS\",\n            help:     concat!(\n                \"Add zero or more signatures to transaction. \",\n                \"This command requires JSON registers:\",\n                \"prevtxs=JSON object, \",\n                \"privatekeys=JSON object. \",\n                \"See signrawtransactionwithkey docs for format of sighash flags, JSON objects.\"\n            ).to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::COMMANDS,\n        }\n    );\n\n    // Register-type commands\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"load=NAME:FILENAME\",\n            help:     \"Load JSON file FILENAME into register NAME\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::REGISTER_COMMANDS,\n        }\n    );\n\n    argsman.add_arg(&\n        ArgDescriptor {\n            name:     \"set=NAME:JSON-STRING\",\n            help:     \"Set register NAME to given JSON-STRING\".to_string(),\n            flags:    ArgsManagerFlags::ALLOW_ANY,\n            category: OptionsCategory::REGISTER_COMMANDS,\n        }\n    );\n}\n\n\n/**\n| Return the currently selected parameters.\n| This won't change after app startup,\n| except for unit tests.\n|\n*/\npub fn base_params() -> MutexGuard<'static, BaseChainParams> {\n    global_chain_base_params.lock()\n}\n\n\n/**\n| Creates and returns\n| a std::unique_ptr<CBaseChainParams> of the\n| chosen chain.\n| \n| -----------\n| @return\n| a CBaseChainParams* of the chosen chain.\n| @throws a std::runtime_error if the\n| chain is not supported.\n|\n-------------------------\n| Port numbers for incoming Tor connections\n| (8334, 18334, 38334, 18445) have been\n| chosen arbitrarily to keep ranges of\n| used ports tight.\n*/\npub fn create_base_chain_params(chain: &str) -> Result<Box<BaseChainParams>, StdException> {\n    match chain {\n        base_chain_params::MAIN => {\n            Ok(Box::new(BaseChainParams::new(\"\",8332,8334)))\n        },\n        base_chain_params::TESTNET => {\n            Ok(Box::new(BaseChainParams::new(\"testnet3\",18332,18334)))\n        },\n        base_chain_params::SIGNET => {\n            Ok(Box::new(BaseChainParams::new(\"signet\",38332,38334)))\n        },\n        base_chain_params::REGTEST => {\n            Ok(Box::new(BaseChainParams::new(\"regtest\",18443,18445)))\n        },\n        _ => {\n            let msg = format!(\"{}: Unknown chain {}.\",func![],chain);\n            Err(runtime_error(&msg))\n        }\n    }\n}\n\n\n/**\n| Sets the params returned by Params()\n| to those for the given network.\n|\n*/\npub fn select_base_params(chain: &str) {\n    *base_params() = *create_base_chain_params(chain).unwrap();\n\n    let guard = G_ARGS.lock();\n\n    let mut inner = (*guard).cs_args.lock();\n\n    inner.select_config_network(chain);\n}\n\n\npub fn setting_name(arg: &str) -> String {\n    match arg.len() > 0 && arg.chars().nth(0).unwrap() == '-' {\n        true   => arg[1..].to_string(),\n        false  => arg.to_string()\n    }\n}\n\n\npub fn get_config_file(conf_path: &str) -> PathBuf {\n    let path = Path::new(conf_path);\n\n    abs_path_for_config_val(&path,Some(false))\n}\n\n\n/**\n| Return true if -datadir option points\n| to a valid directory or is not specified.\n|\n*/\npub fn check_data_dir_option() -> bool {\n    let datadir: String = G_ARGS\n        .lock()\n        .cs_args\n        .lock()\n        .get_arg(\"-datadir\", \"\");\n\n    let path = Path::new(&datadir);\n\n    datadir.is_empty() || std::fs::canonicalize(path).unwrap().is_dir()\n}\n\n\n/**\n| Check settings value validity according\n| to flags.\n| \n| TODO: Add more meaningful error checks\n| here in the future\n| See \"here's how the flags are meant to\n| behave\" in https://github.com/bitcoin/bitcoin/pull/16097#issuecomment-514627823\n|\n*/\npub fn check_valid(\n    key:   &str,\n    val:   &SettingsValue,\n    flags: u32,\n    error: &mut String\n) -> bool\n{\n    if val.0.is_bool() \n    && (flags & ArgsManagerFlags::ALLOW_BOOL.bits()) == 0 \n    {\n        *error = format!{\"Negating of -{} is meaningless and therefore forbidden\",key};\n        return false;\n    }\n\n    true\n}\n\n\npub fn get_config_options<R: std::io::Read>(\n    stream:   &mut std::io::BufReader<R>,\n    filepath: &str,\n    error:    &mut String,\n    options:  &mut Vec<(String,String)>,\n    sections: &mut LinkedList<SectionInfo>\n) -> bool\n{\n    let mut linenr: i32 = 0;\n\n    loop {\n        let mut line = String::new();\n        match stream.read_line(&mut line) {\n            Ok(0) => break,       // EOF\n            Ok(_) => { /* proceed */ }\n            Err(_) => break,      // treat read errors as EOF here\n        }\n        linenr += 1;\n\n        // Strip inline comments\n        let mut used_hash = false;\n        if let Some(p) = line.find('#') {\n            line.truncate(p);\n            used_hash = true;\n        }\n\n        lazy_static! {\n            static ref PAT: String = \" \\t\\r\\n\".to_string();\n        }\n        let mut s = trim_string(&line, Some(PAT.as_str()));\n        if s.is_empty() { continue; }\n\n        if s.starts_with('[') && s.ends_with(']') {\n            // section header\n            let section = s[1..s.len()-1].to_string();\n            sections.push_back(SectionInfo::new(&section, filepath, linenr));\n            s = format!(\"{}.\", section);\n            continue;\n        }\n\n        if s.starts_with('-') {\n            *error = format!(\n                \"parse error on line {}: {}, options in configuration file must be specified without leading -\",\n                linenr, s\n            );\n            return false;\n        }\n\n        if let Some(eq) = s.find('=') {\n            let name = format!(\n                \"{}{}\",\n                if let Some(d) = s.rfind('.') { s[..=d].to_string() } else { \"\".to_string() },\n                trim_string(&s[..eq].to_string(), Some(PAT.as_str()))\n            );\n            let value = trim_string(&s[eq+1..].to_string(), Some(PAT.as_str()));\n\n            if used_hash && name.contains(\"rpcpassword\") {\n                *error = format!(\n                    \"parse error on line {}, using # in rpcpassword can be ambiguous and should be avoided\",\n                    linenr\n                );\n                return false;\n            }\n\n            options.push((name.clone(), value));\n\n            if let Some(dot) = name.rfind('.') {\n                let section = &name[..dot];\n                sections.push_back(SectionInfo::new(section, filepath, linenr));\n            }\n        } else {\n            *error = format!(\"parse error on line {}: {}\", linenr, s);\n            if s.len() >= 2 && &s[..2] == \"no\" {\n                *error = format!(\n                    \"{}, if you intended to specify a negated option, use {}=1 instead\",\n                    error, s\n                );\n            }\n            return false;\n        }\n    }\n\n    true\n}\n\n\npub fn save_errors(errors: Vec<String>, mut error_out: Option<&mut Vec<String>>) {\n    for error in errors.iter() {\n\n        if let Some(ref mut vec) = error_out {\n            vec.push(error.to_string());\n\n        } else {\n            log_printf!(\"{}\\n\", error);\n        }\n    }\n}\n\n\npub fn rename_over(src: &Path, dst: &Path) -> bool {\n    std::fs::rename(src, dst).is_ok()\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Get data directory path\n    | \n    | -----------\n    | @return\n    | Absolute path on success, otherwise\n    | an empty path when a non-directory path\n    | would be returned @post Returned directory\n    | path is created unless it is empty\n    |\n    */\n    pub fn get_data_dir_base(&self) -> PathBuf {\n        self.get_data_dir(false)\n    }\n\n    /**\n    | Get data directory path with appended\n    | network identifier\n    | \n    | -----------\n    | @return\n    | Absolute path on success, otherwise\n    | an empty path when a non-directory path\n    | would be returned @post Returned directory\n    | path is created unless it is empty\n    |\n    */\n    pub fn get_data_dir_net(&self) -> PathBuf {\n        self.get_data_dir(true)\n    }\n\n    /**\n    | Get data directory path\n    | \n    | -----------\n    | @param net_specific\n    | Append network identifier to the returned\n    | path\n    | @return\n    | Absolute path on success, otherwise\n    | an empty path when a non-directory path\n    | would be returned @post Returned directory\n    | path is created unless it is empty\n    |\n    */\n    pub fn get_data_dir(&self, net_specific: bool) -> PathBuf {\n        let maybe_cached = match net_specific {\n            true   => self.cached_network_datadir_path.as_ref(),\n            false  => self.cached_datadir_path.as_ref()\n        };\n        if let Some(path) = maybe_cached {\n            return path.to_path_buf();\n        }\n    \n        let mut buf: PathBuf = PathBuf::new();\n        let datadir: String = self.get_arg(\"-datadir\",\"\");\n    \n        if !datadir.is_empty() {\n            // Keep exactly what the user passed (matches Core expectations/tests).\n            buf.push(Path::new(&datadir));\n    \n            if !buf.as_path().is_dir() {\n                buf.clear();\n                return buf;\n            }\n        } else {\n            buf.push(get_default_data_dir());\n        }\n    \n        if net_specific {\n            buf.push(base_params().data_dir());\n        }\n    \n        // Create datadir and wallets/ on first run\n        if std::fs::create_dir_all(&buf).is_ok() {\n            let mut subdir = buf.clone();\n            subdir.push(\"wallets\");\n            let _ = std::fs::create_dir_all(subdir);\n        }\n    \n        strip_redundant_last_elements_of_path(&mut buf);\n        buf\n    }\n}\n\nimpl SectionInfo {\n\n    pub fn new(name: &str, file: &str, line: i32) -> Self {\n        Self { \n            name: name.to_string(), \n            file: file.to_string(), \n            line: line \n        }\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /// Add subcommand\n    pub fn add_command(&mut self, cmd: &str, help: &str) {\n        assert!(cmd.find('=') == None);\n        assert!(cmd.chars().nth(0) != Some('-'));\n    \n        // latch to false\n        self.accept_any_command = false;\n    \n        let arg_map = self\n            .available_args\n            .entry(OptionsCategory::COMMANDS)\n            .or_insert_with(HashMap::new);\n    \n        let ret = arg_map.insert(\n            cmd.to_string(),\n            ArgsManagerArg::new(\"\", help, ArgsManagerFlags::COMMAND),\n        );\n    \n        // Fail on duplicate commands\n        assert!(ret.is_none());\n    }\n\n    /**\n    | Add argument\n    |\n    */\n    pub fn add_arg(&mut self, x: &ArgDescriptor) {\n        let ArgDescriptor { name, help, flags, category } = x;\n    \n        //  use AddCommand\n        assert!((*flags & ArgsManagerFlags::COMMAND).bits() == 0);\n    \n        //  Split arg name from its help param\n        let mut eq_index: usize = match name.find(\"=\") {\n            Some(item) => item,\n            None       => name.len(),\n        };\n    \n        let arg_name: String \n        = name[0..eq_index]\n            .to_string();\n    \n        //LOCK(cs_args);\n    \n        let arg_map = self\n            .available_args\n            .entry(*category) // requires OptionsCategory: Copy\n            .or_insert_with(HashMap::new);\n    \n        let ret = arg_map.insert(\n            arg_name.clone(), \n            ArgsManagerArg::new(\n                // Help parameter (e.g. \"=<chain>\") should be the suffix starting at '='\n                // or empty if there is no '='.\n                &(if eq_index < name.len() { name[eq_index..].to_string() } else { \"\".to_string() }),\n                help,\n                *flags\n            )\n        );\n    \n        //  Make sure an insertion actually happened\n        assert!(ret.is_none());\n    \n        if (*flags & ArgsManagerFlags::NETWORK_ONLY).bits() != 0 {\n            self.network_only_args.insert(arg_name);\n        }\n    }\n\n    /**\n    | Add many hidden arguments\n    |\n    */\n    pub fn add_hidden_args(&mut self, names: &Vec<&'static str>) {\n        for name in names.iter() {\n            let desc = ArgDescriptor {\n                name:     name,\n                help:     \"\".to_string(),\n                flags:    ArgsManagerFlags::ALLOW_ANY, \n                category: OptionsCategory::HIDDEN\n            };\n    \n            self.add_arg(&desc);\n        }\n    }\n\n    pub fn setup_cli_args(&mut self) {\n        self.setup_help_options();\n    \n        self.add_arg(&ARG_VERSION);\n        self.add_arg(&ARG_SET_CONF_FILE);\n        self.add_arg(&ARG_SET_DATADIR);\n        self.add_arg(&ARG_GENERATE);\n        self.add_arg(&ARG_ADDRINFO);\n        self.add_arg(&ARG_GETINFO);\n        self.add_arg(&ARG_NETINFO); \n    \n        self.setup_chain_params_base_options();\n    \n        self.add_arg(&ARG_SET_COLOR);\n        self.add_arg(&ARG_NAMED);\n        self.add_arg(&ARG_SET_RPC_CLIENTTIMEOUT);\n        self.add_arg(&ARG_SET_RPC_COOKIEFILE);\n        self.add_arg(&ARG_SET_RPC_CONNECT);\n        self.add_arg(&ARG_SET_RPC_PASSWORD);\n        self.add_arg(&ARG_SET_RPC_PORT);\n        self.add_arg(&ARG_SET_RPC_USER);\n        self.add_arg(&ARG_SET_RPC_WAIT);\n        self.add_arg(&ARG_SET_RPC_WAITTIMEOUT);\n        self.add_arg(&ARG_SET_RPC_WALLET);\n        self.add_arg(&ARG_STDIN);\n        self.add_arg(&ARG_STDINRPCPASS);\n        self.add_arg(&ARG_STDINWALLETPASSPHRASE);\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Helper function for LogArgs().\n    |\n    */\n    pub fn log_args_prefix(\n        &self,\n        prefix:  &str,\n        section: &str,\n        args:    &HashMap<String,Vec<SettingsValue>>\n    )\n    {\n        let section_str = if section.is_empty() {\n            \"\".to_string()\n        } else {\n            format!(\"[{}] \", section)\n        };\n    \n        for (name, values) in args.iter() {\n            for value in values.iter() {\n                let flags = self.get_arg_flags(&format!(\"-{}\", name));\n                if let Some(flags) = flags {\n                    let value_str = if (flags & ArgsManagerFlags::SENSITIVE.bits()) != 0 {\n                        \"****\".to_string()\n                    } else {\n                        value.0.write(None, None)\n                    };\n                    log_printf!(\"{} {}{}={}\\n\", prefix, section_str, name, value_str);\n                }\n            }\n        }\n    }\n\n    /**\n    | Log the config file options and the command\n    | line arguments, useful for troubleshooting.\n    |\n    */\n    pub fn log_args(&self) {\n        for (section_name, section_args) in self.settings.ro_config().iter() {\n            self.log_args_prefix(\"Config file arg:\", section_name, section_args);\n        }\n    \n        for (k, v) in self.settings.rw_settings().iter() {\n            log_printf!(\"Setting file arg: {} = {}\\n\", k, v);\n        }\n    \n        self.log_args_prefix(\n            \"Command-line arg:\",\n            \"\",\n            self.settings.command_line_options(),\n        );\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Get the help string\n    |\n    */\n    pub fn get_help_message(&self) -> String {\n        let show_debug: bool = self.get_bool_arg(\"-help-debug\",false);\n    \n        let mut usage: String = \"\".to_string();\n    \n        for arg_map in self.available_args.iter() {\n    \n            match arg_map.0 {\n    \n                OptionsCategory::OPTIONS  => {\n                    usage += &help_message_group(\"Options:\");\n                },\n    \n                OptionsCategory::CONNECTION  => {\n                    usage += &help_message_group(\"Connection options:\");\n                },\n    \n                OptionsCategory::ZMQ  => {\n                    usage += &help_message_group(\"ZeroMQ notification options:\");\n                },\n    \n                OptionsCategory::DEBUG_TEST  => {\n                    usage += &help_message_group(\"Debugging/Testing options:\");\n                },\n    \n                OptionsCategory::NODE_RELAY  => {\n                    usage += &help_message_group(\"Node relay options:\");\n                },\n    \n                OptionsCategory::BLOCK_CREATION  => {\n                    usage += &help_message_group(\"Block creation options:\");\n                },\n    \n                OptionsCategory::RPC  => {\n                    usage += &help_message_group(\"RPC server options:\");\n                },\n    \n                OptionsCategory::WALLET  => {\n                    usage += &help_message_group(\"Wallet options:\");\n                },\n    \n                OptionsCategory::WALLET_DEBUG_TEST  => {\n                    if show_debug {\n                        usage += &help_message_group(\"Wallet debugging/testing options:\");\n                    }\n                },\n    \n                OptionsCategory::CHAINPARAMS  => {\n                    usage += &help_message_group(\"Chain selection options:\");\n                },\n    \n                OptionsCategory::GUI  => {\n                    usage += &help_message_group(\"UI Options:\");\n                },\n    \n                OptionsCategory::COMMANDS  => {\n                    usage += &help_message_group(\"Commands:\");\n                },\n    \n                OptionsCategory::REGISTER_COMMANDS  => {\n                    usage += &help_message_group(\"Register Commands:\");\n                },\n    \n                _  => { },\n            }\n    \n            // When we get to the hidden options, stop\n            if arg_map.0 == &OptionsCategory::HIDDEN {\n                break;\n            }\n    \n            for arg in arg_map.1.iter() {\n    \n                if show_debug || (arg.1.flags & ArgsManagerFlags::DEBUG_ONLY.bits()) == 0 {\n    \n                    let mut name = String::default();\n    \n                    if arg.1.help_param.is_empty() {\n                        name = arg.0.to_string();\n                    } else {\n                        name = format!{\"{}{}\", arg.0, arg.1.help_param};\n                    }\n    \n                    usage += &help_message_opt(\n                        &name,\n                        &arg.1.help_text\n                    );\n                }\n            }\n        }\n    \n        usage\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Clear available arguments\n    |\n    */\n    pub fn clear_args(&mut self) {\n        self.available_args.clear();\n        self.network_only_args.clear();\n    }\n\n    /**\n    | Clear cached directory paths\n    |\n    */\n    pub fn clear_path_cache(&mut self) {\n        self.cached_datadir_path         = None;\n        self.cached_network_datadir_path = None;\n        self.cached_blocks_path          = None;\n    }\n}\n\nimpl ArgsManager {\n\n    #[inline]\n    pub fn add_command(&mut self, cmd: &str, help: &str) {\n        self.cs_args.lock().add_command(cmd,help)\n    }\n\n    #[inline]\n    pub fn add_arg(&mut self, x: &ArgDescriptor) {\n        self.cs_args.lock().add_arg(x)\n    }\n\n    #[inline]\n    pub fn add_hidden_args(&mut self, names: &Vec<&'static str>) {\n        self.cs_args.lock().add_hidden_args(names)\n    }\n\n    #[inline]\n    pub fn setup_cli_args(&mut self) {\n        self.cs_args.lock().setup_cli_args()\n    }\n\n    #[inline]\n    pub fn setup_chain_params_base_options(&mut self) {\n        self.cs_args.lock().setup_chain_params_base_options()\n    }\n\n    #[inline]\n    pub fn clear_args(&mut self) {\n        self.cs_args.lock().clear_args()\n    }\n\n    #[inline]\n    pub fn clear_path_cache(&mut self) {\n        self.cs_args.lock().clear_path_cache()\n    }\n\n    #[inline]\n    pub fn get_arg_flags(&self, name: &str) -> Option<u32> {\n        self.cs_args.lock().get_arg_flags(name)\n    }\n\n    #[inline]\n    pub fn get_args(&self, str_arg: &str) -> Vec<String> {\n        self.cs_args.lock().get_args(str_arg)\n    }\n\n    #[inline]\n    pub fn get_arg(&self, str_arg: &str, str_default: &str) -> String {\n        self.cs_args.lock().get_arg(str_arg,str_default)\n    }\n\n    #[inline]\n    pub fn get_int_arg(&self, str_arg: &str, n_default: i64) -> i64 {\n        self.cs_args.lock().get_int_arg(str_arg,n_default)\n    }\n\n    #[inline]\n    pub fn get_bool_arg(&self, str_arg: &str, default: bool) -> bool {\n        self.cs_args.lock().get_bool_arg(str_arg,default)\n    }\n\n    #[inline]\n    pub fn get_blocks_dir_path(&self) -> Box<Path> {\n        self.cs_args.lock().get_blocks_dir_path()\n    }\n\n    #[inline]\n    pub fn get_chain_name(&mut self) -> Result<String,StdException> {\n        self.cs_args.lock().get_chain_name()\n    }\n\n    #[inline]\n    pub fn get_command(&self) -> Option<ArgsManagerCommand> {\n        self.cs_args.lock().get_command()\n    }\n\n    pub fn get_data_dir_base(&self) -> PathBuf {\n        self.cs_args.lock().get_data_dir_base()\n    }\n\n    pub fn get_data_dir_net(&self) -> PathBuf {\n        self.cs_args.lock().get_data_dir_net()\n    }\n\n    pub fn get_data_dir(&self, net_specific: bool) -> PathBuf {\n        self.cs_args.lock().get_data_dir(net_specific)\n    }\n\n    pub fn get_help_message(&self) -> String {\n        self.cs_args.lock().get_help_message()\n    }\n\n    pub fn get_settings_path(&self, filepath: Option<&mut Box<Path>>, temp: Option<bool>) -> bool {\n        self.cs_args.lock().get_settings_path(filepath,temp)\n    }\n\n    pub fn get_setting(&self, arg: &str) -> SettingsValue {\n        self.cs_args.lock().get_setting(arg)\n    }\n\n    pub fn get_settings_list(&self, arg: &str) -> Vec<SettingsValue> {\n        self.cs_args.lock().get_settings_list(arg)\n    }\n\n    pub fn get_unrecognized_sections(&self) -> LinkedList<SectionInfo> {\n        self.cs_args.lock().get_unrecognized_sections()\n    }\n\n    pub fn help_requested(&self) -> bool {\n        self.cs_args.lock().help_requested()\n    }\n\n    pub fn setup_help_options(&mut self) {\n        self.cs_args.lock().setup_help_options()\n    }\n\n    pub fn log_args_prefix(\n        &self,\n        prefix:  &str,\n        section: &str,\n        args:    &HashMap<String,Vec<SettingsValue>>\n    )\n    {\n        self.cs_args.lock().log_args_prefix(prefix,section,args)\n    }\n\n    pub fn log_args(&self) {\n        self.cs_args.lock().log_args()\n    }\n\n    pub fn parse_parameters(&mut self, argv: &Vec<String>, error: &mut String) -> bool {\n        self.cs_args.lock().parse_parameters(argv,error)\n    }\n\n    pub fn is_arg_set(&self, str_arg: &str) -> bool {\n        self.cs_args.lock().is_arg_set(str_arg)\n    }\n\n    pub fn is_arg_negated(&self, str_arg: &str) -> bool {\n        self.cs_args.lock().is_arg_negated(str_arg)\n    }\n\n    pub fn read_config_stream<R: std::io::Read>(\n        &mut self,\n        stream:              &mut std::io::BufReader<R>,\n        filepath:            &str,\n        error:               &mut String,\n        ignore_invalid_keys: Option<bool>\n    ) -> bool\n    {\n        self.cs_args.lock()\n            .read_config_stream(stream,filepath,error,ignore_invalid_keys)\n    }\n\n    pub fn read_config_files(&mut self, error: &mut String, ignore_invalid_keys: Option<bool>) -> bool {\n        self.cs_args.lock()\n            .read_config_files(error,ignore_invalid_keys)\n    }\n\n    pub fn select_config_network(&mut self, network: &str) {\n        self.cs_args.lock()\n            .select_config_network(network)\n    }\n\n    pub fn soft_set_arg(&mut self, str_arg: &str, str_value: &str) -> bool {\n        self.cs_args.lock()\n            .soft_set_arg(str_arg, str_value)\n    }\n\n    pub fn force_set_arg(&mut self, str_arg: &str, str_value: &str) {\n        self.cs_args.lock()\n            .force_set_arg(str_arg, str_value)\n    }\n\n    pub fn soft_set_bool_arg(&mut self, str_arg: &str, value: bool) -> bool {\n        self.cs_args.lock()\n            .soft_set_bool_arg(str_arg, value)\n    }\n\n    pub fn init_settings(&mut self, error: &mut String) -> Result<(),String> {\n        self.cs_args.lock()\n            .init_settings(error)\n    }\n\n    pub fn read_settings_file(&mut self, errors: Option<&mut Vec<String>>) -> bool {\n        self.cs_args.lock()\n            .read_settings_file(errors)\n    }\n\n    pub fn write_settings_file(&self, mut errors: Option<&mut Vec<String>>) -> Result<bool,StdException> {\n        self.cs_args.lock()\n            .write_settings_file(errors)\n    }\n\n    pub fn use_default_section(&self, arg: &str) -> bool {\n        self.cs_args.lock()\n            .use_default_section(arg)\n    }\n}\n\nimpl Default for ArgsManagerInner {\n\n    fn default() -> Self {\n        Self {\n            settings:                    Settings::default(),\n            command:                     Vec::new(),\n            network:                     None,\n            network_only_args:           HashSet::new(),\n            available_args:              HashMap::new(),\n            accept_any_command:          true,     // <-- important\n            config_sections:             LinkedList::new(),\n            cached_blocks_path:          None,\n            cached_datadir_path:         None,\n            cached_network_datadir_path: None,\n        }\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Return true if the given argument has\n    | been manually set\n    | \n    | -----------\n    | @param strArg\n    | Argument to get (e.g. \"-foo\")\n    | @return\n    | true if the argument has been set\n    |\n    */\n    pub fn is_arg_set(&self, str_arg: &str) -> bool {\n        !self.get_setting(str_arg).0.is_null()\n    }\n\n    /**\n    | Return true if the argument was originally\n    | passed as a negated option, i.e. -nofoo.\n    | \n    | -----------\n    | @param strArg\n    | Argument to get (e.g. \"-foo\")\n    | @return\n    | true if the argument was passed negated\n    |\n    */\n    pub fn is_arg_negated(&self, str_arg: &str) -> bool {\n        self.get_setting(str_arg).0.is_false()\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Get blocks directory path\n    | \n    | -----------\n    | @return\n    | Blocks path which is network specific\n    |\n    */\n    pub fn get_blocks_dir_path(&self) -> Box<Path> {\n        let maybe_cached = self.cached_blocks_path.as_ref();\n    \n        // Cache the path to avoid calling\n        // fs::create_directories on every call of\n        // this function\n        if let Some(path) = maybe_cached {\n    \n            //in c++ we just returned a reference\n            //to path.\n            //\n            //depending on how frequently this is\n            //called, we may not want to alway\n            //clone\n            //\n            //however, this function either\n            //generates a new boxed path or\n            //returns one which already exists\n            //\n            //currently, we clone the one which\n            //already exists in this branch\n            //\n            //if we want to avoid this clone, we\n            //could consider using an Rc\n            return path.clone();\n        }\n    \n        let mut buf: PathBuf = PathBuf::new();\n    \n        if self.is_arg_set(\"-blocksdir\") {\n            let arg = self.get_arg(\"-blocksdir\",\"\");\n            let arg_path = Path::new(&arg);\n            // Canonicalize if it exists; otherwise use it as provided.\n            let abs = std::fs::canonicalize(arg_path).unwrap_or_else(|_| arg_path.to_path_buf());\n    \n            buf.push(abs);\n    \n            if !buf.as_path().is_dir() {\n                buf.clear();\n                return buf.into_boxed_path();\n            }\n        } else {\n            buf.push(self.get_data_dir_base());\n        }\n    \n        buf.push(base_params().data_dir());\n    \n        buf.push(\"blocks\");\n    \n        std::fs::create_dir_all(buf.as_path());\n    \n        strip_redundant_last_elements_of_path(&mut buf);\n    \n        buf.into_boxed_path()\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Log warnings for unrecognized section\n    | names in the config file.\n    |\n    */\n    pub fn get_unrecognized_sections(&self) -> LinkedList<SectionInfo> {\n        //LOCK(cs_args);\n    \n        let mut unrecognized: Vec::<SectionInfo> \n        = self.config_sections\n            .iter()\n            .cloned()\n            .collect();\n    \n        unrecognized.retain(|appeared: &SectionInfo| {\n            AVAILABLE_SECTIONS.get(appeared.name.as_str()) == None\n        });\n    \n        unrecognized\n            .iter()\n            .cloned()\n            .collect()\n    }\n}\n\nimpl ArgsManagerInner {\n\n    pub fn parse_parameters(&mut self, argv: &Vec<String>, error: &mut String) -> bool {\n        let argc = argv.len();\n    \n        //LOCK(cs_args);\n    \n        self.settings.command_line_options_mut().clear();\n    \n        for mut i in 1..argc {\n    \n            let mut key: String = argv[i as usize].to_string();\n    \n            #[cfg(MAC_OSX)]\n            {\n                // At the first time when a user\n                // gets the \"App downloaded from\n                // the internet\" warning, and\n                // clicks the Open button, macOS\n                // passes a unique process serial\n                // number (PSN) as\n                // -psn_... command-line argument,\n                // which we filter out.\n                if key.substr(0, 5) == \"-psn_\" {\n                    continue;\n                }\n            }\n    \n            // bitcoin-tx using stdin\n            if key == \"-\" {\n                break;\n            }\n    \n            let mut val = String::default();\n    \n            if let Some(eq_index) = key.find('=') {\n                // Split into key and value (drop the '=')\n                val = key[eq_index + 1..].to_string();\n                key.truncate(eq_index);\n            }\n    \n            #[cfg(WIN32)]\n            {\n                key = to_lower(key);\n    \n                if key[0] == '/' {\n                    key[0] = '-';\n                }\n            }\n    \n            if key.chars().nth(0) != Some('-') {\n    \n                if !self.accept_any_command && self.command.is_empty() {\n    \n                    // The first non-dash arg is a registered command\n                    let flags: Option::<u32> = self.get_arg_flags(&key);\n    \n                    if flags.is_none() || (flags.unwrap() & ArgsManagerFlags::COMMAND.bits()) == 0 {\n    \n                        *error = format!{\n                            \"Invalid command '{}'\",\n                            argv[i as usize]\n                        };\n    \n                        return false;\n                    }\n                }\n    \n                self.command.push(key);\n    \n                while {\n                    i += 1;\n                    i\n                } < argc{\n                    //  The remaining args are command args\n                    self.command.push(argv[i as usize].to_string());\n                }\n    \n                break;\n            }\n    \n            // Transform --foo to -foo\n            if key.len() > 1 && key.chars().nth(1).unwrap() == '-' {\n                key = key[1..].to_string();\n            }\n    \n            //  Transform -foo to foo\n            key = key[1..].to_string();\n    \n            let mut section = String::default();\n    \n            let arg = format!{\"-{}\",key};\n    \n            let value: SettingsValue = interpret_option(&mut section,&mut key,&val);\n    \n            let flags: Option::<u32> = self.get_arg_flags(&arg);\n    \n            // Unknown command line options and\n            // command line options with dot\n            // characters (which are returned from\n            // InterpretOption with nonempty\n            // section strings) are not valid.\n            //\n            // was: if flags.is_none() || section.is_empty()\n            if flags.is_none() || !section.is_empty() {\n                *error = format!(\"Invalid parameter {:?}\", argv[i as usize]);\n                return false;\n            }\n    \n            if !check_valid(&key,&value,flags.unwrap(),error) {\n                return false;\n            }\n    \n            self.settings\n                .command_line_options_mut()\n                .entry(key.clone())\n                .or_insert_with(Vec::new)\n                .push(value);\n        }\n    \n        // we do not allow -includeconf from\n        // command line, only -noincludeconf\n        let includes = self.settings.command_line_options().get( \"includeconf\");\n    \n        if includes.is_some() {\n    \n            let values: SettingsSpan = SettingsSpan::from(includes.unwrap());\n    \n            //  Range may be empty if -noincludeconf was passed\n            if !values.empty() {\n    \n                *error = format!{\n                    \"-includeconf cannot be used from commandline; -includeconf={}\", \n                    unsafe { (*values.begin()).0.write(None, None) }\n                };\n    \n                // pick first value as example\n                return false;\n            }\n        }\n    \n        true\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Returns true if settings values from\n    | the default section should be used,\n    | depending on the current network and\n    | whether the setting is network-specific.\n    |\n    */\n    pub fn use_default_section(&self, arg: &str) -> bool {\n        self.network == Some(base_chain_params::MAIN.to_string()) \n        || !self.network_only_args.contains(arg)\n    }\n}\n\nimpl ArgsManagerArg {\n\n    pub fn new(help_param: &str, help_text: &str, flags: ArgsManagerFlags) -> Self {\n        Self {\n            help_param: help_param.to_string(),\n            help_text:  help_text.to_string(),\n            flags:      flags.bits()\n        }\n    }\n}\n\nimpl BaseChainParams {\n\n    pub fn data_dir(&self) -> &String {\n        &self.str_data_dir\n    }\n\n    pub fn rpc_port(&self) -> u16 {\n        self.rpc_port\n    }\n\n    pub fn onion_service_target_port(&self) -> u16 {\n        self.onion_service_target_port\n    }\n\n    pub fn new(data_dir: &str, rpc_port: u16, onion_service_target_port: u16) -> Self {\n        Self {\n            rpc_port:                  rpc_port,\n            onion_service_target_port: onion_service_target_port,\n            str_data_dir:              data_dir.to_string()\n        }\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Set the arguments for chainparams\n    |\n    */\n    pub fn setup_chain_params_base_options(&mut self) {\n        self.add_arg(&base_options::ARG_SET_CHAIN);\n        self.add_arg(&base_options::ARG_REGTEST);\n        self.add_arg(&base_options::ARG_TESTACTIVATIONHEIGHT);\n        self.add_arg(&base_options::ARG_TESTNET);\n        self.add_arg(&base_options::ARG_SET_VBPARAMS);\n        self.add_arg(&base_options::ARG_SIGNET);\n        self.add_arg(&base_options::ARG_SIGNET_CHALLENGE);\n        self.add_arg(&base_options::ARG_SIGNET_SEEDNODE);\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Get settings file path, or return false\n    | if read-write settings were disabled\n    | with -nosettings.\n    |\n    */\n    pub fn get_settings_path(&self, filepath: Option<&mut Box<Path>>, temp: Option<bool>) -> bool {\n        let temp: bool = temp.unwrap_or(false);\n    \n        if self.is_arg_negated(\"-settings\") {\n            return false;\n        }\n    \n        if filepath.is_some() {\n    \n            let settings: String \n            = self.get_arg(\"-settings\",BITCOIN_SETTINGS_FILENAME);\n    \n            let p2 = match temp {\n                true   => settings + \".tmp\",\n                false  => settings\n            }.to_string();\n    \n            if let Some(filepath) = filepath {\n    \n                let mut buf = PathBuf::new();\n    \n                buf.push(std::fs::canonicalize(self.get_data_dir_net()).unwrap());\n                buf.push(std::fs::canonicalize(p2).unwrap());\n    \n                *filepath = buf.into_boxed_path();\n            }\n        }\n    \n        true\n    }\n\n    /**\n    | Get setting value.\n    | \n    | Result will be null if setting was unset,\n    | true if \"-setting\" argument was passed\n    | false if \"-nosetting\" argument was\n    | passed, and a string if a \"-setting=value\"\n    | argument was passed.\n    |\n    */\n    pub fn get_setting(&self, arg: &str) -> SettingsValue {\n        let key = setting_name(arg);\n    \n        // 1) Command-line options (last value wins, consistent with Core’s behavior).\n        if let Some(values) = self.settings.command_line_options().get(&key) {\n            if let Some(last) = values.last() {\n                return last.clone();\n            }\n        }\n    \n        // 2) Forced settings (used by force_set_arg). Prefer last-like behavior if present.\n        if let Some(v) = self.settings.forced_settings().get(&key) {\n            return v.clone();\n        }\n    \n        // 3) Nothing set => null\n        SettingsValue(UniValue::default()) // default is a null UniValue\n    }\n\n    /**\n    | Get list of setting values.\n    |\n    */\n    pub fn get_settings_list(&self, arg: &str) -> Vec<SettingsValue> {\n        let key = setting_name(arg);\n    \n        if let Some(values) = self.settings.command_line_options().get(&key) {\n            return values.clone();\n        }\n        if let Some(v) = self.settings.forced_settings().get(&key) {\n            return vec![v.clone()];\n        }\n        Vec::new()\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | @return\n    | \n    | true if help has been requested via a\n    | command-line arg\n    |\n    */\n    pub fn help_requested(&self) -> bool {\n        self.is_arg_set(\"-?\") \n            || self.is_arg_set(\"-h\") \n            || self.is_arg_set(\"-help\") \n            || self.is_arg_set(\"-help-debug\")\n    }\n\n    /**\n    | Add help options to the args manager\n    |\n    */\n    pub fn setup_help_options(&mut self) {\n        self.add_arg(&ARG_HELP);\n    \n        self.add_hidden_args(&vec!{\"-h\", \"-help\"});\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Set an argument if it doesn't already\n    | have a value\n    | \n    | -----------\n    | @param strArg\n    | Argument to set (e.g. \"-foo\")\n    | ----------\n    | @param strValue\n    | Value (e.g. \"1\")\n    | @return\n    | true if argument gets set, false if it\n    | already had a value\n    |\n    */\n    pub fn soft_set_arg(&mut self, str_arg: &str, str_value: &str) -> bool {\n        if self.is_arg_set(str_arg) {\n            return false;\n        }\n    \n        self.force_set_arg(str_arg, str_value);\n    \n        true\n    }\n\n    /**\n    | Forces an arg setting. Called by\n    | \n    | SoftSetArg() if the arg hasn't already\n    | been set. Also called directly in testing.\n    |\n    */\n    pub fn force_set_arg(&mut self, str_arg: &str, str_value: &str) {\n        let key = setting_name(str_arg);\n    \n        let uni = match str_value {\n            \"0\" => UniValue::from(false),\n            \"1\" => UniValue::from(true),\n            _   => UniValue::from(str_value),\n        };\n        let val = SettingsValue(uni);\n    \n        // Keep forced map\n        self.settings\n            .forced_settings_mut()\n            .insert(key.clone(), val.clone());\n    \n        // Mirror into CLI options so local resolver sees it\n        self.settings\n            .command_line_options_mut()\n            .entry(key)\n            .or_insert_with(Vec::new)\n            .push(val);\n    }\n\n    /**\n    | Set a boolean argument if it doesn't\n    | already have a value\n    | \n    | -----------\n    | @param strArg\n    | Argument to set (e.g. \"-foo\")\n    | ----------\n    | @param fValue\n    | Value (e.g. false)\n    | @return\n    | true if argument gets set, false if it\n    | already had a value\n    |\n    */\n    pub fn soft_set_bool_arg(&mut self, str_arg: &str, value: bool) -> bool {\n        if value {\n            self.soft_set_arg(str_arg,&\"1\".to_string())\n        } else {\n            self.soft_set_arg(str_arg,&\"0\".to_string())\n        }\n    }\n}\n\nimpl ArgsManagerInner {\n\n    pub fn read_config_stream<R: std::io::Read>(\n        &mut self,\n        stream:              &mut std::io::BufReader<R>,\n        filepath:            &str,\n        error:               &mut String,\n        ignore_invalid_keys: Option<bool>\n    ) -> bool\n    {\n        let ignore_invalid_keys: bool = ignore_invalid_keys.unwrap_or(false);\n    \n        let mut options = Vec::<(String,String)>::default();\n    \n        if !get_config_options(\n            stream,\n            filepath,\n            error,\n            &mut options,\n            &mut self.config_sections) \n        {\n            return false;\n        }\n    \n        for option in options.iter() {\n    \n            let mut section = String::default();\n    \n            let mut key: String = option.0.to_string();\n    \n            let value: SettingsValue = interpret_option(\n                &mut section,\n                &mut key,\n                &option.1\n            );\n    \n            let arg = format!{\"-{}\",key};\n    \n            let flags: Option::<u32> = self.get_arg_flags(&arg);\n    \n            if flags.is_some() {\n    \n                if !check_valid(&key,&value,flags.unwrap(),error) {\n                    return false;\n                }\n    \n                self.settings\n                    .ro_config_mut()\n                    .get_mut(&section)\n                    .unwrap()\n                    .get_mut(&key)\n                    .unwrap()\n                    .push(value);\n    \n            } else {\n    \n                if ignore_invalid_keys {\n    \n                    log_printf!(\n                        \"Ignoring unknown configuration value {}\\n\", \n                        option.0\n                    );\n    \n                } else {\n    \n                    *error = format!{\n                        \"Invalid configuration value {}\",\n                        option.0\n                    };\n    \n                    return false;\n                }\n            }\n        }\n    \n        true\n    }\n\n    pub fn read_config_files(&mut self, error: &mut String, ignore_invalid_keys: Option<bool>) -> bool {\n        let ignore_invalid_keys: bool = ignore_invalid_keys.unwrap_or(false);\n    \n        self.settings.ro_config_mut().clear();\n        self.config_sections.clear();\n    \n        let conf_path: String = self.get_arg(\"-conf\", BITCOIN_CONF_FILENAME);\n    \n        let mut file: Result<File,_> = File::open(get_config_file(&conf_path));\n    \n        // not ok to have a config file specified\n        // that cannot be opened\n        if self.is_arg_set(\"-conf\") && !file.is_ok() {\n    \n            *error = format!{\n                \"specified config file \\\"{}\\\" could not be opened.\",\n                conf_path\n            };\n    \n            return false;\n        }\n    \n        // ok to not have a config file\n        if file.is_ok() {\n    \n            let mut stream = BufReader::new(file.unwrap());\n    \n            if !self.read_config_stream(\n                &mut stream,\n                &conf_path,\n                error,\n                Some(ignore_invalid_keys)) \n            {\n                return false;\n            }\n    \n            // `-includeconf` cannot be included\n            // in the command line arguments\n            // except as `-noincludeconf` (which\n            // indicates that no included conf\n            // file should be used).\n            let mut use_conf_file: bool = true;\n    \n            //LOCK(cs_args);\n    \n            let includes = self.settings.command_line_options().get(\"includeconf\");\n    \n            if includes.is_some() {\n    \n                // ParseParameters() fails if\n                // a non-negated -includeconf is\n                // passed on the command-line\n                assert!(\n                    SettingsSpan::from(includes.unwrap()).last_negated()\n                );\n    \n                use_conf_file = false;\n            }\n    \n            if use_conf_file {\n    \n                let chain_id: String = self.get_chain_name().unwrap();\n    \n                let mut conf_file_names = Vec::<String>::default();\n    \n                let mut add_includes = |\n                    network:         &str, \n                    skip:            Option::<usize>, \n                    conf_file_names: &mut Vec<String>, \n                    settings:        &Settings\n                | {\n    \n                    let skip = skip.unwrap_or(0);\n    \n                    let mut num_values: usize = 0;\n    \n                    //LOCK(cs_args);\n    \n                    let section = settings.ro_config().get(network);\n    \n                    if section.is_some() {\n    \n                        let values = section.unwrap().get(\"includeconf\");\n    \n                        if values.is_some() {\n    \n                            let span = SettingsSpan::from(values.unwrap());\n                            let vlen = values.as_ref().unwrap().len();\n    \n                            for i in max(skip,span.negated())..vlen {\n                                conf_file_names.push(values.unwrap()[i].to_string());\n                            }\n    \n                            num_values = values.unwrap().len();\n                        }\n                    }\n    \n                    return num_values;\n                };\n    \n                // We haven't set m_network yet\n                // (that happens in\n                // SelectParams()), so manually\n                // check for network.includeconf\n                // args.\n                let chain_includes:   usize = add_includes(&chain_id, None, &mut conf_file_names, &self.settings);\n                let default_includes: usize = add_includes(\"\",        None, &mut conf_file_names, &self.settings);\n    \n                for conf_file_name in conf_file_names.iter() {\n    \n                    let mut conf_file_stream: Result<File,_> = File::open(get_config_file(conf_file_name));\n    \n                    if conf_file_stream.is_ok() {\n    \n                        let mut reader = BufReader::new(conf_file_stream.unwrap());\n    \n                        if !self.read_config_stream(\n                            &mut reader,\n                            conf_file_name,\n                            error,\n                            Some(ignore_invalid_keys)) \n                        {\n                            return false;\n                        }\n    \n                        log_printf!(\n                            \"Included configuration file {}\\n\", \n                            conf_file_name\n                        );\n    \n                    } else {\n    \n                        *error = format!{\n                            \"Failed to include configuration file {}\", \n                            conf_file_name\n                        };\n    \n                        return false;\n                    }\n                }\n    \n                //  Warn about recursive -includeconf\n                conf_file_names.clear();\n    \n                add_includes(&chain_id, /* skip= */ Some(chain_includes),   &mut conf_file_names, &self.settings);\n                add_includes(\"\",        /* skip= */ Some(default_includes), &mut conf_file_names, &self.settings);\n    \n                let chain_id_final: String = self.get_chain_name().unwrap();\n    \n                if chain_id_final != chain_id {\n    \n                    // Also warn about recursive\n                    // includeconf for the chain\n                    // that was specified in one\n                    // of the includeconfs\n                    add_includes(&chain_id_final, None, &mut conf_file_names, &self.settings);\n                }\n    \n                for conf_file_name in conf_file_names.iter() {\n                    eprintln!(\n                        \"warning: -includeconf cannot be used from included files; ignoring -includeconf={}\\n\", \n                        conf_file_name\n                    );\n                }\n            }\n        }\n    \n        // If datadir is changed in .conf file:\n        G_ARGS\n            .lock()\n            .cs_args\n            .lock()\n            .clear_path_cache();\n    \n        if !check_data_dir_option() {\n    \n            *error = format!{\n                \"specified data directory \\\"{}\\\" does not exist.\",\n                self.get_arg(\"-datadir\",\"\")\n            };\n    \n            return false;\n        }\n    \n        true\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Returns the appropriate chain name\n    | from the program arguments.\n    | \n    | -----------\n    | @return\n    | CBaseChainParams::MAIN by default;\n    | raises runtime error if an invalid combination\n    | is given.\n    |\n    */\n    pub fn get_chain_name(&mut self) -> Result<String,StdException> {\n        let ignore_default_section_config = false;\n        let get_chain_name                = true;\n        let section = \"\";\n    \n        let mut get_net = |arg: &str| {\n            // Use local resolver\n            let value = self.get_setting(arg);\n            if value.0.is_null() {\n                false\n            } else if value.0.is_bool() {\n                value.0.get_bool()\n            } else {\n                interpret_bool(value.0.get_str())\n            }\n        };\n    \n        let reg_test:         bool = get_net(\"-regtest\");\n        let sig_net:          bool = get_net(\"-signet\");\n        let test_net:         bool = get_net(\"-testnet\");\n        let is_chain_arg_set: bool = self.is_arg_set(\"-chain\");\n    \n        if is_chain_arg_set as i32 + reg_test as i32 + sig_net as i32 + test_net as i32 > 1 {\n            return Err(runtime_error(\"Invalid combination of -regtest, -signet, -testnet and -chain. Can use at most one.\"));\n        }\n    \n        if reg_test {\n            return Ok(base_chain_params::REGTEST.to_string());\n        }\n    \n        if sig_net {\n            return Ok(base_chain_params::SIGNET.to_string());\n        }\n    \n        if test_net {\n            return Ok(base_chain_params::TESTNET.to_string());\n        }\n    \n        Ok(self.get_arg(\"-chain\",base_chain_params::MAIN))\n    }\n}\n\nimpl ArgsManager {\n\n    /**\n    | Log warnings for options in m_section_only_args\n    | when they are specified in the default\n    | section but not overridden on the command\n    | line or in a network-specific section\n    | in the config file.\n    |\n    */\n    pub fn get_unsuitable_section_only_args(&self) -> HashSet<String> {\n        let mut unsuitables = HashSet::<String>::new();\n    \n        let guard = self.cs_args.lock();\n    \n        /*\n          | if there's no section selected, don't\n          | worry\n          |\n          */\n        if guard.network.is_none() {\n            return unsuitables;\n        }\n    \n        /*\n          | if it's okay to use the default section\n          | for this network, don't worry\n          |\n          */\n        if guard.network == Some(base_chain_params::MAIN.to_string()) {\n            return unsuitables;\n        }\n    \n        for arg in guard.network_only_args.iter() {\n    \n            if only_has_default_section_setting(\n                &guard.settings, \n                &guard.network.as_ref().unwrap().as_str(), \n                &setting_name(arg)) \n            {\n                unsuitables.insert(arg.to_string());\n            }\n        }\n    \n        unsuitables\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Access settings with lock held.\n    |\n    */\n    pub fn lock_settings<F: FnMut(&Settings) -> ()>(&mut self, mut fn_: F) {\n        (fn_)(&self.settings);\n    }\n\n    /**\n    | Read and update settings file with saved\n    | settings. This needs to be called after\n    | SelectParams() because the settings\n    | file location is network-specific.\n    |\n    */\n    pub fn init_settings(&mut self, error: &mut String) -> Result<(),String> {\n        if !self.get_settings_path(None, None) {\n    \n            // Do nothing if settings file\n            // disabled.\n            return Ok(());\n        }\n    \n        let mut errors = Vec::<String>::default();\n    \n        let read_settings_result  = self.read_settings_file(Some(&mut errors));\n    \n        if read_settings_result == false {\n            return Err(format!(\"Failed loading settings file:\\n{}\\n\",make_unordered_list(&errors)));\n        }\n    \n        let write_settings_result = self.write_settings_file(Some(&mut errors));\n    \n        if !write_settings_result.is_err() || write_settings_result.unwrap() == false {\n            return Err(format!(\"Failed saving settings file:\\n{}\\n\",make_unordered_list(&errors)));\n        }\n    \n        Ok(())\n    }\n\n    /**\n    | Read settings file. Push errors to vector,\n    | or log them if null.\n    |\n    */\n    pub fn read_settings_file(&mut self, errors: Option<&mut Vec<String>>) -> bool {\n        let temp = false;\n    \n        let mut path: Option<Box<Path>> = None;\n    \n        if !self.get_settings_path(\n            path.as_mut(),\n            Some(temp)) \n        {\n            // Do nothing if settings file disabled.\n            return true;\n        }\n    \n        self.settings.rw_settings_mut().clear();\n    \n        let mut read_errors = Vec::<String>::default();\n    \n        if !read_settings(\n            path.as_ref().unwrap(),\n            &mut self.settings.rw_settings_mut(),\n            &mut read_errors) \n        {\n            save_errors(read_errors, errors);\n            return false;\n        }\n    \n        for setting in self.settings.rw_settings().iter() {\n    \n            let mut section = String::default();\n    \n            let mut key: String = setting.0.to_string();\n    \n            //  Split setting key into section and argname\n            interpret_option(&mut section,&mut key,&Default::default());\n    \n            let arg = format!{\"-{}\", key};\n    \n            if self.get_arg_flags(&arg).is_none() {\n                log_printf!(\n                    \"Ignoring unknown rw_settings value {}\\n\", \n                    setting.0\n                );\n            }\n        }\n    \n        true\n    }\n\n    /**\n    | Write settings file. Push errors to\n    | vector, or log them if null.\n    |\n    */\n    pub fn write_settings_file(&self, mut errors: Option<&mut Vec<String>>) -> Result<bool,StdException> {\n        let mut path:     Option<Box<Path>> = None;\n        let mut path_tmp: Option<Box<Path>> = None;\n    \n        if !self.get_settings_path(path.as_mut(),     /* temp= */ Some(false)) \n        || !self.get_settings_path(path_tmp.as_mut(), /* temp= */ Some(true)) {\n            return Err(logic_error(\"Attempt to write settings file when dynamic settings are disabled.\"));\n        }\n    \n        let mut write_errors = Vec::<String>::default();\n    \n        if !write_settings(\n            path_tmp.as_mut().unwrap(),\n            &self.settings.rw_settings(),\n            &mut write_errors) \n        {\n            save_errors(write_errors, errors);\n            return Ok(false);\n        }\n    \n        if !rename_over(\n            path_tmp.as_ref().unwrap(),\n            path.as_ref().unwrap()) \n        {\n    \n            let msg = format!{\n                \"Failed renaming settings file {:?} to {:?}\\n\",\n                path_tmp.as_ref().unwrap(), \n                path.as_ref().unwrap()\n            };\n    \n            save_errors(vec!{msg}, errors);\n    \n            return Ok(false);\n        }\n    \n        Ok(true)\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Get the command and command args (returns\n    | std::nullopt if no command provided)\n    |\n    */\n    pub fn get_command(&self) -> Option<ArgsManagerCommand> {\n        let mut ret = ArgsManagerCommand::default();\n    \n        if self.command.is_empty() {\n            // No command was passed\n            return None;\n        }\n    \n        let mut it = self.command.iter();\n    \n        if !self.accept_any_command {\n    \n            // The registered command\n            ret.command = Some(it.as_slice()[0].clone());\n    \n            it.next();\n        }\n    \n        while let Some(item) = it.next() {\n    \n            // The unregistered command and args\n            // (if any)\n            ret.args.push(item.to_string());\n        }\n    \n        Some(ret)\n    }\n}\n\nimpl ArgsManagerInner {\n\n    pub fn get_arg_flags(&self, name: &str) -> Option<u32> {\n        for arg_map in self.available_args.iter() {\n    \n            let search = arg_map.1.get(name);\n    \n            if search.is_some() {\n                return Some(search.unwrap().flags);\n            }\n        }\n    \n        None\n    }\n\n    pub fn get_args(&self, str_arg: &str) -> Vec<String> {\n        let mut result = Vec::<String>::default();\n    \n        for value in self.get_settings_list(str_arg).iter() {\n            result.push(\n                match value.0.is_false() {\n                    true   => \"0\",\n                    false  => match value.0.is_true() {\n                        true   => \"1\",\n                        false  => value.0.get_str()\n                    }\n                }.to_string()\n            );\n        }\n    \n        result\n    }\n\n    pub fn get_arg(&self, str_arg: &str, str_default: &str) -> String {\n        let value: SettingsValue = self.get_setting(str_arg);\n    \n        match value.0.is_null() {\n            true   => str_default,\n            false  => match value.0.is_false() {\n                true   => \"0\",\n                false  => match value.0.is_true() {\n                    true   => \"1\",\n                    false  => value.0.get_str()\n                }\n            }\n        }.to_string()\n    }\n\n    /**\n    | Return integer argument or default\n    | value\n    | \n    | -----------\n    | @param strArg\n    | Argument to get (e.g. \"-foo\")\n    | ----------\n    | @param nDefault\n    | (e.g. 1)\n    | @return\n    | command-line argument (0 if invalid\n    | number) or default value\n    |\n    */\n    pub fn get_int_arg(&self, str_arg: &str, n_default: i64) -> i64 {\n        let value: SettingsValue = self.get_setting(str_arg);\n    \n        match value.0.is_null() {\n            true   => n_default,\n            false  => match value.0.is_false() {\n                true   => 0,\n                false  => match value.0.is_true() {\n                    true   => 1,\n                    false  => match value.0.is_num() {\n                        true   => value.0.get_int64(),\n                        false  => locale_independent_atoi::<i64>(value.0.get_str())\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n    | Return boolean argument or default\n    | value\n    | \n    | -----------\n    | @param strArg\n    | Argument to get (e.g. \"-foo\")\n    | ----------\n    | @param fDefault\n    | (true or false)\n    | @return\n    | command-line argument or default value\n    |\n    */\n    pub fn get_bool_arg(&self, str_arg: &str, default: bool) -> bool {\n        let value: SettingsValue = self.get_setting(str_arg);\n    \n        match value.0.is_null() {\n            true   => default,\n            false  => match value.0.is_bool() {\n                true   => value.0.get_bool(),\n                false  => interpret_bool(value.0.get_str())\n            }\n        }\n    }\n}\n\nimpl ArgsManagerInner {\n\n    /**\n    | Select the network in use\n    |\n    */\n    pub fn select_config_network(&mut self, network: &str) {\n        self.network = Some(network.to_string());\n    }\n}\n\n\n\n\nmod base_options {\n    lazy_static!{\n            pub static ref ARG_SET_CHAIN: ArgDescriptor = ArgDescriptor {\n                name: \"-chain=<chain>\", \n                help: formatdoc!{\n                    \"Use the chain <chain> (default:\n                    main). Allowed values: main, test, signet,\n                    regtest\"\n                },\n                flags:    ArgsManagerFlags::ALLOW_ANY, \n                category: OptionsCategory::CHAINPARAMS\n            };\n    \n            pub static ref ARG_REGTEST: ArgDescriptor = ArgDescriptor {\n                name: \"-regtest\", \n                help: formatdoc!{\n                    \"Enter regression test mode, which uses\n                    a special chain in which blocks can be solved\n                    instantly. This is intended for regression testing\n                    tools and app development. Equivalent to\n                    -chain=regtest.\"\n                }, \n                flags:    ArgsManagerFlags::ALLOW_ANY | ArgsManagerFlags::DEBUG_ONLY, \n                category: OptionsCategory::CHAINPARAMS\n            };\n    \n            pub static ref ARG_TESTACTIVATIONHEIGHT: ArgDescriptor = ArgDescriptor {\n                name: \"-testactivationheight=name@height.\", \n                help: format!{\n                    \"Set the activation height of 'name'\n                    (segwit, bip34, dersig,\n                    cltv,csv). (regtest-only)\"\n                }, \n                flags:    ArgsManagerFlags::ALLOW_ANY | ArgsManagerFlags::DEBUG_ONLY, \n                category: OptionsCategory::DEBUG_TEST\n            };\n    \n            pub static ref ARG_TESTNET: ArgDescriptor = ArgDescriptor {\n                name:  \"-testnet\", \n                help:  formatdoc!{\n                    \"Use the test chain. Equivalent to -chain=test.\"\n                }, \n                flags:    ArgsManagerFlags::ALLOW_ANY, \n                category: OptionsCategory::CHAINPARAMS\n            };\n    \n            pub static ref ARG_SET_VBPARAMS: ArgDescriptor = ArgDescriptor {\n                name:  \"-vbparams=deployment:start:end[:min_activation_height]\", \n                help:  formatdoc!{\n                    \"Use given start/end times and\n                    min_activation_height for specified version bits\n                    deployment (regtest-only)\"\n                }, \n                flags:    ArgsManagerFlags::ALLOW_ANY | ArgsManagerFlags::DEBUG_ONLY, \n                category: OptionsCategory::CHAINPARAMS\n            };\n    \n            pub static ref ARG_SIGNET: ArgDescriptor = ArgDescriptor {\n                name: \"-signet\", \n                help: formatdoc!{\n                    \"Use the signet chain. Equivalent to\n                    -chain=signet. Note that the network is defined by\n                    the -signetchallenge parameter\"\n                }, \n                flags:    ArgsManagerFlags::ALLOW_ANY, \n                category: OptionsCategory::CHAINPARAMS\n            };\n    \n            pub static ref ARG_SIGNET_CHALLENGE: ArgDescriptor = ArgDescriptor {\n                name:  \"-signetchallenge\", \n                help:  formatdoc!{\n                    \"Blocks must satisfy the given script\n                    to be considered valid (only for signet networks;\n                    defaults to the global default signet test network\n                    challenge)\"\n                }, \n                flags:    ArgsManagerFlags::ALLOW_STRING, \n                category: OptionsCategory::CHAINPARAMS\n            };\n    \n            pub static ref ARG_SIGNET_SEEDNODE: ArgDescriptor = ArgDescriptor {\n                name: \"-signetseednode\", \n                help: formatdoc!{\n                    \"Specify a seed node for the signet\n                    network, in the hostname[:port] format,\n                    e.g. sig.net:1234 (may be used multiple times to\n                    specify multiple seed nodes; defaults to the\n                    global default signet test networkseed node(s))\"\n                }, \n                flags:    ArgsManagerFlags::ALLOW_STRING, \n                category: OptionsCategory::CHAINPARAMS\n            };\n        }\n}\n\n\nThis crate has the following authors:\n[\n    \"klebs <none>\",\n]\nThis crate has the following rust edition:\n2021\nThis crate has the following license:\nMIT\nThis crate is held in the following repository:\nhttps://github.com/klebs6/bitcoin-rs\n","role":"user"}],"model":"gpt-5.1"}}
