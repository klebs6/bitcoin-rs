{"id": "batch_req_692cd3bbb76c8190b85fd24f4d4538a4", "custom_id": "bitcoin-blob-ai-readme-request", "response": {"status_code": 200, "request_id": "8f2cd73c1889a54ed91d34e823a04e86", "body": {"id": "chatcmpl-ChlANaPPuEiD0L0vP1TG4vPd4cJtj", "object": "chat.completion", "created": 1764545447, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-blob\",\n    \"full_readme_markdown\": \"# bitcoin-blob\\n\\nA small, no-nonsense crate providing fixed-size opaque byte blobs, modeled after Bitcoin Core's `base_blob` utility types. It focuses on:\\n\\n- **Deterministic, fixed-width byte arrays** (8, 64, 128, 160, 256 bits)\\n- **Efficient comparison and ordering** semantics\\n- **Hex encoding/decoding** with Bitcoin-style conventions\\n- **Serialization/deserialization** via `std::io::{Read, Write}`\\n- **Iterator and slice access** over the underlying bytes\\n\\nThis README was generated by an AI model and may not be 100% accurate; however, it should be a close and practically useful description of the crate.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-blob` defines a macro-based implementation for a family of fixed-size byte containers and then instantiates:\\n\\n- `BaseBlob8`   \u2013 8 bits  (1 byte)\\n- `BaseBlob64`  \u2013 64 bits (8 bytes)\\n- `BaseBlob128` \u2013 128 bits (16 bytes)\\n- `BaseBlob160` \u2013 160 bits (20 bytes)\\n- `BaseBlob256` \u2013 256 bits (32 bytes)\\n\\nEach type is a thin wrapper around `[u8; N]` with a consistent set of operations:\\n\\n- construction from bytes or small primitives\\n- zero/one constants\\n- pointer, slice and iterator access\\n- total ordering and equality\\n- hex string encoding/decoding\\n- simple binary serialization to/from any `Read` / `Write`\\n\\nThe design follows typical Bitcoin low-level primitives such as hashes and IDs, which are represented as fixed-size, little-endian byte arrays but usually *displayed* as big-endian hex strings.\\n\\n---\\n\\n## Features at a Glance\\n\\n### Types\\n\\nThe crate exposes the following concrete blob types:\\n\\n```rust\\nuse bitcoin_blob::{\\n    BaseBlob8,\\n    BaseBlob64,\\n    BaseBlob128,\\n    BaseBlob160,\\n    BaseBlob256,\\n};\\n```\\n\\nEach type is:\\n\\n- `Clone`, `Debug`, `Hash`\\n- `Send` + `Sync` (via `unsafe impl` mirroring Bitcoin Core assumptions)\\n- `Eq`, `Ord`, `PartialEq`, `PartialOrd`\\n- `Default` (all bytes set to zero)\\n\\n### Core API Surface\\n\\nFor any blob type `B` (e.g. `BaseBlob256`), the following methods are available:\\n\\n#### Construction\\n\\n```rust\\nimpl B {\\n    /// Const constructor from an exact-width byte array.\\n    pub const fn from_bytes(arr: [u8; BYTES]) -> Self;\\n\\n    /// All zeros.\\n    pub fn zero() -> Self;\\n\\n    /// Value with the first byte set to 1, others 0.\\n    pub fn one() -> Self;\\n}\\n\\nimpl From<u8> for B;\\nimpl From<&Vec<u8>> for B; // enforces exact length == BYTES\\n```\\n\\n`From<&Vec<u8>>` panics if the vector length does not equal the blob width, helping detect protocol-level length errors early.\\n\\n#### Byte Access and Iteration\\n\\n```rust\\nimpl B {\\n    /// Immutable slice view.\\n    pub fn as_slice(&self) -> &[u8];\\n\\n    /// Mutable slice view.\\n    pub fn as_slice_mut(&mut self) -> &mut [u8];\\n\\n    /// Alias for `as_slice_mut`.\\n    pub fn as_mut_slice(&mut self) -> &mut [u8];\\n\\n    /// Returns `true` if all bytes are zero.\\n    pub fn is_null(&self) -> bool;\\n\\n    /// Sets all bytes to zero.\\n    pub fn set_null(&mut self);\\n\\n    /// Signed lexicographic comparison helper: -1, 0, 1.\\n    pub fn compare(&self, other: &B) -> i32;\\n\\n    /// Raw pointer accessors (const and mut) to the underlying buffer.\\n    pub fn data_ptr(&self) -> *const u8;\\n    pub fn data_ptr_mut(&mut self) -> *mut u8;\\n\\n    /// C-style begin/end pointers (const and mut); `end` is one-past-last.\\n    pub fn begin(&self) -> *const u8;\\n    pub fn end(&self) -> *const u8;\\n    pub fn begin_mut(&mut self) -> *mut u8;\\n    pub fn end_mut(&mut self) -> *mut u8;\\n\\n    /// Number of bytes in the blob.\\n    pub fn size(&self) -> u32;\\n}\\n\\nimpl B {\\n    /// Immutable iterator over bytes.\\n    pub fn iter(&self) -> core::slice::Iter<'_, u8>;\\n\\n    /// Mutable iterator over bytes.\\n    pub fn iter_mut(&mut self) -> core::slice::IterMut<'_, u8>;\\n}\\n\\nimpl IntoIterator for B {\\n    type Item = u8;\\n    type IntoIter = core::array::IntoIter<u8, BYTES>;\\n}\\n\\nimpl<'a> IntoIterator for &'a B {\\n    type Item = &'a u8;\\n    type IntoIter = core::slice::Iter<'a, u8>;\\n}\\n\\nimpl<'a> IntoIterator for &'a mut B {\\n    type Item = &'a mut u8;\\n    type IntoIter = core::slice::IterMut<'a, u8>;\\n}\\n```\\n\\nThis means you can write idiomatic Rust loops over the blob contents:\\n\\n```rust\\nlet blob = BaseBlob256::one();\\n\\n// By reference\\nfor b in &blob {\\n    println!(\\\"{}\\\", b);\\n}\\n\\n// By value\\nfor b in blob {\\n    // consumes blob\\n    println!(\\\"{}\\\", b);\\n}\\n```\\n\\n#### Serialization\\n\\nSerialization is intentionally minimalistic and explicit \u2013 there is no `serde` integration in this crate; instead, a raw byte protocol is implemented:\\n\\n```rust\\nimpl B {\\n    pub fn serialize<Stream>(&self, s: &mut Stream)\\n    where\\n        Stream: std::io::Write;\\n\\n    pub fn unserialize<Stream>(&mut self, s: &mut Stream)\\n    where\\n        Stream: std::io::Read;\\n}\\n```\\n\\nBoth methods are fixed-width: `serialize` writes exactly `BYTES` bytes and `unserialize` reads exactly `BYTES` bytes, panicking on I/O failure. This matches wire formats where these blobs represent fields of static length (e.g. block hashes, txids).\\n\\n#### Hex Encoding / Decoding\\n\\nHex conversion follows the traditional crypto convention: the *display* string is big-endian (highest-order byte first), even though the internal representation is little-endian.\\n\\n```rust\\nimpl B {\\n    /// Returns the big-endian hex representation (two lowercase chars per byte).\\n    pub fn get_hex(&self) -> String;\\n\\n    /// Equivalent to `get_hex`.\\n    pub fn to_string(&self) -> String;\\n\\n    /// Parse from a C-style `char *` (ASCII hex, optional 0x prefix).\\n    pub fn set_hex(&mut self, psz: *const u8);\\n\\n    /// Safe Rust wrapper around `set_hex` taking an `&str`.\\n    pub fn set_hex_from_str(&mut self, str_: &str);\\n}\\n```\\n\\nParsing rules:\\n\\n- Accepts optional `0x` / `0X` prefix\\n- Ignores non-hex characters when counting hex digits\\n- Fills the internal array with the least significant bytes of the parsed value (matching Bitcoin Core semantics)\\n\\nThere is also a helper:\\n\\n```rust\\npub fn nibble_from_hexchar(ch: char) -> u8;\\n```\\n\\nwhich maps `0-9a-fA-F` to the corresponding 4-bit value, logging a warning and returning `0` for invalid characters.\\n\\n---\\n\\n## Ordering and Equality Semantics\\n\\nOrdering is defined lexicographically on the internal byte array via `compare()`:\\n\\n- `Eq` / `PartialEq` delegate to `compare() == 0`\\n- `Ord` and `PartialOrd` are total and consistent, making blobs usable as keys in ordered maps and sets when deterministic ordering of identifiers is required.\\n\\nFor a blob type `B`:\\n\\n```rust\\nlet a = B::zero();\\nlet b = B::one();\\n\\nassert!(a < b);\\nassert!(a != b);\\n```\\n\\nThis is particularly useful when these blobs represent domain objects such as transaction IDs, block hashes, or arbitrary protocol-level identifiers.\\n\\n---\\n\\n## SimpleRng Utility\\n\\nThe crate also includes a lightweight pseudo-random generator intended primarily for testing and fuzzing comparisons:\\n\\n```rust\\npub struct SimpleRng(u64);\\n\\nimpl SimpleRng {\\n    pub fn new(seed: u64) -> Self;\\n\\n    /// Linear congruential step, returning a new pseudo-random `u64`.\\n    pub fn next_u64(&mut self) -> u64;\\n\\n    /// Fill a buffer with pseudo-random bytes using repeated `next_u64` calls.\\n    pub fn fill_bytes(&mut self, buf: &mut [u8]);\\n}\\n```\\n\\n`SimpleRng` uses a standard 64\u2011bit linear congruential generator (LCG):\\n\\n\\\\[\\nX_{n+1} = a X_n + c \\\\pmod{2^{64}}\\n\\\\]\\n\\nwith `a = 6364136223846793005` and `c = 1`. This is not cryptographically secure; it is purely for deterministic testing.\\n\\nExample:\\n\\n```rust\\nuse bitcoin_blob::{BaseBlob256, SimpleRng};\\n\\nlet mut rng = SimpleRng::new(0xDEADBEEF);\\nlet mut buf = [0u8; 32];\\nrng.fill_bytes(&mut buf);\\n\\nlet blob = BaseBlob256::from_bytes(buf);\\nassert!(!blob.is_null());\\n```\\n\\n---\\n\\n## Usage Examples\\n\\n### Constructing and Inspecting Blobs\\n\\n```rust\\nuse bitcoin_blob::BaseBlob256;\\n\\n// From a fixed array\\nlet data = [0xABu8; 32];\\nlet blob = BaseBlob256::from_bytes(data);\\nassert_eq!(blob.size(), 32);\\n\\n// Zero and one\\nlet z = BaseBlob256::zero();\\nlet o = BaseBlob256::one();\\nassert!(z.is_null());\\nassert!(!o.is_null());\\n\\n// Slice access\\nlet slice: &[u8] = blob.as_slice();\\nassert_eq!(slice.len(), 32);\\n\\n// Mutable access\\nlet mut mutable = BaseBlob256::zero();\\nmutable.as_slice_mut()[0] = 0xFF;\\n```\\n\\n### Hex Conversion\\n\\n```rust\\nuse bitcoin_blob::BaseBlob160;\\n\\nlet mut blob = BaseBlob160::zero();\\nblob.set_hex_from_str(\\\"0x00112233445566778899aabbccddeeff00112233\\\");\\n\\nlet hex = blob.get_hex();\\nprintln!(\\\"blob as hex: {}\\\", hex);\\n\\n// `to_string` is the same as `get_hex`.\\nassert_eq!(hex, blob.to_string());\\n```\\n\\n### Serialization to a Stream\\n\\n```rust\\nuse bitcoin_blob::BaseBlob64;\\nuse std::io::Cursor;\\n\\nlet original = BaseBlob64::one();\\n\\nlet mut buf = Vec::new();\\noriginal.serialize(&mut buf); // write 8 bytes\\n\\nlet mut cursor = Cursor::new(buf);\\nlet mut restored = BaseBlob64::zero();\\nrestored.unserialize(&mut cursor);\\n\\nassert_eq!(original, restored);\\n```\\n\\n### Interoperating with `Vec<u8>`\\n\\n```rust\\nuse bitcoin_blob::BaseBlob128;\\n\\nlet v = vec![0x42u8; 16];\\nlet blob = BaseBlob128::from(&v);\\n\\nassert_eq!(blob.as_slice(), &v[..]);\\n```\\n\\n> Note: constructing from a `Vec<u8>` whose length is not exactly the blob width will panic. This enforces length invariants at runtime.\\n\\n---\\n\\n## Design Considerations\\n\\n- **Fixed width as a type-level contract**: using distinct concrete types (`BaseBlob256` etc.) encodes protocol width invariants in the type system while still being lightweight.\\n- **Predictable memory layout**: a blob is just a `[u8; N]` wrapper with no indirection, ideal for FFI, on-disk structures, and unsafe code that needs raw pointers.\\n- **Bitcoin-style semantics**: the hex formatting, little-endian internal representation, and total ordering semantics are chosen to align with typical Bitcoin Core usage.\\n- **No allocations in core paths**: apart from hex conversion and explicit constructs like `Vec<u8>` interop, operations are allocation-free.\\n\\n---\\n\\n## Logging\\n\\nThe implementation uses log macros such as `trace!`, `debug!`, and `warn!`. To see these messages, you must provide a logger implementation (e.g. via the `log` crate ecosystem) in your application or tests.\\n\\n---\\n\\n## Safety\\n\\n- `Send` and `Sync` are implemented as `unsafe impl` on the blob types, which is correct because they only contain plain bytes.\\n- Raw pointer accessors (`data_ptr`, `begin`, `end`, etc.) are offered for low-level interop. Their use is inherently `unsafe` in the Rust sense: the caller must ensure correct lifetimes and bounds.\\n- `unserialize` and `serialize` use `expect` on I/O failures, which will panic on error; if you require recoverable error handling, you should wrap these in your own fallible abstraction.\\n\\n---\\n\\n## Installation\\n\\nIn your `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-blob = \\\"0.1.19\\\"\\n```\\n\\nThis crate targets Rust 2021 edition and is licensed under MIT.\\n\\n---\\n\\n## Repository and Maintenance\\n\\nThe crate is developed in the `bitcoin-rs` repository:\\n\\n- Repository: <https://github.com/klebs6/bitcoin-rs>\\n\\nPlease refer to that repository for issues, pull requests, and broader context in which these blob types are used.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"data-structures\",\n      \"network-programming\"\n    ],\n    \"package_description\": \"Fixed-size opaque byte blobs (8\u2013256 bits) with Bitcoin-style semantics: little-endian storage, big-endian hex, total ordering, and explicit binary serialization over std::io streams.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"blob\",\n      \"hash\",\n      \"hex\",\n      \"serialization\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 5737, "completion_tokens": 3441, "total_tokens": 9178, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
