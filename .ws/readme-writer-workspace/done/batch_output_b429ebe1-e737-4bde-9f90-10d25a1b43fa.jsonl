{"id": "batch_req_692ce569a3808190b62c9b49891b7432", "custom_id": "bitcoinleveldb-util-ai-readme-request", "response": {"status_code": 200, "request_id": "0f3c2629f3eafbda02c2d5bc33c55e70", "body": {"id": "chatcmpl-ChmLQXabo7E6qPiuozKH0UMHCM48A", "object": "chat.completion", "created": 1764549976, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoinleveldb-util\",\n    \"full_readme_markdown\": \"# bitcoinleveldb-util\\n\\nUtility components used by the `bitcoin-rs` / `bitcoinleveldb` codebase, focused on precise control over object lifetime and destructor behavior.\\n\\nThis crate is intentionally small and low-level. It exports primitives that help emulate C++-style *\\\"never call the destructor\\\"* patterns in Rust, primarily for function-local statics and other long-lived objects that must not run cleanup code on shutdown.\\n\\n> Note: This README.md was generated by an AI model and may not be 100% accurate, but it should be a close and practically useful description of the crate.\\n\\n---\\n\\n## Overview\\n\\nThe key types provided are:\\n\\n- `DoNotDestruct` \u2013 A test/utility struct whose destructor **must never run**. If its `Drop` implementation is invoked, the process will immediately abort.\\n- `NoDestructor<T>` \u2013 A wrapper that stores a fully-initialized instance of `T` inside `MaybeUninit<T>` and **never drops it**. This is particularly useful for singletons, function-local statics, or global state that must remain valid for the lifetime of the process and does not require orderly teardown.\\n- `NoDestructorTest` \u2013 A trivial grouping struct, mainly used for tests.\\n\\nThe semantics are deliberately strict and closer to systems-programming idioms, trading graceful shutdown for predictable performance and the avoidance of complex destructor interactions at process exit.\\n\\n---\\n\\n## `DoNotDestruct`\\n\\n```rust\\nuse bitcoinleveldb_util::DoNotDestruct;\\n\\n// Panics? No. If this is dropped, the process aborts.\\nlet obj = DoNotDestruct::new(0xdead_beefu32, 0x0123_4567_89abu64);\\n\\n// Read and write fields via generated getters/setters (from `getset`):\\nlet a = *obj.a();\\nlet b = *obj.b();\\n\\nobj.set_a(1);\\nobj.set_b(2);\\n```\\n\\n### Behavior\\n\\n```rust\\nimpl Drop for DoNotDestruct {\\n    fn drop(&mut self) {\\n        error!(\\\"DoNotDestruct destructor called! Aborting...\\\");\\n        std::process::abort();\\n    }\\n}\\n```\\n\\n- Any attempt to drop a `DoNotDestruct` instance (including unwinding across stack frames) will unconditionally call `process::abort()`.\\n- The type is primarily intended as a *guardrail* in tests or as documentation of intent: this object is meant to be effectively immortal.\\n\\n### Construction\\n\\n```rust\\nimpl DoNotDestruct {\\n    pub fn new(a: u32, b: u64) -> Self {\\n        info!(\\\"Constructing DoNotDestruct with a=0x{:x}, b=0x{:x}\\\", a, b);\\n        Self { a, b }\\n    }\\n}\\n```\\n\\nLogging macros (`info!`, `error!`) are used from the standard Rust logging ecosystem (e.g., `log` crate + chosen logger backend). To see log output, configure a logger in your binary (e.g. `env_logger`, `tracing_subscriber`, etc.).\\n\\n---\\n\\n## `NoDestructor<T>`\\n\\n`NoDestructor<T>` stores an instance of `T` in `MaybeUninit<T>`, ensuring that Rust never runs its destructor. This is the Rust analogue of C++ code that uses aligned storage plus placement-new and deliberately omits destructor calls.\\n\\n### Type definition\\n\\n```rust\\nuse core::mem::MaybeUninit;\\n\\n#[derive(Debug)]\\npub struct NoDestructor<InstanceType> {\\n    instance_storage: MaybeUninit<InstanceType>,\\n}\\n```\\n\\n### Constructor\\n\\n```rust\\nimpl<InstanceType> NoDestructor<InstanceType> {\\n    /// Fully constructs the instance and stores it in `MaybeUninit`,\\n    /// then **never** runs the destructor.\\n    pub fn new(instance: InstanceType) -> Self {\\n        info!(\\\"NoDestructor::new invoked\\\");\\n        let storage = MaybeUninit::new(instance);\\n        Self { instance_storage: storage }\\n    }\\n}\\n```\\n\\nUsage:\\n\\n```rust\\nuse bitcoinleveldb_util::NoDestructor;\\n\\nstruct Cache { /* fields omitted */ }\\n\\nfn global_cache() -> &'static mut Cache {\\n    use core::mem::MaybeUninit;\\n    use core::sync::atomic::{AtomicBool, Ordering};\\n\\n    static mut STORAGE: MaybeUninit<NoDestructor<Cache>> = MaybeUninit::uninit();\\n    static INIT: AtomicBool = AtomicBool::new(false);\\n\\n    // Very low-level: caller must ensure this is called in a single-threaded\\n    // initialization phase or otherwise synchronize access.\\n    if !INIT.load(Ordering::Acquire) {\\n        let cache = Cache { /* ... */ };\\n        unsafe {\\n            STORAGE.write(NoDestructor::new(cache));\\n        }\\n        INIT.store(true, Ordering::Release);\\n    }\\n\\n    unsafe {\\n        // `get()` yields *mut Cache; we convert to &'static mut Cache.\\n        &mut *STORAGE.assume_init_ref().get()\\n    }\\n}\\n```\\n\\n### Pointer access\\n\\n```rust\\nimpl<InstanceType> NoDestructor<InstanceType> {\\n    /// Returns a mutable raw pointer to the stored instance.\\n    /// Lifetime and aliasing are **not** tracked at the type level.\\n    pub fn get(&self) -> *mut InstanceType {\\n        trace!(\\\"NoDestructor::get returning pointer to the stored instance\\\");\\n        self.instance_storage.as_ptr() as *mut InstanceType\\n    }\\n}\\n```\\n\\nImportant properties:\\n\\n- The destructor of `InstanceType` is **never called**.\\n- `get()` returns a `*mut InstanceType` even though `&self` is shared; this mirrors some C++ patterns but deviates from idiomatic Rust. The burden of ensuring sound aliasing rules and exclusive mutation lies with the caller.\\n- The underlying `InstanceType` **must be fully initialized** by the time you call `get()` (which is guaranteed for instances constructed via `NoDestructor::new`).\\n\\n### Safety considerations\\n\\nWhile `NoDestructor<T>` itself is safe to construct and use at the type level, it allows patterns where you can trivially violate Rust's higher-level aliasing disciplines if misused. You must:\\n\\n- Ensure that at most one mutable reference to the underlying `T` exists at any time.\\n- Ensure no mutable reference is used concurrently with any shared references where `T`'s invariants would not permit it.\\n- Accept that resources owned by `T` (file descriptors, sockets, memory buffers, lock guards, etc.) will never be released by RAII; they must either be leak-tolerant or managed manually.\\n\\nThis design is appropriate for process-long singletons where resource reclamation is unnecessary or undesirable.\\n\\n---\\n\\n## `NoDestructorTest`\\n\\n```rust\\n#[derive(Debug, Getters, Setters, Builder)]\\npub struct NoDestructorTest {}\\n```\\n\\nA minimal struct serving as a convenient grouping for tests. Its presence indicates that the crate is used to validate and regression-test the above lifetime primitives.\\n\\n---\\n\\n## Design rationale\\n\\nThe patterns implemented in this crate arise from a specific class of problems in systems and database code:\\n\\n- Some singletons or subsystems are more expensive, brittle, or risky to tear down than to leak.\\n- During shutdown, destructors may depend on global order-of-destruction guarantees that are fragile or impossible to enforce (especially across FFI boundaries or multiple static initializers).\\n- In such contexts, an explicit decision is made to construct once and **never destruct**, trading finite resource leaks at process exit for determinism during the lifetime of the program.\\n\\n### Relation to C++ patterns\\n\\nC++ often uses patterns like:\\n\\n- `static SomeType instance;` with non-trivial destructors, whose order-of-destruction across translation units is notoriously complex.\\n- `std::aligned_storage` + placement-new, followed by intentionally omitting `~SomeType()` calls.\\n\\n`NoDestructor<T>` mirrors the second approach using `MaybeUninit<T>` in Rust. `DoNotDestruct` serves as an explicit sentinel type that aborts if any destructor tries to execute, making tests detect any unintentional destruction.\\n\\n---\\n\\n## Logging\\n\\nThe snippets use logging macros such as `info!`, `error!`, and `trace!`. At integration time, you will typically:\\n\\n```toml\\n[dependencies]\\nlog = \\\"0.4\\\"\\n# and a backend of your choice, e.g.\\nenv_logger = \\\"0.11\\\"\\n```\\n\\nInitialize logging in your binary:\\n\\n```rust\\nfn main() {\\n    env_logger::init();\\n    // use bitcoinleveldb-util types here\\n}\\n```\\n\\nThis allows you to observe constructor calls and any unexpected destructor activity during testing.\\n\\n---\\n\\n## When *not* to use this crate\\n\\nAvoid these primitives if:\\n\\n- You want idiomatic Rust RAII where destructors reliably run and free resources.\\n- You require structured teardown, e.g., for graceful shutdown of network servers.\\n- You can express your requirements using `lazy_static`, `once_cell`, or `std::sync::OnceLock` without destructors that cause problems.\\n\\nUse this crate when you:\\n\\n- Need full control over when (or whether) destructors execute.\\n- Are porting C++ code that already relies on immortal singletons or non-dropping patterns.\\n- Operate in a low-level environment (such as an embedded database, block storage engine, or consensus node) where teardown cost and complexity outweigh the benefits.\\n\\n---\\n\\n## Repository and license\\n\\n- Repository: <https://github.com/klebs6/bitcoin-rs>\\n- Crate: `bitcoinleveldb-util`\\n- License: MIT\\n\\nThis crate is a component in the broader `bitcoin-rs` ecosystem. Consult that repository for examples of how these primitives are used in practice inside a leveldb-like storage engine and related Bitcoin infrastructure.\\n\",\n    \"package_categories\": [\n      \"development-tools\",\n      \"memory-management\",\n      \"data-structures\"\n    ],\n    \"package_description\": \"Low-level utilities for bitcoin-rs/bitcoinleveldb providing C++-style non-dropping singletons and destructor control via DoNotDestruct and NoDestructor<T>.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"leveldb\",\n      \"lifetime\",\n      \"destructor\",\n      \"singleton\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 2566, "completion_tokens": 2432, "total_tokens": 4998, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
