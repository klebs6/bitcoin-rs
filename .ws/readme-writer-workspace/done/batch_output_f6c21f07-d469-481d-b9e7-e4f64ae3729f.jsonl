{"id": "batch_req_692ce96233dc819083b7b0f59a127980", "custom_id": "bitcoinleveldb-posixtools-ai-readme-request", "response": {"status_code": 200, "request_id": "c36309169977858be65421b747fb1303", "body": {"id": "chatcmpl-ChmbmV4IzBO0yA1GVwVjaXTdnlDr0", "object": "chat.completion", "created": 1764550990, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoinleveldb-posixtools\",\n    \"full_readme_markdown\": \"# bitcoinleveldb-posixtools\\n\\nLow-level POSIX tooling extracted from a LevelDB port, focused on deterministic file locking, mmap / file\u2011descriptor limits, and a debuggable singleton environment abstraction. Intended for embedding in storage engines, databases, and performance\u2011sensitive systems that need explicit control over POSIX runtime behavior.\\n\\n> Note: This README was generated by an AI model. It may not be perfectly accurate in every detail, but it should be a very good high\u2011level description of the crate.\\n\\n---\\n\\n## Table of Contents\\n\\n- [Overview](#overview)\\n- [Design Goals](#design-goals)\\n- [Features](#features)\\n- [Crate Layout](#crate-layout)\\n- [Usage](#usage)\\n  - [Configuring global POSIX limits](#configuring-global-posix-limits)\\n  - [Using `SingletonEnv` for global environment wiring](#using-singletonenv-for-global-environment-wiring)\\n  - [Tracking process\u2011local POSIX file locks](#tracking-process-local-posix-file-locks)\\n  - [Locking files with `lock_or_unlock`](#locking-files-with-lock_or_unlock)\\n  - [Mapping POSIX errors to `Status`](#mapping-posix-errors-to-status)\\n- [Concurrency and Memory Model](#concurrency-and-memory-model)\\n- [Caveats](#caveats)\\n- [License](#license)\\n\\n---\\n\\n## Overview\\n\\n`bitcoinleveldb-posixtools` provides the POSIX\u2011oriented substrate for a LevelDB\u2011style storage engine:\\n\\n- A **singleton environment** wrapper (`SingletonEnv`) which hides the lifetime of the underlying `Env` implementation while enforcing a single global instance in debug builds.\\n- Thread\u2011safe globals controlling:\\n  - maximum number of **read\u2011only memory mappings** (`max_mmaps`, `MMAP_LIMIT`), and\\n  - maximum number of **open read\u2011only file descriptors** (`max_open_files`, `OPEN_READ_ONLY_FILE_LIMIT`).\\n- A **POSIX file lock tracker** (`PosixLockTable` / `PosixFileLock`) that works around the fact that `fcntl(F_SETLK)` does not protect against re\u2011locking from the same process.\\n- A thin wrapper over **`fcntl` locking** (`lock_or_unlock`) for write locks and unlocks.\\n- A convenience conversion from **POSIX errno values to LevelDB\u2011style `Status`** (`posix_error`).\\n\\nConceptually, this crate isolates the non\u2011portable POSIX behavior behind narrow, ergonomically wrapped functions and data structures. Higher\u2011level database code depends only on the `Env` trait, `Status`, and these helpers, leaving all detailed OS interaction here.\\n\\n\\n## Design Goals\\n\\n- **Deterministic behavior under load.** Explicit control of mmap and open\u2011file limits avoids accidental resource exhaustion and gives predictable scaling characteristics.\\n- **Process\u2011local lock accounting.** While `fcntl` provides kernel\u2011level inter\u2011process locking, it does not prevent a single process from violating its own lock discipline. `PosixLockTable` maintains an internal `HashSet` to guard against such logic errors.\\n- **Debug\u2011enforced singleton environment.** Many LevelDB/engine configurations assume a single global environment instance. `SingletonEnv` defends that assumption in debug builds while remaining zero\u2011cost in release builds.\\n- **Minimal unsafe surface area.** All unsafe interaction is localized around POSIX FFI calls (`libc::fcntl`, `libc::getrlimit`, `libc::strerror`), wrapped in safe and well\u2011documented functions.\\n\\n\\n## Features\\n\\nAt a high level, the crate exposes:\\n\\n- `SingletonEnv<EnvType>`\\n  - Wraps a concrete `Env` implementation and exposes an `Rc<RefCell<dyn Env>>` handle.\\n  - Asserts in debug builds that the singleton has not been previously initialized.\\n\\n- Global POSIX resource controls\\n  - `MMAP_LIMIT: AtomicI32` and `max_mmaps() -> i32`\\n  - `OPEN_READ_ONLY_FILE_LIMIT: AtomicI32` and `max_open_files() -> i32`\\n\\n- POSIX lock coordination\\n  - `PosixLockTable` / `PosixLockTableInner` for process\u2011local tracking.\\n  - `PosixFileLock` implementing `FileLock` and `Named`.\\n  - `lock_or_unlock(fd: i32, lock: bool) -> i32` wrapping `fcntl(F_SETLK, ...)`.\\n\\n- Error translation\\n  - `posix_error(context: &String, error_number: i32) -> Status`\\n\\n- Stubbed environment factory\\n  - `posix_default_env() -> Rc<RefCell<dyn Env>>` (currently `todo!()` and intended to be wired to OS\u2011specific code).\\n\\n\\n## Crate Layout\\n\\nRelevant public items (simplified):\\n\\n```rust\\nlazy_static! {\\n    pub static ref OPEN_READ_ONLY_FILE_LIMIT: std::sync::atomic::AtomicI32;\\n    pub static ref MMAP_LIMIT: std::sync::atomic::AtomicI32;\\n}\\n\\npub struct SingletonEnv<EnvType> {\\n    env_rc:  Rc<RefCell<dyn Env>>,\\n    _marker: std::marker::PhantomData<EnvType>,\\n}\\n\\npub struct PosixLockTable {\\n    mu: Mutex<PosixLockTableInner>,\\n}\\n\\npub struct PosixLockTableInner {\\n    locked_files: HashSet<String>,\\n}\\n\\npub struct PosixFileLock {\\n    fd:       i32,\\n    filename: String,\\n}\\n\\npub fn posix_default_env() -> Rc<RefCell<dyn Env>>;\\npub fn max_mmaps() -> i32;\\npub fn max_open_files() -> i32;\\npub fn lock_or_unlock(fd: i32, lock: bool) -> i32;\\npub fn posix_error(context: &String, error_number: i32) -> Status;\\n```\\n\\nThe actual traits/types `Env`, `Status`, `Slice`, `FileLock`, `Named`, and the `Mutex` implementation are expected to live in the surrounding LevelDB/Bitcoin codebase and are not redefined here.\\n\\n\\n## Usage\\n\\n### Configuring global POSIX limits\\n\\nTwo global atomics regulate resource usage:\\n\\n- `MMAP_LIMIT` affects `max_mmaps()`.\\n- `OPEN_READ_ONLY_FILE_LIMIT` affects `max_open_files()`.\\n\\nBy default, `MMAP_LIMIT` is initialized to `DEFAULT_MMAP_LIMIT`, and `OPEN_READ_ONLY_FILE_LIMIT` is `-1`, meaning **\\\"not yet computed.\\\"**\\n\\n`max_open_files()` performs the following algorithm:\\n\\n1. If `OPEN_READ_ONLY_FILE_LIMIT >= 0`, return the cached value.\\n2. Otherwise, call `getrlimit(RLIMIT_NOFILE, ...)`.\\n   - On error, fall back to `50` descriptors.\\n   - On `RLIM_INFINITY`, use `i32::MAX`.\\n   - Otherwise, compute `cur / 5` (20% of currently allowed descriptors), with lower bound `50` and upper bound `i32::MAX`.\\n3. Store the result in `OPEN_READ_ONLY_FILE_LIMIT` and return it.\\n\\nExample: overriding the defaults for tests or specialized deployments:\\n\\n```rust\\nuse std::sync::atomic::Ordering;\\nuse bitcoinleveldb_posixtools::{MMAP_LIMIT, OPEN_READ_ONLY_FILE_LIMIT, max_mmaps, max_open_files};\\n\\nfn configure_limits_for_benchmarking() {\\n    // Hard cap mmaps (e.g., to avoid page table blowup under synthetic load).\\n    MMAP_LIMIT.store(1024, Ordering::SeqCst);\\n\\n    // Hard cap read\u2011only file descriptors.\\n    OPEN_READ_ONLY_FILE_LIMIT.store(2048, Ordering::SeqCst);\\n\\n    assert_eq!(max_mmaps(), 1024);\\n    assert_eq!(max_open_files(), 2048);\\n}\\n```\\n\\n\\n### Using `SingletonEnv` for global environment wiring\\n\\n`SingletonEnv` provides a thin, well\u2011typed wrapper around an `Env` implementation that is intended to be globally shared:\\n\\n```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nuse bitcoinleveldb_posixtools::SingletonEnv;\\n\\n// Suppose you have a concrete Env implementation:\\n#[derive(Default)]\\nstruct PlatformEnv;\\nimpl Env for PlatformEnv { /* ... */ }\\n\\n// Type alias matching the C++ pattern `using PlatformSingletonEnv = SingletonEnv<PlatformEnv>`.\\ntype PlatformSingletonEnv = SingletonEnv<PlatformEnv>;\\n\\nfn configure_env() {\\n    // In debug builds, this will assert if a singleton has already been constructed.\\n    PlatformSingletonEnv::assert_env_not_initialized();\\n\\n    // Here you might set global flags that influence Env construction\\n    // (e.g., custom path prefixes, I/O throttling, etc.).\\n}\\n\\nfn global_env() -> Rc<RefCell<dyn Env>> {\\n    static PLATFORM_ENV: PlatformSingletonEnv = PlatformSingletonEnv::default();\\n    PLATFORM_ENV.env()\\n}\\n```\\n\\nSemantic behavior:\\n\\n- `SingletonEnv::default()` constructs an `EnvType::default()`, wraps it in `Rc<RefCell<dyn Env>>`, and records that the singleton is now initialized (debug\u2011only `AtomicBool`).\\n- `SingletonEnv::env()` clones the `Rc`, returning a shared handle without exposing the concrete type.\\n- `SingletonEnv::assert_env_not_initialized()` fails fast in debug builds if a singleton has already been created, catching mis\u2011ordered configuration code.\\n\\n\\n### Tracking process\u2011local POSIX file locks\\n\\n`PosixLockTable` is a mutex\u2011protected table of file names currently considered locked by the process. It is **not** a replacement for kernel locks, but a guardrail around them.\\n\\nTypical pattern:\\n\\n```rust\\nuse bitcoinleveldb_posixtools::PosixLockTable;\\n\\nfn acquire_process_local_lock(table: &mut PosixLockTable, path: &str) -> bool {\\n    // Returns true if \\\"path\\\" was not previously recorded as locked.\\n    table.insert(path)\\n}\\n\\nfn release_process_local_lock(table: &mut PosixLockTable, path: &str) {\\n    table.remove(path);\\n}\\n```\\n\\nProperties:\\n\\n- Internally, `PosixLockTable` holds a `Mutex<PosixLockTableInner>`, where `PosixLockTableInner` owns a `HashSet<String>`.\\n- `insert()` acquires the mutex and performs `HashSet::insert`, returning whether the file was newly inserted.\\n- `remove()` acquires the mutex and removes the file, logging whether it was present.\\n\\nThis structure enables higher\u2011level code to:\\n\\n- Assert that no two logical `FileLock` objects in the same process reference the same path concurrently.\\n- Mirror C++ LevelDB behavior when validating locking semantics.\\n\\n\\n### Locking files with `lock_or_unlock`\\n\\n`lock_or_unlock` is a direct wrapper around `fcntl(F_SETLK, ...)` with a fully initialized `libc::flock` structure:\\n\\n```rust\\nuse bitcoinleveldb_posixtools::lock_or_unlock;\\n\\nfn try_lock(fd: i32) -> std::io::Result<()> {\\n    let rc = lock_or_unlock(fd, true);\\n    if rc == 0 { Ok(()) } else { Err(std::io::Error::last_os_error()) }\\n}\\n\\nfn try_unlock(fd: i32) -> std::io::Result<()> {\\n    let rc = lock_or_unlock(fd, false);\\n    if rc == 0 { Ok(()) } else { Err(std::io::Error::last_os_error()) }\\n}\\n```\\n\\nDetails:\\n\\n- For `lock = true`, `l_type` is set to `F_WRLCK`.\\n- For `lock = false`, `l_type` is set to `F_UNLCK`.\\n- `l_whence = SEEK_SET`, `l_start = 0`, `l_len = 0` \u2192 lock/unlock the entire file.\\n- Return value is exactly the `fcntl` return value (0 on success, \u22121 on error, with `errno` set).\\n\\nThis function is usually combined with `PosixFileLock` instances and `PosixLockTable` to coordinate both kernel and process\u2011local state.\\n\\n\\n### Mapping POSIX errors to `Status`\\n\\n`posix_error` bridges from a POSIX errno (`i32`) and a context string into a LevelDB\u2011style `Status` value:\\n\\n```rust\\nuse bitcoinleveldb_posixtools::posix_error;\\n\\nfn open_maybe_missing(path: &str) -> Status {\\n    // Hypothetical error path where open() fails with errno.\\n    let errno = unsafe { *libc::__errno_location() }; // example only, not recommended API\\n    let ctx = format!(\\\"open {}\\\", path);\\n    posix_error(&ctx, errno)\\n}\\n```\\n\\nBehavior:\\n\\n- Obtains a human\u2011readable error message via `libc::strerror`.\\n- Handles the rare case where `strerror` returns null with a fallback string `\\\"<unknown-posix-error>\\\"`.\\n- If `error_number == ENOENT`, returns `Status::not_found(ctx, msg)`; otherwise, returns `Status::io_error(ctx, msg)`.\\n\\nThis classification mirrors the LevelDB convention of distinguishing *not found* from generic I/O errors.\\n\\n\\n## Concurrency and Memory Model\\n\\nThe crate uses atomics and mutexes to expose deterministic, thread\u2011safe behavior:\\n\\n- `MMAP_LIMIT` and `OPEN_READ_ONLY_FILE_LIMIT` are `AtomicI32` values:\\n  - They are read and written with `Ordering::SeqCst` in the limit functions, providing a straightforward and conservative memory model.\\n- `SINGLETON_ENV_INITIALIZED` (debug\u2011only) is an `AtomicBool` set and read with `Ordering::Relaxed` because it is used only as a *program\u2011order* debugging check, not for data synchronization.\\n- `PosixLockTable` uses a `Mutex` around the internal `HashSet<String>`; all reads/writes to the table go through this mutex.\\n- `SingletonEnv` exposes an `Rc<RefCell<dyn Env>>`:\\n  - `Rc` and `RefCell` are not thread\u2011safe; this matches the underlying LevelDB semantics where the environment is typically used from a thread\u2011safe wrapper or from a single logical owner.\\n  - If you need cross\u2011thread sharing, you should wrap the `Env` in `Arc<Mutex<...>>` or equivalent in your own code, or ensure the surrounding code enforces single\u2011threaded access.\\n\\n\\n## Caveats\\n\\n- **`posix_default_env()` is currently a stub** and calls `todo!()`. It is intended to be wired to a platform\u2011specific `Env` implementation (e.g., using `PlatformEnv` for POSIX, a Windows env, or a test/mock env). Do not call it in production code until the wiring is implemented.\\n- The crate assumes the existence of external traits/types (`Env`, `Status`, `Slice`, `Named`, `FileLock`, `Mutex`) from the broader Bitcoin/LevelDB integration. This crate is not currently intended as a stand\u2011alone, general\u2011purpose library.\\n- File locking semantics are those of `fcntl(F_SETLK)`:\\n  - Advisory locks only.\\n  - No protection against a single process opening the same file multiple times and failing to coordinate; `PosixLockTable` exists to address the latter at the logical level.\\n\\n\\n## License\\n\\nThis crate is distributed under the MIT license.\\n\\nSee the `LICENSE` file for full text.\\n\",\n    \"package_categories\": [\n      \"filesystem\",\n      \"network-programming\",\n      \"database\",\n      \"development-tools\",\n      \"concurrency\"\n    ],\n    \"package_description\": \"POSIX-focused LevelDB support utilities: singleton environment wiring, mmap and open-file limit management, process-local POSIX file-lock tracking, and errno-to-Status translation for Bitcoin-leveldb integrations.\",\n    \"package_keywords\": [\n      \"leveldb\",\n      \"posix\",\n      \"file-locking\",\n      \"bitcoin\",\n      \"mmap\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 4664, "completion_tokens": 3704, "total_tokens": 8368, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
