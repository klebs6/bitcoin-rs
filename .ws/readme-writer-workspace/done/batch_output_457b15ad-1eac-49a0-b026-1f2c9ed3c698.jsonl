{"id": "batch_req_692cd81e64d88190a7bcdb5907ec61d9", "custom_id": "bitcoin-asmap-ai-readme-request", "response": {"status_code": 200, "request_id": "1288863eccb84351988a4fde04caa9cd", "body": {"id": "chatcmpl-ChlSTUaTtTUPnztif0wntqjkRmBS0", "object": "chat.completion", "created": 1764546569, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-asmap\",\n    \"full_readme_markdown\": \"# bitcoin-asmap\\n\\nHigh\u2011fidelity Rust implementation of Bitcoin Core's ASMAP interpreter, decoder, and structural validator.\\n\\nThis crate provides a bit\u2011exact reimplementation of the Autonomous System (AS) mapping logic used by Bitcoin Core to probabilistically infer the AS number (ASN) associated with a peer's IP address. It is designed for:\\n\\n- Node operators and infrastructure providers who need deterministic ASMAP behavior in Rust services.\\n- Researchers performing network topology or AS\u2011level analysis of the Bitcoin network.\\n- Library authors integrating Bitcoin\u2011style AS\u2011based peer selection or routing policies into Rust applications.\\n\\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate, but it should be a close and useful description of the crate.\\n\\n---\\n\\n## Conceptual overview\\n\\n### ASMAP and ASN inference\\n\\nAn **ASMAP** file encodes a decision tree over IP address bits that maps each address to an **Autonomous System Number (ASN)**. In Bitcoin Core, this mapping is used to diversify peer selection by AS to reduce the risk that many peers are controlled by the same routing domain.\\n\\nKey ideas:\\n\\n- The ASMAP is a compact, prefix\u2011based program over bits of an IP address.\\n- An IP address is represented as a boolean slice `[bool; 128]` (for IPv6) or appropriately padded for IPv4\u2011in\u2011IPv6.\\n- The ASMAP is represented as a boolean program `asmap: &[bool]` which is **interpreted** to yield a final ASN.\\n\\nThis crate mirrors the C++ reference implementation used by Bitcoin Core, including its variable\u2011length integer coding, instruction set, and comprehensive structural sanity checks.\\n\\n---\\n\\n## Core data model\\n\\n### Instruction set\\n\\n```rust\\n#[repr(u32)]\\n#[derive(Debug, Clone, PartialEq, Eq)]\\npub enum Instruction {\\n    RETURN,\\n    JUMP,\\n    MATCH,\\n    DEFAULT,\\n}\\n``\\n\\nThe instruction stream is encoded as bits and decoded via `decode_type`, which internally uses `decode_bits` and a compact opcode encoding.\\n\\n- **RETURN**: Decode and return an ASN; terminates the program if structurally valid.\\n- **JUMP**: Conditionally jump forward in the instruction stream based on the next IP bit.\\n- **MATCH**: Match a short bit pattern against the next IP bits; either continue or fall back to the current default ASN.\\n- **DEFAULT**: Update the current default ASN used when a `MATCH` fails.\\n\\nThese instructions, combined with a stack of jump targets, implement a structured decision tree with compact representation.\\n\\n---\\n\\n## Public API\\n\\n### Reading and validating an ASMAP file\\n\\n```rust\\nuse bitcoin_asmap::decode_asmap;\\n\\nlet asmap_bits = decode_asmap(\\\"/path/to/asmap.dat\\\");\\nif asmap_bits.is_empty() {\\n    // Failed to read or validate ASMAP\\n}\\n```\\n\\n`decode_asmap<P: AsRef<Path>>(path: P) -> Vec<bool>`:\\n\\n- Reads the raw ASMAP file from disk (little\u2011endian, LSB\u2011first, identical to C++).\\n- Converts bytes into a `Vec<bool>` bit stream (bit 0 is the LSB of each byte).\\n- Runs a **full structural sanity check** via `sanity_check_as_map`.\\n- Returns the validated bit vector, or an **empty** vector on failure.\\n\\nThis is the entry point you usually want when consuming an ASMAP file shipped with Bitcoin Core or derived tools.\\n\\n### Interpreting an ASMAP for a given IP\\n\\n```rust\\nuse bitcoin_asmap::{decode_asmap, interpret};\\n\\nlet asmap = decode_asmap(\\\"/path/to/asmap.dat\\\");\\nif asmap.is_empty() {\\n    panic!(\\\"Invalid ASMAP\\\");\\n}\\n\\n// Example: represent an IPv4 address as 128 bits (IPv4\u2011mapped)\\nfn ipv4_to_bits(addr: [u8; 4]) -> Vec<bool> {\\n    // Very naive 32\u2011bit big\u2011endian; real usage should follow Bitcoin Core's\\n    // IPv4\u2011in\u2011IPv6 representation and bit ordering.\\n    let mut bits = Vec::with_capacity(32);\\n    for byte in addr {\\n        for offset in (0..8).rev() { // big\u2011endian per byte\\n            bits.push(((byte >> offset) & 1) != 0);\\n        }\\n    }\\n    bits\\n}\\n\\nlet ip_bits = ipv4_to_bits([203, 0, 113, 1]);\\nlet asn = interpret(&asmap, &ip_bits);\\n\\nif asn == 0 {\\n    // 0 is not a valid ASN; indicates structural failure during interpret()\\n}\\n```\\n\\n`interpret(asmap: &[bool], ip: &[bool]) -> u32`:\\n\\n- Executes the ASMAP program over `ip`'s bits.\\n- Returns the mapped ASN on success.\\n- Returns `0` on structural failure (e.g., invalid jumps, truncated encodings), even if `sanity_check_as_map` should normally prevent such cases in production.\\n\\n> **Important**: This crate expects the same IP bit ordering and normalization that Bitcoin Core uses. If you want behavior identical to Core, ensure you pass in `ip` bits constructed according to its reference logic (e.g., IPv4 mapped into IPv6).\\n\\n### Structural sanity checking\\n\\n```rust\\nuse bitcoin_asmap::{decode_asmap, sanity_check_as_map};\\n\\nlet asmap = decode_asmap(\\\"/path/to/asmap.dat\\\");\\nif asmap.is_empty() {\\n    // Already failed, but you can also explicitly check:\\n}\\n\\nlet ok = sanity_check_as_map(&asmap, 128);\\nassert!(ok);\\n```\\n\\n`sanity_check_as_map(asmap: &[bool], bits: i32) -> bool`:\\n\\n- Performs **exhaustive structural validation** of the ASMAP program.\\n- Mirrors Bitcoin Core's rules:\\n  - No jumps into the middle of another instruction.\\n  - No intersecting jumps.\\n  - No consuming IP bits past the declared input width.\\n  - No consecutive `DEFAULT`s.\\n  - No `RETURN` immediately after `DEFAULT`.\\n  - No unmatched trailing code after `RETURN`.\\n  - Correct use of padding and zero padding bits.\\n  - Constraints on sequences of short `MATCH` instructions.\\n- Returns `true` iff the structure is valid.\\n\\nThis is useful if you:\\n\\n- Load ASMAPs from untrusted sources.\\n- Mutate or generate ASMAPs programmatically.\\n- Want defensive validation independent of `decode_asmap`.\\n\\n### Bit\u2011level primitives\\n\\nThese are low\u2011level helpers that directly mirror the C++ implementation and are usually not needed by typical users but are valuable for experimentation or custom tooling.\\n\\n#### `decodeasn`\\n\\n```rust\\npub fn decodeasn(asmap: &[bool], pos: &mut usize) -> u32\\n```\\n\\nDecodes an ASN value from `asmap` starting at `*pos` using a variable\u2011length integer scheme defined by `ASN_BIT_SIZES`.\\n\\n- `pos` is updated in\u2011place.\\n- Returns the ASN, or an `INVALID` sentinel value (internal constant) on failure.\\n\\n#### `decode_jump`\\n\\n```rust\\npub fn decode_jump(asmap: &[bool], pos: &mut usize) -> u32\\n```\\n\\nDecodes a jump offset using `JUMP_BIT_SIZES`. The returned value is a **forward** offset from the current `pos`.\\n\\n#### `decode_match`\\n\\n```rust\\npub fn decode_match(asmap: &[bool], pos: &mut usize) -> u32\\n```\\n\\nDecodes a match pattern plus a sentinel bit using `MATCH_BIT_SIZES`. The number of data bits in the pattern is `count_bits(m) - 1`, where `m` is the decoded value.\\n\\n#### `decode_bits`\\n\\n```rust\\npub fn decode_bits(\\n    asmap:     &[bool],\\n    pos:       &mut usize,\\n    minval:    u8,\\n    bit_sizes: &[u8],\\n) -> u32\\n```\\n\\nThis is the **core variable\u2011length integer decoder**, parameterized by:\\n\\n- `minval`: base value added to the final decoded integer.\\n- `bit_sizes`: an increasing sequence of mantissa widths.\\n\\nThe decoding logic is exponential\u2011Golomb\u2011like:\\n\\n1. For each `bitsize` except the last, it reads an **exponent bit**.\\n2. If the exponent bit is `1`, it increments `val` by `1 << bitsize` and continues to the next `bitsize`.\\n3. If the exponent bit is `0`, it consumes `bitsize` mantissa bits into `val` and returns.\\n4. For the last `bitsize`, no exponent bit is read; instead, the path falls through if all previous exponent bits were `1`.\\n\\nOn early EOF, returns `INVALID` and leaves an error trace.\\n\\n#### `decode_type`\\n\\n```rust\\npub fn decode_type(asmap: &[bool], pos: &mut usize) -> Instruction\\n```\\n\\nDecodes an instruction opcode using `TYPE_BIT_SIZES` and returns the corresponding `Instruction` variant.\\n\\n#### `count_bits`\\n\\n```rust\\n#[inline]\\npub fn count_bits(x: u32) -> u32 {\\n    x.count_ones()\\n}\\n```\\n\\nHelper that wraps `u32::count_ones` for internal clarity.\\n\\n---\\n\\n## Logging and diagnostics\\n\\nThe implementation uses structured logging macros such as `trace!`, `debug!`, `info!`, and `error!` (typically from the `tracing` crate). These log at every decision point:\\n\\n- Early returns during decoding.\\n- Invalid opcodes or truncated integers.\\n- Sanity check violations including exact reason and offset.\\n\\nTo benefit from these diagnostics, configure a compatible subscriber in your application, for example:\\n\\n```rust\\nuse tracing_subscriber::FmtSubscriber;\\n\\nfn main() {\\n    let subscriber = FmtSubscriber::builder()\\n        .with_max_level(tracing::Level::TRACE)\\n        .finish();\\n\\n    tracing::subscriber::set_global_default(subscriber)\\n        .expect(\\\"setting default subscriber failed\\\");\\n\\n    // use bitcoin_asmap here\\n}\\n```\\n\\n---\\n\\n## Error handling and invariants\\n\\n- `decode_asmap` returns an empty `Vec<bool>` on any I/O error or failed sanity check. Empty means **\\\"do not use\\\"**.\\n- `interpret` returns `0` on structural failure; `0` is not a valid ASN by design.\\n- Internally, decoding uses an `INVALID` sentinel (not exposed) to signal truncated encodings.\\n- `sanity_check_as_map` should be run on any externally provided ASMAP before using `interpret` in production.\\n\\nIf you require stronger typing (e.g., non\u2011zero ASN newtypes) or richer error types, you can wrap this crate in a thin adapter layer.\\n\\n---\\n\\n## Performance considerations\\n\\n- Bit representation uses `Vec<bool>`, which is compact but may have non\u2011trivial overhead for heavy random access. This mirrors the reference C++ behavior but not necessarily the most optimal Rust representation.\\n- The interpreter is single\u2011pass and operates in `O(|asmap| + |ip|)` time.\\n- Sanity checking is more expensive (`O(|asmap|)` with additional structural invariants) and should be performed once per ASMAP file, not per lookup.\\n\\nFor workloads performing a large number of `interpret` calls against a static ASMAP, the typical pattern is:\\n\\n1. Load and validate the ASMAP once via `decode_asmap` (or manually reading the file and using `sanity_check_as_map`).\\n2. Reuse the resulting `Vec<bool>` for all subsequent IP lookups.\\n\\n---\\n\\n## Intended use cases\\n\\n- **Bitcoin node infrastructure**: Implement AS\u2011aware peer selection or connection policies in Rust node software.\\n- **Research and analysis**: Offline analysis of Bitcoin network AS distribution using the same mapping logic as Bitcoin Core.\\n- **Monitoring and policy engines**: Integrate ASMAP\u2011based classification into monitoring agents or traffic policy components written in Rust.\\n\\n---\\n\\n## Repository, license, and edition\\n\\n- **Crate name**: `bitcoin-asmap`\\n- **Version**: `0.1.19`\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n- **License**: MIT\\n- **Rust edition**: 2021\\n\\n---\\n\\n## Caveats and compatibility\\n\\n- Behavior is designed to be bit\u2011for\u2011bit compatible with the original Bitcoin Core C++ implementation. Nevertheless, you should validate against known test vectors when integrating into a critical system.\\n- Ensure that the IP bit ordering and normalization (IPv4 vs IPv6) match Bitcoin Core if you seek identical outcomes.\\n- This crate does not fetch or update ASMAP data itself; you must supply a valid ASMAP file.\\n\",\n    \"package_categories\": [\n      \"network-programming\",\n      \"cryptography\",\n      \"parsing\",\n      \"algorithms\"\n    ],\n    \"package_description\": \"Bit-exact Rust reimplementation of Bitcoin Core's ASMAP decoder, interpreter, and structural validator for mapping IP addresses to autonomous system numbers (ASNs).\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"asmap\",\n      \"asn\",\n      \"network\",\n      \"routing\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 4612, "completion_tokens": 3119, "total_tokens": 7731, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
