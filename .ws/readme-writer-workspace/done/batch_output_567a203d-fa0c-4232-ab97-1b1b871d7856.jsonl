{"id": "batch_req_692cdddbed48819096d5be4fc33d7a40", "custom_id": "bitcoin-sha256-hkdf-ai-readme-request", "response": {"status_code": 200, "request_id": "a0588ecd5d99a90942f0f9fa887ee8b5", "body": {"id": "chatcmpl-ChlqG5NCVk1bKHejENo3re49Bt8B9", "object": "chat.completion", "created": 1764548044, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-sha256-hkdf\",\n    \"full_readme_markdown\": \"# bitcoin-sha256-hkdf\\n\\nA compact, single\u2011purpose HKDF (RFC 5869) implementation specialized for:\\n\\n- HMAC-SHA256 as the underlying PRF\\n- A fixed output length of 32 bytes (L = 32)\\n- Compatibility with Bitcoin-style codebases and key-derivation workflows\\n\\nThis crate is intentionally narrow in scope: it exists to derive *exactly one* 32\u2011byte key from an input keying material (IKM), with a salt and an info string, using the expand step of HKDF with a single block.\\n\\n> **Note:** This README was generated by an AI model. It may not be perfectly accurate in every detail, but it is designed to be directionally correct and practically useful.\\n\\n---\\n\\n## Motivating use case\\n\\nMany Bitcoin and cryptocurrency systems need a simple, auditable, deterministic key-derivation mechanism built from SHA\u2011256 primitives. Typical scenarios include:\\n\\n- Deriving per\u2011channel keys or per\u2011session secrets from a long\u2011term KDF root key\\n- Generating context\u2011scoped 32\u2011byte secrets (e.g., for protocol instances, channels, or peers)\\n- Avoiding ad\u2011hoc derivation constructions while still staying very close to Bitcoin\u2019s low\u2011level SHA\u2011256/HMAC style\\n\\nThis crate encapsulates that pattern behind a small, predictable API, without depending on large cryptographic frameworks.\\n\\n---\\n\\n## Cryptographic background (HKDF + HMAC-SHA256)\\n\\nHKDF, specified in [RFC 5869](https://datatracker.ietf.org/doc/html/rfc5869), is a key derivation function built on top of a pseudorandom function (PRF), typically HMAC. It has two logical phases:\\n\\n1. **Extract**: `PRK = HMAC(salt, IKM)`\\n2. **Expand**: `OKM = T(1) || T(2) || ... || T(n)`, where each block is derived inductively.\\n\\nWhere:\\n- `IKM` \u2014 input keying material (possibly high\u2011entropy secret)\\n- `salt` \u2014 non\u2011secret randomizer (can be public; recommended to be at least hash length)\\n- `info` \u2014 optional context string to bind derived keys to a domain or usage\\n\\nFor HMAC-SHA256, the hash output length is 32 bytes. When you derive only a single 32\u2011byte key, `n = 1`, and the expand step reduces to:\\n\\n\\\\[\\n\\\\text{OKM} = \\\\text{HMAC-SHA256}(\\\\text{PRK}, \\\\text{info} \\\\Vert 0x01)\\n\\\\]\\n\\nThis crate implements exactly this pattern:\\n\\n- `Extract`: performed once in `CHKDF_HMAC_SHA256_L32::new` to compute `prk`\\n- `Expand`: performed once in `expand32`, for a single 32\u2011byte block\\n\\nThe design is intentionally minimal to align with deterministic protocols, auditability, and constant 32\u2011byte secret sizes (Bitcoin keys, scalar fields, etc.).\\n\\n---\\n\\n## Crate goals and non\u2011goals\\n\\n**Goals**\\n\\n- Provide a small, easily inspectable HKDF-SHA256 implementation with fixed 32\u2011byte output\\n- Mirror Bitcoin\u2011style usage patterns, where 32\u2011byte secrets are the canonical primitive\\n- Avoid configuration overhead: no dynamic output lengths, no algorithm switching\\n\\n**Non\u2011goals**\\n\\n- General HKDF implementation for arbitrary lengths or multiple blocks\\n- Pluggable PRFs or hash functions\\n- High\u2011level protocol logic; this crate just performs a single HKDF extract+expand\\n\\n---\\n\\n## Security notes\\n\\n- HKDF is a standard, well\u2011analyzed KDF construction. This crate adheres to the canonical HMAC-SHA256 variant with L=32.\\n- The **salt** and **info** parameters are caller\u2011supplied. Proper choice of these parameters (e.g., domain separation via `info`) is your responsibility.\\n- `info` length is typically bounded (the C++ reference code asserts `info.size() <= 128`). Enforcing such a bound helps match existing deployments and avoid misuse.\\n- All cryptographic assumptions reduce to the usual properties of HMAC-SHA256: pseudorandomness and collision resistance of SHA\u2011256 and the unforgeability of HMAC.\\n\\nThis crate does **not** attempt to be side\u2011channel hardened beyond what the underlying HMAC-SHA256 implementation provides. For highly adversarial environments, review the implementation with a security engineer.\\n\\n---\\n\\n## API overview\\n\\nPublic interface (simplified):\\n\\n```rust\\n/// RFC 5869 HKDF using HMAC-SHA256 with fixed 32-byte output (L = 32).\\npub struct CHKDF_HMAC_SHA256_L32 {\\n    prk: [u8; 32],\\n}\\n\\nimpl CHKDF_HMAC_SHA256_L32 {\\n    /// Perform HKDF-Extract: PRK = HMAC_SHA256(salt, ikm).\\n    pub fn new(ikm: *const u8, ikmlen: usize, salt: &String) -> Self;\\n\\n    /// Perform HKDF-Expand for a single 32-byte block.\\n    /// Writes exactly 32 bytes to `hash`.\\n    pub fn expand32(&mut self, info: &String, hash: [u8; CHKDF_HMAC_SHA256_L32_OUTPUT_SIZE]);\\n}\\n```\\n\\nThe naming follows the originating C++ implementation. Internally, `new` computes the pseudorandom key (`prk`), and `expand32` uses it to derive a single 32\u2011byte output.\\n\\n> **Note:** The pointer\u2011based `ikm` interface (`*const u8`, `ikmlen`) mirrors C/C++ FFI style. In higher\u2011level Rust code, you will typically want your own safe wrapper that operates on slices.\\n\\n---\\n\\n## Usage\\n\\n### Adding the dependency\\n\\n```toml\\n[dependencies]\\nbitcoin-sha256-hkdf = \\\"0.1.1\\\"\\n```\\n\\n### Basic example (unsafe pointer interface)\\n\\n```rust\\nuse bitcoin_sha256_hkdf::CHKDF_HMAC_SHA256_L32;\\n\\nfn derive_key_example() {\\n    // Input keying material (IKM): could be an ECDH shared secret, master key, etc.\\n    let ikm: [u8; 32] = [0x11; 32];\\n\\n    // Salt: non-secret randomizer; can be zero or protocol-specific\\n    let salt = String::from(\\\"bitcoin-hkdf-salt\\\");\\n\\n    let mut hkdf = unsafe {\\n        CHKDF_HMAC_SHA256_L32::new(ikm.as_ptr(), ikm.len(), &salt)\\n    };\\n\\n    // Info: domain separation tag / context string\\n    let info = String::from(\\\"channel-key-derivation:v1\\\");\\n\\n    const CHKDF_HMAC_SHA256_L32_OUTPUT_SIZE: usize = 32;\\n    let mut out = [0u8; CHKDF_HMAC_SHA256_L32_OUTPUT_SIZE];\\n\\n    hkdf.expand32(&info, out);\\n\\n    // `out` now holds a derived 32-byte key\\n    // Use `out` as a symmetric key, scalar seed, or similar.\\n}\\n```\\n\\nIn production code you would typically encapsulate this pattern in a safe wrapper that:\\n\\n- Accepts `&[u8]` for `ikm`\\n- Accepts `&[u8]` or `&str` for salt and info\\n- Returns `[u8; 32]` instead of handling raw pointers\\n\\nThis crate keeps the core primitive faithful to its origin; you can build ergonomic layers on top as needed.\\n\\n---\\n\\n## Design alignment with Bitcoin ecosystems\\n\\nBitcoin and related systems often:\\n\\n- Use 32\u2011byte secrets ubiquitously (private keys, chain codes, seeds)\\n- Favor SHA\u2011256 and HMAC-SHA256 as cryptographic primitives\\n- Prefer minimal, reviewable cryptographic code without runtime configurability\\n\\n`CHKDF_HMAC_SHA256_L32` fits directly into that model:\\n\\n- Output is always `[u8; 32]`\\n- Hash function is always SHA\u2011256\\n- Key derivation is standardized by RFC 5869 and easy to audit\\n\\nThis makes it a natural building block for Bitcoin\u2011centric Rust libraries that want HKDF\u2019s standard guarantees while maintaining familiarity with existing C++ / C codebases.\\n\\n---\\n\\n## Error handling and constraints\\n\\nThe underlying C++ reference includes an assertion like:\\n\\n```c++\\nassert(info.size() <= 128);\\n```\\n\\nIf the Rust implementation keeps the same constraint, `expand32` will panic when `info` exceeds the allowed length. This is not a cryptographic requirement of HKDF, but rather a protocol policy to:\\n\\n- Keep info fields small and predictable\\n- Match historical deployment constraints\\n\\nWhen designing protocols on top of this crate, treat `info` as a short, structured label rather than an arbitrary blob.\\n\\n---\\n\\n## FFI and interoperability\\n\\nBecause `new` takes `ikm` as `*const u8` with a separate length, and both `salt` and `info` are `String`, the type signature is suitable for binding to C/C++ style APIs or for embedding in larger, FFI\u2011heavy systems.\\n\\nIf you are integrating with an existing C++ codebase that already uses `CHMAC_SHA256` and `CHKDF_HMAC_SHA256_L32`, this crate gives you a Rust side that is conceptually isomorphic:\\n\\n- `ikm` and `ikmlen` match typical C `uint8_t*` + length pairs\\n- `salt` and `info` mirror `std::string` payloads\\n- The internal `prk` and derived 32\u2011byte `hash` are binary\u2011compatible sequences of bytes\\n\\n---\\n\\n## License\\n\\nThis crate is distributed under the **MIT** license.\\n\\n---\\n\\n## Caveats\\n\\n- This README is generated by an AI model. Verify the exact function signatures and behavioral details against the actual source code.\\n- Do not treat this documentation as a security review. If you are using this crate in a high\u2011value system, commission an expert cryptographic review of the implementation and its usage patterns.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"mathematics\",\n      \"algorithms\",\n      \"development-tools\",\n      \"science\"\n    ],\n    \"package_description\": \"RFC 5869 HKDF implementation specialized for HMAC-SHA256 with a fixed 32-byte output, designed for Bitcoin-style key derivation workflows.\",\n    \"package_keywords\": [\n      \"hkdf\",\n      \"hmac-sha256\",\n      \"key-derivation\",\n      \"bitcoin\",\n      \"cryptography\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 2189, "completion_tokens": 2503, "total_tokens": 4692, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
