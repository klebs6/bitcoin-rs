{"id": "batch_req_692cd61c1db08190aab1a042d6df5996", "custom_id": "bitcoin-string-ai-readme-request", "response": {"status_code": 200, "request_id": "3cb06aa1f6dc41b3e392fea5dfe625e1", "body": {"id": "chatcmpl-ChlK5lRVCwv2x7LA2VW22g9UMSSUJ", "object": "chat.completion", "created": 1764546049, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-string\",\n    \"full_readme_markdown\": \"# bitcoin-string\\n\\nLocale\u2011independent, consensus\u2011compatible string, integer, and encoding utilities extracted from the Bitcoin Core codebase and ported to Rust.\\n\\nThis crate focuses on *reproducing the exact control\u2011flow and edge\u2011case semantics* of the original C++ helpers that operate on textual data, numeric literals, base encodings, and fixed\u2011point monetary values. It is designed for projects that:\\n\\n- interact with Bitcoin data structures or wire formats,\\n- must remain byte\u2011for\u2011byte compatible with existing Bitcoin Core behaviour,\\n- require constant\u2011time comparisons or strict parsers for untrusted input.\\n\\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate in every detail, but it should be a very good approximation of the crate's intent and usage. Always consult the source for definitive behaviour.\\n\\n---\\n\\n## Features at a Glance\\n\\n- **ASCII\u2011only, locale\u2011independent case conversion**\\n  - [`ToUpper`] and [`ToLower`] traits implemented for `String` and `u8`.\\n  - Deterministic, 7\u2011bit ASCII semantics independent of the process locale.\\n\\n- **String sanitisation for untrusted text**\\n  - [`sanitize_string`] with configurable [`SafeChars`] policies mirroring Bitcoin Core:\\n    - `SAFE_CHARS_DEFAULT` \u2014 permissive text & URLs.\\n    - `SAFE_CHARS_UA_COMMENT` \u2014 user\u2011agent comments.\\n    - `SAFE_CHARS_FILENAME` \u2014 filenames.\\n    - `SAFE_CHARS_URI` \u2014 URI components.\\n\\n- **Bilingual message abstraction**\\n  - [`BilingualStr`] carries both `original` (English) and `translated` strings.\\n  - Centralised translation dispatch via [`set_translation_fn`] and [`bilingual_tr`].\\n  - `bilingual_format!` macro for dual\u2011language formatted strings.\\n\\n- **Robust integer parsing utilities**\\n  - [`parse_integral`] and type\u2011specific wrappers (`parse_int32`, `parse_uint64`, \u2026) with explicit success/failure and C\u2011style out\u2011pointers.\\n  - [`to_integral`] \u2014 strict `Option<T>` parser with no whitespace, no leading `+`, and full\u2011string consumption.\\n  - [`locale_independent_atoi`] \u2014 exact behavioural clone of C `atoi`/`atoi64` in the C locale, including handling of \\\"+-\\\".\\n\\n- **Fixed\u2011point and monetary parsing/formatting**\\n  - [`parse_fixed_point`] \u2014 parse JSON\u2011syntax numbers into signed 64\u2011bit fixed\u2011point values with bounded exponent and mantissa.\\n  - [`format_money`] \u2014 format `Amount` (Bitcoin amount in satoshis) as decimal coins, trimming redundant trailing zeros while preserving precision constraints.\\n  - [`parse_money`] \u2014 parse coin\u2011denominated string amounts (e.g. `\\\"0.0034\\\"`) into internal `Amount`, with strict range checks.\\n\\n- **Base32 / Base64 encoding and decoding**\\n  - RFC 4648 compliant encoders: [`encode_base32_bytes`], [`encode_base32`], [`encode_base64_bytes`], [`encode_base64`].\\n  - Multiple decoders mirroring historical Bitcoin and Tor/I2P paths:\\n    - [`decode_base32_bytes`] \u2014 C\u2011string, padded RFC 4648.\\n    - [`decode_base32_bytes_strict`] \u2014 Rust `&str`, padded RFC 4648.\\n    - [`decode_base32_bytes_nopad_lower`] \u2014 lower\u2011case alphabet, *no* padding, strict tail\u2011bit checks.\\n    - [`decode_base32`] \u2014 decode to UTF\u20118 `String`.\\n    - [`decode_base64_bytes`] \u2014 C\u2011string, padded RFC 4648.\\n    - [`decode_base64`] \u2014 decode to UTF\u20118 `String`.\\n  - Shared internal [`convert_bits`] primitive implementing the `FROM \u2192 TO` bit\u2011group mapping logic (as per BIP\u2011173 and RFC 4648), reusable for custom alphabets.\\n\\n- **Hex utilities**\\n  - [`is_hex`] \u2014 validate even\u2011length, fully\u2011hex byte strings.\\n  - [`is_hex_number`] \u2014 validate optional `0x`/`0X` prefixed hex literals.\\n  - [`parse_hex`] \u2014 parse hex dumps with embedded ASCII whitespace.\\n  - [`hex_str`] \u2014 lower\u2011case hex encoding of raw bytes.\\n\\n- **Timing\u2011resistant comparison**\\n  - [`timing_resistant_equal`] \u2014 constant\u2011time (in the length of `a`) comparison over any `AsRef<[u8]>` type; suitable for secret material comparisons.\\n\\n- **General string helpers**\\n  - [`trim_string`] \u2014 configurable trim pattern.\\n  - [`remove_prefix`] \u2014 prefix stripping.\\n  - [`join`] and [`make_unordered_list`] \u2014 list composition.\\n  - [`valid_as_cstring`] \u2014 check for absence of embedded NUL (`\\\\0`).\\n  - [`to_string`] \u2014 locale\u2011independent formatting alias for `format!`.\\n  - [`has_prefix`] \u2014 const\u2011generic, byte\u2011slice prefix test.\\n  - [`capitalize`] \u2014 ASCII\u2011only first\u2011character capitalization.\\n\\nAll functions are instrumented with [`tracing`] so that call\u2011site, control\u2011flow, and error conditions can be observed precisely during testing and production debugging.\\n\\n---\\n\\n## Installation\\n\\n```toml\\n[dependencies]\\nbitcoin-string = \\\"0.1.19\\\"\\n```\\n\\nThis crate targets Rust **edition 2021** and is licensed under **MIT**.\\n\\n---\\n\\n## Core Concepts and Guarantees\\n\\n### Locale\u2011independent parsing and formatting\\n\\nMany standard library functions (both in C and some higher\u2011level languages) exhibit locale\u2011dependent behaviour for numbers, whitespace, and casing rules. Bitcoin consensus and network code cannot depend on locale, because that would fragment nodes by environment.\\n\\n`bitcoin-string` intentionally restricts itself to **ASCII and locale\u2011independent semantics**:\\n\\n- Numeric parsers (`parse_integral`, `parse_fixed_point`, `parse_money`, `to_integral`, `locale_independent_atoi`) treat input as if processed in the C locale.\\n- Case transforms operate strictly on ASCII ranges `A\u2013Z` and `a\u2013z` and leave all other bytes untouched.\\n\\nThis constraint is crucial when strings represent consensus\u2011critical data such as numeric fields in transactions, RPC inputs, or on\u2011disk configuration.\\n\\n### Fixed\u2011point representation and overflow discipline\\n\\n`parse_fixed_point` interprets a JSON number (roughly the grammar from <https://json.org/number.gif>) and maps it into a signed 64\u2011bit integer with a caller\u2011supplied decimal *scale* (`decimals`).\\n\\nConceptually, it computes\\n\\n\\\\[\\n\\\\text{mantissa} = \\\\left\\\\lfloor x \\\\times 10^{d} \\\\right\\\\rfloor\\n\\\\]\\n\\nsubject to the invariant\\n\\n\\\\[\\n|\\\\text{mantissa}| < 10^{18}\\n\\\\]\\n\\nwhere `x` is the input real and `d` is `decimals`. Internally it:\\n\\n1. Parses sign, integral, fractional, and exponential parts.\\n2. Accumulates an integer mantissa by scaling the previous mantissa by 10 and adding the new digit, while counting trailing zeros separately to delay scaling (see [`process_mantissa_digit`]).\\n3. Applies exponent and decimal point offsets, producing an effective power of 10.\\n4. Rejects any underflow or overflow: invalid ranges, exponent outside `[0, 17]`, or mantissa exceeding `10^18 \u2212 1` in magnitude.\\n\\nThis careful control\u2011flow is engineered to match the original Bitcoin Core implementation, so that any system using these helpers in Rust remains consistent with C++ peers.\\n\\n### Timing\u2011attack resistance\\n\\n[`timing_resistant_equal`] compares two secrets `a` and `b` such that the running time depends solely on the length of `a`, **not** on the first differing byte position. It does this by:\\n\\n- XOR\u2011ing the lengths of `a` and `b` into an accumulator;\\n- XOR\u2011ing every byte of `a` with the corresponding byte of `b` (cycling through `b` if shorter) and OR\u2011ing the result into the accumulator;\\n- returning `acc == 0`.\\n\\nThis prevents simple timing attacks that exploit early\u2011exit comparisons.\\n\\n> **Important**: While this function is designed to be timing\u2011resistant at the library level, overall application security depends on compiler, CPU, and surrounding control\u2011flow. Use in conjunction with other standard hardening techniques.\\n\\n---\\n\\n## Usage Examples\\n\\n### Case conversion and sanitisation\\n\\n```rust\\nuse bitcoin_string::{ToUpper, ToLower, sanitize_string, SafeChars};\\n\\nlet s = \\\"Hello, World!\\\".to_string();\\nassert_eq!(s.to_upper(), \\\"HELLO, WORLD!\\\");\\nassert_eq!(s.to_lower(), \\\"hello, world!\\\");\\n\\n// Sanitize for generic text / URLs\\nlet raw = \\\"Visit https://example.com/?q=<script>\\\";\\nlet clean = sanitize_string(raw, Some(SafeChars::SAFE_CHARS_URI as i32));\\n// `clean` contains only characters from the SAFE_CHARS_URI set.\\n```\\n\\n### Bilingual strings and translations\\n\\n```rust\\nuse bitcoin_string::{BilingualStr, untranslated, bilingual_tr, set_translation_fn};\\n\\n// Mark a string as untranslated: original == translated\\nlet msg: BilingualStr = untranslated(\\\"Wallet loaded\\\");\\nassert_eq!(msg.original(), \\\"Wallet loaded\\\");\\nassert_eq!(msg.translated(), \\\"Wallet loaded\\\");\\n\\n// Install a trivial translation function (e.g. from your i18n layer)\\nset_translation_fn(Some(|s: &str| {\\n    if s == \\\"Wallet loaded\\\" { \\\"Portefeuille charg\u00e9\\\".to_owned() } else { s.to_owned() }\\n}));\\n\\nlet localized = bilingual_tr(\\\"Wallet loaded\\\");\\nassert_eq!(localized.original(), \\\"Wallet loaded\\\");\\nassert_eq!(localized.translated(), \\\"Portefeuille charg\u00e9\\\");\\n```\\n\\nUsing the `bilingual_format!` macro (from the `tinyformat` module):\\n\\n```rust\\nuse bitcoin_string::{BilingualStr, bilingual_tr};\\nuse bitcoin_string::bilingual_format; // macro is exported at crate root\\n\\nlet tmpl = bilingual_tr(\\\"Processed {} transactions\\\");\\nlet count = 42;\\n\\nlet formatted = bilingual_format!(&tmpl, count);\\n// formatted.original()  == \\\"Processed 42 transactions\\\"\\n// formatted.translated() == translation of that template with `42` substituted\\n```\\n\\n### Integer parsing\\n\\n```rust\\nuse bitcoin_string::{parse_int32, parse_uint64, to_integral, locale_independent_atoi};\\n\\n// C\u2011style parser with out\u2011pointer\\nlet mut v: i32 = 0;\\nlet ok = parse_int32(&\\\"123\\\".to_string(), &mut v as *mut i32);\\nassert!(ok);\\nassert_eq!(v, 123);\\n\\n// Strict parser that forbids whitespace and leading '+'\\nassert_eq!(to_integral::<i64>(\\\"42\\\"), Some(42));\\nassert_eq!(to_integral::<i64>(\\\" 42\\\"), None);\\nassert_eq!(to_integral::<i64>(\\\"+42\\\"), None);\\n\\n// `atoi`\u2011like behaviour\\nlet x: i32 = locale_independent_atoi(\\\"  +123\\\");\\nlet y: i32 = locale_independent_atoi(\\\"+-5\\\");\\nassert_eq!(x, 123);\\nassert_eq!(y, 0); // matches C `atoi(\\\"+-5\\\")`\\n```\\n\\n### Fixed\u2011point parsing\\n\\n```rust\\nuse bitcoin_string::parse_fixed_point;\\n\\nlet mut amount: i64 = 0;\\n// Interpret as 2 decimal places: \\\"1.23\\\" \u2192 123\\nlet ok = parse_fixed_point(\\\"1.23\\\", 2, &mut amount as *mut i64);\\nassert!(ok);\\nassert_eq!(amount, 123);\\n\\n// Out\u2011of\u2011range exponents or mantissas are rejected\\nassert!(!parse_fixed_point(\\\"1e20\\\", 0, std::ptr::null_mut()));\\n```\\n\\n### Base32 / Base64 encoding and decoding\\n\\n```rust\\nuse bitcoin_string::{encode_base32, decode_base32_bytes_strict};\\nuse bitcoin_string::{encode_base64, decode_base64};\\n\\nlet data = b\\\"hello\\\";\\nlet b32 = encode_base32(data, Some(true));\\nlet mut invalid = false;\\nlet roundtrip = decode_base32_bytes_strict(&b32, Some(&mut invalid as *mut bool));\\nassert!(!invalid);\\nassert_eq!(roundtrip, data);\\n\\nlet s = \\\"hello\\\".to_string();\\nlet encoded = encode_base64(&s);\\nlet decoded = decode_base64(&encoded, None);\\nassert_eq!(decoded, s);\\n```\\n\\n### Hex utilities\\n\\n```rust\\nuse bitcoin_string::{is_hex, is_hex_number, parse_hex, hex_str};\\n\\nassert!(is_hex(\\\"00ff10\\\"));\\nassert!(!is_hex(\\\"0xff\\\"));\\nassert!(is_hex_number(\\\"0xff\\\"));\\n\\nlet bytes = parse_hex(\\\"00 ff 10\\\");\\nassert_eq!(hex_str(&bytes), \\\"00ff10\\\");\\n```\\n\\n### Timing\u2011resistant equality\\n\\n```rust\\nuse bitcoin_string::timing_resistant_equal;\\n\\nlet secret_a = b\\\"super_secret_key\\\".to_vec();\\nlet secret_b = b\\\"super_secret_key\\\".to_vec();\\nlet secret_c = b\\\"super_secret_keZ\\\".to_vec();\\n\\nassert!(timing_resistant_equal(&secret_a, &secret_b));\\nassert!(!timing_resistant_equal(&secret_a, &secret_c));\\n```\\n\\n---\\n\\n## Integration Notes\\n\\n- The crate depends on [`tracing`] for structured logging. In a production application, install an appropriate subscriber (e.g. `tracing-subscriber`) to capture diagnostics.\\n- Monetary helpers rely on `Amount`, `COIN`, and `money_range` from the surrounding Bitcoin domain. When used outside the `bitcoin-rs` tree, ensure that these are wired consistently with Bitcoin Core semantics (e.g. `COIN = 100_000_000` for sats per BTC).\\n- Many parsers accept raw pointers (for C\u2011compatibility). In idiomatic Rust code, you can often pass `std::ptr::null_mut()` when you want to check validity but discard the result.\\n\\n---\\n\\n## Safety and Security Considerations\\n\\n- **Pointer arguments**: functions like `parse_integral`, `parse_fixed_point`, `parse_int32`, etc., mirror the original C++ signature pattern and accept raw pointers. The implementations are careful, but the caller is responsible for providing valid, appropriately aligned pointers or `null_mut()`.\\n- **Constant\u2011time claims**: `timing_resistant_equal` is structured to avoid early returns and to depend only on the length of `a`, but micro\u2011architectural details can still leak information. For critical key\u2011material handling, consider layering it with additional defences.\\n- **Sanitisation**: [`sanitize_string`] enforces an *allowlist* of characters. Pick the correct [`SafeChars`] rule for your context. For example, URIs and filenames have different constraints.\\n\\n---\\n\\n## License\\n\\nThis crate is distributed under the **MIT** license.\\n\\nThe upstream repository is hosted at: <https://github.com/klebs6/bitcoin-rs>\\n\\n---\\n\\n## Provenance\\n\\nThis crate is part of the `bitcoin-rs` effort to provide a faithful, well\u2011structured Rust port of the Bitcoin Core codebase. The implementation choices are driven by the goal of **behavioural equivalence**, not by API minimalism. Consequently, some functions retain C\u2011style signatures and pointer\u2011based semantics to preserve compatibility with existing call sites.\\n\\nIf you require different ergonomics (e.g. pure `Result<T, E>` APIs), consider wrapping these primitives in your own higher\u2011level abstractions while keeping this crate as the compatibility layer.\\n\\n[`tracing`]: https://docs.rs/tracing\\n[`SafeChars`]: #features-at-a-glance\\n[`BilingualStr`]: #bilingual-message-abstraction\\n[`sanitize_string`]: #case-conversion-and-sanitisation\\n[`set_translation_fn`]: #bilingual-strings-and-translations\\n[`bilingual_tr`]: #bilingual-strings-and-translations\\n[`parse_integral`]: #integer-parsing\\n[`parse_fixed_point`]: #fixed-point-parsing\\n[`parse_money`]: #fixed-point-and-monetary-parsingformatting\\n[`format_money`]: #fixed-point-and-monetary-parsingformatting\\n[`encode_base32_bytes`]: #base32--base64-encoding-and-decoding\\n[`encode_base32`]: #base32--base64-encoding-and-decoding\\n[`encode_base64_bytes`]: #base32--base64-encoding-and-decoding\\n[`encode_base64`]: #base32--base64-encoding-and-decoding\\n[`decode_base32_bytes`]: #base32--base64-encoding-and-decoding\\n[`decode_base32_bytes_strict`]: #base32--base64-encoding-and-decoding\\n[`decode_base32_bytes_nopad_lower`]: #base32--base64-encoding-and-decoding\\n[`decode_base32`]: #base32--base64-encoding-and-decoding\\n[`decode_base64_bytes`]: #base32--base64-encoding-and-decoding\\n[`decode_base64`]: #base32--base64-encoding-and-decoding\\n[`convert_bits`]: #base32--base64-encoding-and-decoding\\n[`timing_resistant_equal`]: #timing-resistant-equality\\n[`trim_string`]: #general-string-helpers\\n[`remove_prefix`]: #general-string-helpers\\n[`join`]: #general-string-helpers\\n[`make_unordered_list`]: #general-string-helpers\\n[`valid_as_cstring`]: #general-string-helpers\\n[`to_string`]: #general-string-helpers\\n[`has_prefix`]: #general-string-helpers\\n[`capitalize`]: #general-string-helpers\\n[`is_hex`]: #hex-utilities\\n[`is_hex_number`]: #hex-utilities\\n[`parse_hex`]: #hex-utilities\\n[`hex_str`]: #hex-utilities\\n[`process_mantissa_digit`]: #fixed-point-representation-and-overflow-discipline\\n[`to_integral`]: #integer-parsing\\n[`locale_independent_atoi`]: #integer-parsing\\n[`parse_int32`]: #integer-parsing\\n[`parse_uint64`]: #integer-parsing\\n[`ToLower`]: #features-at-a-glance\\n[`ToUpper`]: #features-at-a-glance\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"encoding\",\n      \"parsing\",\n      \"data-structures\",\n      \"development-tools\"\n    ],\n    \"package_description\": \"Bitcoin Core\u2013compatible string, integer, hex, Base32/Base64, and fixed-point monetary utilities with locale-independent semantics and timing-resistant comparison.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"string\",\n      \"base32\",\n      \"base64\",\n      \"hex\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 12811, "completion_tokens": 4390, "total_tokens": 17201, "prompt_tokens_details": {"cached_tokens": 0, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
