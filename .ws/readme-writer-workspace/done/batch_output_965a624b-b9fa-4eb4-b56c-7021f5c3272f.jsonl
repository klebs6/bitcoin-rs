{"id": "batch_req_692cd7bd521c8190bf0b94a5fadce3ed", "custom_id": "bitcoin-epoch-ai-readme-request", "response": {"status_code": 200, "request_id": "0dcfa65c899ffc764334fc47742e53cf", "body": {"id": "chatcmpl-ChlQvfXaAJAdvElJRnX3vxwnFBZOd", "object": "chat.completion", "created": 1764546473, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-epoch\",\n    \"full_readme_markdown\": \"# bitcoin-epoch\\n\\nEpoch-based deduplication for Bitcoin mempool graph traversals, extracted as a focused, RAII-driven Rust crate.\\n\\nThis crate implements the C++-style *epoch traversal* pattern used in Bitcoin Core to avoid revisiting transactions during ancestor/descendant walks over the mempool graph. It provides a tiny, contention-free mechanism to replace `std::set` / `HashSet`-based deduplication with a monotonic counter and per-node markers.\\n\\n> **Note**: This README was generated by an AI model and may not be 100% accurate. It should, however, be a good approximation of the crate's intent and usage. Always consult the actual source for authoritative behavior.\\n\\n## Conceptual overview\\n\\nWhen walking a graph (e.g., mempool transactions linked by dependencies), a na\u00efve deduplication strategy stores a `visited` set containing each transaction seen so far. This introduces:\\n\\n- **Time complexity**: `O(log n)` per insert/lookup in tree-based sets, or extra constant factors for hash sets.\\n- **Memory traffic**: dynamic allocations and cache-unfriendly pointer-chasing for each insertion.\\n\\nThe *epoch* technique replaces the explicit `visited` set with:\\n\\n- A single **global traversal counter**: the `Epoch`.\\n- A **per-node marker**: an `EpochMarker` stored with each transaction.\\n\\nTraversal algorithm:\\n\\n1. Start a new traversal by incrementing the global `epoch` and marking it as **guarded** via `EpochGuard`.\\n2. For each node (transaction), compare its `EpochMarker` against the current `epoch` value.\\n3. If the marker is **less than** the current epoch, this is the first visit in this traversal; update the marker to the current epoch and continue.\\n4. If the marker is **equal to or greater than** the current epoch, the node has already been visited in this traversal; skip.\\n\\nThis yields:\\n\\n- **Amortized O(1)** tracking per node\\n- **Zero per-visit heap allocations**\\n- **Excellent cache locality** when `EpochMarker` is embedded in existing structures\\n\\nThis pattern is mathematically analogous to using a strictly monotone mapping from traversal instances to integers and storing a scalar per vertex for the most recent traversal that touched it.\\n\\n## Crate API\\n\\n### Types\\n\\n```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nuse bitcoin_epoch::{Epoch, EpochGuard, EpochMarker};\\n``\\n\\n#### `Epoch`\\n\\n```rust\\n#[derive(Getters, Builder)]\\n#[getset(get = \\\"pub\\\")]\\n#[builder(setter(into), default)]\\npub struct Epoch {\\n    raw_epoch: u64,\\n    guarded:   bool,\\n}\\n```\\n\\nAn RAII-style epoch tracker. It holds:\\n\\n- `raw_epoch: u64` \u2013 the current epoch counter.\\n- `guarded: bool` \u2013 `true` when an `EpochGuard` is active.\\n\\nKey methods:\\n\\n- `fn visited(&self, marker: &mut EpochMarker) -> bool`\\n  - Returns `true` if the marker indicates that the node has already been visited in the **current** epoch.\\n  - Returns `false` and updates the marker for the first visit in the current epoch.\\n  - **Panics** if called outside an `EpochGuard` scope (`guarded == false`).\\n\\nInternal methods (crate-internal, documented here for conceptual completeness):\\n\\n- `fn increment_epoch(&mut self)` \u2013 `raw_epoch += 1` with overflow check.\\n- `fn set_guarded(&mut self, value: bool)` \u2013 toggles `guarded`.\\n\\n`Epoch` implements `Default` with `raw_epoch = 0`, `guarded = false`.\\n\\n#### `EpochMarker`\\n\\n```rust\\n#[derive(Getters, Builder, Default)]\\n#[getset(get = \\\"pub\\\")]\\npub struct EpochMarker {\\n    marker: u64,\\n}\\n```\\n\\nA per-transaction (or per-node) marker storing the last epoch in which this node was visited.\\n\\n- Initially `0` via `Default`.\\n- Updated *only* by `Epoch` through a crate-internal method, exposed here for understanding:\\n\\n```rust\\nimpl EpochMarker {\\n    pub(crate) fn update(&mut self, value: u64) {\\n        self.marker = value;\\n    }\\n}\\n```\\n\\nIn a consumer of this crate, you would typically store an `EpochMarker` as a field on your mempool entry struct and never mutate it manually.\\n\\n#### `EpochGuard`\\n\\n```rust\\npub struct EpochGuard {\\n    epoch: Rc<RefCell<Epoch>>,\\n}\\n```\\n\\nAn RAII guard for a **scope-bound epoch**. On construction:\\n\\n- Verifies that there is no active guard (`guarded == false`), panicking if a nested guard is attempted.\\n- Increments the epoch and sets `guarded = true`.\\n\\nOn `Drop` (i.e., at scope exit):\\n\\n- Asserts that `guarded == true`.\\n- Increments the epoch again to create a clear separation between traversals.\\n- Sets `guarded = false`.\\n\\nThis ensures each guarded traversal obtains a **fresh epoch span** and that nested traversals are disallowed, preventing subtle logical corruption.\\n\\nConstructor:\\n\\n```rust\\nimpl EpochGuard {\\n    pub fn new(epoch: Rc<RefCell<Epoch>>) -> Self { /* ... */ }\\n}\\n```\\n\\n### Macro: `with_fresh_epoch!`\\n\\n```rust\\nwith_fresh_epoch!(mempool_epoch);\\n```\\n\\nThe macro expands to construction of a scoped `EpochGuard`:\\n\\n```rust\\nlet _epoch_guard = bitcoin_epoch::EpochGuard::new(mempool_epoch.clone());\\n```\\n\\nUsage pattern:\\n\\n```rust\\n{\\n    with_fresh_epoch!(mempool_epoch);\\n    // run traversal using mempool_epoch\\n} // guard dropped here; epoch advanced and unguarded\\n```\\n\\nThis mirrors the original C++ `WITH_FRESH_EPOCH` helper in Bitcoin Core.\\n\\n## Typical usage pattern\\n\\nAssume you have a mempool entry type embedding an `EpochMarker`:\\n\\n```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nuse bitcoin_epoch::{Epoch, EpochGuard, EpochMarker};\\n\\nstruct TxEntry {\\n    id: TxId,              // your transaction identifier type\\n    parents: Vec<TxId>,    // graph edges\\n    children: Vec<TxId>,\\n    epoch_marker: EpochMarker,\\n}\\n\\nstruct Mempool {\\n    epoch: Rc<RefCell<Epoch>>,\\n    entries: HashMap<TxId, TxEntry>,\\n}\\n```\\n\\n### Initialisation\\n\\n```rust\\nimpl Mempool {\\n    fn new() -> Self {\\n        Self {\\n            epoch: Rc::new(RefCell::new(Epoch::default())),\\n            entries: HashMap::new(),\\n        }\\n    }\\n}\\n```\\n\\n### Traversal with deduplication\\n\\n```rust\\nimpl Mempool {\\n    /// Depth-first traversal over descendants, without revisiting entries.\\n    fn walk_descendants(&mut self, root: &TxId) {\\n        // 1. Start a fresh epoch for this traversal.\\n        with_fresh_epoch!(self.epoch);\\n\\n        // 2. Inner recursive/iterative walk.\\n        self.walk_descendants_impl(root);\\n    }\\n\\n    fn walk_descendants_impl(&mut self, txid: &TxId) {\\n        let epoch_rc = self.epoch.clone();\\n        let epoch_ref = epoch_rc.borrow();\\n\\n        let Some(entry) = self.entries.get_mut(txid) else { return; };\\n\\n        // 3. Deduplicate with O(1) epoch check instead of a HashSet.\\n        if epoch_ref.visited(&mut entry.epoch_marker) {\\n            return; // already visited in this traversal\\n        }\\n\\n        // 4. Process the entry.\\n        self.process_entry(entry);\\n\\n        // 5. Recurse or iterate through descendants.\\n        let children: Vec<TxId> = entry.children.clone();\\n        drop(epoch_ref); // avoid borrow conflicts if needed\\n\\n        for child in children {\\n            self.walk_descendants_impl(&child);\\n        }\\n    }\\n\\n    fn process_entry(&self, _entry: &TxEntry) {\\n        // domain-specific logic\\n    }\\n}\\n```\\n\\nProperties of this approach:\\n\\n- No `HashSet<TxId>` or allocation-heavy containers are needed for visited tracking.\\n- Each entry carries its own `EpochMarker`, which is just a `u64`.\\n- Concurrent traversals using the same `Epoch` are **not** supported; the guard enforces exclusivity via the `guarded` flag.\\n\\n## Safety and invariants\\n\\nThe crate enforces several invariants via panics:\\n\\n- `EpochGuard::new` asserts that the supplied `Epoch` is not already guarded, preventing nested guards for the same `Epoch` instance.\\n- `Drop for EpochGuard` asserts that the `Epoch` is guarded when the guard is dropped.\\n- `Epoch::visited` asserts that the epoch is guarded, i.e., it must be called within the dynamic scope of an `EpochGuard`.\\n- `Epoch::increment_epoch` uses `checked_add` and panics on overflow of the 64-bit epoch counter.\\n\\nThese panics are deliberate: they defend against subtle misuse leading to incorrect traversal deduplication.\\n\\nIn typical Bitcoin-style mempool usage, epochs will never approach `u64::MAX`, so overflow is a theoretical boundary rather than a practical concern.\\n\\n## Concurrency model\\n\\nThe crate itself uses `Rc<RefCell<Epoch>>`, which is single-threaded. For multi-threaded contexts, you can wrap the `Epoch` in `Arc<Mutex<_>>` or similar, reimplementing the RAII guard semantics on top, or by using one epoch per thread.\\n\\nThe presence of annotations like `#[LOCKABLE]`, `#[SCOPED_LOCKABLE]`, `#[EXCLUSIVE_LOCK_FUNCTION]`, and `#[EXCLUSIVE_LOCKS_REQUIRED(*this)]` mirrors Clang thread-safety attributes from C++, primarily for static analysis tooling and documentation. They express the logical locking discipline:\\n\\n- `EpochGuard` works like a scoped lock.\\n- `Epoch::visited` requires the epoch to be logically *locked* (i.e., guarded by `EpochGuard`).\\n\\nThese annotations do not, by themselves, provide synchronization; the caller is responsible for ensuring proper thread safety when sharing epochs across threads.\\n\\n## Integration notes\\n\\n- The crate is intentionally minimal and focused; it does **not** define the mempool structure, transaction IDs, or graph storage.\\n- Designed to integrate into existing Bitcoin-related Rust codebases or any project using graph traversals where high-performance deduplication is valuable.\\n- The API mirrors the semantics of the original Bitcoin Core implementation to ease porting of algorithms from C++.\\n\\n## When to use this crate\\n\\nUse `bitcoin-epoch` when:\\n\\n- You maintain a large, mostly in-memory graph (mempool, dependency DAG, reachability graph, etc.).\\n- Traversals are frequent and deduplication cost is material.\\n- You can afford to store a small `EpochMarker` per node.\\n\\nDo **not** use this crate when:\\n\\n- You require unbounded overlapping traversals on the same epoch object.\\n- You cannot or do not wish to store extra state per node.\\n\\n## License and provenance\\n\\n- **License**: MIT\\n- **Edition**: Rust 2021\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n\\nThis crate is part of a broader effort to provide high-fidelity Rust analogues of the Bitcoin Core internals.\\n\",\n    \"package_categories\": [\n      \"algorithms\",\n      \"data-structures\",\n      \"science\",\n      \"finance\",\n      \"network-programming\"\n    ],\n    \"package_description\": \"Epoch-based RAII traversal helper for Bitcoin-style mempool graphs, providing high-performance O(1) deduplication via a shared epoch counter and per-transaction markers.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"mempool\",\n      \"epoch\",\n      \"graph-traversal\",\n      \"deduplication\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 3141, "completion_tokens": 2865, "total_tokens": 6006, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
