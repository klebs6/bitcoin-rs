{"id": "batch_req_692cd96214408190bb336296e20c681d", "custom_id": "bitcoin-chacha-ai-readme-request", "response": {"status_code": 200, "request_id": "4b77ef8bcf038bca3ae35534083c8aeb", "body": {"id": "chatcmpl-ChlXbYs5IndGsOZ8B9p4sSsb3tJzd", "object": "chat.completion", "created": 1764546887, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-chacha\",\n    \"full_readme_markdown\": \"# bitcoin-chacha\\n\\nA low-level, Bitcoin-flavoured implementation of the ChaCha20 stream cipher and the ChaCha20\u2011Poly1305@bitcoin AEAD construction, suitable for interoperating with Bitcoin's P2P transport encryption.\\n\\n> NOTE: This README.md was generated by an AI model and may not be 100% accurate, though it should be a close and practically useful description of the crate.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-chacha` provides:\\n\\n- A **constant\u2011time, low\u2011level ChaCha20** implementation (Bernstein, 2008).\\n- A **ChaCha20\u2011Poly1305 AEAD** that follows the *Bitcoin Core* P2P transport construction (`chacha20-poly1305@bitcoin`), not the generic RFC\u202f7539 layout.\\n- A **quarterround macro** and supporting primitives mirroring the original public\u2011domain C implementation, translated into Rust.\\n- A **Poly1305 tag computation wrapper** around `bitcoin_poly1305::poly1305_auth` with constant\u2011time tag comparison.\\n\\nThe crate focuses on **bit\u2011exact compatibility** with the Bitcoin reference implementation and on predictable performance properties (constant\u2011time tag checks, explicit keystream use, explicit memory cleansing of key material).\\n\\nThis is **not** a high\u2011level AEAD abstraction; instead, it gives you precise control over sequence numbers, nonces, counters, and buffer management, which is required for correct implementation of the Bitcoin P2P handshake and transport.\\n\\n---\\n\\n## Cryptographic Background\\n\\n### ChaCha20\\n\\nChaCha20 is a 256\u2011bit stream cipher built from a 4\u00d74 matrix of 32\u2011bit words:\\n\\n\\\\[\\n\\\\text{state} =\\n\\\\begin{bmatrix}\\n  c_0 & c_1 & c_2 & c_3 \\\\\\\\\\n  k_0 & k_1 & k_2 & k_3 \\\\\\\\\\n  k_4 & k_5 & k_6 & k_7 \\\\\\\\\\n  ctr & n_0 & n_1 & n_2\\n\\\\end{bmatrix}\\n\\\\]\\n\\nEach **round** applies the `quarterround` operation four times on the columns, then on the diagonals. After 20 rounds (10 double\u2011rounds), the result is added to the original state and serialized little\u2011endian into 64 bytes of keystream.\\n\\nThis crate exposes that via:\\n\\n- `ChaCha20::set_key` \u2014 initialize from 128\u2011 or 256\u2011bit key (16 or 32 bytes) using the standard `TAU`/`SIGMA` constants.\\n- `ChaCha20::setiv` \u2014 set a 64\u2011bit nonce (Bitcoin uses a 64\u2011bit sequence number as nonce).\\n- `ChaCha20::seek` \u2014 set a 64\u2011bit block counter (word 12/13 of the state).\\n- `ChaCha20::keystream` \u2014 fill a buffer with raw ChaCha20 keystream.\\n- `ChaCha20::crypt` \u2014 XOR the keystream with a message (encryption and decryption are symmetric).\\n\\nThe `quarterround!` macro operates directly on four mutable `u32` registers and is inlined by the compiler.\\n\\n### Poly1305 and AEAD\\n\\nPoly1305 is a one\u2011time message authentication code over a prime field modulo \\\\(2^{130} \u2212 5\\\\). Given a 256\u2011bit key, it produces a 128\u2011bit tag. Correct usage requires a **fresh Poly1305 key per message**.\\n\\n`bitcoin-chacha` derives the Poly1305 key from the first 256 bits of ChaCha20 keystream under `K\u2082` for each packet, following the Bitcoin transport design. It then authenticates **both the encrypted 3\u2011byte length field and the ciphertext payload**.\\n\\nTag computation/verification is done via:\\n\\n- `compute_poly1305_tag(key, msg)` \u2013 wraps `bitcoin_poly1305::poly1305_auth` and returns a `GenericArray<u8, U16>`.\\n- `timingsafe_bcmp` \u2013 constant\u2011time equality check used for tag verification.\\n\\n---\\n\\n## Bitcoin-specific AEAD Construction\\n\\nBitcoin\u2019s `chacha20-poly1305@bitcoin` differs from RFC\u202f7539 AEAD in:\\n\\n- **Two independent ChaCha20 instances**:\\n  - `K\u2081`: encrypts the 3\u2011byte length field (\\\"AAD\\\" in this crate\u2019s nomenclature).\\n  - `K\u2082`: drives both payload encryption and Poly1305 key derivation.\\n- **Encrypted length field**: the first 3 bytes of each packet are encrypted using a cached keystream derived from `K\u2081`, sequence numbers, and a position in the 64\u2011byte keystream block.\\n- **Per\u2011packet Poly1305 key** derived from `K\u2082` using:\\n  - Nonce: packet sequence number as a 64\u2011bit little\u2011endian value.\\n  - Counter: 0 for Poly1305 key derivation, `1` for payload encryption.\\n- **MAC over (encrypted length || ciphertext payload)**.\\n\\nThis crate models that as:\\n\\n```rust\\n#[derive(MutGetters, Debug, Getters)]\\npub struct ChaCha20Poly1305AEAD {\\n    chacha_header:        ChaCha20,                 // K\u2081 instance\\n    chacha_main:          ChaCha20,                 // K\u2082 instance\\n    aad_keystream_buffer: [u8; CHACHA20_ROUND_OUTPUT],\\n    cached_aad_seqnr:     u64,\\n}\\n```\\n\\nThe key points:\\n\\n- **Length cipher (`K\u2081`)**\\n  - Nonce: AAD sequence number (`seqnr_aad`).\\n  - Counter: 0.\\n  - Keystream block (64 bytes) is cached per `seqnr_aad` to amortize multiple 3\u2011byte length encryptions.\\n  - Reuse of `{key, nonce, position}` is forbidden beyond the allowed bounds (2^70 bytes/nonce).\\n\\n- **Payload + MAC cipher (`K\u2082`)**\\n  - Nonce: payload sequence number (`seqnr_payload`).\\n  - Counter 0: first 32 keystream bytes form the Poly1305 key.\\n  - Counter 1+: used for payload encryption.\\n\\n---\\n\\n## API Surface\\n\\n### quarterround!\\n\\n```rust\\nquarterround!(a, b, c, d);\\n```\\n\\nExpands to a ChaCha quarter\u2011round on four `u32` variables `a, b, c, d`, using `wrapping_add`, XOR, and `rotl32` rotations by {16, 12, 8, 7} bits. This macro is used internally by `ChaCha20::keystream` but is exported for use in specialized low\u2011level code (e.g., constant\u2011time gadget experimentation, verification against test vectors).\\n\\n### ChaCha20\\n\\n#### Construction and configuration\\n\\n```rust\\nuse bitcoin_chacha::ChaCha20;\\n\\n// From a 256\u2011bit key\\nlet key: [u8; 32] = [0x00; 32];\\nlet mut chacha = ChaCha20::new(key.as_ptr(), key.len());\\n\\n// Or create then set key later\\nlet mut chacha2 = ChaCha20::default();\\nchacha2.set_key(key.as_ptr(), key.len());\\n\\n// Set 64\u2011bit nonce and counter\\nchacha.setiv(42u64);       // nonce / IV\\nchacha.seek(0);            // block counter\\n```\\n\\n`set_key` expects either:\\n\\n- 16\u2011byte key (128\u2011bit; uses `TAU` constants), or\\n- 32\u2011byte key (256\u2011bit; uses `SIGMA` constants).\\n\\nAny other length panics via `assert!` to prevent silent misconfiguration.\\n\\n#### Stream generation\\n\\n```rust\\n// Generate 64 bytes of raw keystream\\nlet mut ks = [0u8; 64];\\nchacha.keystream(ks.as_mut_ptr(), ks.len());\\n```\\n\\n`keystream` uses the current `(key, nonce, counter)` state and updates the internal 64\u2011bit counter words (12 and 13) as it consumes blocks. Partial\u2011block requests are handled safely by writing to a temporary 64\u2011byte buffer and copying only the required prefix.\\n\\n#### Encryption / decryption\\n\\n```rust\\nlet plaintext = b\\\"hello world\\\";\\nlet mut ciphertext = vec![0u8; plaintext.len()];\\n\\nchacha.crypt(\\n    plaintext.as_ptr(),\\n    ciphertext.as_mut_ptr(),\\n    plaintext.len(),\\n);\\n\\n// Decrypt: reset counter/nonce and XOR again\\nchacha.setiv(42u64);\\nchacha.seek(0);\\nlet mut recovered = vec![0u8; plaintext.len()];\\nchacha.crypt(\\n    ciphertext.as_ptr(),\\n    recovered.as_mut_ptr(),\\n    ciphertext.len(),\\n);\\nassert_eq!(&recovered[..], &plaintext[..]);\\n```\\n\\n`crypt` is a convenience wrapper around `keystream` + XOR. It allocates a temporary `Vec<u8>` of size `bytes` for the keystream, which is acceptable in typical Bitcoin P2P packet sizes; if you need zero\u2011allocation, use `keystream` and XOR manually.\\n\\n### ChaCha20Poly1305AEAD\\n\\n#### Construction\\n\\n```rust\\nuse bitcoin_chacha::ChaCha20Poly1305AEAD;\\n\\nlet k1 = [0u8; CHACHA20_POLY1305_AEAD_KEY_LEN];\\nlet k2 = [1u8; CHACHA20_POLY1305_AEAD_KEY_LEN];\\n\\nlet mut aead = ChaCha20Poly1305AEAD::new(\\n    k1.as_ptr(), k1.len(),\\n    k2.as_ptr(), k2.len(),\\n);\\n```\\n\\nBoth `k_1_len` and `k_2_len` must equal `CHACHA20_POLY1305_AEAD_KEY_LEN` (256\u2011bit keys). The constructor asserts on mismatch.\\n\\nThe expected key mapping for a full duplex connection:\\n\\n- Initiator:\\n  - Send:   `K\u2081_A, K\u2082_A`\\n  - Receive:`K\u2081_B, K\u2082_B`\\n- Responder:\\n  - Send:   `K\u2081_B, K\u2082_B`\\n  - Receive:`K\u2081_A, K\u2082_A`\\n\\nExactly as in Bitcoin\u2019s transport specification.\\n\\n#### Packet encryption/decryption\\n\\n```rust\\nlet seqnr_payload: u64 = 0; // packet seq for payload/MAC\\nlet seqnr_aad: u64     = 0; // packet seq for length/AAD\\nlet aad_pos: i32       = 0; // position within cached 64\u2011byte keystream block\\n\\n// Layout: [ 3\u2011byte AAD length | payload bytes (N) ]\\nlet mut src = Vec::new();\\nlet payload = b\\\"example payload\\\";\\nlet len = payload.len() as u32; // must fit in 24 bits\\nsrc.extend_from_slice(&[ (len & 0xFF) as u8,\\n                         ((len >> 8) & 0xFF) as u8,\\n                         ((len >> 16) & 0xFF) as u8 ]);\\nsrc.extend_from_slice(payload);\\n\\n// Destination must hold AAD + payload + MAC (when encrypting)\\nlet mut dest = vec![0u8; src.len() + POLY1305_TAGLEN];\\n\\nlet ok = aead.crypt(\\n    seqnr_payload,\\n    seqnr_aad,\\n    aad_pos,\\n    dest.as_mut_ptr(),\\n    dest.len(),\\n    src.as_ptr(),\\n    src.len(),\\n    true, // encrypt\\n);\\nassert!(ok);\\n\\n// To decrypt, reverse: dest becomes input, a new buffer for output\\nlet mut decrypted = vec![0u8; dest.len() - POLY1305_TAGLEN];\\nlet ok = aead.crypt(\\n    seqnr_payload,\\n    seqnr_aad,\\n    aad_pos,\\n    decrypted.as_mut_ptr(),\\n    decrypted.len(),\\n    dest.as_ptr(),\\n    dest.len(),\\n    false, // decrypt (also verifies MAC)\\n);\\nassert!(ok);\\n```\\n\\n**Contract of `crypt`**:\\n\\n- When `is_encrypt == true`:\\n  - `src` must hold `[AAD || payload]`.\\n  - `dest` must have length \u2265 `src_len + POLY1305_TAGLEN`.\\n  - Output layout: `[AAD' || payload' || tag]`.\\n\\n- When `is_encrypt == false`:\\n  - `src` must hold `[AAD' || payload' || tag]`.\\n  - `dest` must have length \u2265 `src_len - POLY1305_TAGLEN`.\\n  - If the MAC is invalid, returns `false` and does not yield plaintext.\\n\\nBounds checks are done up front; the function returns `false` on any size violation.\\n\\nInternally, `crypt` ensures:\\n\\n1. Derive the Poly1305 key from `K\u2082` with nonce `seqnr_payload`, counter = 0.\\n2. If decrypting, compute a fresh tag on `[AAD' || payload']` and verify it in constant time using `timingsafe_bcmp`. Reject on failure.\\n3. Ensure the cached AAD keystream buffer matches `seqnr_aad`; if not, recompute 64 bytes of `K\u2081` keystream for that sequence number.\\n4. XOR the 3 AAD bytes against the cached keystream starting at `aad_pos`.\\n5. Set `K\u2082` counter to 1, then encrypt/decrypt the payload with ChaCha20.\\n6. If encrypting, compute and append the Poly1305 tag over `[encrypted AAD || ciphertext payload]`.\\n7. Zeroize Poly1305 key material and actively cleanse memory (`memory_cleanse`).\\n\\nThis closely matches the design constraints stated in the Bitcoin documentation: avoiding oracles via independent keying for lengths, preventing `{key, nonce}` reuse, and enforcing MAC verification *before* payload usage.\\n\\n#### Decrypting only the length (get_length)\\n\\n`get_length` is optimized for the critical path where you must know the packet length **before** reading the entire payload.\\n\\n```rust\\nlet mut len24: u32 = 0;\\nlet ok = aead.get_length(\\n    &mut len24 as *mut u32,\\n    seqnr_aad,\\n    aad_pos,\\n    encrypted_len_ptr, // *const u8, first 3 bytes of packet\\n);\\nassert!(ok);\\n\\nlet packet_len = len24 & 0x00FF_FFFF; // 24\u2011bit length field\\n```\\n\\n- `aad_pos` must satisfy:\\n\\n  ```text\\n  0 <= aad_pos < CHACHA20_ROUND_OUTPUT - CHACHA20_POLY1305_AEAD_AAD_LEN\\n  ```\\n\\n  This is asserted at runtime.\\n\\n- Reuses the same AAD keystream cache machinery as `crypt`, keyed by `seqnr_aad`.\\n\\n---\\n\\n## Poly1305 Utilities\\n\\n### compute_poly1305_tag\\n\\n```rust\\nuse bitcoin_chacha::compute_poly1305_tag;\\n\\nlet key: [u8; POLY1305_KEYLEN] = [0u8; POLY1305_KEYLEN];\\nlet msg = b\\\"data\\\";\\nlet tag = compute_poly1305_tag(&key, msg);\\nassert_eq!(tag.len(), POLY1305_TAGLEN);\\n```\\n\\n- Delegates to `bitcoin_poly1305::poly1305_auth`.\\n- Produces a 16\u2011byte tag as `GenericArray<u8, U16>`.\\n- Tracing hooks record message length.\\n\\n### timingsafe_bcmp\\n\\n```rust\\nuse bitcoin_chacha::timingsafe_bcmp;\\n\\nlet a = [0u8; 16];\\nlet b = [0u8; 16];\\nlet res = timingsafe_bcmp(a.as_ptr(), b.as_ptr(), a.len());\\nassert_eq!(res, 0); // 0 means equal\\n```\\n\\n- Returns `0` if equal, `1` otherwise.\\n- Time\u2011independent with respect to the first differing byte.\\n- Intended for MAC/tag comparison.\\n\\n---\\n\\n## Safety and Correctness Considerations\\n\\n- The crate makes **heavy use of raw pointers** (`*const u8`, `*mut u8`) to match the structure and performance properties of the C reference implementation. All unsafe blocks are narrowly scoped and rely on documented preconditions:\\n  - Pointers must be valid for the specified length.\\n  - Buffers must be non\u2011overlapping where required (e.g., `copy_nonoverlapping`).\\n- The AEAD logic **zeroizes** per\u2011packet Poly1305 keys and calls `memory_cleanse` to clear sensitive material.\\n- Tag verification uses `timingsafe_bcmp`, not `memcmp`, to avoid timing side channels.\\n- **Key/nonce reuse bounds** are enforced only by documentation and invariants in higher\u2011level protocol code; the library asserts lengths, but does not attempt to track global nonce usage.\\n- The design is intended to be **bit\u2011compatible** with Bitcoin Core. When integrating, you should validate against known\u2011good test vectors or run cross\u2011implementation tests between this crate and reference nodes.\\n\\n---\\n\\n## Example: Bitcoin\u2011style Transport Packet\\n\\nThe following is a schematic example of end\u2011to\u2011end send/receive for a single packet:\\n\\n```rust\\nfn send_packet(\\n    aead: &mut ChaCha20Poly1305AEAD,\\n    seqnr_payload: u64,\\n    seqnr_aad: u64,\\n    aad_pos: i32,\\n    payload: &[u8],\\n) -> Vec<u8> {\\n    assert!(payload.len() < (1 << 24));\\n\\n    let len24 = payload.len() as u32;\\n    let mut src = Vec::with_capacity(3 + payload.len());\\n    src.push((len24 & 0xFF) as u8);\\n    src.push(((len24 >> 8) & 0xFF) as u8);\\n    src.push(((len24 >> 16) & 0xFF) as u8);\\n    src.extend_from_slice(payload);\\n\\n    let mut dest = vec![0u8; src.len() + POLY1305_TAGLEN];\\n    let ok = aead.crypt(\\n        seqnr_payload,\\n        seqnr_aad,\\n        aad_pos,\\n        dest.as_mut_ptr(),\\n        dest.len(),\\n        src.as_ptr(),\\n        src.len(),\\n        true,\\n    );\\n    assert!(ok);\\n\\n    dest\\n}\\n\\nfn recv_packet(\\n    aead: &mut ChaCha20Poly1305AEAD,\\n    seqnr_payload: u64,\\n    seqnr_aad: u64,\\n    aad_pos: i32,\\n    packet: &[u8],\\n) -> Option<Vec<u8>> {\\n    use core::ptr;\\n\\n    // 1. Decrypt length only\\n    let mut len24: u32 = 0;\\n    let ok = aead.get_length(\\n        &mut len24 as *mut u32,\\n        seqnr_aad,\\n        aad_pos,\\n        packet.as_ptr(),\\n    );\\n    if !ok { return None; }\\n\\n    let len = (len24 & 0x00FF_FFFF) as usize;\\n    if packet.len() < 3 + len + POLY1305_TAGLEN { return None; }\\n\\n    // 2. Decrypt + authenticate full packet\\n    let mut out = vec![0u8; 3 + len];\\n    let ok = aead.crypt(\\n        seqnr_payload,\\n        seqnr_aad,\\n        aad_pos,\\n        out.as_mut_ptr(),\\n        out.len(),\\n        packet.as_ptr(),\\n        3 + len + POLY1305_TAGLEN,\\n        false,\\n    );\\n    if !ok { return None; }\\n\\n    Some(out[3..].to_vec())\\n}\\n```\\n\\nThis pattern illustrates the split between early length decryption and full AEAD processing consistent with the Bitcoin specification.\\n\\n---\\n\\n## Repository and License\\n\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n- **Crate**: `bitcoin-chacha`\\n- **License**: MIT\\n- **Edition**: Rust 2021\\n\\nThe implementation is based on the public\u2011domain ChaCha20 reference by D. J. Bernstein and adapted for Bitcoin\u2019s P2P transport.\\n\\n---\\n\\n## When (and When Not) to Use This Crate\\n\\nUse `bitcoin-chacha` when:\\n\\n- You need **bit\u2011exact compatibility with Bitcoin Core\u2019s ChaCha20\u2011Poly1305@bitcoin transport**.\\n- You need **fine control** over sequence numbers, counters, and nonce usage for Bitcoin\u2011style protocols.\\n- You accept **pointer\u2011level, low\u2011level APIs** in exchange for tight control and minimal overhead.\\n\\nYou may prefer higher\u2011level AEAD crates (e.g., `chacha20poly1305`) when you want:\\n\\n- Generic RFC\u202f8439\u2011style AEAD semantics.\\n- Safer, slice\u2011based APIs with no explicit raw pointers.\\n- Non\u2011Bitcoin\u2011specific data layout and nonce semantics.\\n\\n---\\n\\n*Generated programmatically by an AI model; review before relying on it for security\u2011critical documentation.*\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"network-programming\",\n      \"algorithms\",\n      \"science\",\n      \"no-std\"\n    ],\n    \"package_description\": \"Bitcoin-compatible ChaCha20 stream cipher and ChaCha20-Poly1305@bitcoin AEAD, with low-level pointer-based APIs, constant-time tag verification, and explicit control over nonces, counters, and keystream caching.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"chacha20\",\n      \"poly1305\",\n      \"aead\",\n      \"cryptography\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 7495, "completion_tokens": 5113, "total_tokens": 12608, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
