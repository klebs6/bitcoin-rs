{"custom_id":"bitcoin-remote-ai-readme-request","method":"POST","url":"/v1/chat/completions","body":{"max_completion_tokens":8192,"messages":[{"content":"We would like you to write a README.md for a rust crate with maximally helpful content.\nAdditionally, we would like you to generate several fields from the Cargo.toml package section for this crate.\nWe will show you the strict json output format we would like you to provide.\nPlease tailor your response for an apex consumer of maximal intelligence.\nA reader of this README.md should have a good sense of what the crate does and how to use it after reading what you write.\nPlease include a messaage indicating that this README.md file was generated by an AI model and may not be 100% accurate however it should be pretty good.\n\n\nCarefully read and parse the information we sent you.\n\nWe want to generate all information items requested by our schema:\n\n- Read the description of each field. Use it, along with the content we sent you to generate an appropriate value for each.\n- Ensure that each generated field optimally serves its desired purpose.\n- Each item should be deep, detailed, and specific. Use optimally descriptive and useful language. Do not be too verbose.\n- Do not add any extra keys to the generated object. Generate precisely what we ask of you: no more, no less.\n- For fields which are of an enum type: pick *exactly one variant*. Do not generate any information for the unselected variants.\n- For array fields: supply a JSON list [ ... ] of items, each conforming to the correct item type.\n- For map fields: Provide a JSON object { \"key_as_string\": <value>, ... }. Keys must be valid JSON strings. Keys and Values must conform to the key and value schemas we provide to you. Fill all subfields of each and every map value.\n- If we ask you to justify a map field, provide your justification/confidence score for the entire map. Do not attempt to separately justify each map element.\n- Likewise, if we ask you to justify an array field, provide your justification/confidence score for the entire array. Do not attempt to separately justify each element.\n- Provide numeric fields as real JSON numbers (not strings).\n- For string fields: provide the value precisely as a string literal. If optional, you may set it to null.\n- If we ask you to justify or provide confidence scores for the fields of a structure, please do so carefully. For each field we ask you to justify, please explain or justify your choice clearly. Confidence scores must be specified as real JSON numbers in the range `[0..1]`.\n- If we ask to you generate an optional field, either fill it or set it to null.\n- If we ask you to justify your choice of an enum variant, please explain your choice clearly. Do not justify your decision to leave a variant unselected. Provide your justification as a JSON string. Provide your confidence score as a real JSON number in the range `[0..1]`.\n- In terms of the JSON format we would like you to provide, the object itself will be deserialied based on the following schema. \n- We begin exactly at the top: the data should not be nested under a parent named 'fields' or anything similar.\n\n## Here is the schema to use:\n\nObject {\n    \"fields\": Object {\n        \"crate_name\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be the name of our crate, *verbatim*, trimmed for use as a toml field\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"full_readme_markdown\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be valid markdown representing the readme for this crate.\\\\n\\\\n Please make it terse, useful, and designed for an industrious commercially savy consumer of industrious nature. \\\\n\\\\n Advanced vocabulary and concepts are welcome. \\\\n\\\\n If this crate involves concepts from mathematics and/or physics, please describe and document them here.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_categories\": Object {\n            \"generation_instructions\": String(\"\\\"These categories will be used in our Cargo.toml file.\\\\n\\\\n It is important that users of this crate can find it on crates.io.\\\\n\\\\n Choose maximum 5 categories and make sure they are actually meaningful for our crate.\\\\n\\\\n These categories should only be chosen from among the legal crates.io categories. \\\\n\\\\n The ONLY legal categoreis are:\\\\n\\\\n``\\\\n accessibility\\\\n aerospace\\\\n algorithms\\\\n api-bindings\\\\n asynchronous\\\\n authentication\\\\n caching\\\\n command-line-interface\\\\n command-line-utilities\\\\n compilers\\\\n compression\\\\n computer-vision\\\\n concurrency\\\\n config\\\\n cryptography\\\\n data-structures\\\\n database\\\\n database-implementations\\\\n date-and-time\\\\n development-tools\\\\n email\\\\n embedded\\\\n emulators\\\\n encoding\\\\n external-ffi-bindings\\\\n filesystem\\\\n finance\\\\n game-development\\\\n game-engines\\\\n games\\\\n graphics\\\\n gui\\\\n hardware-support\\\\n internationalization\\\\n localization\\\\n mathematics\\\\n memory-management\\\\n multimedia\\\\n network-programming\\\\n no-std\\\\n os\\\\n parser-implementations\\\\n parsing\\\\n rendering\\\\n rust-patterns\\\\n science\\\\n simulation\\\\n template-engine\\\\n text-editors\\\\n text-processing\\\\n value-formatting\\\\n virtualization\\\\n visualization\\\\n wasm\\\\n web-programming\\\\n ``\\\\n\\\\n DO NOT specify a category that is not on this list.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n        \"package_description\": Object {\n            \"generation_instructions\": String(\"\\\"We will place this package_description in our Cargo.toml file so the users of this crate\\\\n know what it does.\\\\n\\\\n The discription should be technical, clear, and useful. It should be terse.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_keywords\": Object {\n            \"generation_instructions\": String(\"\\\"These keywords will be used in our Cargo.toml file so the users of this crate can easily\\\\n find it in the package system. Keywords should be useful, varied, meaningful, and reflect\\\\n the contents of our crate. They should make it easy to find. Please provide exactly five.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n    },\n    \"struct_docs\": String(\" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\"),\n    \"struct_name\": String(\"AiReadmeWriterDesiredOutput\"),\n    \"type\": String(\"struct\"),\n}\n\n## Please keep the following in mind:\n\nEntry phrasing:\n\n- Ensure entries are concise and focused.\n- Ensure there are no vague phrases (e.g., avoid starting with \"Illustrates the something something...\"; instead, use direct details like \"The hanging green vines on the garden wall\").\n\nEnsure Clarity and Consistency:\n\n- Use clear, grammatically correct sentences.\n- Maintain a consistent tone and style throughout.\n\nEnrich Content:\n\n- Communicate additional information where appropriate to enhance depth and value.\n- If a mathematical, physical, or otherwise technical background is helpful, please provide it.\n- Ensure that the content is comprehensive and meets all requirements.\n\nFocus Language:\n\n- Use deliberate and precise language.\n- Avoid vague verbs and keep the maximally intelligent and detail oriented audience in mind. \n- We explicitly ban the words `hush`, `subtle`, `mythic`, and `aura`. Please keep your vocabulary choices rigorous.\n- Do not use modern cultural references \n- Do not generically reference ideas which do not belong in the global environment.\n\n## Present the Final JSON:\n\n- Format the output as a JSON object.\n- Include all fields properly named from the schema we sent you.\n\nEnsure Proper Formatting:\n\n- Use proper JSON syntax with keys and arrays.\n- Ensure that all entries are correctly placed in their respective places.\n\nProvide only the final JSON data as specified by the schema. \n\nDo not include any schema generation instructions, meta-fields, nested-templates (unless directly asked) or extraneous information. \n\nProvide only the populated fields and their values, conforming exactly to the required structure without embedding any intermediate annotations or placeholders.\n\nYour output should only consist of the JSON object. do *not* include a preamble or postamble to your response. \n\nWe seek to successfully parse your response directly as JSON.\n\nFor the final answer, output the result only as a valid JSON object, wrapped inside triple backticks with json immediately after the opening backticks.\nThe JSON must be parser-ready:\n– No additional text before or after the block\n– No markdown or prose outside the fenced block\n– No HTML escaping of quotes, slashes, or other characters\n– Indentation and whitespace preserved exactly as written\n– The content between the fences must be valid JSON as per RFC 8259","role":"system"},{"content":"We have a rust crate named 'bitcoin-remote' 0.1.22. \n\nHere is the interface:\n/**\n| HTTP status codes\n|\n*/\n#[repr(i32)]\npub enum HTTPStatusCode {\n    HTTP_OK,\n    HTTP_BAD_REQUEST,\n    HTTP_UNAUTHORIZED,\n    HTTP_FORBIDDEN,\n    HTTP_NOT_FOUND,\n    HTTP_BAD_METHOD,\n    HTTP_INTERNAL_SERVER_ERROR,\n    HTTP_SERVICE_UNAVAILABLE,\n}\n\n\npub enum JSONRPCRequestMode {\n    EXECUTE,\n    GET_HELP,\n    GET_ARGS,\n}\n\n/**\n| Bitcoin RPC error codes\n|\n*/\n/**\n  | Bitcoin RPC error codes\n  |\n  */\nbitflags! {\n\n    pub struct RPCErrorCode: i32 {\n\n        /* --------- Standard JSON-RPC 2.0 errors  --------- */\n\n        /*\n          | RPC_INVALID_REQUEST is internally mapped to\n          | HTTP_BAD_REQUEST (400).\n          |\n          | It should not be used for application-layer\n          | errors.\n          */\n        const RPC_INVALID_REQUEST  = -32600;\n\n        /*\n          | RPC_METHOD_NOT_FOUND is internally mapped\n          | to HTTP_NOT_FOUND (404).\n          |\n          | It should not be used for application-layer\n          | errors.\n          */\n        const RPC_METHOD_NOT_FOUND = -32601;\n        const RPC_INVALID_PARAMS   = -32602;\n\n        /*\n          | RPC_INTERNAL_ERROR should only be\n          | used for genuine errors in bitcoind\n          | (for example datadir corruption).\n          |\n          */\n        const RPC_INTERNAL_ERROR   = -32603;\n        const RPC_PARSE_ERROR      = -32700;\n\n        /* ------ General application defined errors  ------ */\n\n        /*\n          | std::exception thrown in command handling\n          |\n          */\n        const RPC_MISC_ERROR                  = -1;\n\n        /*\n          | Unexpected type was passed as parameter\n          |\n          */\n        const RPC_TYPE_ERROR                  = -3;\n\n        /*\n          | Invalid address or key\n          |\n          */\n        const RPC_INVALID_ADDRESS_OR_KEY      = -5;\n\n        /*\n          | Ran out of memory during operation\n          |\n          */\n        const RPC_OUT_OF_MEMORY               = -7;\n\n        /*\n          | Invalid, missing or duplicate parameter\n          |\n          */\n        const RPC_INVALID_PARAMETER           = -8;\n\n        /*\n          | Database error\n          |\n          */\n        const RPC_DATABASE_ERROR              = -20;\n\n        /*\n          | Error parsing or validating structure\n          | in raw format\n          |\n          */\n        const RPC_DESERIALIZATION_ERROR       = -22;\n\n        /*\n          | General error during transaction or\n          | block submission\n          |\n          */\n        const RPC_VERIFY_ERROR                = -25;\n\n        /*\n          | Transaction or block was rejected by\n          | network rules\n          |\n          */\n        const RPC_VERIFY_REJECTED             = -26;\n\n        /*\n          | Transaction already in chain\n          |\n          */\n        const RPC_VERIFY_ALREADY_IN_CHAIN     = -27;\n\n        /*\n          | Client still warming up\n          |\n          */\n        const RPC_IN_WARMUP                   = -28;\n\n        /*\n          | RPC method is deprecated\n          |\n          */\n        const RPC_METHOD_DEPRECATED           = -32;\n\n\n        /* ------ Aliases for backward compatibility  ------ */\n        const RPC_TRANSACTION_ERROR           = Self::RPC_VERIFY_ERROR.bits;\n        const RPC_TRANSACTION_REJECTED        = Self::RPC_VERIFY_REJECTED.bits;\n        const RPC_TRANSACTION_ALREADY_IN_CHAIN= Self::RPC_VERIFY_ALREADY_IN_CHAIN.bits;\n\n        /* --------------- P2P client errors  --------------- */\n\n        /*\n          | Bitcoin is not connected\n          |\n          */\n        const RPC_CLIENT_NOT_CONNECTED        = -9;\n\n        /*\n          | Still downloading initial blocks\n          |\n          */\n        const RPC_CLIENT_IN_INITIAL_DOWNLOAD  = -10;\n\n        /*\n          | Node is already added\n          |\n          */\n        const RPC_CLIENT_NODE_ALREADY_ADDED   = -23;\n\n        /*\n          | Node has not been added before\n          |\n          */\n        const RPC_CLIENT_NODE_NOT_ADDED       = -24;\n\n        /*\n          | Node to disconnect not found in connected\n          | nodes\n          |\n          */\n        const RPC_CLIENT_NODE_NOT_CONNECTED   = -29;\n\n        /*\n          | Invalid IP/Subnet\n          |\n          */\n        const RPC_CLIENT_INVALID_IP_OR_SUBNET = -30;\n\n        /*\n          | No valid connection manager instance\n          | found\n          |\n          */\n        const RPC_CLIENT_P2P_DISABLED         = -31;\n\n        /*\n          | Max number of outbound or block-relay\n          | connections already open\n          |\n          */\n        const RPC_CLIENT_NODE_CAPACITY_REACHED= -34;\n\n        /* ----------------- Chain errors  ----------------- */\n\n        /*\n          | No mempool instance found\n          |\n          */\n        const RPC_CLIENT_MEMPOOL_DISABLED     = -33;\n\n        /* ----------------- Wallet errors  ----------------- */\n\n        /*\n          | Unspecified problem with wallet (key\n          | not found etc.)\n          |\n          */\n        const RPC_WALLET_ERROR                = -4;\n\n        /*\n          | Not enough funds in wallet or account\n          |\n          */\n        const RPC_WALLET_INSUFFICIENT_FUNDS   = -6;\n\n        /*\n          | Invalid label name\n          |\n          */\n        const RPC_WALLET_INVALID_LABEL_NAME   = -11;\n\n        /*\n          | Keypool ran out, call keypoolrefill\n          | first\n          |\n          */\n        const RPC_WALLET_KEYPOOL_RAN_OUT      = -12;\n\n        /*\n          | Enter the wallet passphrase with walletpassphrase\n          | first\n          |\n          */\n        const RPC_WALLET_UNLOCK_NEEDED        = -13;\n\n        /*\n          | The wallet passphrase entered was incorrect\n          |\n          */\n        const RPC_WALLET_PASSPHRASE_INCORRECT = -14;\n\n        /*\n          | Command given in wrong wallet encryption\n          | state (encrypting an encrypted wallet\n          | etc.)\n          |\n          */\n        const RPC_WALLET_WRONG_ENC_STATE      = -15;\n\n        /*\n          | Failed to encrypt the wallet\n          |\n          */\n        const RPC_WALLET_ENCRYPTION_FAILED    = -16;\n\n        /*\n          | Wallet is already unlocked\n          |\n          */\n        const RPC_WALLET_ALREADY_UNLOCKED     = -17;\n\n        /*\n          | Invalid wallet specified\n          |\n          */\n        const RPC_WALLET_NOT_FOUND            = -18;\n\n        /*\n          | No wallet specified (error when there\n          | are multiple wallets loaded)\n          |\n          */\n        const RPC_WALLET_NOT_SPECIFIED        = -19;\n\n        /*\n          | This same wallet is already loaded\n          |\n          */\n        const RPC_WALLET_ALREADY_LOADED       = -35;\n\n        /* --------- Backwards compatible aliases  --------- */\n        const RPC_WALLET_INVALID_ACCOUNT_NAME = Self::RPC_WALLET_INVALID_LABEL_NAME.bits;\n\n        /*\n         | Unused reserved codes, kept around for\n         | backwards compatibility. Do not reuse.  \n         */\n\n        /*\n          | Server is in safe mode, and command is\n          | not allowed in safe mode\n          |\n          */\n        const RPC_FORBIDDEN_BY_SAFE_MODE      = -2;\n    }\n}\n\n\nlazy_static! {\n    /// Global, lazily‑initialised conversion table\n    /// protected by a `Mutex` for thread‑safe access.\n    pub static ref RPC_CVT_TABLE: std::sync::Mutex<RPCConvertTable> =\n        std::sync::Mutex::new(RPCConvertTable::new());\n}\n\n#[derive(Debug, Getters, MutGetters, Setters, Default, Builder)]\n#[builder(pattern = \"owned\", setter(into), default)]\n#[getset(get=\"pub\")]\npub struct RPCConvertParam  {\n    method_name: &'static str,\n    param_idx:   i32,\n    param_name:  &'static str,\n}\n\n\n/// Lookup helper for determining whether a given RPC parameter (identified\n/// either by positional *index* or by *name*) must be converted from its\n/// textual CLI form to native JSON for the underlying RPC call.\n///\n/// The two internal `HashSet`s are built **once** at initialization from the\n/// canonical `vRPCConvertParams` table generated directly from Bitcoin Core.\n/// No mutation occurs afterwards, so external callers only need immutable\n/// accessors.\n/// Robust logging (via the `tracing` crate) is provided at strategic points to\n/// aid troubleshooting without polluting the hot path.\n#[derive(Debug, Getters, MutGetters, Setters, Default, Builder)]\n#[builder(pattern = \"owned\", setter(into), default)]\n#[getset(get=\"pub\")]\npub struct RPCConvertTable  {\n    members:         HashSet<(String, i32)>,\n    members_by_name: HashSet<(String, String)>,\n}\n\n\npub struct JSONRPCRequest  {\n    id:         UniValue,\n    str_method: String,\n    params:     UniValue,\n    mode:       JSONRPCRequestMode,\n    uri:        String,\n    auth_user:  String,\n    peer_addr:  String,\n    context:    Box<dyn Any>,\n}\n\n/// Delete RPC authentication cookie from disk\n///\n/// Any I/O error is logged but otherwise ignored (parity with upstream).\npub fn delete_auth_cookie() {\n    let filepath = get_auth_cookie_file(None);\n    if let Err(e) = fs::remove_file(&filepath) {\n        // Only log failures that are not “file doesn’t exist”.\n        if e.kind() != std::io::ErrorKind::NotFound {\n            error!(\n                %e,\n                \"Unable to remove auth‑cookie file {:?} in {}\", \n                filepath,\n                \"delete_auth_cookie\"\n            );\n        }\n    } else {\n        trace!(\"Deleted auth‑cookie file {:?}\", filepath);\n    }\n}\n\n\n/// Generate a brand‑new cookie and *atomically* write it to disk.  \n///\n/// Returns **true** on success and populates `cookie_out` with the newly‑minted value.\npub fn generate_auth_cookie(cookie_out: &mut String) -> bool {\n    const COOKIE_SIZE: i32 = 32;\n\n    // 1. Create random password\n    let mut rand_pwd = [0u8; COOKIE_SIZE as usize];\n    get_rand_bytes(rand_pwd.as_mut_slice(), COOKIE_SIZE);\n\n    let cookie: String = format!(\n        \"{}:{}\",\n        COOKIEAUTH_USER,\n        hex::encode(rand_pwd)\n    );\n\n    // 2. Write to temporary file first\n    let filepath_tmp = get_auth_cookie_file(Some(true));\n    if let Err(e) = {\n        if let Some(parent) = filepath_tmp.parent() {\n            if let Err(e) = fs::create_dir_all(parent) {\n                error!(%e, \"Unable to create parent directory for cookie\");\n                return false;\n            }\n        }\n        let mut file = match std::fs::OpenOptions::new()\n            .write(true)\n            .create(true)\n            .truncate(true)\n            // rely on process umask as per Core comment\n            .open(&filepath_tmp)\n        {\n            Ok(f) => f,\n            Err(e) => {\n                error!(\n                    %e,\n                    \"Unable to open cookie authentication file {:?} for writing\",\n                    filepath_tmp\n                );\n                return false;\n            }\n        };\n        file.write_all(cookie.as_bytes())\n            .and_then(|_| file.flush())\n    } {\n        error!(\n            %e,\n            \"Failed to write temporary cookie file {:?}\",\n            filepath_tmp\n        );\n        // best‑effort clean‑up\n        let _ = fs::remove_file(&filepath_tmp);\n        return false;\n    }\n\n    // 3. Atomically rename to final destination\n    let filepath_final = get_auth_cookie_file(Some(false));\n    if let Err(e) = fs::rename(&filepath_tmp, &filepath_final) {\n        error!(\n            %e,\n            \"Unable to rename cookie authentication file {:?} to {:?}\",\n            filepath_tmp, filepath_final\n        );\n        let _ = fs::remove_file(&filepath_tmp);\n        return false;\n    }\n\n    info!(\n        \"Generated RPC authentication cookie at {:?}\",\n        filepath_final\n    );\n\n    *cookie_out = cookie;\n    true\n}\n\n\n/// Read the cookie from disk into `cookie_out`.  Returns\n/// **false** if the file is not present or not readable.\npub fn get_auth_cookie(cookie_out: &mut String) -> bool {\n    let filepath = get_auth_cookie_file(None);\n\n    let file = match fs::File::open(&filepath) {\n        Ok(f) => f,\n        Err(e) => {\n            debug!(\n                %e,\n                \"Failed to open auth‑cookie file {:?} for reading\",\n                filepath\n            );\n            return false;\n        }\n    };\n\n    let mut reader = BufReader::new(file);\n    let mut line = String::new();\n    if let Err(e) = reader.read_line(&mut line) {\n        warn!(%e, \"Failed to read cookie from {:?}\", filepath);\n        return false;\n    }\n\n    // Trim trailing newline if present (parity with getline)\n    if line.ends_with('\\n') {\n        line.pop();\n        if line.ends_with('\\r') {\n            line.pop();\n        }\n    }\n\n    *cookie_out = line;\n    true\n}\n\n\n/// JSON-RPC protocol.\n/// \n/// Bitcoin speaks version 1.0 for maximum compatibility, but uses JSON-RPC\n/// 1.1/2.0 standards for parts of the 1.0 standard that were unspecified (HTTP\n/// errors and contents of 'error').\n/// 1.0 spec: http://json-rpc.org/wiki/specification\n/// 1.2 spec: http://jsonrpc.org/historical/json-rpc-over-http.html\n///\n/// Build a JSON-RPC request object using **UniValue**:\n/// { \"method\": <strMethod>, \"params\": <params>, \"id\": <id> }\npub fn jsonrpc_request_obj(str_method: &str, params: &UniValue, id: &UniValue) -> UniValue {\n    trace!(method = str_method, \"jsonrpc_request_obj: building request\");\n\n    let mut obj = UniValue::new(uni_value::VType::VOBJ, None);\n    assert!(obj.pushkv(\"method\", str_method));\n    assert!(obj.pushkv(\"params\", params.clone()));\n    assert!(obj.pushkv(\"id\", id.clone()));\n\n    debug!(request = ?obj, \"jsonrpc_request_obj: built\");\n    obj\n}\n\n\n/// Build a JSON-RPC reply object (UniValue):\n///\n/// If `error` is not null, `\"result\"` is forced to `null`.\n/// {\n///   \"result\": <result or null>,\n///   \"error\":  <error>,\n///   \"id\":     <id>\n/// }\npub fn jsonrpc_reply_obj(result: &UniValue, error: &UniValue, id: &UniValue) -> UniValue {\n    let mut reply = UniValue::new(uni_value::VType::VOBJ, None);\n\n    if !error.is_null() {\n        assert!(reply.pushkv(\"result\", UniValue::null()));\n    } else {\n        assert!(reply.pushkv(\"result\", result.clone()));\n    }\n    assert!(reply.pushkv(\"error\",  error.clone()));\n    assert!(reply.pushkv(\"id\",     id.clone()));\n\n    trace!(reply = ?reply, \"jsonrpc_reply_obj: built\");\n    reply\n}\n\n\n/// Serialize a JSON-RPC reply object to a compact JSON string with a trailing\n/// newline, mirroring upstream's `write() + \"\\n\"`.\npub fn jsonrpc_reply(result: &UniValue, error: &UniValue, id: &UniValue) -> String {\n    let reply_obj = jsonrpc_reply_obj(result, error, id);\n    let mut s = reply_obj.write(None, None);\n    s.push('\\n');\n    trace!(len = s.len(), \"jsonrpc_reply: serialized\");\n    s\n}\n\n\n/// Construct a JSON-RPC error object:\n///\n/// { \"code\": <code>, \"message\": <message> }\npub fn jsonrpc_error(code: i32, message: &str) -> UniValue {\n    let mut err = UniValue::new(uni_value::VType::VOBJ, None);\n    assert!(err.pushkv(\"code\", code));\n    assert!(err.pushkv(\"message\", message));\n    debug!(code, message, err = ?err, \"jsonrpc_error: built\");\n    err\n}\n\n\n/// Parse a JSON-RPC *batch* reply into a vector whose indices correspond to the\n/// numeric `\"id\"` of each member.\n///\n/// Structural violations panic, mirroring the original C++ exceptions.\n/// Errors:\n/// - *\"Batch must be an array\"* if `in_` is not an array\n/// - *\"Batch member must be an object\"* for non-object members\n/// - *\"Batch member id is larger than batch size\"* if an `id` exceeds the batch bound\npub fn jsonrpc_process_batch_reply(in_: &UniValue) -> Vec<UniValue> {\n    trace!(\"jsonrpc_process_batch_reply: begin\");\n\n    if !in_.is_array() {\n        error!(\"jsonrpc_process_batch_reply: not an array\");\n        panic!(\"Batch must be an array\");\n    }\n\n    let num = in_.size();\n    let mut batch: Vec<UniValue> = vec![UniValue::null(); num];\n\n    for rec in in_.get_values().iter() {\n        if !rec.is_object() {\n            error!(record = ?rec, \"jsonrpc_process_batch_reply: member not an object\");\n            panic!(\"Batch member must be an object\");\n        }\n\n        let id_uv = &rec[\"id\"];\n        let id_i64 = if id_uv.is_num() {\n            id_uv.get_int64()\n        } else {\n            error!(id = ?id_uv, \"jsonrpc_process_batch_reply: non-integer id\");\n            panic!(\"Batch member id is larger than batch size\");\n        };\n\n        if id_i64 < 0 {\n            error!(id = id_i64, \"jsonrpc_process_batch_reply: negative id\");\n            panic!(\"Batch member id is larger than batch size\");\n        }\n\n        let id_u = id_i64 as usize;\n        if id_u >= num {\n            error!(id = id_u, num, \"jsonrpc_process_batch_reply: id out of bounds\");\n            panic!(\"Batch member id is larger than batch size\");\n        }\n\n        trace!(id = id_u, \"jsonrpc_process_batch_reply: placing record\");\n        batch[id_u] = rec.clone();\n    }\n\n    debug!(count = batch.len(), \"jsonrpc_process_batch_reply: end\");\n    batch\n}\n\n\n/// Resolve the absolute path for the *RPC‑auth* cookie file.\n///\n/// If `temp == true` the function appends **`.tmp`** to the\n/// filename, mirroring Core’s strategy of writing to a\n/// temporary file first and then renaming atomically.\npub fn get_auth_cookie_file(temp: Option<bool>) -> Box<Path> {\n    let mut name: String = {\n        // Honour `-rpccookiefile=<path>` if provided, otherwise\n        // fall back to the default.\n        let g_args = G_ARGS.lock();\n        g_args.get_arg(\"-rpccookiefile\", COOKIEAUTH_FILE)\n    };\n\n    if temp.unwrap_or(false) {\n        name.push_str(\".tmp\");\n    }\n\n    let path = abs_path_for_config_val(&PathBuf::from(&name), Some(false));\n\n    trace!(path = ?path, \"Computed auth‑cookie path\");\n    path.into_boxed_path()\n}\n\nimpl RPCConvertTable {\n\n    /// Build a fully‑populated conversion table using the\n    /// static list emitted above.\n    pub fn new() -> Self {\n        let mut members = HashSet::<(String, i32)>::with_capacity(vRPCConvertParams.len());\n        let mut members_by_name =\n            HashSet::<(String, String)>::with_capacity(vRPCConvertParams.len());\n    \n        for cp in vRPCConvertParams {\n            members.insert((cp.method_name().to_owned().to_string(), *cp.param_idx()));\n            members_by_name.insert((cp.method_name().to_owned().to_string(), cp.param_name().to_owned().to_string()));\n        }\n    \n        debug!(\n            table_size_idx = members.len(),\n            table_size_name = members_by_name.len(),\n            \"RPCConvertTable initialised\"\n        );\n    \n        Self {\n            members,\n            members_by_name,\n        }\n    }\n\n    /// Does *(`method`, `idx`)* require JSON conversion?\n    ///\n    /// A mutable receiver is accepted for parity with the\n    /// original C++ signature; however, no mutation is\n    /// performed.\n    pub fn convert_with_method_and_idx(&mut self, method: &str, idx: i32) -> bool {\n        let hit = self.members.contains(&(method.to_owned(), idx));\n        trace!(method, idx, hit, \"idx‑based lookup\");\n        hit\n    }\n\n    /// Does *(`method`, `name`)* require JSON conversion?\n    ///\n    /// A mutable receiver is accepted for parity with the\n    /// original C++ signature; however, no mutation is\n    /// performed.\n    pub fn convert_with_method_and_name(&mut self, method: &str, name: &str) -> bool {\n        let hit = self\n            .members_by_name\n            .contains(&(method.to_owned(), name.to_owned()));\n        trace!(method, name, hit, \"name‑based lookup\");\n        hit\n    }\n}\n\nimpl JSONRPCRequest {\n\n    /// Parse a single JSON-RPC request object into this `JSONRPCRequest`\n    /// using **UniValue** exclusively (no `serde_json`).\n    pub fn parse(&mut self, val_request: &UniValue) {\n        trace!(\"JSONRPCRequest::parse: begin\");\n    \n        // Parse request\n        if !val_request.is_object() {\n            error!(\"JSONRPCRequest::parse: invalid top-level type (expected object)\");\n            let err = jsonrpc_error(RPCErrorCode::RPC_INVALID_REQUEST.bits(), \"Invalid Request object\");\n            panic!(\"{}\", err.write(None, None));\n        }\n    \n        // Parse id now so errors from here on will have the id\n        self.id = find_value(val_request, \"id\").clone();\n        debug!(id = ?self.id, \"JSONRPCRequest::parse: captured id\");\n    \n        // Parse method\n        let val_method = find_value(val_request, \"method\").clone();\n        if val_method.is_null() {\n            error!(\"JSONRPCRequest::parse: missing method\");\n            let err = jsonrpc_error(RPCErrorCode::RPC_INVALID_REQUEST.bits(), \"Missing method\");\n            panic!(\"{}\", err.write(None, None));\n        }\n        if !val_method.is_str() {\n            error!(\"JSONRPCRequest::parse: method not a string\");\n            let err = jsonrpc_error(RPCErrorCode::RPC_INVALID_REQUEST.bits(), \"Method must be a string\");\n            panic!(\"{}\", err.write(None, None));\n        }\n        self.str_method = val_method.get_str().to_owned();\n    \n        // Parity with upstream logging (include peer address when available)\n        if self.peer_addr.is_empty() {\n            info!(\n                method = %self.str_method,\n                user = %self.auth_user,\n                \"ThreadRPCServer method log (no peer address)\"\n            );\n        } else {\n            info!(\n                method = %self.str_method,\n                user = %self.auth_user,\n                peeraddr = %self.peer_addr,\n                \"ThreadRPCServer method log\"\n            );\n        }\n    \n        // Parse params\n        let val_params = find_value(val_request, \"params\").clone();\n        if val_params.is_array() || val_params.is_object() {\n            self.params = val_params;\n        } else if val_params.is_null() {\n            self.params = UniValue::empty_array();\n        } else {\n            error!(\"JSONRPCRequest::parse: params wrong type (must be array or object)\");\n            let err = jsonrpc_error(\n                RPCErrorCode::RPC_INVALID_REQUEST.bits(),\n                \"Params must be an array or object\",\n            );\n            panic!(\"{}\", err.write(None, None));\n        }\n    \n        trace!(\n            method = %self.str_method,\n            params_kind = %if self.params.is_array() { \"array\" } else if self.params.is_object() { \"object\" } else { \"null\" },\n            \"JSONRPCRequest::parse: end\"\n        );\n    }\n}\n\n\nThis crate has the following authors:\n[\n    \"klebs <none>\",\n]\nThis crate has the following rust edition:\n2021\nThis crate has the following license:\nMIT\nThis crate is held in the following repository:\nhttps://github.com/klebs6/bitcoin-rs\n","role":"user"}],"model":"gpt-5.1"}}
