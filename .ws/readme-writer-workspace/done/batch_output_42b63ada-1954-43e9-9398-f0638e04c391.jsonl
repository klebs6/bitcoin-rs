{"id": "batch_req_692cdcca1d8c8190b78b0065e46b15e0", "custom_id": "bitcoin-random-ai-readme-request", "response": {"status_code": 200, "request_id": "56e97d378da1e7217537d8ab5bc4c777", "body": {"id": "chatcmpl-ChllapseomyvPe9xN33NcAYl8ZopP", "object": "chat.completion", "created": 1764547754, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-random\",\n    \"full_readme_markdown\": \"# bitcoin-random\\n\\nA carefully ported subset of Bitcoin Core's entropy collection and pseudo\u2011random number generation, exposed as a reusable Rust crate.\\n\\nThis README was generated by an AI model and may not be 100% accurate, but it should be a close approximation of the crate's intent and API.\\n\\n## Overview\\n\\n`bitcoin-random` provides a layered randomness subsystem modeled on Bitcoin Core's production code. It combines OS entropy, CPU hardware RNG instructions, high\u2011resolution timers, environment snapshots, and an internal SHA\u2011512\u2013based DRBG to supply both fast and cryptographically strong random bytes.\\n\\nYou typically want this crate if:\\n\\n- You are implementing or porting Bitcoin Core subsystems that expect the same RNG semantics (e.g. consensus\u2011relevant logic, wallet key generation, or P2P behavior).\\n- You need a battle\u2011tested entropy aggregator with defensive mixing, strengthening, and hardware feature detection.\\n- You want deterministic test RNGs with the same distributional properties as Bitcoin Core\u2019s `FastRandomContext`.\\n\\nThe crate exposes:\\n\\n- **High\u2011level APIs** for fast and strong randomness:\\n  - `get_rand_bytes`, `get_strong_rand_bytes`\\n  - `get_rand`, `get_rand_int`, `get_rand_hash`\\n  - `get_random_duration`\\n- **An internal DRBG and state machine** (`RNGState`, `RNGInnerState`, `RNGStateEvents`) that maintains 256 bits of entropy and continuously mixes in new sources.\\n- **FastRandomContext**: a deterministic, ChaCha20\u2011based PRNG implementing `rand_core::RngCore` and a custom `RandRange` trait.\\n- **Environment entropy collectors** (`rand_add_dynamic_env`, `rand_add_static_env`, and several OS/CPU\u2011specific helpers) closely matching Bitcoin Core\u2019s C++ implementation.\\n- **Hardware RNG integration and reporting** for Intel/AMD `RDRAND` and `RDSEED`.\\n- **Low\u2011level OS entropy backends** for Linux (`getrandom`/`/dev/urandom`), BSD (`getentropy`, `sysctl KERN_ARND`), macOS, Windows (CryptoAPI), and a `/dev/urandom` fallback.\\n\\nThe design emphasizes:\\n\\n- **Cryptographic robustness**: entropy is aggregated into a SHA\u2011512 DRBG which maintains at least 256 bits of internal state; additional entropy is mixed in on each call to strong RNG interfaces.\\n- **Side\u2011channel resilience**: sensitive buffers are cleared via `memory_cleanse` after use where appropriate.\\n- **Deterministic testing**: `FastRandomContext` can be seeded deterministically; a global flag `G_MOCK_DETERMINISTIC_TESTS` exists to route `get_rand` into deterministic mode.\\n- **Close fidelity to Bitcoin Core**: structure, sequencing, and environment gathering paths are designed to be isomorphic to the upstream C++ implementation, preserving security properties and behavior.\\n\\n## Crate status and scope\\n\\nThis crate is derived from the `bitcoin-rs` project and is intended primarily to support that ecosystem. It is not a general\u2011purpose, standards\u2011audited cryptographic library; however, it is based on code that has undergone extensive real\u2011world scrutiny in the context of Bitcoin Core.\\n\\nUse for key generation and consensus\u2011relevant randomness should follow Bitcoin Core\u2019s threat model and assumptions. If you need FIPS\u2011validated primitives or formal proofs, you may prefer a dedicated cryptographic RNG crate.\\n\\n## RNG layers and conceptual model\\n\\n### 1. OS entropy (`get_os_rand` and friends)\\n\\nThe lowest layer is direct OS entropy:\\n\\n- **Linux/Android**: `getrandom(2)` when available; falls back to reading `/dev/urandom`.\\n- **OpenBSD**: `getentropy`.\\n- **macOS**: `getentropy`.\\n- **FreeBSD/NetBSD and similar**: `sysctl` with `KERN_ARND`.\\n- **Windows**: CryptoAPI `CryptAcquireContextW` + `CryptGenRandom`.\\n- **Portable fallback**: `/dev/urandom` where no specialized support is compiled in.\\n\\nThese backends always try to fill a 32\u2011byte buffer (`NUM_OS_RANDOM_BYTES`) and **fail hard** via `rand_failure()` if the OS cannot supply randomness.\\n\\n### 2. Internal DRBG (`RNGState` and `RNGInnerState`)\\n\\n`RNGInnerState` maintains:\\n\\n- `state: [u8; 32]` \u2014 256 bits of internal entropy.\\n- `counter: u64` \u2014 a monotonically increasing counter mixed into each extraction.\\n- `strongly_seeded: bool` \u2014 indicates whether a strong (OS\u2011backed) seed has been mixed in at least once.\\n\\n`RNGState` wraps this inner state with mutexes and an event hasher (`Sha256`) used to mix in timing and application events.\\n\\nEntropy extraction and mixing is performed by:\\n\\n```rust\\npub fn mix_extract(\\n    &mut self,\\n    out: &mut [u8],\\n    num: usize,\\n    hasher: Sha512,\\n    strong_seed: bool,\\n) -> bool\\n```\\n\\nKey properties:\\n\\n- The current `state` and `counter` are appended to a `Sha512` hasher plus any external entropy provided by the caller.\\n- `finalize()` of the hasher yields 64 bytes:\\n  - The **last 32 bytes** become the new internal `state`.\\n  - The **first 32 bytes** (optionally truncated to `num \u2264 32`) are returned as output.\\n- If `strong_seed` is `true`, `strongly_seeded` is updated; the function returns the current `strongly_seeded` flag so callers (e.g. `proc_rand`) can determine whether strong seeding has ever happened.\\n\\nThis structure matches Bitcoin Core\u2019s DRBG: the new state is a one\u2011way function of the old state, the counter, and new entropy. Compromise of a single output does not reveal prior state.\\n\\n### 3. Seeding strategies\\n\\nSeveral seeding functions, each with distinct cost and entropy assumptions, feed into the DRBG:\\n\\n- **`seed_fast`**: minimal latency seed for high\u2011frequency use.\\n  - Uses stack pointer, optional hardware RNG (`seed_hardware_fast`), and a high\u2011resolution timestamp (`seed_timestamp`).\\n- **`seed_slow`**: stronger reseed path.\\n  - Calls `seed_fast`.\\n  - Adds 32 bytes of OS randomness (`get_os_rand`).\\n  - Incorporates event hash via `rng.seed_events`.\\n  - Adds another high\u2011precision timestamp.\\n- **`seed_hardware_slow`**: high\u2011quality hardware RNG (if available).\\n  - Prefers `RDSEED` and collects 256 bits directly.\\n  - Falls back to repeatedly XORed `RDRAND` results to obtain 256 bits with inter\u2011call reseeding.\\n- **`seed_periodic`**: expensive reseed path intended to run periodically (e.g. once a minute).\\n  - Includes `seed_fast` + `seed_timestamp` + `rng.seed_events`.\\n  - Mixes a wide set of dynamic environment data via `rand_add_dynamic_env` (timers, `/proc` snapshots, resource usage, etc.).\\n  - Strengthens the resulting seed with a `strengthen` loop over ~10 ms.\\n- **`seed_startup`**: heavy startup seeding for first use.\\n  - Uses `seed_hardware_slow`.\\n  - Uses `seed_slow`.\\n  - Mixes dynamic and static environment data (`rand_add_dynamic_env`, `rand_add_static_env`).\\n  - Applies `strengthen` for ~100 ms.\\n\\nThe `strengthen` function repeatedly hashes an initial 32\u2011byte seed through `Sha512` for a configurable number of microseconds, periodically folding in high\u2011resolution performance counters. This is conceptually a time\u2011hardening step: it converts any partial entropy from noisy sources into pseudorandom bits while amortizing over CPU time.\\n\\n### 4. Hardware RNG integration (x86/x86_64)\\n\\nWhen compiled with `have_getcpuid` and on supported targets:\\n\\n- `init_hardware_rand` uses CPUID leaves to query `RDRAND` and `RDSEED` support, setting `G_RDRAND_SUPPORTED` and `G_RDSEED_SUPPORTED`.\\n- `report_hardware_rand` logs which features are in use.\\n- `get_rd_rand` and `get_rd_seed` use inline assembly to issue the corresponding instructions, including the recommended retry loops to handle transient failure.\\n\\nThe seeding functions (`seed_hardware_fast` / `seed_hardware_slow`) only use these instructions when the corresponding hardware support flags are set.\\n\\n### 5. Event and environment entropy\\n\\nTo defend against state compromise and to continuously add entropy, the RNG mixes in information from:\\n\\n- **Event timing**: `rand_add_event(event_info: u32)` writes the event identifier and low 32 bits of a high\u2011frequency performance counter into a `Sha256` hasher in `RNGStateEvents`. This is suitable for network packet arrivals, user input, or other external events.\\n- **Dynamic environment** (`rand_add_dynamic_env`):\\n  - System clocks: `CLOCK_REALTIME`, `CLOCK_MONOTONIC`, `CLOCK_BOOTTIME` (Linux), `gettimeofday`, C++\u2011style triple of `system_clock`, `steady_clock`, `high_resolution_clock` equivalents.\\n  - Resource usage: `getrusage(RUSAGE_SELF)`.\\n  - `/proc` snapshots: several small files on Linux (`diskstats`, `vmstat`, `schedstat`, `zoneinfo`, `meminfo`, `softirqs`, `stat`, `self/schedstat`, `self/status`).\\n  - Heap/stack pointers: allocations via `malloc` and raw addresses.\\n  - Network interfaces: `getifaddrs` enumeration, interface names, flags, and socket addresses.\\n  - Hostname, uname fields, and key filesystem paths.\\n- **Static environment** (`rand_add_static_env`):\\n  - Sizes of fundamental types and signedness of `char`.\\n  - Linux `getauxval` data (`AT_HWCAP`, `AT_HWCAP2`, `AT_RANDOM`, `AT_PLATFORM`, `AT_EXECFN`).\\n  - CPU feature set via CPUID enumeration (`add_allcpuid`).\\n  - Addresses of code and data symbols (e.g. function pointers, `malloc`, `errno`, `environ`).\\n  - Full environment variables.\\n  - Process and thread identifiers (`pid`, `ppid`, `sid`, `pgid`, `uid/gid`, `euid/egid`, and `pthread_self`).\\n\\nThese sources are not relied upon as primary entropy; instead, they hedge against partial compromise and OS RNG failures by adding unpredictability from system\u2011specific and timing\u2011dependent state.\\n\\n## Public API\\n\\n### Top\u2011level RNG functions\\n\\nThese are the main entry points most consumers should use.\\n\\n#### `get_rand_bytes`\\n\\n```rust\\npub fn get_rand_bytes(buf: &mut [u8], num: i32)\\n```\\n\\n- Fills `buf[..num]` with random bytes generated via the internal PRNG.\\n- Uses `RNGLevel::FAST` seeding via `proc_rand`, so it is tuned for throughput rather than maximum entropy.\\n- Thread\u2011safe.\\n\\nUsage:\\n\\n```rust\\nuse bitcoin_random::get_rand_bytes;\\n\\nlet mut key = [0u8; 32];\\nget_rand_bytes(&mut key, key.len() as i32);\\n```\\n\\n#### `get_strong_rand_bytes`\\n\\n```rust\\npub fn get_strong_rand_bytes(buf: &mut [u8], num: i32)\\n```\\n\\n- Fills `buf[..num]` with random bytes using the **strong** seeding path (`RNGLevel::SLOW`).\\n- This path always incorporates OS randomness and event information and will abort if the OS RNG fails.\\n- Intended for security\u2011critical operations such as key generation.\\n\\nUsage:\\n\\n```rust\\nuse bitcoin_random::get_strong_rand_bytes;\\n\\nlet mut secret = [0u8; 32];\\nget_strong_rand_bytes(&mut secret, secret.len() as i32);\\n```\\n\\n#### `get_rand`\\n\\n```rust\\npub fn get_rand(n_max: u64) -> u64\\n```\\n\\n- Returns a uniform random integer in `[0, n_max)` using `FastRandomContext::randrange`.\\n- Preconditions: `n_max > 0`.\\n- Uses the global `G_MOCK_DETERMINISTIC_TESTS` flag to optionally switch into deterministic mode for tests.\\n\\nExample:\\n\\n```rust\\nuse bitcoin_random::get_rand;\\n\\nlet x = get_rand(1_000_000);\\nassert!(x < 1_000_000);\\n```\\n\\n#### `get_rand_int`\\n\\n```rust\\npub fn get_rand_int(n_max: i32) -> i32\\n```\\n\\n- Thin wrapper around `get_rand`, returning `i32` instead of `u64`.\\n- Preconditions: `n_max > 0`.\\n\\n#### `get_rand_hash`\\n\\n```rust\\npub fn get_rand_hash() -> u256\\n```\\n\\n- Returns a random 256\u2011bit value as a `u256` type (from the surrounding Bitcoin numeric crate).\\n- Backed by `get_rand_bytes` over the raw bytes of the `u256` structure.\\n\\nThis is the primitive used by `FastRandomContext::random_seed` to construct ChaCha20 keys.\\n\\n#### `get_random_duration`\\n\\n```rust\\npub fn get_random_duration(max: Duration) -> Duration\\n```\\n\\n- Returns a random `Duration` uniformly distributed in `[0, max)`.\\n- Preconditions: `max.as_seconds_f64() > 0`.\\n- Used to derive randomized timers or retry backoffs.\\n\\n### RNG lifecycle helpers\\n\\n#### `random_init`\\n\\n```rust\\npub fn random_init()\\n```\\n\\n- Optional explicit initialization step.\\n- Internally calls `proc_rand(&mut [], 0, RNGLevel::FAST)` to trigger `RNGState` setup and hardware RNG detection.\\n- Then calls `report_hardware_rand` to log discovered CPU RNG features.\\n\\nYou may call this early in process startup to ensure RNG initialization happens on your own schedule, instead of lazily on first use.\\n\\n#### `random_sanity_check`\\n\\n```rust\\npub fn random_sanity_check() -> bool\\n```\\n\\n- Performs a self\u2011test of the OS randomness backend and the performance counter:\\n  - Repeatedly calls `get_os_rand` on a zeroed buffer and checks that each byte is overwritten at least once within a bounded number of attempts.\\n  - Verifies that `get_performance_counter` increases across a call to `get_os_rand` + 1 ms sleep.\\n  - Feeds the performance counter values back into the global `RNGState` as additional entropy.\\n- Returns `false` if the OS RNG appears to misbehave or if the performance counter does not advance.\\n\\nThis is primarily a diagnostic / defensive primitive.\\n\\n#### `rand_add_periodic`\\n\\n```rust\\npub fn rand_add_periodic()\\n```\\n\\n- Invokes `proc_rand(&mut [], 0, RNGLevel::PERIODIC)`.\\n- Intended to be called periodically (e.g. via a timer) to add slow, expensive environmental entropy (perfmon, `/proc`, network interfaces, etc.) and strengthen the state.\\n\\n#### `rand_add_event`\\n\\n```rust\\npub fn rand_add_event(event_info: u32)\\n```\\n\\n- Adds an event descriptor plus timing information into the RNG\u2019s event hasher.\\n- Thread\u2011safe.\\n\\nYou can use this to feed in application\u2011specific events that may provide extra entropy, such as network message arrivals, user actions, or I/O completions.\\n\\n### `FastRandomContext`\\n\\n`FastRandomContext` is a fast, non\u2011cryptographic PRNG seeded from strong randomness (unless explicitly configured as deterministic). It is conceptually similar to a C++ `UniformRandomBitGenerator` and implements both the custom `RandRange` trait and `rand_core::RngCore`.\\n\\nKey properties:\\n\\n- Underlying core: `ChaCha20` stream cipher.\\n- Seed: 256\u2011bit `u256` key from `get_rand_hash()` when `requires_seed` is true.\\n- Deterministic option: when constructed with `deterministic = true`, the context is seeded with a fixed all\u2011zero `u256` key.\\n- Not thread\u2011safe; each instance is intended for single\u2011threaded use.\\n\\n#### Construction\\n\\n```rust\\nimpl FastRandomContext {\\n    pub fn new(deterministic: bool) -> Self { /* ... */ }\\n}\\n\\nimpl Default for FastRandomContext { /* deterministic = false */ }\\n\\nimpl From<&u256> for FastRandomContext { /* seed from explicit u256 */ }\\nimpl From<&mut FastRandomContext> for FastRandomContext { /* move semantics */ }\\n```\\n\\nTypical usage:\\n\\n```rust\\nuse bitcoin_random::FastRandomContext;\\n\\n// Non\u2011deterministic context, seeded from global RNG\\nlet mut rng = FastRandomContext::default();\\nlet x = rng.rand64();\\n\\n// Deterministic context for tests or simulations\\nlet mut det_rng = FastRandomContext::new(true);\\nlet a = det_rng.rand32();\\nlet b = det_rng.rand32();\\n```\\n\\nIf a `FastRandomContext` is moved using `From<&mut FastRandomContext>`, the original instance becomes logically invalid until it reseeds itself on next use (`requires_seed` is set back to `true`).\\n\\n#### Basic methods\\n\\n```rust\\nimpl FastRandomContext {\\n    pub fn rand64(&mut self) -> u64;\\n    pub fn rand32(&mut self) -> u32;\\n    pub fn randbits(&mut self, bits: i32) -> u64; // 0 \u2264 bits \u2264 64\\n    pub fn randbool(&mut self) -> bool;\\n    pub fn rand256(&mut self) -> u256;\\n    pub fn randbytes(&mut self, len: usize) -> Vec<u8>;\\n\\n    pub fn min() -> u64 { 0 }\\n    pub fn max() -> u64 { u64::MAX }\\n    #[inline]\\n    pub fn invoke(&mut self) -> u64 { self.rand64() }\\n}\\n```\\n\\n`randbits` uses an internal bit buffer (`bitbuf`) to collect and reuse entropy at bit\u2011level granularity, avoiding waste when many small random values are needed.\\n\\n`randbytes` uses the underlying ChaCha20 keystream directly and is efficient for filling large buffers.\\n\\n#### Integration with `rand_core`\\n\\n`FastRandomContext` implements `rand_core::RngCore`:\\n\\n```rust\\nimpl rand_core::RngCore for FastRandomContext {\\n    fn next_u32(&mut self) -> u32;\\n    fn next_u64(&mut self) -> u64;\\n    fn fill_bytes(&mut self, dest: &mut [u8]);\\n    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand::Error>;\\n}\\n```\\n\\nThis allows you to plug it into consumers that expect a `RngCore` implementation.\\n\\n#### `RandRange` trait\\n\\nThe crate defines a minimal trait for generating uniform integers in a given range:\\n\\n```rust\\npub trait RandRange {\\n    fn randrange(&mut self, range: u64) -> u64;\\n}\\n\\nimpl RandRange for FastRandomContext { /* rejection sampling */ }\\n```\\n\\n`randrange` implements rejection sampling:\\n\\n- Let `range > 0`; compute `bits = count_bits(range - 1)`.\\n- Draw `bits` random bits via `randbits(bits)`.\\n- If the sample is \u2264 `range - 1`, accept; otherwise, retry.\\n\\nThis ensures uniform distribution in `[0, range)` for any range not necessarily a power of two.\\n\\n### Shuffling utilities\\n\\nThe crate offers a highly specialized shuffle function optimized to minimize entropy waste and avoid specific issues with `std::shuffle` in some C++ standard libraries. The Rust port uses a generic iterator/index model constrained by several traits.\\n\\n```rust\\npub fn shuffle<'a, I: 'a, R>(mut first: I, last: I, mut rng: R)\\nwhere\\n    I: PartialEq + Copy + Sub<Output = I> + AddAssign<u64> + Add<Output = u64>,\\n    I: Deref<Target = &'a mut I> + DerefMut<Target = &'a mut I>,\\n    I: Add<u64>,\\n    R: RandRange,\\n    <I as Add<u64>>::Output: Deref<Target = &'a mut I>,\\n    <I as Add<u64>>::Output: DerefMut<Target = &'a mut I>,\\n    u64: From<I>,\\n```\\n\\nThis is a direct structural translation of the C++ `shuffle` used in Bitcoin Core's container utilities, which assumes a pointer\u2011like index type. It is not intended as a general drop\u2011in replacement for typical Rust iterators and may require custom wrapper types; in many Rust codebases you will prefer `rand::seq::SliceRandom` instead.\\n\\n`shuffle_all` is present but currently `todo!()`, mirroring an unimplemented C++ pattern.\\n\\n## Platform behavior and performance counters\\n\\n### `get_performance_counter`\\n\\n```rust\\npub fn get_performance_counter() -> i64\\n```\\n\\n- On x86/x86_64 Windows: uses `RDTSC` via `_rdtsc()` intrinsics.\\n- On non\u2011Windows x86/x86_64: uses inline assembly `rdtsc`.\\n- On other platforms: falls back to `quanta::Instant::now().as_u64()`.\\n\\nThe counter is used for:\\n\\n- Event timing in `rand_add_event`.\\n- Strengthening loops (`strengthen`).\\n- Periodic sanity checks.\\n\\nIt is treated as an entropy source only in combination with other inputs; alone it is not assumed to be unpredictable.\\n\\n## Example: generating keys and nonces\\n\\n```rust\\nuse bitcoin_random::{\\n    random_init,\\n    random_sanity_check,\\n    get_strong_rand_bytes,\\n    get_rand_bytes,\\n    FastRandomContext,\\n};\\n\\nfn main() {\\n    // Optional: ensure RNG is initialized early and hardware RNG reported.\\n    random_init();\\n\\n    // Optional: run a one\u2011time self\u2011test.\\n    assert!(random_sanity_check(), \\\"OS RNG failed sanity check\\\");\\n\\n    // Generate a 32\u2011byte secret (e.g. for an EC private key).\\n    let mut sk = [0u8; 32];\\n    get_strong_rand_bytes(&mut sk, sk.len() as i32);\\n\\n    // Generate a non\u2011cryptographic nonce using the fast path.\\n    let mut nonce = [0u8; 16];\\n    get_rand_bytes(&mut nonce, nonce.len() as i32);\\n\\n    // Use a dedicated, fast context for many draws.\\n    let mut ctx = FastRandomContext::default();\\n    let session_id = ctx.rand64();\\n\\n    println!(\\\"secret key: {:02x?}\\\", sk);\\n    println!(\\\"nonce: {:02x?}\\\", nonce);\\n    println!(\\\"session id: {}\\\", session_id);\\n}\\n```\\n\\n## Safety and correctness notes\\n\\n- Many functions marked `unsafe` in the implementation are strictly internal; the public API is safe, but relies heavily on FFI and OS behavior.\\n- Misconfigured `cfg` flags can change which backend is used for `get_os_rand`; link errors or runtime aborts typically indicate such misconfiguration.\\n- `G_MOCK_DETERMINISTIC_TESTS` is a global `AtomicBool` that affects `get_rand`; it is intended for tests and should not be enabled in production.\\n- Functions like `rand_add_dynamic_env` and `rand_add_static_env` may read a substantial amount of system state. They are not cheap and should be used via the seeding interfaces (`seed_startup`, `seed_periodic`) rather than directly in hot paths.\\n\\n## Integration with the rest of `bitcoin-rs`\\n\\nThis crate is designed to be used by other crates in the `bitcoin-rs` repository, sharing:\\n\\n- The `u256` type for 256\u2011bit values.\\n- Common logging macros (`log_print!`, `log_printf!`).\\n- Shared cryptographic primitives (`Sha256`, `Sha512`, `ChaCha20`, `SecureAllocator`).\\n\\nWhen using `bitcoin-random` in isolation, be aware that some items (numeric types, logging, memory allocators) come from sibling crates in the same repository.\\n\\n## License\\n\\nThis crate is licensed under the **MIT License**, consistent with the rest of the `bitcoin-rs` repository.\\n\\n## Repository\\n\\nThe source for this crate lives in:\\n\\n- GitHub: <https://github.com/klebs6/bitcoin-rs>\\n\\nThe RNG implementation here is intended to be kept structurally close to its C++ counterpart. When in doubt about behavior or security properties, consult the corresponding Bitcoin Core source files and documentation.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"network-programming\",\n      \"algorithms\",\n      \"science\",\n      \"development-tools\"\n    ],\n    \"package_description\": \"Bitcoin Core-style entropy collection and pseudo-random number generation for Rust, including OS entropy backends, x86 hardware RNG integration, a SHA-512-based DRBG, and a ChaCha20 FastRandomContext compatible with Bitcoin Core semantics.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"rng\",\n      \"entropy\",\n      \"cryptography\",\n      \"chacha20\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 20119, "completion_tokens": 5887, "total_tokens": 26006, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
