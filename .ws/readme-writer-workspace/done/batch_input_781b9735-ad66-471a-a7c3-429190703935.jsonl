{"custom_id":"bitcoin-univalue-ai-readme-request","method":"POST","url":"/v1/chat/completions","body":{"max_completion_tokens":8192,"messages":[{"content":"We would like you to write a README.md for a rust crate with maximally helpful content.\nAdditionally, we would like you to generate several fields from the Cargo.toml package section for this crate.\nWe will show you the strict json output format we would like you to provide.\nPlease tailor your response for an apex consumer of maximal intelligence.\nA reader of this README.md should have a good sense of what the crate does and how to use it after reading what you write.\nPlease include a messaage indicating that this README.md file was generated by an AI model and may not be 100% accurate however it should be pretty good.\n\n\nCarefully read and parse the information we sent you.\n\nWe want to generate all information items requested by our schema:\n\n- Read the description of each field. Use it, along with the content we sent you to generate an appropriate value for each.\n- Ensure that each generated field optimally serves its desired purpose.\n- Each item should be deep, detailed, and specific. Use optimally descriptive and useful language. Do not be too verbose.\n- Do not add any extra keys to the generated object. Generate precisely what we ask of you: no more, no less.\n- For fields which are of an enum type: pick *exactly one variant*. Do not generate any information for the unselected variants.\n- For array fields: supply a JSON list [ ... ] of items, each conforming to the correct item type.\n- For map fields: Provide a JSON object { \"key_as_string\": <value>, ... }. Keys must be valid JSON strings. Keys and Values must conform to the key and value schemas we provide to you. Fill all subfields of each and every map value.\n- If we ask you to justify a map field, provide your justification/confidence score for the entire map. Do not attempt to separately justify each map element.\n- Likewise, if we ask you to justify an array field, provide your justification/confidence score for the entire array. Do not attempt to separately justify each element.\n- Provide numeric fields as real JSON numbers (not strings).\n- For string fields: provide the value precisely as a string literal. If optional, you may set it to null.\n- If we ask you to justify or provide confidence scores for the fields of a structure, please do so carefully. For each field we ask you to justify, please explain or justify your choice clearly. Confidence scores must be specified as real JSON numbers in the range `[0..1]`.\n- If we ask to you generate an optional field, either fill it or set it to null.\n- If we ask you to justify your choice of an enum variant, please explain your choice clearly. Do not justify your decision to leave a variant unselected. Provide your justification as a JSON string. Provide your confidence score as a real JSON number in the range `[0..1]`.\n- In terms of the JSON format we would like you to provide, the object itself will be deserialied based on the following schema. \n- We begin exactly at the top: the data should not be nested under a parent named 'fields' or anything similar.\n\n## Here is the schema to use:\n\nObject {\n    \"fields\": Object {\n        \"crate_name\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be the name of our crate, *verbatim*, trimmed for use as a toml field\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"full_readme_markdown\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be valid markdown representing the readme for this crate.\\\\n\\\\n Please make it terse, useful, and designed for an industrious commercially savy consumer of industrious nature. \\\\n\\\\n Advanced vocabulary and concepts are welcome. \\\\n\\\\n If this crate involves concepts from mathematics and/or physics, please describe and document them here.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_categories\": Object {\n            \"generation_instructions\": String(\"\\\"These categories will be used in our Cargo.toml file.\\\\n\\\\n It is important that users of this crate can find it on crates.io.\\\\n\\\\n Choose maximum 5 categories and make sure they are actually meaningful for our crate.\\\\n\\\\n These categories should only be chosen from among the legal crates.io categories. \\\\n\\\\n The ONLY legal categoreis are:\\\\n\\\\n``\\\\n accessibility\\\\n aerospace\\\\n algorithms\\\\n api-bindings\\\\n asynchronous\\\\n authentication\\\\n caching\\\\n command-line-interface\\\\n command-line-utilities\\\\n compilers\\\\n compression\\\\n computer-vision\\\\n concurrency\\\\n config\\\\n cryptography\\\\n data-structures\\\\n database\\\\n database-implementations\\\\n date-and-time\\\\n development-tools\\\\n email\\\\n embedded\\\\n emulators\\\\n encoding\\\\n external-ffi-bindings\\\\n filesystem\\\\n finance\\\\n game-development\\\\n game-engines\\\\n games\\\\n graphics\\\\n gui\\\\n hardware-support\\\\n internationalization\\\\n localization\\\\n mathematics\\\\n memory-management\\\\n multimedia\\\\n network-programming\\\\n no-std\\\\n os\\\\n parser-implementations\\\\n parsing\\\\n rendering\\\\n rust-patterns\\\\n science\\\\n simulation\\\\n template-engine\\\\n text-editors\\\\n text-processing\\\\n value-formatting\\\\n virtualization\\\\n visualization\\\\n wasm\\\\n web-programming\\\\n ``\\\\n\\\\n DO NOT specify a category that is not on this list.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n        \"package_description\": Object {\n            \"generation_instructions\": String(\"\\\"We will place this package_description in our Cargo.toml file so the users of this crate\\\\n know what it does.\\\\n\\\\n The discription should be technical, clear, and useful. It should be terse.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_keywords\": Object {\n            \"generation_instructions\": String(\"\\\"These keywords will be used in our Cargo.toml file so the users of this crate can easily\\\\n find it in the package system. Keywords should be useful, varied, meaningful, and reflect\\\\n the contents of our crate. They should make it easy to find. Please provide exactly five.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n    },\n    \"struct_docs\": String(\" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\"),\n    \"struct_name\": String(\"AiReadmeWriterDesiredOutput\"),\n    \"type\": String(\"struct\"),\n}\n\n## Please keep the following in mind:\n\nEntry phrasing:\n\n- Ensure entries are concise and focused.\n- Ensure there are no vague phrases (e.g., avoid starting with \"Illustrates the something something...\"; instead, use direct details like \"The hanging green vines on the garden wall\").\n\nEnsure Clarity and Consistency:\n\n- Use clear, grammatically correct sentences.\n- Maintain a consistent tone and style throughout.\n\nEnrich Content:\n\n- Communicate additional information where appropriate to enhance depth and value.\n- If a mathematical, physical, or otherwise technical background is helpful, please provide it.\n- Ensure that the content is comprehensive and meets all requirements.\n\nFocus Language:\n\n- Use deliberate and precise language.\n- Avoid vague verbs and keep the maximally intelligent and detail oriented audience in mind. \n- We explicitly ban the words `hush`, `subtle`, `mythic`, and `aura`. Please keep your vocabulary choices rigorous.\n- Do not use modern cultural references \n- Do not generically reference ideas which do not belong in the global environment.\n\n## Present the Final JSON:\n\n- Format the output as a JSON object.\n- Include all fields properly named from the schema we sent you.\n\nEnsure Proper Formatting:\n\n- Use proper JSON syntax with keys and arrays.\n- Ensure that all entries are correctly placed in their respective places.\n\nProvide only the final JSON data as specified by the schema. \n\nDo not include any schema generation instructions, meta-fields, nested-templates (unless directly asked) or extraneous information. \n\nProvide only the populated fields and their values, conforming exactly to the required structure without embedding any intermediate annotations or placeholders.\n\nYour output should only consist of the JSON object. do *not* include a preamble or postamble to your response. \n\nWe seek to successfully parse your response directly as JSON.\n\nFor the final answer, output the result only as a valid JSON object, wrapped inside triple backticks with json immediately after the opening backticks.\nThe JSON must be parser-ready:\n– No additional text before or after the block\n– No markdown or prose outside the fenced block\n– No HTML escaping of quotes, slashes, or other characters\n– Indentation and whitespace preserved exactly as written\n– The content between the fences must be valid JSON as per RFC 8259","role":"system"},{"content":"We have a rust crate named 'bitcoin-univalue' 0.1.20. \n\nHere is the interface:\n#[repr(u32)]\npub enum ExpectBits {\n    EXP_OBJ_NAME,\n    EXP_COLON,\n    EXP_ARR_VALUE,\n    EXP_VALUE,\n    EXP_NOT_VALUE,\n}\n\n/// C‑style macros from the C++ implementation re‑expressed\n/// in Rust.  \n///  \n/// They expect a mutable `expect_mask: u32` binding to be\n/// in scope (exactly matching the C++ variable name\n/// `expectMask`).  This keeps the downstream translation of\n/// `UniValue::read` almost byte‑for‑byte.\n#[macro_export]\nmacro_rules! expect { {\n    ($expect_mask:expr,$bit:ident) => {\n        ($expect_mask & (ExpectBits::$bit as u32)) != 0\n    };\n} }\n\n\n#[macro_export]\nmacro_rules! set_expect { {\n    ($expect_mask:expr,$bit:ident) => {\n        $expect_mask |= ExpectBits::$bit as u32;\n    };\n} }\n\n\n#[macro_export]\nmacro_rules! clear_expect { {\n    ($expect_mask:expr,$bit:ident) => {\n        $expect_mask &= !(ExpectBits::$bit as u32);\n    };\n} }\n\nlazy_static!{\n    pub static ref NULL_UNI_VALUE: UniValue = UniValue::default();\n}\n\n#[derive(Setters,MutGetters,Getters,Clone,Debug)]\n#[getset(get=\"pub\",get_mut=\"pub\",set=\"pub\")]\npub struct UniValue  {\n    typ:    uni_value::VType,\n    val:    String,\n    keys:   Vec<String>,\n    values: Vec<UniValue>,\n}\n\n\n/// Filter that generates and validates UTF-8, as well as collates UTF-16\n/// surrogate pairs as specified in RFC4627.\n/// \n/// Validates UTF‑8 byte‑by‑byte and, when the input comes from JSON `\\uXXXX`\n/// escapes, additionally collates UTF‑16 surrogate pairs into a single scalar\n/// value.\n///\n/// Keep track of the following state to handle the following section of\n/// RFC4627:\n///    To escape an extended character that is not in the Basic Multilingual\n///    Plane, the character is represented as a twelve-character sequence,\n///    encoding the UTF-16 surrogate pair.  \n///    So, for example, a string containing only the G clef character (U+1D11E)\n///    may be represented as \"\\uD834\\uDD1E\".\n///  Two subsequent \\u.... may have to be replaced with one actual codepoint.\npub struct JSONUTF8StringFilter  {\n    str_:      Rc<RefCell<String>>,\n    is_valid:  bool,\n    codepoint: u32,\n    state:     u8,\n    surpair:   u32,\n}\n\n\n/// Minimal stand‑in so we can faithfully mirror the upstream\n/// C++ exception‑based API without adopting `std::error::Error`\n/// plumbing throughout the translated crate just yet.\n#[derive(Debug, Clone)]\npub struct StdException  (\n    pub String,\n);\n\n/// Immutable lookup in a JSON object.  \n/// Returns a reference to `NULL_UNI_VALUE` when the key is\n/// absent or when *obj* is not an object.\n#[instrument(level = \"trace\", skip_all)]\npub fn find_value<'a>(obj: &'a UniValue, name: &'a str) -> &'a UniValue {\n    if *obj.typ() != uni_value::VType::VOBJ {\n        return &NULL_UNI_VALUE;\n    }\n\n    for (idx, key) in obj.keys().iter().enumerate() {\n        if key == name {\n            trace!(found = true, key);\n            return &obj.values()[idx];\n        }\n    }\n\n    trace!(found = false, key = name);\n    &NULL_UNI_VALUE\n}\n\n\n/// Mutable lookup variant.  \n/// Upstream returns a *const* global when the key is missing.\n/// Re‑creating that semantics in Rust requires `unsafe` as we\n/// must coerce an immutable static to `&mut`.  The operation is\n/// gated under an `allow` so we can compile with\n/// `#![deny(invalid_reference_casting)]` elsewhere.\n#[instrument(level = \"trace\", skip_all)]\npub fn find_value_mut<'a>(obj: &'a mut UniValue, name: &'a str) -> &'a mut UniValue {\n    if *obj.typ() == uni_value::VType::VOBJ {\n        for (idx, key) in obj.keys().iter().enumerate() {\n            if key == name {\n                trace!(found = true, key);\n                return &mut obj.values_mut()[idx];\n            }\n        }\n    }\n\n    trace!(found = false, key = name);\n    // SAFETY: identical to the upstream C++ behaviour; callers\n    // that mutate the returned **null** value do so knowingly.\n    #[allow(invalid_reference_casting)]\n    unsafe {\n        &mut *(&*NULL_UNI_VALUE as *const UniValue as *mut UniValue)\n    }\n}\n\n\n/// Escape a raw string according to the\n/// Bitcoin‑Core Univalue rules (identical\n/// to RFC 7159 JSON string escaping).\n///\n/// Uses the pre‑computed `escapes` lookup\n/// table for performance.\n#[instrument(level = \"trace\", skip_all)]\npub fn json_escape(in_s: &str) -> String {\n    let mut out = String::with_capacity(in_s.len() * 2);\n\n    for &byte in in_s.as_bytes() {\n        if let Some(esc) = escapes[byte as usize] {\n            out.push_str(esc);\n        } else {\n            out.push(byte as char);\n        }\n    }\n\n    out\n}\n\n\n/// Append `pretty_indent * indent_level` space\n/// characters to `s`.\n///\n/// Used by the pretty‑printer in `UniValue::write`.\n#[instrument(level = \"trace\", skip(s))]\npub fn indent_str(pretty_indent: u32, indent_level: u32, s: &mut String) {\n    if pretty_indent == 0 || indent_level == 0 {\n        return;\n    }\n    // Calculated once to avoid re‑allocation churn.\n    let count = (pretty_indent * indent_level) as usize;\n    s.reserve(count);\n    for _ in 0..count {\n        s.push(' ');\n    }\n}\n\n\n/// Stand‑alone helper mirroring the original `gen.cpp`.  \n/// It initialises the escape lookup table and immediately\n/// writes it to *stdout*.\n///\n/// The arguments are ignored – they exist solely to keep the\n/// C++ signature intact.\n#[instrument(level = \"trace\", skip_all)]\npub fn univalue_gen_main(_argc: i32, _argv: &[*mut u8]) -> i32 {\n    init_json_escape();\n    output_escape();\n    0\n}\n\n\n/// Up‑stream C++ performs an expensive, one‑time construction of the\n/// `escapes` table.  In Rust we already ship a *const* lookup‑table in\n/// `escapes.rs`, therefore the helper becomes a cheap, idempotent\n/// no‑op.  It remains public only to satisfy the legacy interface and\n/// associated unit‑tests.\n#[instrument(level = \"trace\", skip_all)]\npub fn init_json_escape() {\n    static ONCE: Once = Once::new();\n    ONCE.call_once(|| {\n        trace!(\"init_json_escape called – nothing to do (table baked‑in)\");\n    });\n}\n\n\npub fn parse_double(x: &String, out: *mut f64) -> bool {\n    if !parse_prechecks(x) {\n        return false;\n    }\n\n    let first  = x.chars().nth(0).unwrap();\n    let second = x.chars().nth(1).unwrap();\n\n    if x.len() >= 2 && first == '0' && second == 'x' {\n\n        //  No hexadecimal floats allowed\n        return false;\n    }\n\n    let result: Result<f64,_> = x.parse::<f64>();\n\n    if out != std::ptr::null_mut() {\n\n        unsafe {\n\n            if let Ok(result) = result {\n                *out = result;\n\n            } else {\n                *out = 0.0;\n            }\n        }\n    }\n\n    result.is_ok()\n}\n\n\n#[instrument(level = \"trace\", skip_all)]\npub fn parse_int32(str_: &String, out: *mut i32) -> bool {\n    if !parse_prechecks(str_) { return false; }\n\n    match str_.parse::<i64>() {\n        Ok(n) if (i32::MIN as i64..=i32::MAX as i64).contains(&n) => {\n            unsafe { if !out.is_null() { *out = n as i32; } }\n            trace!(value = n, \"parse_int32 success\");\n            true\n        }\n        _ => {\n            trace!(\"parse_int32 failure: range or syntax error\");\n            false\n        }\n    }\n}\n\n\n#[instrument(level = \"trace\", skip_all)]\npub fn parse_int64(str_: &String, out: *mut i64) -> bool {\n    if !parse_prechecks(str_) { return false; }\n\n    match str_.parse::<i64>() {\n        Ok(n) => {\n            unsafe { if !out.is_null() { *out = n; } }\n            trace!(value = n, \"parse_int64 success\");\n            true\n        }\n        Err(e) => {\n            trace!(%e, \"parse_int64 failure\");\n            false\n        }\n    }\n}\n\n\n/// Stand‑alone generator that constructs **and returns** the complete\n/// Rust source for the escape lookup‑table.  Keeping the generator\n/// pure (it only produces a `String`) lets the unit‑tests inspect the\n/// result directly without resorting to brittle child‑process hacks.\n#[instrument(level = \"trace\", skip_all)]\npub fn generate_escapes_table() -> String {\n    /// Emit a Rust string literal with minimal escaping.\n    fn rust_quote(s: &str) -> String {\n        s.replace('\\\\', r\"\\\\\").replace('\"', r#\"\\\"\"#)\n    }\n\n    use std::fmt::Write;\n\n    let mut buf = String::new();\n\n    writeln!(\n        buf,\n        \"// Automatically generated file. Do not modify.\\n\\\n         crate::ix!();\\n\\n\\\n         /// Lookup‑table used by `json_escape()`.\\n\\\n         pub const escapes: [Option<&'static str>; 256] = [\"\n    )\n    .unwrap();\n\n    for (idx, byte) in (0u8..=255).enumerate() {\n        match escape_for_byte(byte) {\n            Some(s) => writeln!(buf, \"    Some(\\\"{}\\\"),\", rust_quote(&s)).unwrap(),\n            None    => writeln!(buf, \"    None,\").unwrap(),\n        }\n\n        // readability: blank line after every eight entries\n        if (idx + 1) % 8 == 0 {\n            writeln!(buf).unwrap();\n        }\n    }\n\n    writeln!(buf, \"];\").unwrap();\n    buf\n}\n\n\n/// Emit the escape lookup‑table to **stdout**\n/// (the legacy contract expected by `univalue_gen_main`),\n/// now implemented by delegating to `generate_escapes_table()`.\n#[instrument(level = \"trace\", skip_all)]\npub fn output_escape() {\n    use std::io::{self, Write};\n\n    let tbl = generate_escapes_table();\n    io::stdout()\n        .write_all(tbl.as_bytes())\n        .expect(\"write escapes table\");\n}\n\n\n/// Strict pre‑scan for numeric / string parsing.\n/// Rejects empty input, padding whitespace, and\n/// embedded NUL bytes (RFC 7159 §2).\n#[instrument(level = \"trace\", skip_all)]\npub fn parse_prechecks(x: &str) -> bool {\n    if x.is_empty() {\n        trace!(input = x, \"rejected: empty string\");\n        return false;\n    }\n    let first = x.as_bytes()[0] as i32;\n    let last  = x.as_bytes()[x.len() - 1] as i32;\n    if json_isspace(first) || json_isspace(last) {\n        trace!(input = x, \"rejected: padded with whitespace\");\n        return false;\n    }\n    if x.bytes().any(|b| b == 0) {\n        trace!(input = x, \"rejected: embedded NUL\");\n        return false;\n    }\n\n    trace!(input = x, \"parse_prechecks accepted\");\n    true\n}\n\n\n#[inline]\npub fn runtime_error<T: Into<String>>(msg: T) -> StdException {\n    StdException(msg.into())\n}\n\n\n#[instrument(level = \"trace\", skip_all)]\npub fn uv_type_name(t: uni_value::VType) -> *const u8 {\n    match t {\n        uni_value::VType::VNULL => b\"null\\0\".as_ptr(),\n        uni_value::VType::VBOOL => b\"bool\\0\".as_ptr(),\n        uni_value::VType::VOBJ  => b\"object\\0\".as_ptr(),\n        uni_value::VType::VARR  => b\"array\\0\".as_ptr(),\n        uni_value::VType::VSTR  => b\"string\\0\".as_ptr(),\n        uni_value::VType::VNUM  => b\"number\\0\".as_ptr(),\n    }\n}\n\nimpl UniValue {\n\n    /// Set from an `i32`.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_i32(&mut self, val: i32) -> bool {\n        self.set_int_inner(val.to_string())\n    }\n\n    /// Set from an `i64`.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_i64(&mut self, val: i64) -> bool {\n        self.set_int_inner(val.to_string())\n    }\n\n    /// Set from a `u64`.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_u64(&mut self, val: u64) -> bool {\n        self.set_int_inner(val.to_string())\n    }\n\n    /// Set to **null**.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_null(&mut self) -> bool {\n        self.clear();\n        true\n    }\n\n    /// Set to a JSON boolean.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_bool(&mut self, val: bool) -> bool {\n        self.clear();\n        self.set_typ(uni_value::VType::VBOOL);\n        self.set_val(if val { \"1\" } else { \"0\" }.to_owned());\n        true\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_int<T: Debug + std::fmt::Display>(&mut self, val: T) -> bool {\n        self.set_num_str(&val.to_string())\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_array(&mut self) -> bool {\n        self.clear();\n        self.set_typ(uni_value::VType::VARR);\n        true\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_object(&mut self) -> bool {\n        self.clear();\n        self.set_typ(uni_value::VType::VOBJ);\n        true\n    }\n\n    /// Set from a Rust string slice (JSON string).\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_str(&mut self, val: &str) -> bool {\n        self.clear();\n        self.set_typ(uni_value::VType::VSTR);\n        self.set_val(val.to_owned());\n        true\n    }\n\n    /// Set from a JSON number string *as‑is*.\n    /// Returns `false` when *val* is **not** a syntactically‑valid\n    /// JSON number (per the lexical rules in `valid_num_str`).\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_num_str(&mut self, val: &String) -> bool {\n        if !parse_prechecks(val) || !valid_num_str(val) {\n            trace!(\"rejected: invalid JSON number\");\n            return false;\n        }\n        self.clear();\n        self.set_typ(uni_value::VType::VNUM);\n        self.set_val(val.clone());\n        true\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_float(&mut self, val: f64) -> bool {\n        self.clear();\n        self.set_typ(uni_value::VType::VNUM);\n        self.set_val(Self::format_f64_canonical(val));\n        true\n    }\n}\n\nimpl UniValue {\n\n    /// Validate that **every** entry in *template* exists in `self`\n    /// **and** has the requested `VType`.\n    #[instrument(level = \"trace\", skip(self, template))]\n    pub fn check_object(&self, template: &HashMap<String, uni_value::VType>) -> bool {\n        if *self.typ() != uni_value::VType::VOBJ {\n            trace!(\"receiver not an object\");\n            return false;\n        }\n    \n        for (key, want) in template {\n            let mut idx = 0usize;\n            if !self.find_key(key, &mut idx) {\n                trace!(missing = key);\n                return false;\n            }\n            let got = self.values()[idx].get_type();\n            if got != *want {\n                trace!(key, ?got, ?want, \"type mismatch\");\n                return false;\n            }\n        }\n        true\n    }\n}\n\nimpl From<Instant> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(_val: Instant) -> Self {\n        // No canonical JSON representation for `Instant` in\n        // Bitcoin‑Core.  We model it as null (matching upstream).\n        UniValue::default()\n    }\n}\n\nimpl From<u64> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: u64) -> Self {\n        let mut uv = UniValue::default();\n        uv.set_u64(val);\n        uv\n    }\n}\n\nimpl From<usize> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: usize) -> Self {\n        let mut uv = UniValue::default();\n        uv.set_u64(val as u64);\n        uv\n    }\n}\n\nimpl From<uni_value::VType> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: uni_value::VType) -> Self {\n        UniValue::new(val, None)\n    }\n}\n\nimpl From<i64> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: i64) -> Self {\n        let mut uv = UniValue::default();\n        uv.set_i64(val);\n        uv\n    }\n}\n\nimpl From<i32> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: i32) -> Self {\n        let mut uv = UniValue::default();\n        uv.set_i32(val);\n        uv\n    }\n}\n\nimpl From<bool> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: bool) -> Self {\n        let mut uv = UniValue::default();\n        uv.set_bool(val);\n        uv\n    }\n}\n\nimpl From<&str> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: &str) -> Self {\n        let mut uv = UniValue::default();\n        uv.set_str(val);\n        uv\n    }\n}\n\nimpl From<String> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: String) -> Self {\n        let mut uv = UniValue::default();\n        uv.set_str(&val);\n        uv\n    }\n}\n\nimpl From<*const u8> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: *const u8) -> Self {\n        // SAFETY: caller promises `val` points to a valid\n        //         NUL‑terminated C string.\n        let c_str = unsafe { std::ffi::CStr::from_ptr(val as *const i8) };\n        let s     = c_str.to_string_lossy();\n        UniValue::from(s.as_ref())\n    }\n}\n\nimpl From<f64> for UniValue {\n\n    #[instrument(level = \"trace\", skip_all)]\n    fn from(val: f64) -> Self {\n        let mut uv = UniValue::default();\n        // delegates to the revised canonical formatter\n        uv.set_float(val);\n        uv\n    }\n}\n\nimpl UniValue {\n\n    /// Return **true** when this value is the\n    /// JSON literal `null`.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn is_null(&self) -> bool {\n        let result = *self.typ() == uni_value::VType::VNULL;\n        trace!(result);\n        result\n    }\n\n    /// Return **true** when this value is the\n    /// JSON boolean `true`.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn is_true(&self) -> bool {\n        let result = *self.typ() == uni_value::VType::VBOOL && *self.val() == \"1\";\n        trace!(result);\n        result\n    }\n\n    /// Return **true** when this value is the\n    /// JSON boolean `false`.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn is_false(&self) -> bool {\n        let result = *self.typ() == uni_value::VType::VBOOL && *self.val() != \"1\";\n        trace!(result);\n        result\n    }\n\n    /// Return **true** when this value is any\n    /// JSON boolean (either `true` or `false`).\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn is_bool(&self) -> bool {\n        let result = *self.typ() == uni_value::VType::VBOOL;\n        trace!(result);\n        result\n    }\n\n    /// Return **true** when this value is a\n    /// JSON string.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn is_str(&self) -> bool {\n        let result = *self.typ() == uni_value::VType::VSTR;\n        trace!(result);\n        result\n    }\n\n    /// Return **true** when this value is a\n    /// JSON number.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn is_num(&self) -> bool {\n        let result = *self.typ() == uni_value::VType::VNUM;\n        trace!(result);\n        result\n    }\n\n    /// Return **true** when this value is a\n    /// JSON array.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn is_array(&self) -> bool {\n        let result = *self.typ() == uni_value::VType::VARR;\n        trace!(result);\n        result\n    }\n\n    /// Return **true** when this value is a\n    /// JSON object.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn is_object(&self) -> bool {\n        let result = *self.typ() == uni_value::VType::VOBJ;\n        trace!(result);\n        result\n    }\n}\n\nimpl UniValue {\n\n    /// Serialise this value to JSON.  \n    /// `pretty_indent == 0` → compact, single‑line output.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn write(&self, pretty_indent: Option<u32>, indent_level: Option<u32>) -> String {\n        let pretty_indent = pretty_indent.unwrap_or(0);\n        let indent_level  = indent_level.unwrap_or(0);\n        let mod_indent    = if indent_level == 0 { 1 } else { indent_level };\n    \n        let mut s = String::with_capacity(128);\n    \n        match *self.typ() {\n            uni_value::VType::VNULL => s.push_str(\"null\"),\n            uni_value::VType::VOBJ  => self.write_object(pretty_indent, mod_indent, &mut s),\n            uni_value::VType::VARR  => self.write_array(pretty_indent, mod_indent, &mut s),\n            uni_value::VType::VSTR  => {\n                s.push('\"');\n                s.push_str(&json_escape(self.val()));\n                s.push('\"');\n            }\n            uni_value::VType::VNUM  => s.push_str(self.val()),\n            uni_value::VType::VBOOL => {\n                s.push_str(if self.val() == \"1\" { \"true\" } else { \"false\" });\n            }\n        }\n        s\n    }\n}\n\nimpl Index<&str> for UniValue {\n\n    type Output = UniValue;\n\n    #[inline]\n    fn index(&self, key: &str) -> &Self::Output {\n        if *self.typ() != uni_value::VType::VOBJ {\n            return &NULL_UNI_VALUE;\n        }\n    \n        for (idx, k) in self.keys().iter().enumerate() {\n            if k == key {\n                return &self.values()[idx];\n            }\n        }\n        &NULL_UNI_VALUE\n    }\n}\n\nimpl Index<usize> for UniValue {\n\n    type Output = UniValue;\n\n    #[inline]\n    fn index(&self, index: usize) -> &Self::Output {\n        match *self.typ() {\n            uni_value::VType::VOBJ | uni_value::VType::VARR => {\n                self.values().get(index).unwrap_or(&NULL_UNI_VALUE)\n            }\n            _ => &NULL_UNI_VALUE,\n        }\n    }\n}\n\nimpl UniValue {\n\n    /// Copy this object into a plain HashMap.  \n    /// No‑op when the receiver is not an object.\n    #[instrument(level = \"trace\", skip(self, kv))]\n    pub fn get_obj_map(&self, kv: &mut HashMap<String, UniValue>) {\n        if *self.typ() != uni_value::VType::VOBJ {\n            trace!(\"not an object – nothing to copy\");\n            return;\n        }\n    \n        kv.clear();\n        for (k, v) in self.keys().iter().zip(self.values().iter()) {\n            kv.insert(k.clone(), v.clone());\n        }\n    }\n\n    /// Lightweight accessor for the underlying type.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_type(&self) -> uni_value::VType {\n        *self.typ()\n    }\n\n    /// Returns the internal string representation *without*\n    /// validating that this is a string value.  Prefer\n    /// `get_str()` for type‑safe access.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_val_str(&self) -> &String {\n        self.val()\n    }\n\n    /// Return the object's *key* vector.\n    ///\n    /// Up‑stream throws a `std::runtime_error` when the value is not an\n    /// object; we mirror that behaviour with a plain Rust `panic!`.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_keys(&self) -> &Vec<String> {\n        if *self.typ() != uni_value::VType::VOBJ {\n            panic!(\"JSON value is not an object as expected\");\n        }\n        self.keys()\n    }\n\n    /// Return the object's/array's *value* vector.\n    ///\n    /// Panics unless the receiver is an object **or** an array –\n    /// identical contract to the original C++ implementation.\n    #[inline]\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_values(&self) -> &Vec<UniValue> {\n        match *self.typ() {\n            uni_value::VType::VOBJ | uni_value::VType::VARR => self.values(),\n            _ => panic!(\"JSON value is not an object or array as expected\"),\n        }\n    }\n\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_bool(&self) -> bool {\n        if *self.typ() != uni_value::VType::VBOOL {\n            panic!(\"JSON value is not a boolean as expected\");\n        }\n        self.is_true()\n    }\n\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_str(&self) -> &str {\n        if *self.typ() != uni_value::VType::VSTR {\n            panic!(\"JSON value is not a string as expected\");\n        }\n        self.val()\n    }\n\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_str_mut(&mut self) -> &mut str {\n        if *self.typ() != uni_value::VType::VSTR {\n            panic!(\"JSON value is not a string as expected\");\n        }\n        self.val_mut()\n    }\n\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_int(&self) -> i32 {\n        if *self.typ() != uni_value::VType::VNUM {\n            panic!(\"JSON value is not an integer as expected\");\n        }\n        i32::from_str(self.val())\n            .expect(\"JSON integer out of range\")\n    }\n\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_int64(&self) -> i64 {\n        if *self.typ() != uni_value::VType::VNUM {\n            panic!(\"JSON value is not an integer as expected\");\n        }\n        i64::from_str(self.val())\n            .expect(\"JSON integer out of range\")\n    }\n\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_real(&self) -> f64 {\n        if *self.typ() != uni_value::VType::VNUM {\n            panic!(\"JSON value is not a number as expected\");\n        }\n        f64::from_str(self.val())\n            .expect(\"JSON double out of range\")\n    }\n\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_obj(&self) -> &UniValue {\n        if *self.typ() != uni_value::VType::VOBJ {\n            panic!(\"JSON value is not an object as expected\");\n        }\n        self\n    }\n\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn get_array(&self) -> &UniValue {\n        if *self.typ() != uni_value::VType::VARR {\n            panic!(\"JSON value is not an array as expected\");\n        }\n        self\n    }\n}\n\nimpl Default for UniValue {\n\n    /// A default `UniValue` is the JSON literal **null**.\n    fn default() -> Self {\n        Self::null() \n    }\n}\n\nimpl UniValue {\n\n    pub fn null() -> Self {\n        Self {\n            typ:    uni_value::VType::VNULL,\n            val:    String::new(),\n            keys:   Vec::new(),\n            values: Vec::new(),\n        }\n    }\n\n    pub fn empty_array() -> Self {\n        Self {\n            typ:    uni_value::VType::VARR,\n            val:    String::new(),\n            keys:   Vec::new(),\n            values: Vec::new(),\n        }\n    }\n\n    /// Create a new `UniValue` with the provided type\n    /// and (optionally) initial string value.\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn new(initial_type: uni_value::VType, initial_str: Option<&str>) -> Self {\n        let mut uv = Self::default();\n        match initial_type {\n            uni_value::VType::VNULL => { /* nothing */ }\n            uni_value::VType::VBOOL => {\n                uv.set_bool(initial_str == Some(\"1\"));\n            }\n            uni_value::VType::VSTR => {\n                uv.set_str(initial_str.unwrap_or_default());\n            }\n            uni_value::VType::VNUM => {\n                uv.val = initial_str.unwrap_or_default().to_owned();\n                uv.typ = uni_value::VType::VNUM;\n            }\n            uni_value::VType::VARR => {\n                uv.typ = uni_value::VType::VARR;\n            }\n            uni_value::VType::VOBJ => {\n                uv.typ = uni_value::VType::VOBJ;\n            }\n        }\n        uv\n    }\n\n    /// Return `true` when the *values* vector is empty.\n    #[inline]\n    pub fn empty(&self) -> bool {\n        self.values.is_empty()\n    }\n\n    /// Number of child values (arrays/objects) or `0`\n    /// for scalars.\n    #[inline]\n    pub fn size(&self) -> usize {\n        self.values.len()\n    }\n\n    /// `true` if *key* exists in this object.\n    #[inline]\n    pub fn exists(&self, key: &str) -> bool {\n        let mut idx = 0usize;\n        self.find_key(key, &mut idx)\n    }\n\n    /// Shorthand for `get_type()` in the C++ original.\n    #[inline]\n    pub fn ty(&self) -> uni_value::VType {\n        *self.typ()\n    }\n\n    /// Linear search helper (same algorithm as upstream).\n    pub fn find_key(&self, key: &str, ret_idx: &mut usize) -> bool {\n        for (i, k) in self.keys.iter().enumerate() {\n            if k == key {\n                *ret_idx = i;\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Clear the current value, turning it into **null**.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn clear(&mut self) {\n        self.typ    = uni_value::VType::VNULL;\n        self.val.clear();\n        self.keys.clear();\n        self.values.clear();\n    }\n}\n\nimpl UniValue {\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn read(&mut self, raw: *const u8, size: usize) -> bool {\n        use crate::ExpectBits::{EXP_ARR_VALUE, EXP_COLON, EXP_NOT_VALUE, EXP_OBJ_NAME, EXP_VALUE};\n    \n        unsafe {\n            self.clear();\n            trace!(size, \"read – entry\");\n    \n            let mut expect_mask: u32           = 0;\n            let mut stack:       Vec<*mut Self> = Vec::new();\n            let mut token_val    = String::new();\n            let mut consumed     = 0u32;\n            let mut tok          = JTokenType::JTOK_NONE;\n            let mut last_tok     = JTokenType::JTOK_NONE;\n    \n            let mut p       = raw;\n            let     end_ptr = raw.add(size);\n    \n            while {\n                /* ---------- fetch next token ---------- */\n                last_tok = tok;\n                tok = get_json_token(&mut token_val, &mut consumed, p, end_ptr);\n                if matches!(tok, JTokenType::JTOK_NONE | JTokenType::JTOK_ERR) {\n                    trace!(?tok, \"lexer signalled error / eof\");\n                    return false;\n                }\n                p = p.add(consumed as usize);\n    \n                /* ---------- consume trailing WS / NUL padding ---------- */\n                while p < end_ptr && ((*p == 0) || json_isspace(*p as i32)) {\n                    p = p.add(1);\n                }\n    \n                /* ---------- expectation bookkeeping ---------- */\n                let is_value_open = json_token_is_value(tok)\n                    || tok == JTokenType::JTOK_OBJ_OPEN\n                    || tok == JTokenType::JTOK_ARR_OPEN;\n    \n                if expect!(expect_mask, EXP_VALUE) {\n                    trace!(?tok, \"EXP_VALUE gate\");\n                    if !is_value_open { return false; }\n                    clear_expect!(expect_mask, EXP_VALUE);\n                } else if expect!(expect_mask, EXP_ARR_VALUE) {\n                    trace!(?tok, \"EXP_ARR_VALUE gate\");\n                    let ok = is_value_open || tok == JTokenType::JTOK_ARR_CLOSE;\n                    if !ok { return false; }\n                    clear_expect!(expect_mask, EXP_ARR_VALUE);\n                } else if expect!(expect_mask, EXP_OBJ_NAME) {\n                    trace!(?tok, \"EXP_OBJ_NAME gate\");\n                    let ok = tok == JTokenType::JTOK_OBJ_CLOSE || tok == JTokenType::JTOK_STRING;\n                    if !ok { return false; }\n                } else if expect!(expect_mask, EXP_COLON) {\n                    trace!(?tok, \"EXP_COLON gate\");\n                    if tok != JTokenType::JTOK_COLON { return false; }\n                    clear_expect!(expect_mask, EXP_COLON);\n                } else if !expect!(expect_mask, EXP_COLON) && tok == JTokenType::JTOK_COLON {\n                    return false;\n                }\n    \n                if expect!(expect_mask, EXP_NOT_VALUE) {\n                    if is_value_open { return false; }\n                    clear_expect!(expect_mask, EXP_NOT_VALUE);\n                }\n    \n                /* ---------- state machine ---------- */\n                match tok {\n                    /* ~~~~~~~~~~~~~~~~~~~~ structure openers ~~~~~~~~~~~~~~~~~~~~ */\n                    JTokenType::JTOK_OBJ_OPEN | JTokenType::JTOK_ARR_OPEN => {\n                        let utyp = if tok == JTokenType::JTOK_OBJ_OPEN {\n                            uni_value::VType::VOBJ\n                        } else {\n                            uni_value::VType::VARR\n                        };\n    \n                        if stack.is_empty() {\n                            if utyp == uni_value::VType::VOBJ { self.set_object(); }\n                            else                               { self.set_array();  }\n                            stack.push(self as *mut Self);\n                        } else {\n                            let mut tmp = Self::new(utyp, None);\n                            let top = *stack.last().unwrap();\n                            (*top).values_mut().push(tmp);\n                            let new_top = (*top).values_mut().last_mut().unwrap();\n                            stack.push(new_top as *mut Self);\n                        }\n    \n                        if stack.len() > MAX_JSON_DEPTH { return false; }\n    \n                        if utyp == uni_value::VType::VOBJ {\n                            set_expect!(expect_mask, EXP_OBJ_NAME);\n                            trace!(depth = stack.len(), \"object open\");\n                        } else {\n                            set_expect!(expect_mask, EXP_ARR_VALUE);\n                            trace!(depth = stack.len(), \"array open\");\n                        }\n                    }\n    \n                    /* ~~~~~~~~~~~~~~~~~~~~ structure closers ~~~~~~~~~~~~~~~~~~~~ */\n                    JTokenType::JTOK_OBJ_CLOSE | JTokenType::JTOK_ARR_CLOSE => {\n                        if stack.is_empty() || last_tok == JTokenType::JTOK_COMMA {\n                            return false;\n                        }\n                        let utyp = if tok == JTokenType::JTOK_OBJ_CLOSE {\n                            uni_value::VType::VOBJ\n                        } else {\n                            uni_value::VType::VARR\n                        };\n                        let top = *stack.last().unwrap();\n                        if (*top).get_type() != utyp { return false; }\n                        stack.pop();\n                        clear_expect!(expect_mask, EXP_OBJ_NAME);\n                        set_expect!(expect_mask, EXP_NOT_VALUE);\n                        trace!(depth = stack.len(), \"close\");\n                    }\n    \n                    /* ~~~~~~~~~~~~~~~~~~~~ colon / comma ~~~~~~~~~~~~~~~~~~~~ */\n                    JTokenType::JTOK_COLON => {\n                        let top = match stack.last() { Some(ptr) => *ptr, None => return false };\n                        if (*top).get_type() != uni_value::VType::VOBJ { return false; }\n                        set_expect!(expect_mask, EXP_VALUE);\n                        trace!(\"colon handled – expecting value next\");\n                    }\n    \n                    JTokenType::JTOK_COMMA => {\n                        if stack.is_empty()\n                            || last_tok == JTokenType::JTOK_COMMA\n                                || last_tok == JTokenType::JTOK_ARR_OPEN\n                                { return false; }\n                        let top = *stack.last().unwrap();\n                        if (*top).get_type() == uni_value::VType::VOBJ {\n                            set_expect!(expect_mask, EXP_OBJ_NAME);\n                        } else {\n                            set_expect!(expect_mask, EXP_ARR_VALUE);\n                        }\n                        trace!(\"comma handled – updated expect_mask\");\n                    }\n    \n                    /* ~~~~~~~~~~~~~~~~~~~~ literals ~~~~~~~~~~~~~~~~~~~~ */\n                    JTokenType::JTOK_KW_NULL | JTokenType::JTOK_KW_TRUE | JTokenType::JTOK_KW_FALSE => {\n                        let mut tmp = Self::default();\n                        if tok == JTokenType::JTOK_KW_TRUE  { tmp.set_bool(true);  }\n                        if tok == JTokenType::JTOK_KW_FALSE { tmp.set_bool(false); }\n    \n                        if stack.is_empty() {\n                            *self = tmp;\n                        } else {\n                            let top = *stack.last().unwrap();\n                            (*top).values_mut().push(tmp);\n                            set_expect!(expect_mask, EXP_NOT_VALUE);\n                        }\n                        trace!(literal = ?tok, \"literal stored\");\n                    }\n    \n                    /* ~~~~~~~~~~~~~~~~~~~~ numbers ~~~~~~~~~~~~~~~~~~~~ */\n                    JTokenType::JTOK_NUMBER => {\n                        let mut tmp = Self::new(uni_value::VType::VNUM, Some(&token_val));\n                        if stack.is_empty() {\n                            *self = tmp;\n                        } else {\n                            let top = *stack.last().unwrap();\n                            (*top).values_mut().push(tmp);\n                            set_expect!(expect_mask, EXP_NOT_VALUE);\n                        }\n                        trace!(value = %token_val, \"number stored\");\n                    }\n    \n                    /* ~~~~~~~~~~~~~~~~~~~~ strings ~~~~~~~~~~~~~~~~~~~~ */\n                    JTokenType::JTOK_STRING => {\n                        if expect!(expect_mask, EXP_OBJ_NAME) {\n                            let top = *stack.last().unwrap();\n                            (*top).keys_mut().push(token_val.clone());\n                            clear_expect!(expect_mask, EXP_OBJ_NAME);\n                            set_expect!(expect_mask, EXP_COLON);\n                            trace!(key = %token_val, \"object key stored\");\n                        } else {\n                            let mut tmp = Self::new(uni_value::VType::VSTR, Some(&token_val));\n                            if stack.is_empty() {\n                                *self = tmp;\n                            } else {\n                                let top = *stack.last().unwrap();\n                                (*top).values_mut().push(tmp);\n                                set_expect!(expect_mask, EXP_NOT_VALUE);\n                            }\n                            trace!(value = %token_val, \"string value stored\");\n                        }\n                    }\n    \n                    /* ~~~~~~~~~~~~~~~~~~~~ unknown (shouldn’t happen) ~~~~~~~~~~~~~~~~~~~~ */\n                    _ => return false,\n                }\n    \n                /* continue if we’re still inside at least one open container */\n                !stack.is_empty()\n            } {} // while‑loop\n    \n            /* ---------- ensure no trailing junk ---------- */\n            let mut dummy = String::new();\n            let mut n     = 0u32;\n            if get_json_token(&mut dummy, &mut n, p, end_ptr) != JTokenType::JTOK_NONE {\n                trace!(\"trailing garbage after top‑level value\");\n                return false;\n            }\n            true\n        }\n    }\n}\n\nimpl UniValue {\n\n    /// **Bit‑for‑bit port of Bitcoin‑Core’s `FormatSaferDouble`.**\n    ///\n    /// The implementation is *driven by the 73‑case test‑suite* that ships\n    /// with Bitcoin‑Core (all of which now pass in Rust):\n    /// 1.  Build Ryu’s shortest finite form → `short`.\n    /// 2.  *Normalise `short`*  \n    ///    * Trim a trailing “`.0`” **unless** the value is&nbsp;`0.0`.  \n    ///    * If it still has **no decimal point** *or* an exponent → done.  \n    ///    * If it has **one decimal** but the value is *exactly*\n    ///      an integer × 0.10 (e.g. `‑4.9`, `2.0`) → pad “0” to obtain\n    ///      two explicit decimals (*`‑4.90`*).  \n    ///    * If it has **> 2 decimals** → done (pure Ryu case).  \n    /// 3.  For the remaining “two‑decimal” numbers build the historic\n    ///    `\"%#.17g\"` fallback (`legacy`, always 16 decimals).  \n    /// 4.  **glibc quirk emulation**  \n    ///    Flip the very last digit `0 → 1` **only when** the tweaked string\n    ///    still round‑trips *exactly* to the original IEEE‑754 value.  \n    /// These rules reproduce Bitcoin‑Core’s output for every value covered\n    /// by the upstream tests – including the notorious *± 7.21* case.\n    #[instrument(level = \"trace\", skip_all)]\n    pub fn format_f64_canonical(val: f64) -> String {\n        /* ───────── 1 / 4  Ryu candidate ───────────────────────── */\n        let mut ryu_buf = ryu::Buffer::new();\n        let mut short   = ryu_buf.format_finite(val).to_owned();\n        trace!(%short);\n    \n        /* ---- trim a useless “.0” (but *keep* it for 0.0) ---- */\n        if short.ends_with(\".0\") && val != 0.0 {\n            short.truncate(short.len() - 2);\n        }\n    \n        /* ---- exponent or pure integer → already canonical ---- */\n        if short.contains(['e', 'E']) || !short.contains('.') {\n            return short;\n        }\n    \n        /*  Count explicit decimals. */\n        let decimals = short.len() - short.find('.').unwrap() - 1;\n    \n        /* ---- one‑decimal “.x” forms ---- */\n        if decimals == 1 {\n            /*  Pad a ‘0’ when the value is an exact multiple of 0.10 so that\n             *  two‑decimal literals like  ‑4.90 round‑trip back with their\n             *  original precision (the upstream tests require this).         */\n            let v_times_100 = val * 100.0;\n            if (v_times_100 - v_times_100.round()).abs() <= f64::EPSILON {\n                short.push('0');               // e.g. ‑4.9  →  ‑4.90\n            }\n            return short;                      // Ryu path finished\n        }\n    \n        /* ---- > 2 decimals → keep Ryu untouched ---- */\n        if decimals > 2 {\n            return short;\n        }\n    \n        /* ───────── 2 / 4  legacy 17‑digit form ───────────────────────── */\n        let mut raw: [i8; 32] = [0; 32];\n        unsafe {\n            libc::snprintf(\n                raw.as_mut_ptr(),\n                raw.len(),\n                b\"%#.17g\\0\".as_ptr() as *const _,\n                val,\n            );\n        }\n        let mut legacy = unsafe { std::ffi::CStr::from_ptr(raw.as_ptr()) }\n            .to_string_lossy()\n            .into_owned();\n        trace!(candidate = %legacy);\n    \n        /* ───────── 3 / 4  glibc “…1” workaround ───────────────────────── */\n        if legacy.ends_with('0') && !legacy.contains(['e', 'E']) {\n            // Build an alternative with the last digit toggled 0→1 …\n            let mut alt_bytes = legacy.as_bytes().to_vec();\n            *alt_bytes.last_mut().unwrap() = b'1';\n            let alt = unsafe { String::from_utf8_unchecked(alt_bytes) };\n    \n            // … and keep it **only** if it still round‑trips bit‑perfectly.\n            if alt.parse::<f64>().unwrap().to_bits() == val.to_bits() {\n                trace!(adjusted = %alt, \"glibc quirk applied\");\n                legacy = alt;\n            }\n        }\n    \n        /* ───────── 4 / 4  done ─────────────────────────────────────────── */\n        legacy\n    }\n}\n\nimpl UniValue {\n\n    /// Copy every key/value pair from *obj* into `self`, **without**\n    /// deduplication.  Fails when either receiver or source is not\n    /// a JSON object (faithfully mirrors C++ `pushKVs`).\n    #[instrument(level = \"trace\", skip(self, obj))]\n    pub fn push_kvs(&mut self, obj: &UniValue) -> bool {\n        if *self.typ() != uni_value::VType::VOBJ || *obj.typ() != uni_value::VType::VOBJ {\n            trace!(\"receiver or source not an object – push_kvs rejected\");\n            return false;\n        }\n    \n        for (k, v) in obj.keys().iter().cloned().zip(obj.values().iter().cloned()) {\n            self.push_kv_raw(k, v);\n        }\n        true\n    }\n\n    /// Insert or replace *key* with *val*.\n    /// - If `self` is **not** an object → **false**  \n    /// - If *key* exists → value is **replaced**  \n    /// - Otherwise      → pair is **appended**\n    #[instrument(level = \"trace\", skip(self, val))]\n    pub fn pushkv<T: Into<UniValue>>(&mut self, key: &str, val: T) -> bool {\n        if *self.typ() != uni_value::VType::VOBJ {\n            trace!(\"receiver is not an object – pushkv rejected\");\n            return false;\n        }\n    \n        let uv_val: UniValue = val.into();\n        match self.keys().iter().position(|k| k == key) {\n            Some(idx) => {\n                trace!(action = \"replace\", key);\n                self.values_mut()[idx] = uv_val;\n            }\n            None => {\n                trace!(action = \"insert\", key);\n                self.push_kv_raw(key.to_owned(), uv_val);\n            }\n        }\n        true\n    }\n}\n\nimpl UniValue {\n\n    /// Append a single element to a JSON array.\n    /// Accepts any scalar with explicit matching. Returns false when called on non-array.\n    #[instrument(level = \"trace\", skip(self, val))]\n    pub fn push_back<T: Any>(&mut self, val: &T) -> bool {\n        if *self.typ() != uni_value::VType::VARR {\n            trace!(\"receiver is not an array – push_back rejected\");\n            return false;\n        }\n    \n        if let Some(uv) = (val as &dyn Any).downcast_ref::<UniValue>() {\n            self.values_mut().push(uv.clone());\n            return true;\n        }\n    \n        if let Some(v) = (val as &dyn Any).downcast_ref::<bool>() {\n            self.values_mut().push(UniValue::from(*v));\n            return true;\n        }\n        if let Some(v) = (val as &dyn Any).downcast_ref::<i32>() {\n            self.values_mut().push(UniValue::from(*v));\n            return true;\n        }\n        if let Some(v) = (val as &dyn Any).downcast_ref::<i64>() {\n            self.values_mut().push(UniValue::from(*v));\n            return true;\n        }\n        if let Some(v) = (val as &dyn Any).downcast_ref::<u64>() {\n            self.values_mut().push(UniValue::from(*v));\n            return true;\n        }\n        if let Some(v) = (val as &dyn Any).downcast_ref::<f64>() {\n            self.values_mut().push(UniValue::from(*v));\n            return true;\n        }\n        if let Some(v) = (val as &dyn Any).downcast_ref::<&str>() {\n            self.values_mut().push(UniValue::from(*v));\n            return true;\n        }\n        if let Some(v) = (val as &dyn Any).downcast_ref::<String>() {\n            self.values_mut().push(UniValue::from(v.clone()));\n            return true;\n        }\n    \n        trace!(\"unsupported element type for push_back\");\n        false\n    }\n\n    /// Bulk append: extend the JSON array with *vec*’s elements.\n    #[instrument(level = \"trace\", skip(self, vec))]\n    pub fn push_backv(&mut self, vec: &Vec<UniValue>) -> bool {\n        if *self.typ() != uni_value::VType::VARR {\n            trace!(\"receiver is not an array – push_backv rejected\");\n            return false;\n        }\n        self.values_mut().extend(vec.clone());\n        true\n    }\n}\n\nimpl JSONUTF8StringFilter {\n\n    /// Create a new filter writing into *target*.\n    ///\n    pub fn new(target: Rc<RefCell<String>>) -> Self {\n        Self {\n            str_: target,\n            is_valid: true,\n            codepoint: 0,\n            state: 0,\n            surpair: 0,\n        }\n    }\n\n    /// Finalise the stream – no open sequences or surrogate pairs allowed.\n    ///\n    /// Check that we're in a state where the string can be ended No open\n    /// sequences, no open surrogate pairs, etc\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn finalize(&mut self) -> bool {\n        if self.state != 0 || self.surpair != 0 {\n            self.is_valid = false;\n        }\n        self.is_valid\n    }\n\n    /// Feed a single raw byte (possibly part of a UTF‑8 multi‑byte\n    /// sequence) into the filter.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn push_back(&mut self, ch: u8) {\n        trace!(byte = ch, state = self.state, codepoint = self.codepoint);\n    \n        if self.state == 0 {\n            match ch {\n                0x00..=0x7F => self.str_.borrow_mut().push(ch as char),\n                0xC0..=0xDF => {\n                    self.codepoint = ((ch & 0x1F) as u32) << 6;\n                    self.state = 6;\n                }\n                0xE0..=0xEF => {\n                    self.codepoint = ((ch & 0x0F) as u32) << 12;\n                    self.state = 12;\n                }\n                0xF0..=0xF7 => {\n                    self.codepoint = ((ch & 0x07) as u32) << 18;\n                    self.state = 18;\n                }\n                _ => {\n                    self.is_valid = false; // stray continuation / reserved\n                    trace!(\"invalid first byte – marked as invalid\");\n                }\n            }\n        } else {\n            if (ch & 0xC0) != 0x80 {\n                self.is_valid = false;\n                trace!(\"continuation byte violates 10xxxxxx rule\");\n            }\n            self.state -= 6;\n            self.codepoint |= ((ch & 0x3F) as u32) << self.state;\n    \n            if self.state == 0 {\n                self.push_back_u(self.codepoint);\n            }\n        }\n    }\n\n    /// Inject a full UCS‑4 value (used when decoding `\\uXXXX` escapes),\n    /// handling surrogate‑pair collation and validity checks.\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn push_back_u(&mut self, cp: u32) {\n        trace!(cp, surpair = self.surpair, state = self.state);\n    \n        if self.state != 0 {\n            self.is_valid = false;\n            trace!(\"push_back_u called with open UTF‑8 sequence – invalid\");\n            return;\n        }\n    \n        match cp {\n            /* -------- high surrogate -------- */\n            0xD800..=0xDBFF => {\n                if self.surpair != 0 {\n                    self.is_valid = false; // two high surrogates in a row\n                    trace!(\"double high surrogate – invalid\");\n                } else {\n                    self.surpair = cp;\n                    trace!(\"stored high surrogate\");\n                }\n            }\n    \n            /* -------- low surrogate -------- */\n            0xDC00..=0xDFFF => {\n                if self.surpair != 0 {\n                    let full = 0x10000\n                        | ((self.surpair - 0xD800) << 10)\n                        | (cp - 0xDC00);\n                    self.append_codepoint(full);\n                    self.surpair = 0;\n                    trace!(full, \"surrogate pair combined\");\n                } else {\n                    self.is_valid = false; // low without high\n                    trace!(\"lone low surrogate – invalid\");\n                }\n            }\n    \n            /* -------- regular scalar -------- */\n            _ => {\n                if self.surpair != 0 {\n                    self.is_valid = false; // dangling high surrogate\n                    trace!(\"dangling high surrogate – invalid\");\n                } else {\n                    self.append_codepoint(cp);\n                }\n            }\n        }\n    }\n}\n\nimpl std::fmt::Display for StdException {\n\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\nimpl std::error::Error for StdException {}\n\n\nmod uni_value {\n    #[derive(Copy,PartialEq,Eq,Clone,Debug)]\n    pub enum VType {\n        VNULL,\n        VOBJ,\n        VARR,\n        VSTR,\n        VNUM,\n        VBOOL,\n    }\n}\n\n\nThis crate has the following authors:\n[\n    \"klebs <none>\",\n]\nThis crate has the following rust edition:\n2021\nThis crate has the following license:\nMIT\nThis crate is held in the following repository:\nhttps://github.com/klebs6/bitcoin-rs\n","role":"user"}],"model":"gpt-5.1"}}
