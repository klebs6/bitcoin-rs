{"id": "batch_req_692ce681191881908155a1a1c13b3512", "custom_id": "bitcoinleveldb-lru-ai-readme-request", "response": {"status_code": 200, "request_id": "7a56753ce329368e517bfdfd7f93b5c2", "body": {"id": "chatcmpl-ChmPprNB3aBvqYoujh5PoUVHyOFAx", "object": "chat.completion", "created": 1764550249, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoinleveldb-lru\",\n    \"full_readme_markdown\": \"# bitcoinleveldb-lru\\n\\nA faithful, low-level Rust port of LevelDB's sharded LRU cache implementation, as used inside the `bitcoin-rs` project. This crate exposes the internal cache primitives that back a LevelDB-compatible block cache, including sharded LRU caches, intrusive list nodes, and a custom hash table.\\n\\n> **Note**\\n> This README was generated by an AI model and may not be 100% accurate; however, it should be a close and useful description of the crate.\\n\\n---\\n\\n## Overview\\n\\n`bitcoinleveldb-lru` implements the exact cache semantics of LevelDB's C++ `ShardedLRUCache`, translated into Rust with careful attention to:\\n\\n- **Intrusive LRU lists** implemented as circular doubly linked lists of `LRUHandle` nodes.\\n- **Sharding** across a fixed number of shards (`NUM_SHARDS`) to reduce contention in multi-threaded workloads.\\n- **Custom handle table** (`HandleTable`) that acts as a compact open-hashing structure keyed by LevelDB `Slice` values.\\n- **Precise reference-counting semantics** identical to LevelDB: an entry is freed when `refs == 0` *and* `in_cache == false`.\\n- **Explicit manual memory management**, using `libc::malloc`/`free` and flexible array members that inline the key bytes adjacent to the `LRUHandle` header.\\n\\nThe design is intentionally low-level and unsafe in places, because it aims to be wire-compatible with LevelDB expectations and to interoperate with foreign code (e.g., C and C++) with minimal overhead.\\n\\nThe crate is not a general-purpose Rust cache with ergonomic types; instead, it is the *internal engine* for a LevelDB-style block cache used by higher-layer crates in the `bitcoin-rs` repository.\\n\\n---\\n\\n## Core Data Structures\\n\\n### `LRUHandle`\\n\\n`LRUHandle` represents a single cache entry. It is allocated on the heap with a flexible trailing key byte array:\\n\\n```rust\\n#[repr(C)]\\npub struct LRUHandle {\\n    value:      *mut c_void,\\n    deleter:    fn(_0: &Slice, value: *mut c_void) -> c_void,\\n    next_hash:  *mut LRUHandle,\\n    next:       *mut LRUHandle,\\n    prev:       *mut LRUHandle,\\n    charge:     usize,\\n    key_length: usize,\\n    in_cache:   bool,\\n    refs:       u32,\\n    hash:       u32,\\n    key_data:   [u8; 1],\\n}\\n```\\n\\nSemantically:\\n\\n- `key_data` stores `key_length` key bytes inline; this minimizes allocations.\\n- `next`/`prev` form a circular doubly linked list for the LRU and in-use lists.\\n- `next_hash` links handles within a hash bucket in `HandleTable`.\\n- `charge` is the logical size/weight of the entry (e.g., bytes of a block), used to constrain total cache usage.\\n- `refs` is a reference count; the cache itself holds one reference while the entry is in the cache, and clients hold additional references while they are using the entry.\\n\\nImportant invariants (matching LevelDB):\\n\\n- An entry is destroyed when `refs == 0` and `in_cache == false`.\\n- When the only remaining reference is held by the cache (`refs == 1 && in_cache == true`), the entry resides on the LRU list.\\n- When additional references exist, the entry is instead on the `in_use` list.\\n\\n### `HandleTable`\\n\\n`HandleTable` is a custom hash table over `*mut LRUHandle` values, tuned for speed and to avoid C++-porting complications:\\n\\n```rust\\n#[derive(Getters,Setters)]\\npub struct HandleTable {\\n    length: u32,\\n    elems:  u32,\\n    list:   *mut *mut LRUHandle,\\n}\\n```\\n\\n- `length` is the number of buckets, always a power of two.\\n- `elems` counts entries.\\n- `list` points to a C-style array of `length` buckets, where each bucket is a linked list via `LRUHandle::next_hash`.\\n\\nThe core operations:\\n\\n- `insert(&mut self, h: *mut LRUHandle) -> *mut LRUHandle` \u2013 insert handle, possibly replacing an existing one with the same key and hash.\\n- `lookup(&mut self, key_: &Slice, hash_: u32) -> *mut LRUHandle` \u2013 locate handle by key and precomputed hash.\\n- `remove(&mut self, key_: &Slice, hash_: u32) -> *mut LRUHandle` \u2013 detach handle from table without altering its refcount.\\n\\nThe table dynamically grows via `resize` when `elems > length`, rehashing all handles into a new bucket array. Allocation and deallocation are performed with `libc::malloc`/`free`.\\n\\n### `LRUCacheInner`\\n\\n`LRUCacheInner` contains the core state of a non-sharded LRU cache:\\n\\n```rust\\npub struct LRUCacheInner {\\n    usage:  usize,\\n    lru:    Box<LRUHandle>,\\n    in_use: Box<LRUHandle>,\\n    table:  HandleTable,\\n}\\n```\\n\\n- `usage` tracks total `charge` of all entries currently in the cache.\\n- `lru` and `in_use` are sentinel nodes that serve as list heads for the LRU and in-use lists, respectively.\\n- `table` indexes entries by `(key, hash)`.\\n\\nThe constructor `LRUCacheInner::new()` creates sentinel nodes via `LRUHandle::make_sentinel()` and links them into empty circular lists.\\n\\n### `LRUCache`\\n\\n`LRUCache` is a thread-safe, single-shard LRU cache, wrapping `LRUCacheInner` in a `Mutex` and a `RefCell`:\\n\\n```rust\\n#[derive(Getters,Setters)]\\npub struct LRUCache {\\n    capacity: usize,\\n    mutex:    RefCell<Mutex<LRUCacheInner>>,\\n}\\n```\\n\\nKey operations (per shard):\\n\\n- `insert(&mut self, key_: &Slice, hash_: u32, value: *mut c_void, charge: usize, deleter: fn(&Slice, *mut c_void) -> c_void) -> *mut CacheHandle`\\n- `lookup(&mut self, key_: &Slice, hash_: u32) -> *mut CacheHandle`\\n- `release(&mut self, handle: *mut CacheHandle)`\\n- `erase(&mut self, key_: &Slice, hash_: u32)`\\n- `prune(&mut self)` \u2013 aggressively drop all LRU entries whose `refs == 1`.\\n- `total_charge(&self) -> usize`\\n\\nThe public API follows LevelDB's `Cache` interface style:\\n\\n- `insert` returns a `CacheHandle` pointer for the client; the caller is responsible for calling `release` when done.\\n- `lookup` returns a handle with an incremented refcount, or null if not found.\\n- `release` decrements the refcount and triggers deletion if the entry is no longer cached.\\n- `erase` removes an entry from the cache; it will be freed once no client holds it.\\n\\nInternally, the helper functions `ref_inner`, `unref_inner`, `finish_erase_inner`, `lru_append_node`, and `lru_remove_node` enforce list and refcount consistency.\\n\\n### `ShardedLRUCache`\\n\\n`ShardedLRUCache` composes multiple `LRUCache` instances to reduce lock contention:\\n\\n```rust\\npub struct ShardedLRUCache {\\n    base:     Cache,\\n    shard:    [LRUCache; NUM_SHARDS],\\n    id_mutex: parking_lot::RawMutex,\\n    last_id:  u64,\\n}\\n```\\n\\n- The total capacity is divided across `NUM_SHARDS` by `per_shard = (capacity + NUM_SHARDS - 1)/NUM_SHARDS`.\\n- `hash_slice(s: &Slice) -> u32` computes a 32-bit hash (via `leveldb_hash`) and is used to derive the shard index.\\n- `shard(hash_: u32) -> u32` maps a hash to a shard index by taking the upper `NUM_SHARD_BITS` bits.\\n\\nPublic operations:\\n\\n- `new(capacity: usize) -> Self` \u2013 allocate shards and configure per-shard capacities.\\n- `insert(&mut self, key_: &Slice, value: *mut c_void, charge: usize, deleter: fn(&Slice, *mut c_void) -> c_void) -> *mut CacheHandle`\\n- `lookup(&mut self, key_: &Slice) -> *mut CacheHandle`\\n- `release(&mut self, handle: *mut CacheHandle)` \u2013 determines the shard from the handle's hash and forwards to that shard.\\n- `erase(&mut self, key_: &Slice)` \u2013 calculates hash from key and erases in the appropriate shard.\\n- `value(&mut self, handle: *mut CacheHandle) -> *mut c_void` \u2013 obtains the underlying stored pointer.\\n- `new_id(&mut self) -> u64` \u2013 monotonically increasing ID generation protected by `RawMutex`.\\n- `prune(&mut self)` \u2013 runs `prune()` on each shard.\\n- `total_charge(&self) -> usize` \u2013 aggregate `total_charge` across all shards.\\n\\nThe sharded design is crucial when this cache is used in high-concurrency database workloads, such as a Bitcoin node replaying or validating large blockchains.\\n\\n---\\n\\n## Safety and Memory Model\\n\\nThis crate heavily uses raw pointers and manual allocation. Safety is established by a set of invariants enforced through assertions and debug checks:\\n\\n- All `LRUHandle` pointers must be properly aligned (verified via `lru_debug_verify_list` and `unref_inner_list_contains`).\\n- Circular list invariants are asserted: for each node, `next.prev == node` and `prev.next == node`.\\n- `unref_inner` asserts that `refs_before > 0` before decrementing.\\n- `LRUCache::prune`, `LRUCache::drop`, and `HandleTable::resize` contain additional checks and safety breaks to avoid undefined behavior in case of corruption.\\n\\nBecause the interface exposes raw `*mut CacheHandle` and `*mut c_void`, it is intended for controlled internal usage inside `bitcoin-rs` and LevelDB-compatible infrastructure. It is not designed as an ergonomic public API for general Rust applications.\\n\\nWhen using it directly, you must:\\n\\n- Ensure that each acquired handle is released exactly once.\\n- Ensure that `value` pointers are valid for the lifetime expected by the cache, and that the provided `deleter` correctly deallocates or manages them.\\n- Treat `Slice` values as immutable while in use as keys in the cache.\\n\\n---\\n\\n## API Sketch and Usage\\n\\nThe intended high-level usage pattern closely matches LevelDB's `Cache` interface.\\n\\n### Creating a sharded cache\\n\\n```rust\\nuse bitcoinleveldb_lru::{ShardedLRUCache, new_lru_cache};\\nuse core::ffi::c_void;\\n\\n// Capacity in some logical units (often bytes)\\nlet capacity: usize = 64 * 1024 * 1024; // 64 MiB\\n\\n// High-level: construct directly\\nlet mut cache = ShardedLRUCache::new(capacity);\\n\\n// Or, for FFI-style usage: obtain a raw Cache pointer\\nlet raw_cache: *mut Cache = new_lru_cache(capacity);\\n```\\n\\n### Inserting and retrieving entries\\n\\nAssuming you have a `Slice` type compatible with LevelDB semantics and a buffer stored elsewhere:\\n\\n```rust\\nuse core::ffi::c_void;\\n\\nfn my_deleter(key: &Slice, value: *mut c_void) -> c_void {\\n    unsafe {\\n        // Example: value is a Box<u8> cast to *mut c_void\\n        let _ = Box::from_raw(value as *mut u8);\\n        core::mem::zeroed()\\n    }\\n}\\n\\n// `key` is your LevelDB-style Slice\\nlet key: Slice = ...;\\n\\n// Example value\\nlet value: *mut c_void = Box::into_raw(Box::new(42u8)) as *mut c_void;\\nlet charge: usize = 1; // cost of this entry\\n\\nlet handle = cache.insert(&key, value, charge, my_deleter);\\nassert!(!handle.is_null());\\n\\n// Later: lookup by key\\nlet handle2 = cache.lookup(&key);\\nif !handle2.is_null() {\\n    unsafe {\\n        let ptr = cache.value(handle2) as *mut u8;\\n        assert_eq!(*ptr, 42u8);\\n    }\\n\\n    // Release the lookup reference\\n    cache.release(handle2);\\n}\\n\\n// Release the original insert reference when you're done\\ncache.release(handle);\\n```\\n\\n### Erasing and pruning\\n\\n```rust\\n// Erase a specific key; entry will be freed once no client holds it\\ncache.erase(&key);\\n\\n// Manually prune all LRU entries that are only referenced by the cache\\ncache.prune();\\n\\n// Measure usage\\nlet total = cache.total_charge();\\n```\\n\\n---\\n\\n## Concurrency\\n\\n`ShardedLRUCache` is designed for concurrent access:\\n\\n- Each `LRUCache` shard owns a `Mutex<LRUCacheInner>`; operations on distinct shards can proceed in parallel.\\n- Shard selection is deterministic based on the high bits of the hash of the key (via `hash_slice` and `shard`).\\n- `new_id` uses a `parking_lot::RawMutex` to serialize ID allocation without interfering with cache operations.\\n\\nNote that the API presented here mostly uses `&mut self`; in the broader `bitcoin-rs` ecosystem, the cache is typically wrapped and shared in a way that hides mutability details while preserving correctness.\\n\\n---\\n\\n## Diagnostics and Debugging\\n\\nThe crate includes a rich set of debug utilities:\\n\\n- `lru_debug_verify_inner(inner: &mut LRUCacheInner)` \u2013 verifies structural invariants of the LRU and in-use lists.\\n- `lru_debug_verify_list(head: *mut LRUHandle, list_name: &str)` \u2013 checks pointer alignment and next/prev consistency.\\n- `unref_inner_list_contains(head: *mut LRUHandle, target: *mut LRUHandle, list_name: &str) -> bool` \u2013 linear search with alignment checks and cycle protection.\\n\\nAdditionally, many functions emit trace/debug/warn/error messages for instrumentation, which can be routed through the `log` ecosystem.\\n\\nThese facilities are useful for diagnosing subtle reference-counting or pointer errors when integrating with external code or when porting from other LevelDB variants.\\n\\n---\\n\\n## Integration Notes\\n\\n- **Repository**: This crate lives inside the `bitcoin-rs` monorepo: <https://github.com/klebs6/bitcoin-rs>\\n- **License**: MIT\\n- **Edition**: Rust 2021\\n\\nIt is primarily intended as an internal component of a LevelDB-compatible storage subsystem for Bitcoin-related applications. While it can be reused elsewhere, you should treat it as a low-level, expert-only primitive: misuse can easily produce memory unsafety.\\n\\nIf you need a safe, generic LRU cache for application-level code, consider using a different crate that exposes a high-level, type-safe API.\\n\\n---\\n\\n## Caveats\\n\\n- The public interface is pointer-centric and `unsafe`-oriented; misuse can cause undefined behavior.\\n- The semantics explicitly mirror LevelDB, including details like `charge`, double lists (`lru_` vs `in_use_`), and deletion rules.\\n- The crate assumes the existence of `Slice`, `Cache`, `CacheHandle`, `NUM_SHARDS`, `NUM_SHARD_BITS`, and `leveldb_hash`, provided elsewhere in the `bitcoin-rs` ecosystem.\\n\\nDespite these constraints, when used correctly within its intended environment, `bitcoinleveldb-lru` offers a highly efficient, production-grade LRU cache engine suitable for heavy blockchain and database workloads.\\n\",\n    \"package_categories\": [\n      \"algorithms\",\n      \"concurrency\",\n      \"data-structures\",\n      \"database\",\n      \"network-programming\"\n    ],\n    \"package_description\": \"Low-level, LevelDB-compatible sharded LRU cache engine for bitcoin-rs, implementing intrusive LRU lists, a custom hash table, and precise refcount-based eviction with manual memory management.\",\n    \"package_keywords\": [\n      \"leveldb\",\n      \"lru-cache\",\n      \"bitcoin\",\n      \"sharded-cache\",\n      \"database-cache\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 12532, "completion_tokens": 3851, "total_tokens": 16383, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
