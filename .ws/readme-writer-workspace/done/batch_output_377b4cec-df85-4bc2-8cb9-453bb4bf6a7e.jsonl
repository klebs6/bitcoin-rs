{"id": "batch_req_692cd428454c8190998eacf9d8f2f80e", "custom_id": "bitcoin-bufferedfile-ai-readme-request", "response": {"status_code": 200, "request_id": "4c284875d0c27c5c1240a959b8a1c1cb", "body": {"id": "chatcmpl-ChlC1bKiPrvSvdkNmJqYwKszfBNA1", "object": "chat.completion", "created": 1764545549, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-bufferedfile\",\n    \"full_readme_markdown\": \"# bitcoin-bufferedfile\\n\\nHigh\u2011performance, C\u2011compatible, rewindable buffered reader for `FILE*` streams, modeled on Bitcoin Core's `BufferedFile`. Provides deterministic RAII semantics, fixed\u2011capacity ring buffering, and a trait\u2011based deserialization interface suitable for consensus\u2011critical binary formats.\\n\\n> **Note**: This README was generated by an AI model. It may contain minor inaccuracies, but it aims to be a faithful and practically useful description of the crate.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-bufferedfile` exposes a low\u2011level primitive, [`BufferedFile`], that wraps a raw `*mut libc::FILE` and presents a logically linear byte stream backed by a circular buffer with a configurable rewind window.\\n\\nThis design allows you to:\\n\\n- Perform streaming reads from large files without unbounded memory growth.\\n- Rewind the stream by a bounded amount without re\u2011seeking the OS file descriptor.\\n- Precisely control error semantics: most failures are treated as logic errors and result in panics with clear diagnostics, matching the expectations of consensus validation code.\\n- Integrate with higher\u2011level, type\u2011driven deserialization logic via the [`BufferedFileReadable`] trait and the `>>` operator (via `Shr`).\\n\\nThe crate is deliberately stringent: it prefers to panic rather than silently continue on I/O failure, end\u2011of\u2011file, or logical mis\u2011use (e.g., reading past an explicit limit). This mirrors C++ Bitcoin Core semantics where such violations indicate bugs in the higher\u2011level protocol code rather than routine recoverable errors.\\n\\n---\\n\\n## Core Concepts\\n\\n### Circular buffer and rewind window\\n\\n`BufferedFile` maintains:\\n\\n- A fixed\u2011size byte buffer `vch_buf`.\\n- A **source position** `n_src_pos`: total bytes pulled from the underlying `FILE*` into the buffer.\\n- A **read position** `n_read_pos`: logical cursor indicating how many bytes have been consumed.\\n- A **rewind budget** `n_rewind`: maximum number of bytes by which reads are permitted to move backwards, implicitly enforced by the buffer size.\\n\\nThe buffer is indexed by `n_src_pos % buf_len` and `n_read_pos % buf_len`, turning it into a ring (circular) buffer. The invariant `n_src_pos - n_read_pos <= buf_len - n_rewind` ensures that the last `n_rewind` bytes are always available for rewinding without being overwritten by new data.\\n\\nThis is materially different from `BufReader`: the buffer is not merely an optimization but also encodes *how much history you may rely on*. Attempting to \\\"rewind\\\" beyond what the buffer can retain will clamp to the earliest feasible position.\\n\\n### RAII and FILE* ownership\\n\\n`BufferedFile` owns a `*mut libc::FILE` and guarantees:\\n\\n- Automatic `fclose` on `Drop` if the pointer is still non\u2011null.\\n- A safe manual close via [`fclose`](#explicitly-closing-the-file), which nulls out the pointer to preclude double close.\\n\\nThis makes it straightforward to interoperate with C APIs (including those from Bitcoin Core) that hand out raw `FILE*` handles, while still providing Rust\u2011style lifetime semantics.\\n\\n### Type\u2011driven deserialization\\n\\nThe trait:\\n\\n```rust\\npub trait BufferedFileReadable {\\n    fn read_from_buffer(stream: &mut BufferedFile, out: &mut Self);\\n}\\n```\\n\\nabstracts over *how* a type `T` should be read from a `BufferedFile`. Implementors consume bytes from the stream and populate `out`, leaving `stream` positioned *just after* the reading. The trait is intentionally minimal to allow:\\n\\n- Blanket derives in other crates for simple data structures.\\n- Hand\u2011written implementations for consensus\u2011critical or bit\u2011level encodings.\\n\\nThe crate also implements the right\u2011shift operator `>>` for ergonomic chaining:\\n\\n```rust\\nimpl<T: BufferedFileReadable> Shr<&mut T> for BufferedFile {\\n    type Output = Self;\\n\\n    fn shr(mut self, rhs: &mut T) -> Self::Output {\\n        T::read_from_buffer(&mut self, rhs);\\n        self\\n    }\\n}\\n```\\n\\nThis lets you write C++\u2011style extraction code:\\n\\n```rust\\n// pseudocode-style usage\\nbuffered_file >> &mut header >> &mut payload >> &mut trailer;\\n```\\n\\nwithout exposing the internal reading machinery in user code.\\n\\n---\\n\\n## Usage\\n\\n### Constructing a `BufferedFile`\\n\\nYou typically start from some external `FILE*` (for example, produced in FFI code or via `libc::fopen`):\\n\\n```rust\\nuse bitcoin_bufferedfile::BufferedFile;\\nuse std::ffi::CString;\\n\\nfn open_buffered(path: &str) -> BufferedFile {\\n    let c_path = CString::new(path).expect(\\\"no interior NULs\\\");\\n\\n    let mode   = CString::new(\\\"rb\\\").unwrap();\\n    let file = unsafe { libc::fopen(c_path.as_ptr(), mode.as_ptr()) };\\n    if file.is_null() {\\n        panic!(\\\"unable to open file: {path}\\\");\\n    }\\n\\n    // buffer size and rewind budget in bytes\\n    let buf_size   = 1 << 16;   // 64 KiB\\n    let rewind     = 1 << 14;   // 16 KiB of rewind\\n    let n_type     = 0;         // application-specific\\n    let n_version  = 0;         // application-specific\\n\\n    BufferedFile::new(file, buf_size, rewind, n_type, n_version)\\n}\\n```\\n\\nRequirements:\\n\\n- `n_rewind_in < n_buf_size`. Violating this will panic on construction.\\n- `file_in` must be a valid, open `FILE*`. `BufferedFile` does not perform ownership analysis; it assumes exclusive ownership for the purposes of `fclose`.\\n\\n### Reading raw bytes\\n\\nTo pull raw bytes into a caller\u2011provided buffer:\\n\\n```rust\\nlet mut bf   = open_buffered(\\\"blocks.dat\\\");\\nlet mut buf  = [0u8; 80]; // e.g., read a Bitcoin block header\\n\\n// Panics if EOF is reached before 80 bytes or if limit is exceeded\\nbf.read(buf.as_mut_ptr(), buf.len());\\n\\n// Position has advanced by 80 bytes\\nlet pos = bf.get_pos();\\nprintln!(\\\"current position: {pos}\\\");\\n```\\n\\nSemantics:\\n\\n- `read` will keep refilling the internal buffer until either `n_size` bytes have been copied or the underlying file cannot supply more (EOF or error).\\n- If the current read position + requested size exceeds `n_read_limit`, the call panics.\\n- On encountering EOF before satisfying `n_size`, the call panics with a diagnostic.\\n\\n### Rewinding and positioning\\n\\n`BufferedFile` does not expose a direct \\\"rewind by N\\\" function but allows you to set the absolute logical position, subject to the constraints of the ring buffer.\\n\\n```rust\\nlet mut bf = open_buffered(\\\"blocks.dat\\\");\\n\\n// ... perform some reads ...\\nlet checkpoint = bf.get_pos();\\n\\n// read some speculative data\\nlet mut tmp = [0u8; 16];\\nbf.read(tmp.as_mut_ptr(), tmp.len());\\n\\n// Try to return to the checkpoint\\nlet ok = bf.set_pos(checkpoint);\\nif !ok {\\n    // the requested position was outside the maintainable window\\n    // the stream has been clamped to the earliest feasible position\\n    eprintln!(\\\"checkpoint outside rewind window; position clamped\\\");\\n}\\n```\\n\\n`set_pos` behavior:\\n\\n- If `n_pos + bufsize < n_src_pos`, the position is *too far back* to be fully represented by the current buffer contents; it clamps to `n_src_pos - bufsize` and returns `false`.\\n- If `n_pos > n_src_pos`, the position is *too far forward*; it clamps to `n_src_pos` and returns `false`.\\n- Otherwise, it sets `n_read_pos = n_pos` and returns `true`.\\n\\nThis gives you a robust mechanism to implement limited backtracking parsers where the maximum rollback distance is bounded and known a priori.\\n\\n### Limiting the readable region\\n\\nYou can impose a hard upper bound on the logical read position:\\n\\n```rust\\nlet mut bf = open_buffered(\\\"blocks.dat\\\");\\n\\n// allow reading only the first 1 MiB\\nlet ok = bf.set_limit(Some(1 << 20));\\nassert!(ok);\\n\\n// remove any explicit limit\\nlet _ = bf.set_limit(None);\\n```\\n\\nProperties:\\n\\n- A limit smaller than the current read position is rejected: `set_limit` returns `false` and leaves the limit unchanged. This protects against nonsensical configurations such as retroactively forbidding already\u2011performed reads.\\n- `read` will panic if a requested read would cross the limit.\\n\\nThis is particularly useful in protocol code where a message length is read from the wire and then used to bound the subsequent parsing logic.\\n\\n### Searching for a byte\\n\\n`find_byte` scans forward until a target byte is encountered:\\n\\n```rust\\nlet mut bf = open_buffered(\\\"log.bin\\\");\\n\\n// search for newline\\nbf.find_byte(b'\\\\n');\\nlet newline_pos = bf.get_pos();\\nprintln!(\\\"found newline at {newline_pos}\\\");\\n```\\n\\nDetails:\\n\\n- The read pointer ends **on** the matching byte (i.e., `get_pos()` returns the index of `ch`).\\n- `fill` is called as needed; failures propagate as panics.\\n- If EOF is reached without finding the target byte, the function panics.\\n\\nThis provides a primitive for delimiter\u2011based framing without needing to materialize the entire preceding data.\\n\\n### EOF detection\\n\\nYou can query whether the stream is at EOF:\\n\\n```rust\\nif bf.eof() {\\n    // both the buffer is exhausted and the underlying FILE* reports EOF\\n}\\n```\\n\\n`eof()` returns `true` *only* if:\\n\\n- `n_read_pos == n_src_pos` (no buffered unread bytes), and\\n- `feof(src) != 0` (the underlying C stream is at EOF).\\n\\n---\\n\\n## Integrating `BufferedFileReadable`\\n\\nTo leverage the ergonomic `>>` operator and type\u2011driven parsing, implement `BufferedFileReadable` for your types.\\n\\n### Example: reading a fixed\u2011layout struct\\n\\nSuppose you have a simple header format:\\n\\n```rust\\n#[derive(Debug, Default)]\\nstruct Header {\\n    magic: u32,\\n    version: u32,\\n}\\n```\\n\\nYou can implement `BufferedFileReadable` manually:\\n\\n```rust\\nuse bitcoin_bufferedfile::BufferedFile;\\nuse bitcoin_bufferedfile::BufferedFileReadable;\\nuse std::mem::size_of;\\n\\nimpl BufferedFileReadable for Header {\\n    fn read_from_buffer(stream: &mut BufferedFile, out: &mut Self) {\\n        unsafe {\\n            // read magic (little-endian assumed as example)\\n            let mut buf = [0u8; size_of::<u32>()];\\n            stream.read(buf.as_mut_ptr(), buf.len());\\n            out.magic = u32::from_le_bytes(buf);\\n\\n            // read version\\n            let mut buf = [0u8; size_of::<u32>()];\\n            stream.read(buf.as_mut_ptr(), buf.len());\\n            out.version = u32::from_le_bytes(buf);\\n        }\\n    }\\n}\\n```\\n\\nNow you can consume a `Header` from a `BufferedFile` via the shift operator:\\n\\n```rust\\nuse std::ops::Shr;\\n\\nlet mut bf      = open_buffered(\\\"header.bin\\\");\\nlet mut header  = Header::default();\\n\\n// bf >> &mut header consumes bytes and leaves bf advanced\\nbf = bf.shr(&mut header);\\nprintln!(\\\"parsed header: {header:?}\\\");\\n```\\n\\nContract for `BufferedFileReadable::read_from_buffer`:\\n\\n- **Must** advance the stream to just after the consumed object.\\n- **Must not** attempt to read beyond `n_read_limit`; if it does, a panic will occur inside `read`.\\n- On encountering malformed data, it is acceptable to panic or to encode an error state into `out`, depending on higher\u2011level design. The crate itself is agnostic.\\n\\n### Relationship to Bitcoin serialization\\n\\nIn the original Bitcoin Core codebase, `CBufferedFile` is used in conjunction with `Unserialize(Stream&, T&)` free functions. This crate exposes the minimal machinery required to port that pattern into Rust:\\n\\n- `BufferedFile` as the low\u2011level `Stream`.\\n- `BufferedFileReadable::read_from_buffer` as the trait\u2011based analog of `Unserialize`.\\n- `Shr` implementation to preserve the extraction syntax idiom.\\n\\nThis makes the crate particularly suitable for projects that:\\n\\n- Reuse Bitcoin Core's on\u2011disk or on\u2011wire formats.\\n- Need behaviorally faithful reimplementations for consensus\u2011sensitive code.\\n\\n---\\n\\n## Error Model\\n\\nThe crate intentionally uses panics to signal conditions that, in the context of consensus code, are programmer errors or fatal I/O failures:\\n\\n- **Construction**: `BufferedFile::new` panics if `n_rewind_in >= n_buf_size`.\\n- **fill**: panics if `fread` returns 0 and either EOF is reached or the call fails.\\n- **read**: panics if a read attempts to cross `n_read_limit` or if EOF occurs before all requested bytes are read.\\n- **find_byte**: panics if the target byte is not found before EOF.\\n\\nAll such panics are accompanied by `tracing` diagnostics (`error`, `warn`, `trace`, `debug`), enabling you to capture structured logs in production deployments.\\n\\nIf you require a fully fallible API (returning `Result` instead of panicking), you can build a thin wrapper around `BufferedFile` that:\\n\\n- Catches panics at the FFI boundary or at top\u2011level worker threads.\\n- Encodes error causes using your project's error type.\\n\\nHowever, for environments mirroring Bitcoin Core's expectations\u2014where data corruption or I/O failures are terminal\u2014panicking is an adequate and simpler model.\\n\\n---\\n\\n## Logging and Observability\\n\\nThe crate uses the `tracing` ecosystem for diagnostics. Log statements include structured fields such as positions, limits, and buffer capacities:\\n\\n- `trace!` for high\u2011frequency events like buffer refills and reads.\\n- `debug!` for state transitions like `set_pos` and `fclose`.\\n- `warn!` for non\u2011fatal misconfigurations (e.g., invalid `set_limit` attempts).\\n- `error!` for conditions that immediately precede panics.\\n\\nTo take advantage of this, initialize a subscriber in your application, for example using `tracing-subscriber` in `main`:\\n\\n```rust\\nfn main() {\\n    use tracing_subscriber::FmtSubscriber;\\n\\n    let subscriber = FmtSubscriber::builder()\\n        .with_max_level(tracing::Level::TRACE)\\n        .finish();\\n\\n    tracing::subscriber::set_global_default(subscriber)\\n        .expect(\\\"setting tracing default failed\\\");\\n\\n    // now use bitcoin-bufferedfile APIs as usual\\n}\\n```\\n\\n---\\n\\n## Safety Considerations\\n\\n`BufferedFile` is explicitly low\u2011level and interacts with raw pointers and C APIs. The crate confines `unsafe` to its implementation, but consumers must still respect its contracts:\\n\\n- The `FILE*` passed to `BufferedFile::new` must not be used elsewhere while the `BufferedFile` exists, to avoid data races and double closes.\\n- The lifetime of the underlying file must extend across all operations on the `BufferedFile` (this is enforced in practice by RAII, given correct ownership transfer).\\n- When using `read` directly, you are responsible for ensuring that `pch` points to a valid, writable region of at least `n_size` bytes.\\n\\nIf you stay at the level of `BufferedFileReadable` implementations and slice\u2011based reading, the primary risk vectors are logical (e.g., misinterpreting on\u2011disk formats) rather than memory safety violations.\\n\\n---\\n\\n## Relationship to the `bitcoin-rs` Workspace\\n\\nThis crate lives in the [`bitcoin-rs`](https://github.com/klebs6/bitcoin-rs) repository and is designed to be used as an internal building block for a larger ecosystem of Bitcoin\u2011related crates. It focuses narrowly on faithfully replicating the semantics of Bitcoin Core's buffered file abstraction, rather than trying to provide a general\u2011purpose Rust I/O layer.\\n\\nUpstream crates in the workspace typically provide:\\n\\n- Higher\u2011level consensus and P2P message parsing.\\n- Derives and utilities that implement `BufferedFileReadable` (and related traits) for Bitcoin primitives.\\n- Ergonomic, strongly typed frontends that avoid direct exposure of `FILE*` and unsafe APIs.\\n\\nYou can, however, use `bitcoin-bufferedfile` independently in other projects that require C\u2011compatible, rewind\u2011capable buffered reading of binary data.\\n\\n---\\n\\n## License\\n\\nThis crate is distributed under the MIT license, as part of the `bitcoin-rs` repository.\\n\\nSee the repository for full license text and additional context:\\n\\n- Repository: <https://github.com/klebs6/bitcoin-rs>\\n\",\n    \"package_categories\": [\n      \"filesystem\",\n      \"network-programming\",\n      \"parser-implementations\",\n      \"parsing\",\n      \"development-tools\"\n    ],\n    \"package_description\": \"RAII wrapper around a C FILE* providing a rewindable, ring-buffered binary input stream with strict panic-on-error semantics and a trait-based deserialization interface modeled on Bitcoin Core's BufferedFile.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"bufferedfile\",\n      \"ffi\",\n      \"serialization\",\n      \"io\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 4145, "completion_tokens": 4123, "total_tokens": 8268, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
