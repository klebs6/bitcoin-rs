{"id": "batch_req_692ce3c677f48190839edfa07f46b9e0", "custom_id": "bitcoinleveldb-rand-ai-readme-request", "response": {"status_code": 200, "request_id": "cef9d6055b5897029b8ac36be6518a6d", "body": {"id": "chatcmpl-ChmEh43YvXvy8yiwTqB5Ni1HYpFnx", "object": "chat.completion", "created": 1764549559, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoinleveldb-rand\",\n    \"full_readme_markdown\": \"# bitcoinleveldb-rand\\n\\nA small, deterministic pseudo-random number generator (PRNG) that reproduces the behavior of LevelDB's historical `Random` implementation. This crate exists to make the LevelDB-compatible RNG available as an independent, well-documented Rust component.\\n\\n> Note: This README was generated by an AI model and may not be 100% accurate, but it should be a close reflection of the crate's intent and API. Always consult the source for authoritative details.\\n\\n## Motivation\\n\\nLevelDB (and derivatives) rely on a trivial but deterministic PRNG for tests and some internal randomized decisions. When re-implementing LevelDB in Rust\u2014such as in the `bitcoin-rs` project\u2014it is often desirable to:\\n\\n- Preserve bit-for-bit compatibility with the original C++ implementation.\\n- Keep the PRNG extremely small, cheap, and reproducible across platforms.\\n- Avoid pulling in a heavyweight RNG stack for internal, non-cryptographic randomness.\\n\\n`bitcoinleveldb-rand` provides that: a single-struct PRNG with LevelDB semantics.\\n\\nThis crate is **not** intended for cryptography or security-sensitive randomness. It is a simple linear congruential generator designed for reproducible test data and randomized algorithm steps where statistical quality is secondary to determinism and compatibility.\\n\\n## Core Idea: Park\u2013Miller \\\"minimal standard\\\" LCG\\n\\nThe generator is a classical **Park\u2013Miller LCG**:\\n\\n- Modulus: \\\\( M = 2^{31} - 1 = 2147483647 \\\\)\\n- State: integer `seed` in the range \\\\([1, M-1]\\\\)\\n- Recurrence: \\\\( \\\\text{seed}_{k+1} = A \\\\cdot \\\\text{seed}_k \\\\bmod M \\\\)\\n\\nwhere `A` is a fixed multiplier (matching LevelDB's choice). This recurrence produces a full-period sequence over \\\\([1, M-1]\\\\) if `seed` is not 0 or `M` and `A` is chosen correctly.\\n\\nThe implementation uses the classic Park\u2013Miller trick to avoid overflow and to compute the modulus efficiently, mirroring LevelDB's `util/random.h` exactly.\\n\\n## Crate Features\\n\\n- **Deterministic**: given the same initial seed, you get the same sequence on all platforms.\\n- **LevelDB-compatible**: the sequence is designed to match LevelDB's historical RNG.\\n- **Minimal surface area**: a single struct, a handful of methods.\\n- **Non-allocating & `no_std`-friendly** (aside from logging macros, which can be compiled out or adapted depending on your feature set).\\n- **Logging hooks**: uses `debug!`, `trace!`, and `error!`/`warn!` calls around edge cases for easier debugging in larger systems.\\n\\nAgain, this PRNG is **not cryptographically secure** and must not be used for secrets, key generation, or adversarial settings.\\n\\n## Usage\\n\\nAdd to `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoinleveldb-rand = \\\"0.1.19\\\"\\n```\\n\\n### Basic example\\n\\n```rust\\nuse bitcoinleveldb_rand::Random;\\n\\nfn main() {\\n    // Seed with an arbitrary 32-bit value. The implementation normalizes it\\n    // into the internal 31-bit domain, avoiding degenerate seeds.\\n    let mut rng = Random::new(0x1234_5678);\\n\\n    // Raw 31-bit-ish pseudo-random values\\n    let a = rng.next();\\n    let b = rng.next();\\n\\n    println!(\\\"a = {a}, b = {b}\\\");\\n}\\n```\\n\\n### Uniform integers in [0, n)\\n\\n```rust\\nuse bitcoinleveldb_rand::Random;\\n\\nfn main() {\\n    let mut rng = Random::new(1);\\n\\n    // Uniform in [0, 99]\\n    let sample = rng.uniform(100);\\n    assert!(sample < 100);\\n}\\n```\\n\\n**Important contract:**\\n\\n- `uniform(n)` requires `n > 0`. If `n <= 0`, it logs an error and returns `0`.\\n\\n### Bernoulli trial: `one_in(n)`\\n\\n```rust\\nuse bitcoinleveldb_rand::Random;\\n\\nfn main() {\\n    let mut rng = Random::new(42);\\n\\n    // ~1/10 chance of true each call\\n    if rng.one_in(10) {\\n        println!(\\\"Hit\\\");\\n    } else {\\n        println!(\\\"Miss\\\");\\n    }\\n}\\n```\\n\\nSemantics:\\n\\n- `one_in(n)` logically returns `true` with probability approximately `1/n` and `false` otherwise.\\n- It requires `n > 0`. If `n <= 0`, it logs an error and returns `false`.\\n\\nInternally it computes `next() % n == 0`.\\n\\n### Exponentially biased distribution: `skewed(max_log)`\\n\\n```rust\\nuse bitcoinleveldb_rand::Random;\\n\\nfn main() {\\n    let mut rng = Random::new(7);\\n\\n    // Exponentially biased towards small integers, but bounded above by 2^max_log - 1.\\n    let v = rng.skewed(10);\\n    assert!(v < (1u32 << 10));\\n}\\n```\\n\\nSemantics in detail:\\n\\n1. Choose `base` uniformly from `[0, effective_max_log]` where `effective_max_log = min(max_log, 30)`.\\n2. Compute `range = 1 << base`.\\n3. Draw uniformly in `[0, range-1]` by `uniform(range as i32)`.\\n\\nThus the distribution over \\\\(v\\\\) is piecewise-uniform with an **exponential bias** toward smaller values. Most draws are small; large draws become exponentially rare. This mirrors LevelDB's method for choosing skewed random sizes, e.g., for randomized tests.\\n\\nContracts and edge handling:\\n\\n- Requires `max_log >= 0`. If `max_log < 0`, it logs an error and returns `0`.\\n- For `max_log >= 31`, it logs a warning and caps the effective exponent at 30 to avoid overflow and keep `1u32 << base` well-defined on all platforms.\\n\\n### Seeding rules and degeneracy avoidance\\n\\nYou construct a `Random` as:\\n\\n```rust\\npub fn new(s: u32) -> Random\\n```\\n\\n- The raw seed `s` is first masked with the internal modulus `M = 0x7fffffff` (31 bits).\\n- If the normalized `seed` is `0` or `M`, the constructor overwrites it with `1` and logs a warning. These two pathological seeds would otherwise collapse the sequence to a fixed point (all subsequent values would be `0` or `M`).\\n\\nThis treatment preserves the full-period property of the Park\u2013Miller LCG.\\n\\n### Determinism and reproducibility\\n\\nBecause this is a pure integer-state LCG with a fixed modulus and multiplier, the sequence is entirely deterministic once the seed is set. For any given seed:\\n\\n- `Random::new(seed).next()` will always yield the same first value.\\n- The same applies to `uniform`, `one_in`, and `skewed`: their behavior depends only on the internal state transitions from `next()`.\\n\\nThis is especially useful when you want to:\\n\\n- Reproduce failures in randomized tests.\\n- Keep protocol or data structure behavior reproducible across platforms.\\n- Stay compatible with LevelDB-based test vectors.\\n\\n## API Summary\\n\\n```rust\\npub struct Random {\\n    seed: u32,\\n}\\n\\nimpl Random {\\n    /// Create a new RNG seeded from `s`.\\n    ///\\n    /// The seed is normalized to 31 bits and coerced away from the\\n    /// degenerate 0 and M states.\\n    pub fn new(s: u32) -> Self;\\n\\n    /// Advance the internal state and return the next pseudo-random `u32`.\\n    ///\\n    /// The returned value is effectively a 31-bit number in (0, M],\\n    /// matching LevelDB's intent.\\n    pub fn next(&mut self) -> u32;\\n\\n    /// Return an integer uniformly distributed in `[0, n-1]`.\\n    ///\\n    /// Requires `n > 0`. On invalid input, logs and returns `0`.\\n    pub fn uniform(&mut self, n: i32) -> u32;\\n\\n    /// Return `true` with probability approximately `1/n`.\\n    ///\\n    /// Requires `n > 0`. On invalid input, logs and returns `false`.\\n    pub fn one_in(&mut self, n: i32) -> bool;\\n\\n    /// Return an exponentially biased random value in\\n    /// `[0, 2^max_log - 1]`, heavily skewed toward smaller values.\\n    ///\\n    /// Requires `max_log >= 0`. On invalid input, logs and returns `0`.\\n    /// For `max_log >= 31`, caps the effective exponent at 30.\\n    pub fn skewed(&mut self, max_log: i32) -> u32;\\n}\\n```\\n\\n## Integration Notes\\n\\n- **Logging**: The implementation uses `log`-style macros (`debug!`, `trace!`, `warn!`, `error!`). To see diagnostic output, configure a logger in your binary or test harness (e.g., `env_logger`, `tracing`, or a custom adapter).\\n- **Std vs no_std**: The core logic itself is integer arithmetic and is amenable to `no_std` environments if logging is either disabled or redirected. Check the crate features and your target environment; if you are compiling for a constrained platform, you may want to compile with logging turned off.\\n- **Not for cryptography**: This generator is trivial to predict and invert. Do not use it for authentication tokens, keys, or anything requiring unpredictability.\\n\\n## Relationship to `bitcoin-rs`\\n\\nThis crate lives in the [`bitcoin-rs` repository](https://github.com/klebs6/bitcoin-rs) and primarily serves the LevelDB re-implementation embedded there. Extracting this RNG into its own crate allows:\\n\\n- Independent versioning and reuse.\\n- Focused documentation and tests around the RNG behavior.\\n- Reuse by other LevelDB-style projects that need the same deterministic generator.\\n\\n## License\\n\\nThis crate is distributed under the MIT license.\\n\\nSee the repository for full license text and contribution guidelines.\\n\",\n    \"package_categories\": [\n      \"algorithms\",\n      \"data-structures\",\n      \"development-tools\",\n      \"science\",\n      \"no-std\"\n    ],\n    \"package_description\": \"Deterministic LevelDB-compatible Park\u2013Miller pseudo-random number generator for tests and internal randomized decisions; small, fast, and non-cryptographic.\",\n    \"package_keywords\": [\n      \"random\",\n      \"leveldb\",\n      \"prng\",\n      \"deterministic\",\n      \"testing\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 3148, "completion_tokens": 2562, "total_tokens": 5710, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
