{"custom_id":"bitcoin-chacha-ai-readme-request","method":"POST","url":"/v1/chat/completions","body":{"max_completion_tokens":8192,"messages":[{"content":"We would like you to write a README.md for a rust crate with maximally helpful content.\nAdditionally, we would like you to generate several fields from the Cargo.toml package section for this crate.\nWe will show you the strict json output format we would like you to provide.\nPlease tailor your response for an apex consumer of maximal intelligence.\nA reader of this README.md should have a good sense of what the crate does and how to use it after reading what you write.\nPlease include a messaage indicating that this README.md file was generated by an AI model and may not be 100% accurate however it should be pretty good.\n\n\nCarefully read and parse the information we sent you.\n\nWe want to generate all information items requested by our schema:\n\n- Read the description of each field. Use it, along with the content we sent you to generate an appropriate value for each.\n- Ensure that each generated field optimally serves its desired purpose.\n- Each item should be deep, detailed, and specific. Use optimally descriptive and useful language. Do not be too verbose.\n- Do not add any extra keys to the generated object. Generate precisely what we ask of you: no more, no less.\n- For fields which are of an enum type: pick *exactly one variant*. Do not generate any information for the unselected variants.\n- For array fields: supply a JSON list [ ... ] of items, each conforming to the correct item type.\n- For map fields: Provide a JSON object { \"key_as_string\": <value>, ... }. Keys must be valid JSON strings. Keys and Values must conform to the key and value schemas we provide to you. Fill all subfields of each and every map value.\n- If we ask you to justify a map field, provide your justification/confidence score for the entire map. Do not attempt to separately justify each map element.\n- Likewise, if we ask you to justify an array field, provide your justification/confidence score for the entire array. Do not attempt to separately justify each element.\n- Provide numeric fields as real JSON numbers (not strings).\n- For string fields: provide the value precisely as a string literal. If optional, you may set it to null.\n- If we ask you to justify or provide confidence scores for the fields of a structure, please do so carefully. For each field we ask you to justify, please explain or justify your choice clearly. Confidence scores must be specified as real JSON numbers in the range `[0..1]`.\n- If we ask to you generate an optional field, either fill it or set it to null.\n- If we ask you to justify your choice of an enum variant, please explain your choice clearly. Do not justify your decision to leave a variant unselected. Provide your justification as a JSON string. Provide your confidence score as a real JSON number in the range `[0..1]`.\n- In terms of the JSON format we would like you to provide, the object itself will be deserialied based on the following schema. \n- We begin exactly at the top: the data should not be nested under a parent named 'fields' or anything similar.\n\n## Here is the schema to use:\n\nObject {\n    \"fields\": Object {\n        \"crate_name\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be the name of our crate, *verbatim*, trimmed for use as a toml field\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"full_readme_markdown\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be valid markdown representing the readme for this crate.\\\\n\\\\n Please make it terse, useful, and designed for an industrious commercially savy consumer of industrious nature. \\\\n\\\\n Advanced vocabulary and concepts are welcome. \\\\n\\\\n If this crate involves concepts from mathematics and/or physics, please describe and document them here.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_categories\": Object {\n            \"generation_instructions\": String(\"\\\"These categories will be used in our Cargo.toml file.\\\\n\\\\n It is important that users of this crate can find it on crates.io.\\\\n\\\\n Choose maximum 5 categories and make sure they are actually meaningful for our crate.\\\\n\\\\n These categories should only be chosen from among the legal crates.io categories. \\\\n\\\\n The ONLY legal categoreis are:\\\\n\\\\n``\\\\n accessibility\\\\n aerospace\\\\n algorithms\\\\n api-bindings\\\\n asynchronous\\\\n authentication\\\\n caching\\\\n command-line-interface\\\\n command-line-utilities\\\\n compilers\\\\n compression\\\\n computer-vision\\\\n concurrency\\\\n config\\\\n cryptography\\\\n data-structures\\\\n database\\\\n database-implementations\\\\n date-and-time\\\\n development-tools\\\\n email\\\\n embedded\\\\n emulators\\\\n encoding\\\\n external-ffi-bindings\\\\n filesystem\\\\n finance\\\\n game-development\\\\n game-engines\\\\n games\\\\n graphics\\\\n gui\\\\n hardware-support\\\\n internationalization\\\\n localization\\\\n mathematics\\\\n memory-management\\\\n multimedia\\\\n network-programming\\\\n no-std\\\\n os\\\\n parser-implementations\\\\n parsing\\\\n rendering\\\\n rust-patterns\\\\n science\\\\n simulation\\\\n template-engine\\\\n text-editors\\\\n text-processing\\\\n value-formatting\\\\n virtualization\\\\n visualization\\\\n wasm\\\\n web-programming\\\\n ``\\\\n\\\\n DO NOT specify a category that is not on this list.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n        \"package_description\": Object {\n            \"generation_instructions\": String(\"\\\"We will place this package_description in our Cargo.toml file so the users of this crate\\\\n know what it does.\\\\n\\\\n The discription should be technical, clear, and useful. It should be terse.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_keywords\": Object {\n            \"generation_instructions\": String(\"\\\"These keywords will be used in our Cargo.toml file so the users of this crate can easily\\\\n find it in the package system. Keywords should be useful, varied, meaningful, and reflect\\\\n the contents of our crate. They should make it easy to find. Please provide exactly five.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n    },\n    \"struct_docs\": String(\" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\"),\n    \"struct_name\": String(\"AiReadmeWriterDesiredOutput\"),\n    \"type\": String(\"struct\"),\n}\n\n## Please keep the following in mind:\n\nEntry phrasing:\n\n- Ensure entries are concise and focused.\n- Ensure there are no vague phrases (e.g., avoid starting with \"Illustrates the something something...\"; instead, use direct details like \"The hanging green vines on the garden wall\").\n\nEnsure Clarity and Consistency:\n\n- Use clear, grammatically correct sentences.\n- Maintain a consistent tone and style throughout.\n\nEnrich Content:\n\n- Communicate additional information where appropriate to enhance depth and value.\n- If a mathematical, physical, or otherwise technical background is helpful, please provide it.\n- Ensure that the content is comprehensive and meets all requirements.\n\nFocus Language:\n\n- Use deliberate and precise language.\n- Avoid vague verbs and keep the maximally intelligent and detail oriented audience in mind. \n- We explicitly ban the words `hush`, `subtle`, `mythic`, and `aura`. Please keep your vocabulary choices rigorous.\n- Do not use modern cultural references \n- Do not generically reference ideas which do not belong in the global environment.\n\n## Present the Final JSON:\n\n- Format the output as a JSON object.\n- Include all fields properly named from the schema we sent you.\n\nEnsure Proper Formatting:\n\n- Use proper JSON syntax with keys and arrays.\n- Ensure that all entries are correctly placed in their respective places.\n\nProvide only the final JSON data as specified by the schema. \n\nDo not include any schema generation instructions, meta-fields, nested-templates (unless directly asked) or extraneous information. \n\nProvide only the populated fields and their values, conforming exactly to the required structure without embedding any intermediate annotations or placeholders.\n\nYour output should only consist of the JSON object. do *not* include a preamble or postamble to your response. \n\nWe seek to successfully parse your response directly as JSON.\n\nFor the final answer, output the result only as a valid JSON object, wrapped inside triple backticks with json immediately after the opening backticks.\nThe JSON must be parser-ready:\n– No additional text before or after the block\n– No markdown or prose outside the fenced block\n– No HTML escaping of quotes, slashes, or other characters\n– Indentation and whitespace preserved exactly as written\n– The content between the fences must be valid JSON as per RFC 8259","role":"system"},{"content":"We have a rust crate named 'bitcoin-chacha' 0.1.19. \n\nHere is the interface:\n/**\n| Based on the public domain implementation\n| 'merged' by D. J. Bernstein See\n| https://cr.yp.to/chacha.html.\n*/\n#[macro_export]\nmacro_rules! quarterround { {\n    ($a:expr, $b:expr, $c:expr, $d:expr) => {{\n        $a = $a.wrapping_add($b); $d ^= $a; $d = rotl32($d, 16);\n        $c = $c.wrapping_add($d); $b ^= $c; $b = rotl32($b, 12);\n        $a = $a.wrapping_add($b); $d ^= $a; $d = rotl32($d,  8);\n        $c = $c.wrapping_add($d); $b ^= $c; $b = rotl32($b,  7);\n    }};\n} }\n\n/// A AEAD class for ChaCha20-Poly1305@bitcoin.\n/// \n/// ChaCha20 is a stream cipher designed by Daniel Bernstein and described in\n/// <ref>[https://cr.yp.to/chacha/chacha-20080128.pdf ChaCha20]</ref>.\n/// It operates by permuting 128 fixed bits,\n/// 128 or 256 bits of key, a 64 bit nonce and a 64 bit counter into 64 bytes of\n/// output.\n/// This output is used as a keystream, with any unused bytes simply discarded.\n/// Poly1305 <ref>[https://cr.yp.to/mac/poly1305-20050329.pdf Poly1305]</ref>,\n/// also by Daniel Bernstein, is a one-time Carter-Wegman MAC that computes\n/// a 128 bit integrity tag given a message and a single-use 256 bit secret key.\n/// The chacha20-poly1305@bitcoin combines these two primitives into an\n/// authenticated encryption mode.\n/// The construction used is based on that proposed for TLS by Adam Langley in\n/// <ref>[http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03 \"ChaCha20\n/// and Poly1305 based Cipher Suites for TLS\", Adam Langley]</ref>, but differs\n/// in the layout of data passed to the MAC and in the addition of encryption of\n/// the packet lengths. \n///\n/// ==== Detailed Construction ====\n/// The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material\n/// as output from the key exchange.\n/// Each key (K_1 and K_2) are used by two separate instances of chacha20.\n/// The instance keyed by K_1 is a stream cipher that is used only to encrypt\n/// the\n/// 3 byte packet length field and has its own sequence number.\n/// The second instance, keyed by K_2, is used in conjunction with poly1305 to\n/// build an AEAD (Authenticated Encryption with Associated Data) that is used\n/// to encrypt and authenticate the entire packet.\n/// Two separate cipher instances are used here so as to keep the packet lengths\n/// confidential but not create an oracle for the packet payload cipher by\n/// decrypting and using the packet length prior to checking the MAC.\n/// By using an independently-keyed cipher instance to encrypt the length, an\n/// active attacker seeking to exploit the packet input handling as a decryption\n/// oracle can learn nothing about the payload contents or its MAC (assuming key\n/// derivation,\n/// ChaCha20 and Poly1305 are secure).\n/// The AEAD is constructed as follows: for each packet, generate a Poly1305 key\n/// by taking the first 256 bits of ChaCha20 stream output generated using K_2,\n/// an IV consisting of the packet sequence number encoded as an LE uint64 and\n/// a ChaCha20 block counter of zero.\n/// The K_2 ChaCha20 block counter is then set to the little-endian encoding of\n/// 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used for encryption\n/// of the packet payload. \n/// ==== Packet Handling ====\n/// When receiving a packet, the length must be decrypted first. When 3 bytes of\n/// ciphertext length have been received, they may be decrypted.\n/// A ChaCha20 round always calculates 64bytes which is sufficient to crypt\n/// 21 times a 3 bytes length field (21*3 = 63). The length field sequence\n/// number can thus be used 21 times (keystream caching).\n/// The length field must be enc-/decrypted with the ChaCha20 keystream keyed\n/// with\n/// K_1 defined by block counter 0, the length field sequence number in little\n/// endian and a keystream position from 0 to 60.\n/// Once the entire packet has been received, the MAC MUST be checked before\n/// decryption.\n/// A per-packet Poly1305 key is generated as described above and the MAC tag\n/// calculated using Poly1305 with this key over the ciphertext of the packet\n/// length and the payload together.\n/// The calculated MAC is then compared in constant time with the one appended\n/// to the packet and the packet decrypted using ChaCha20 as described above\n/// (with K_2, the packet sequence number as nonce and a starting block counter\n/// of 1).\n/// Detection of an invalid MAC MUST lead to immediate connection termination.\n/// To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n/// described above.\n/// Encrypt the packet payload (using K_2) and append it to the encrypted\n/// length. Finally, calculate a MAC tag and append it.\n/// The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages\n/// on the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt\n/// messages on the receive channel.\n/// The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages\n/// on the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt\n/// messages on the send channel.\n/// Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast\n/// in general, therefore it is very likely that encrypted messages require not\n/// more\n/// CPU cycles per bytes then the current unencrypted p2p message format\n/// (ChaCha20/Poly1305 versus double SHA256).\n/// The initial packet sequence numbers are 0.\n/// K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n/// encryption nor may it be used to encrypt more than 2^70 bytes under the same\n/// {key, nonce}.\n/// K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key,\n/// nonce, position-in-keystream} for encryption nor may it be used to encrypt\n/// more than 2^70 bytes under the same {key, nonce}.\n/// We use message sequence numbers for both communication directions.\n#[derive(MutGetters,Debug,Getters)]\n#[getset(get=\"pub\",get_mut=\"pub\")]\npub struct ChaCha20Poly1305AEAD  {\n    chacha_header:        ChaCha20,\n    chacha_main:          ChaCha20,\n    aad_keystream_buffer: [u8; CHACHA20_ROUND_OUTPUT],\n    cached_aad_seqnr:     u64,\n}\n\n\n/**\n| A class for ChaCha20 256-bit stream\n| cipher developed by Daniel J. Bernstein\n| https://cr.yp.to/chacha/chacha-20080128.pdf\n|\n*/\n#[derive(Clone,MutGetters,Debug,Getters)]\n#[getset(get=\"pub\",get_mut=\"pub\")]\npub struct ChaCha20  {\n    input: [u32; 16],\n}\n\n#[inline]\npub fn rotl32(v: u32, c: i32) -> u32 {\n    v.rotate_left(c as u32)\n}\n\n\n/// Constant‑time byte‑wise comparison (returns 0 for equality, 1 otherwise).\n#[cfg(not(HAVE_TIMINGSAFE_BCMP))]\npub fn timingsafe_bcmp(b1: *const u8, b2: *const u8, n: usize) -> i32 {\n    trace!(len = n, \"timingsafe_bcmp\");\n    if n == 0 {\n        return 0;\n    }\n\n    // SAFETY: caller guarantees both pointers are valid for `n` bytes.\n    let a = unsafe { core::slice::from_raw_parts(b1, n) };\n    let b = unsafe { core::slice::from_raw_parts(b2, n) };\n\n    let mut diff: u8 = 0;\n    for i in 0..n {\n        diff |= a[i] ^ b[i];\n    }\n    (diff != 0) as i32\n}\n\n\n/// Compute a Poly1305 tag for `msg` using the supplied 256‑bit `key`.\n///\n/// This version delegates the entire MAC calculation to the\n/// **constant‑time, RFC 7539‑compatible** `bitcoin_poly1305::poly1305_auth`\n/// routine, eliminating the duplicate high‑bit/padding mistakes that\n/// previously produced incorrect tags.\n/// # Parameters\n/// * `key` – 32‑byte (256‑bit) one‑time key.\n/// * `msg` – The message to authenticate (any length).\n/// # Returns\n/// A `GenericArray<u8, U16>` containing the 16‑byte authentication tag.\n/// # Tracing\n/// Emits a `trace!` event recording the message length.\npub fn compute_poly1305_tag(key: &[u8; POLY1305_KEYLEN], msg: &[u8]) -> GenericArray<u8, U16> {\n    trace!(msg_len = msg.len(), \"compute_poly1305_tag\");\n    let mut tag = [0u8; POLY1305_TAGLEN];\n    poly1305_auth(&mut tag, msg, key);\n    GenericArray::clone_from_slice(&tag)\n}\n\nimpl ChaCha20Poly1305AEAD {\n\n    /// Encrypts/decrypts a packet\n    /// \n    /// -seqnr_payload, the message sequence number\n    /// -seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n    /// -aad_pos, position to use in the AAD keystream to encrypt the AAD\n    /// -dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN\n    /// + payload (+ POLY1305_TAG_LEN in encryption) bytes\n    /// -destlen, length of the destination buffer\n    /// -src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n    /// -src_len, the length of the source buffer\n    /// -is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying\n    /// it)\n    #[allow(clippy::too_many_arguments)]\n    pub fn crypt(\n        &mut self,\n        seqnr_payload: u64,\n        seqnr_aad:     u64,\n        aad_pos:       i32,\n        dest:          *mut u8,\n        dest_len:      usize,\n        src:           *const u8,\n        mut src_len:   usize,\n        is_encrypt:    bool\n    ) -> bool\n    {\n        debug!(\n            seqnr_payload,\n            seqnr_aad,\n            aad_pos,\n            src_len,\n            dest_len,\n            is_encrypt,\n            \"ChaCha20Poly1305AEAD::crypt\"\n        );\n    \n        /* ---------- 1. bounds checks ---------- */\n        let need = CHACHA20_POLY1305_AEAD_AAD_LEN;\n        if (is_encrypt && (src_len < need || dest_len < src_len + POLY1305_TAGLEN))\n            || (!is_encrypt\n                && (src_len < need + POLY1305_TAGLEN\n                    || dest_len < src_len - POLY1305_TAGLEN))\n        {\n            return false;\n        }\n    \n        unsafe {\n            let src_slice = core::slice::from_raw_parts(src, src_len);\n            let dest_slice =\n                core::slice::from_raw_parts_mut(dest, dest_len);\n    \n            /* ---------- 2. derive per‑packet Poly1305 key ---------- */\n            let mut poly_key = [0u8; POLY1305_KEYLEN];\n            self.chacha_main_mut().setiv(seqnr_payload);\n            self.chacha_main_mut().seek(0);\n            self.chacha_main_mut()\n                .keystream(poly_key.as_mut_ptr(), POLY1305_KEYLEN);\n    \n            /* ---------- 3. verify tag when decrypting ---------- */\n            if !is_encrypt {\n                let tag_offset = src_len - POLY1305_TAGLEN;\n                let provided_tag_ptr = src.add(tag_offset);\n    \n                let calc_tag =\n                    compute_poly1305_tag(&poly_key, &src_slice[..tag_offset]);\n    \n                if timingsafe_bcmp(\n                    calc_tag.as_ptr(),\n                    provided_tag_ptr,\n                    POLY1305_TAGLEN,\n                ) != 0\n                {\n                    poly_key.zeroize();\n                    return false;\n                }\n    \n                // exclude MAC from subsequent processing\n                src_len -= POLY1305_TAGLEN;\n            }\n    \n            /* ---------- 4. AAD keystream cache ---------- */\n            if *self.cached_aad_seqnr() != seqnr_aad {\n                *self.cached_aad_seqnr_mut() = seqnr_aad;\n    \n                // obtain raw pointer before borrowing `chacha_header`\n                let buf_ptr = self.aad_keystream_buffer_mut().as_mut_ptr();\n    \n                {\n                    let hdr = self.chacha_header_mut();\n                    hdr.setiv(seqnr_aad);\n                    hdr.seek(0);\n                    hdr.keystream(buf_ptr, CHACHA20_ROUND_OUTPUT);\n                }\n            }\n    \n            /* ---------- 5. crypt AAD (3 bytes) ---------- */\n            for i in 0..CHACHA20_POLY1305_AEAD_AAD_LEN {\n                dest_slice[i] =\n                    src_slice[i]\n                        ^ self.aad_keystream_buffer()\n                            [(aad_pos as usize) + i];\n            }\n    \n            /* ---------- 6. crypt payload ---------- */\n            self.chacha_main_mut().seek(1);\n            self.chacha_main_mut().crypt(\n                src.add(CHACHA20_POLY1305_AEAD_AAD_LEN),\n                dest.add(CHACHA20_POLY1305_AEAD_AAD_LEN),\n                src_len - CHACHA20_POLY1305_AEAD_AAD_LEN,\n            );\n    \n            /* ---------- 7. append tag when encrypting ---------- */\n            if is_encrypt {\n                let tag =\n                    compute_poly1305_tag(&poly_key, &dest_slice[..src_len]);\n                dest_slice[src_len..src_len + POLY1305_TAGLEN]\n                    .copy_from_slice(tag.as_slice());\n            }\n    \n            /* ---------- 8. cleanse key material ---------- */\n            poly_key.zeroize();\n            memory_cleanse(\n                poly_key.as_mut_ptr() as *mut c_void,\n                poly_key.len(),\n            );\n        }\n    \n        true\n    }\n}\n\nimpl ChaCha20Poly1305AEAD {\n\n    /**\n    | decrypt the 3‑byte AAD length field\n    | into `len24_out`\n    */\n    pub fn get_length(\n        &mut self,\n        len24_out:  *mut u32,\n        seqnr_aad:  u64,\n        aad_pos:    i32,\n        ciphertext: *const u8\n    ) -> bool\n    {\n        trace!(seqnr_aad, aad_pos, \"ChaCha20Poly1305AEAD::get_length\");\n    \n        assert!(\n            aad_pos >= 0\n                && (aad_pos as usize)\n                    < CHACHA20_ROUND_OUTPUT - CHACHA20_POLY1305_AEAD_AAD_LEN\n        );\n    \n        if *self.cached_aad_seqnr() != seqnr_aad {\n            *self.cached_aad_seqnr_mut() = seqnr_aad;\n    \n            // obtain raw pointer before borrowing header\n            let buf_ptr = self.aad_keystream_buffer_mut().as_mut_ptr();\n    \n            {\n                let hdr = self.chacha_header_mut();\n                hdr.setiv(seqnr_aad);\n                hdr.seek(0);\n                hdr.keystream(buf_ptr, CHACHA20_ROUND_OUTPUT);\n            }\n        }\n    \n        unsafe {\n            let c = core::slice::from_raw_parts(\n                ciphertext,\n                CHACHA20_POLY1305_AEAD_AAD_LEN,\n            );\n    \n            let out = (c[0] ^ self.aad_keystream_buffer()[aad_pos as usize + 0]) as u32\n                | ((c[1] ^ self.aad_keystream_buffer()[aad_pos as usize + 1]) as u32) << 8\n                | ((c[2] ^ self.aad_keystream_buffer()[aad_pos as usize + 2]) as u32) << 16;\n    \n            std::ptr::write(len24_out, out);\n        }\n    \n        true\n    }\n}\n\nimpl ChaCha20 {\n\n    /**\n    | outputs the keystream of size `bytes` into `c`\n    */\n    pub fn keystream(&mut self, mut c: *mut u8, mut bytes: usize) {\n        // copy the current input (j*) so that we can keep track of the counter\n        let mut state = self.input().clone();\n        let mut tmp   = [0u8; 64];\n    \n        unsafe {\n            while bytes != 0 {\n                // decide where this 64‑byte chunk will be written\n                let (out_ptr, ctarget) = if bytes < 64 {\n                    (tmp.as_mut_ptr(), Some(c))\n                } else {\n                    (c, None)\n                };\n    \n                // working variables\n                let mut x = state;\n    \n                // 20 ChaCha rounds (10 × double‑round)\n                for _ in 0..10 {\n                    quarterround!(x[0], x[4],  x[8],  x[12]);\n                    quarterround!(x[1], x[5],  x[9],  x[13]);\n                    quarterround!(x[2], x[6],  x[10], x[14]);\n                    quarterround!(x[3], x[7],  x[11], x[15]);\n    \n                    quarterround!(x[0], x[5],  x[10], x[15]);\n                    quarterround!(x[1], x[6],  x[11], x[12]);\n                    quarterround!(x[2], x[7],  x[8],  x[13]);\n                    quarterround!(x[3], x[4],  x[9],  x[14]);\n                }\n    \n                // add the original state\n                for i in 0..16 {\n                    x[i] = x[i].wrapping_add(state[i]);\n                }\n    \n                // serialize little‑endian words\n                for (i, chunk) in (0..64).step_by(4).enumerate() {\n                    write_le32(\n                        core::slice::from_raw_parts_mut(out_ptr.add(chunk), 4),\n                        x[i].into(),\n                    );\n                }\n    \n                // increment 64‑byte counter\n                state[12] = state[12].wrapping_add(1);\n                if state[12] == 0 {\n                    state[13] = state[13].wrapping_add(1);\n                }\n    \n                // copy partial block if necessary\n                if let Some(dst) = ctarget {\n                    core::ptr::copy_nonoverlapping(tmp.as_ptr(), dst, bytes);\n                    self.input_mut()[12] = state[12];\n                    self.input_mut()[13] = state[13];\n                    return;\n                }\n    \n                bytes -= 64;\n                c = c.add(64);\n            }\n        }\n    \n        self.input_mut()[12] = state[12];\n        self.input_mut()[13] = state[13];\n    }\n}\n\nimpl ChaCha20Poly1305AEAD {\n\n    pub fn new(\n        k_1:     *const u8,\n        k_1_len: usize,\n        k_2:     *const u8,\n        k_2_len: usize\n    ) -> Self\n    {\n        trace!(\"ChaCha20Poly1305AEAD::new\");\n        assert_eq!(\n            k_1_len, CHACHA20_POLY1305_AEAD_KEY_LEN,\n            \"K₁ must be 256 bits\"\n        );\n        assert_eq!(\n            k_2_len, CHACHA20_POLY1305_AEAD_KEY_LEN,\n            \"K₂ must be 256 bits\"\n        );\n    \n        let mut chacha_header = ChaCha20::default();\n        chacha_header.set_key(k_1, k_1_len);\n    \n        let mut chacha_main = ChaCha20::default();\n        chacha_main.set_key(k_2, k_2_len);\n    \n        Self {\n            chacha_header,\n            chacha_main,\n            aad_keystream_buffer: [0u8; CHACHA20_ROUND_OUTPUT],\n    \n            // set the cached sequence number to uint64 max which hints for an unset cache.\n            // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n            cached_aad_seqnr: u64::MAX,\n        }\n    }\n}\n\nimpl ChaCha20 {\n\n    /// Set key with flexible key‑length (128‑ or 256‑bit; 256 bit recommended)\n    pub fn set_key(&mut self, k: *const u8, keylen: usize) {\n        debug!(keylen, \"ChaCha20::set_key\");\n        assert!(\n            keylen == 16 || keylen == 32,\n            \"ChaCha20 key must be 128 or 256 bits\"\n        );\n    \n        // SAFETY: caller guarantees `k` is valid for `keylen` bytes.\n        let key = unsafe { core::slice::from_raw_parts(k, keylen) };\n        let (constants, k_tail) = if keylen == 32 {\n            (crate::chacha20::SIGMA_BYTES, &key[16..])\n        } else {\n            (crate::chacha20::TAU_BYTES, key)\n        };\n    \n        self.input_mut()[4]  = read_le32(&key[0..]);\n        self.input_mut()[5]  = read_le32(&key[4..]);\n        self.input_mut()[6]  = read_le32(&key[8..]);\n        self.input_mut()[7]  = read_le32(&key[12..]);\n        self.input_mut()[8]  = read_le32(&k_tail[0..]);\n        self.input_mut()[9]  = read_le32(&k_tail[4..]);\n        self.input_mut()[10] = read_le32(&k_tail[8..]);\n        self.input_mut()[11] = read_le32(&k_tail[12..]);\n    \n        self.input_mut()[0] = read_le32(&constants[0..]);\n        self.input_mut()[1] = read_le32(&constants[4..]);\n        self.input_mut()[2] = read_le32(&constants[8..]);\n        self.input_mut()[3] = read_le32(&constants[12..]);\n    \n        self.input_mut()[12] = 0;\n        self.input_mut()[13] = 0;\n        self.input_mut()[14] = 0;\n        self.input_mut()[15] = 0;\n    }\n}\n\nimpl Default for ChaCha20 {\n\n    fn default() -> Self {\n        trace!(\"ChaCha20::default\");\n        Self { input: [0u32; 16] }\n    }\n}\n\nimpl ChaCha20 {\n\n    pub fn new(k: *const u8, keylen: usize) -> Self {\n        let mut c = Self::default();\n        c.set_key(k, keylen);\n        c\n    }\n\n    /**\n    | set the 64bit nonce\n    |\n    */\n    pub fn setiv(&mut self, iv: u64) {\n        trace!(iv, \"ChaCha20::setiv\");\n        self.input[14] = (iv & 0xFFFF_FFFF) as u32;\n        self.input[15] = (iv >> 32)       as u32;\n    }\n\n    /**\n    | set the 64bit block counter\n    |\n    */\n    pub fn seek(&mut self, pos: u64) {\n        trace!(pos, \"ChaCha20::seek\");\n        self.input[12] = (pos & 0xFFFF_FFFF) as u32;\n        self.input[13] = (pos >> 32)       as u32;\n    }\n}\n\nimpl ChaCha20 {\n\n    /**\n    | enciphers the message <input> of length\n    | <bytes> and write the enciphered representation\n    | into <output>\n    | \n    | Used for encryption and decryption\n    | (XOR)\n    |\n    */\n    pub fn crypt(\n        &mut self,\n        m:         *const u8,\n        c:         *mut u8,\n        bytes:     usize\n    )\n    {\n        trace!(bytes, \"ChaCha20::crypt\");\n        if bytes == 0 {\n            return;\n        }\n    \n        unsafe {\n            // Produce keystream.\n            let mut ks = vec![0u8; bytes];\n            self.keystream(ks.as_mut_ptr(), bytes);\n    \n            // XOR keystream with `m` into `c`.\n            let src = core::slice::from_raw_parts(m, bytes);\n            let dst = core::slice::from_raw_parts_mut(c, bytes);\n            for i in 0..bytes {\n                dst[i] = src[i] ^ ks[i];\n            }\n        }\n    }\n}\n\n\nThis crate has the following authors:\n[\n    \"klebs <none>\",\n]\nThis crate has the following rust edition:\n2021\nThis crate has the following license:\nMIT\nThis crate is held in the following repository:\nhttps://github.com/klebs6/bitcoin-rs\n","role":"user"}],"model":"gpt-5.1"}}
