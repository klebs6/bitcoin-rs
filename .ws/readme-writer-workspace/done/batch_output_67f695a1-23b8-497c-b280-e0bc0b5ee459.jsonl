{"id": "batch_req_692cd2c1e6bc8190a6168275b5cd1d29", "custom_id": "bitcoin-autofile-ai-readme-request", "response": {"status_code": 200, "request_id": "c27cf5ecb0705a00719225eb53c34cce", "body": {"id": "chatcmpl-Chl6MtHXAwBksIL6sq7duqPzE7KGG", "object": "chat.completion", "created": 1764545198, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-autofile\",\n    \"full_readme_markdown\": \"# bitcoin-autofile\\n\\nNon-refcounted RAII wrapper around a C `FILE*` used by the `bitcoin-rs` project to reproduce Bitcoin Core's bit-exact serialization semantics while remaining idiomatic Rust.\\n\\n> This README was generated by an AI model. It may not be perfectly accurate or complete, but it should be a good starting point. Please consult the source code for definitive behavior.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-autofile` exposes a single core type:\\n\\n```rust\\npub struct AutoFile {\\n    n_type:    i32,\\n    n_version: i32,\\n    file:      *mut libc::FILE,\\n}\\n```\\n\\n`AutoFile`:\\n\\n- Owns a raw `*mut libc::FILE` and closes it automatically on `Drop` using `libc::fclose`.\\n- Can be explicitly closed early via [`fclose`](#method-fclose) (idempotent).\\n- Can relinquish ownership of the underlying `FILE*` via [`release`](#method-release).\\n- Implements `std::io::Read` and `std::io::Write` using the C stdio API (`fread`, `fwrite`, `fflush`).\\n- Provides low-level, panic-on-error `read_ptr`, `write_ptr`, and `ignore` methods modeled on the historical Bitcoin Core C++ implementation.\\n- Integrates with the project's custom Bitcoin (de)serialization traits via `<<` / `>>` operator overloading using Rust's `Shl` and `Shr` traits.\\n\\nThis crate exists to provide a thin, controlled interop layer between Rust code and the C `FILE*` abstractions used in legacy Bitcoin Core code, while matching binary serialization behavior exactly.\\n\\n---\\n\\n## When should you use this crate?\\n\\nYou likely want `bitcoin-autofile` if:\\n\\n- You are porting or interfacing with the Bitcoin Core C++ codebase and must preserve its wire format and file layout byte-for-byte.\\n- You need to use the project's `BtcSerialize` / `BtcUnserialize` traits over `FILE*` in a way that mirrors C++ `CAutoFile` semantics.\\n- You already have a `FILE*` coming from C, from `libc::fopen`, or indirectly via `std::fs::File::into_raw_fd()` and `fdopen`, and you want RAII-based cleanup in Rust.\\n\\nIf you do not care about `FILE*` or C stdio compatibility, using `std::fs::File` with `Read` / `Write` is more idiomatic and safer.\\n\\n---\\n\\n## Safety model\\n\\n`AutoFile` is intentionally low-level and `unsafe`-adjacent. Key properties:\\n\\n- Construction is **safe** in Rust's type system but documented with an `# Safety` contract. You must only pass valid, uniquely-owned `FILE*` handles.\\n- All methods treat a null `file` pointer as an error; some panic, some return an `io::Error`.\\n- `Drop` will `fclose` the `FILE*` if and only if it is non-null.\\n\\nBecause `AutoFile` operates on a raw pointer and calls into `libc`, misuse can lead to undefined behavior at the C level. In particular:\\n\\n- Do not share the same `FILE*` concurrently with other code that can write to it.\\n- Do not call `fclose` manually on the underlying `FILE*` while it is still owned by an `AutoFile`.\\n- Do not double-wrap the same `FILE*` in two `AutoFile` instances.\\n\\nThe crate is designed so that, in the intended usage, correctness is enforced by disciplined ownership rather than Rust's borrow checker alone.\\n\\n---\\n\\n## Core API\\n\\n### Construction\\n\\n```rust\\nuse bitcoin_autofile::AutoFile;\\nuse libc;\\n\\n// SAFETY: You must ensure `file` is a valid, uniquely-owned FILE*.\\nlet file: *mut libc::FILE = unsafe {\\n    libc::fopen(\\\"blocks.dat\\\\0\\\".as_ptr() as *const i8, \\\"rb+\\\\0\\\".as_ptr() as *const i8)\\n};\\n\\nif file.is_null() {\\n    panic!(\\\"failed to open file via libc::fopen\\\");\\n}\\n\\nlet autofile = AutoFile::new(file, n_type, n_version);\\n```\\n\\nThe `n_type` and `n_version` parameters mirror Bitcoin Core's `CDataStream` / `CAutoFile` metadata and are passed on to `BtcSerialize` / `BtcUnserialize` implementations.\\n\\n**Safety contract (from `AutoFile::new`):**\\n\\n- `file` must come from `libc::fopen` or from an equivalent raw descriptor conversion (e.g. `File::into_raw_fd()` followed by `fdopen`).\\n- No other live owner may close or mutably alias this `FILE*`.\\n\\n### Ownership and lifetime\\n\\n```rust\\nimpl AutoFile {\\n    pub fn fclose(&mut self);\\n    pub fn release(&mut self) -> *mut libc::FILE;\\n    pub fn get(&self) -> *mut libc::FILE;\\n    pub fn is_null(&self) -> bool;\\n}\\n```\\n\\n- `fclose`: Closes the file early, logging via `trace!`, and sets `file` to `nullptr`. It is safe to call multiple times.\\n- `release`: Transfers ownership of the `FILE*` to the caller and nulls out the internal pointer. `Drop` will no longer close the file.\\n- `get`: Returns the raw pointer **without** transferring ownership; it must not be closed externally.\\n- `is_null`: Lightweight check for whether the `AutoFile` currently owns a `FILE*`.\\n\\nAfter `release` or `fclose`, the value becomes inert: all I/O operations detect the null pointer and either panic (low-level methods) or return `io::Error` (trait-based I/O).\\n\\n### Low-level, panic-on-error primitives\\n\\nThese methods provide tightly constrained, Bitcoin-Core-style I/O behavior, panicking on error rather than returning `Result`.\\n\\n```rust\\nimpl AutoFile {\\n    /// Read exactly `n_size` bytes into `pch` or panic.\\n    pub fn read_ptr(&mut self, pch: *mut u8, n_size: usize);\\n\\n    /// Skip exactly `n_size` bytes by reading into a temporary buffer or panic.\\n    pub fn ignore(&mut self, n_size: usize);\\n\\n    /// Write exactly `n_size` bytes from `pch` or panic.\\n    pub fn write_ptr(&mut self, pch: *const u8, n_size: usize);\\n}\\n```\\n\\nAll three methods:\\n\\n- Require `self.file` to be non-null; otherwise they log and panic.\\n- Use `libc::fread` / `libc::fwrite` directly.\\n- Examine `feof` to differentiate EOF from other errors.\\n- Panic on short read/write or any failure to match `n_size`.\\n\\nThis is deliberate: the surrounding Bitcoin serialization logic often assumes infallible I/O and treats I/O failure as fatal.\\n\\n### Standard I/O traits\\n\\n`AutoFile` implements `std::io::Read` and `std::io::Write` so it can be used with the broader Rust ecosystem where appropriate.\\n\\n#### `Read`\\n\\n```rust\\nimpl std::io::Read for AutoFile {\\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize>;\\n}\\n```\\n\\n- Returns an `io::Error` if `file` is null.\\n- Uses `fread`; returns `Ok(0)` at EOF (`got == 0 && feof != 0`).\\n- Otherwise returns the byte count read.\\n\\n#### `Write`\\n\\n```rust\\nimpl std::io::Write for AutoFile {\\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize>;\\n    fn flush(&mut self) -> io::Result<()>;\\n}\\n```\\n\\n- Returns an `io::Error` if `file` is null.\\n- Uses `fwrite` for `write`, returning an error if a short write occurs.\\n- Uses `fflush` for `flush`, returning `last_os_error` on failure.\\n\\nThese trait impls are idiomatic and integrate with any library that expects a `Read + Write` object, while still preserving the underlying C `FILE*` semantics.\\n\\n### Drop semantics\\n\\n```rust\\nimpl Drop for AutoFile {\\n    fn drop(&mut self) {\\n        if !self.file.is_null() {\\n            unsafe { libc::fclose(self.file) };\\n            self.file = std::ptr::null_mut();\\n        }\\n    }\\n}\\n```\\n\\n- `Drop` closes the `FILE*` exactly once, assuming it has not been nulled by `release` or `fclose`.\\n- Logging via `trace!` can be enabled to audit lifecycle behavior.\\n\\nThis models classic RAII: deterministic resource cleanup when the value goes out of scope.\\n\\n---\\n\\n## Integration with Bitcoin (de)serialization\\n\\n`AutoFile` is designed to work with the project's custom serialization traits:\\n\\n```rust\\ntrait BtcSerialize<S> {\\n    fn serialize(&self, s: &mut S);\\n}\\n\\ntrait BtcUnserialize<S> {\\n    fn unserialize(&mut self, s: &mut S);\\n}\\n```\\n\\nTo provide a C++-like stream operator interface, `AutoFile` implements `Shl` and `Shr`:\\n\\n```rust\\nimpl<'a, T> std::ops::Shl<&'a T> for AutoFile\\nwhere\\n    T: BtcSerialize<AutoFile>,\\n{\\n    type Output = AutoFile;\\n\\n    fn shl(mut self, rhs: &'a T) -> Self::Output {\\n        BtcSerialize::<AutoFile>::serialize(rhs, &mut self);\\n        self\\n    }\\n}\\n\\nimpl<'a, T> std::ops::Shr<&'a mut T> for AutoFile\\nwhere\\n    T: BtcUnserialize<AutoFile>,\\n{\\n    type Output = AutoFile;\\n\\n    fn shr(mut self, rhs: &'a mut T) -> Self::Output {\\n        BtcUnserialize::<AutoFile>::unserialize(rhs, &mut self);\\n        self\\n    }\\n}\\n```\\n\\nThis allows code mathematically analogous to C++'s `CAutoFile` usage:\\n\\n```rust\\nuse bitcoin_autofile::AutoFile;\\nuse bitcoin_autofile::{BtcSerialize, BtcUnserialize};\\n\\nlet autofile = AutoFile::new(file, n_type, n_version);\\n\\nlet header: BlockHeader = /* ... */;\\nlet tx: Transaction = /* ... */;\\n\\n// Serialize:\\nlet autofile = autofile << &header << &tx;\\n\\n// Deserialize:\\nlet mut header2 = BlockHeader::default();\\nlet mut tx2 = Transaction::default();\\nlet autofile = autofile >> &mut header2 >> &mut tx2;\\n```\\n\\nThis style is primarily beneficial for codebases being ported directly from the C++ reference implementation where the `<<` and `>>` idioms are already pervasive.\\n\\n---\\n\\n## Error handling philosophy\\n\\nThe crate intentionally mixes two modes of error handling:\\n\\n- **Panic-on-error** for low-level primitives (`read_ptr`, `write_ptr`, `ignore`, `Shl`/`Shr`-driven serialization). This matches Bitcoin Core\u2019s behavior where I/O failure is treated as a fatal, unrecoverable condition.\\n- **`Result`-based** for trait-based `Read`/`Write`, allowing integration with Rust infrastructure that expects recoverable I/O errors.\\n\\nIn performance-critical or consensus-critical Bitcoin code, panicking on disk or file corruption can be preferable to attempting partial recovery that might compromise invariants. For application-level code, you may prefer using the `Read`/`Write` APIs and handling `io::Result` explicitly.\\n\\n---\\n\\n## Example: reading a fixed-size record\\n\\n```rust\\nuse bitcoin_autofile::AutoFile;\\nuse libc;\\nuse std::io::{Read, Write};\\n\\nfn open_autofile(path: &str) -> AutoFile {\\n    use std::ffi::CString;\\n\\n    let c_path = CString::new(path).expect(\\\"no interior NUL\\\");\\n    let c_mode = CString::new(\\\"rb+\\\").unwrap();\\n\\n    let file = unsafe { libc::fopen(c_path.as_ptr(), c_mode.as_ptr()) };\\n    if file.is_null() {\\n        panic!(\\\"failed to open {} via fopen\\\", path);\\n    }\\n\\n    // n_type and n_version chosen to match Bitcoin Core semantics\\n    AutoFile::new(file, /* n_type = */ 1, /* n_version = */ 70015)\\n}\\n\\nfn read_magic_prefix(mut af: AutoFile) -> [u8; 4] {\\n    let mut buf = [0u8; 4];\\n    // Using standard Read trait:\\n    af.read_exact(&mut buf).expect(\\\"short read\\\");\\n    buf\\n}\\n\\nfn write_then_flush(mut af: AutoFile, data: &[u8]) {\\n    af.write_all(data).expect(\\\"write failed\\\");\\n    af.flush().expect(\\\"flush failed\\\");\\n}\\n```\\n\\n---\\n\\n## Logging\\n\\n`AutoFile` uses the standard Rust logging macros (`trace!`, `debug!`, `error!`). To see lifecycle and error logs, enable a compatible logger (e.g. `env_logger`, `tracing-subscriber`) and set appropriate log levels, particularly for the `autofile` target.\\n\\n---\\n\\n## Repository, license, and maintenance\\n\\n- **Crate name:** `bitcoin-autofile`\\n- **Version:** 0.1.20\\n- **Repository:** <https://github.com/klebs6/bitcoin-rs>\\n- **License:** MIT\\n- **Edition:** Rust 2021\\n- **Author:** `klebs <none>`\\n\\nThis crate is part of the broader `bitcoin-rs` codebase; it is not a general-purpose I/O abstraction but a focused compatibility layer intended primarily for that project and for developers who explicitly need bit-exact Bitcoin Core behavior.\\n\",\n    \"package_categories\": [\n      \"filesystem\",\n      \"network-programming\",\n      \"encoding\",\n      \"parsing\",\n      \"rust-patterns\"\n    ],\n    \"package_description\": \"RAII wrapper around a C FILE* used by bitcoin-rs, providing Drop-based fclose, explicit ownership transfer, panic-on-error low-level read/write helpers, and integration with custom Bitcoin (de)serialization while implementing std::io::Read and std::io::Write using libc.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"FILE\",\n      \"ffi\",\n      \"serialization\",\n      \"libc\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 3786, "completion_tokens": 3425, "total_tokens": 7211, "prompt_tokens_details": {"cached_tokens": 0, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
