{"id": "batch_req_692ce27993808190812641b801a0019a", "custom_id": "bitcoinleveldb-compat-ai-readme-request", "response": {"status_code": 200, "request_id": "015407559db9bb13cf3d8701e6c6411c", "body": {"id": "chatcmpl-Chm9EDvHYuC38DDIBCdG1VmaAZlze", "object": "chat.completion", "created": 1764549220, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoinleveldb-compat\",\n    \"full_readme_markdown\": \"# bitcoinleveldb-compat\\n\\nLow-level Rust bindings that emulate the original C++ LevelDB `port` and Snappy interfaces used by Bitcoin Core, with tracing, safety checks, and modern Rust infrastructure under the hood.\\n\\nThis crate is intentionally narrow in scope: it exists to make it straightforward to plug Bitcoin's LevelDB-dependent code into Rust with minimal semantic drift. It provides\\n\\n- C/FFI-friendly Snappy compression helpers with LevelDB-style contracts\\n- CRC32C acceleration in the same shape as LevelDB's `crc32c` helpers\\n- A `port` module implementing LevelDB-compatible mutexes and condition variables on top of Rust primitives\\n- Stubs for heap profiling to satisfy link-time expectations without adding heavy dependencies\\n\\nAll interfaces are designed to be close to the C++ originals (pointer-based, explicit contracts, and boolean success flags) while being implemented in Rust with logging and modern concurrency primitives.\\n\\n> Note: This README was generated by an AI model based on the visible code and may not be perfectly accurate or complete, though it should be quite close. Always defer to the actual source for authoritative behavior.\\n\\n---\\n\\n## Features at a Glance\\n\\n- **Snappy compatibility**\\n  - `snappy_compress(input, length, output) -> bool`\\n  - `snappy_uncompress(input, length, output) -> bool`\\n  - `snappy_get_uncompressed_length(input, length, result) -> bool`\\n  - Behavior gated behind the `leveldb_snappy` Cargo feature; without it, the functions are present but always return `false`, matching LevelDB's conditional Snappy support.\\n\\n- **CRC32C acceleration**\\n  - `acceleratedcrc32c(crc, buf, size) -> u32` wraps a performant CRC32C implementation and mirrors LevelDB's accelerated CRC API.\\n\\n- **Synchronization primitives (`port` module)**\\n  - `port::Mutex`: thin wrapper over `parking_lot::RawMutex`, with explicit `lock()`, `unlock()`, and `assert_held()` semantics aligned with LevelDB's `port::Mutex`.\\n  - `port::CondVar`: condition variable that works with `port::Mutex`, mirroring LevelDB's `CondVar` semantics (`wait`, `signal`, `signal_all`).\\n\\n- **Heap profiling stub**\\n  - `get_heap_profile(func, arg) -> bool` satisfies LevelDB's expected symbol but always returns `false`, indicating that heap profiling is not supported in this build.\\n\\n- **Observability**\\n  - All public operations are instrumented using [`tracing`](https://docs.rs/tracing), producing detailed spans and events at `trace`, `debug`, and `error` levels for diagnosis of concurrency and compression behavior.\\n\\n---\\n\\n## Installation\\n\\n```toml\\n[dependencies]\\nbitcoinleveldb-compat = \\\"0.1.19\\\"\\n\\n# Optional: to enable Snappy support\\n[features]\\n# In your own crate, just enable this feature for bitcoinleveldb-compat\\n# bitcoinleveldb-compat = { version = \\\"0.1.19\\\", features = [\\\"leveldb_snappy\\\"] }\\n```\\n\\nThis crate targets Rust **edition 2021** and is licensed under **MIT**.\\n\\nThe code lives in the `bitcoin-rs` monorepo:\\n\\n- Repository: <https://github.com/klebs6/bitcoin-rs>\\n\\n---\\n\\n## Snappy API\\n\\nThe Snappy interface is deliberately low-level and pointer-based to approximate the C++ implementation.\\n\\n### Feature gating\\n\\nAll Snappy functions are compiled in both with and without Snappy support:\\n\\n- With `leveldb_snappy` feature enabled:\\n  - Functions perform real Snappy compression/decompression using the `snap` crate.\\n- Without `leveldb_snappy` feature:\\n  - Functions are no-ops that return `false` and log that Snappy is disabled, mirroring LevelDB's optional Snappy integration.\\n\\n### `snappy_compress`\\n\\n```rust\\n#[cfg(feature = \\\"leveldb_snappy\\\")]\\npub fn snappy_compress(input: *const u8, length: usize, output: *mut String) -> bool\\n```\\n\\n- **Input**: `input[0..length)` is treated as a raw byte slice.\\n- **Output**: On success, `*output` is overwritten with a `String` whose underlying bytes are the raw compressed Snappy buffer.\\n- **Return**: `true` on success, `false` on failure or invalid pointers.\\n\\nImportant properties:\\n\\n- The function treats `String` purely as an owned byte container, using `String::from_utf8_unchecked`. The compressed Snappy stream is *not* guaranteed to be UTF-8. This is intentional to mimic the original `std::string` usage in LevelDB, which is a generic byte container.\\n- Callers must never rely on UTF-8 validity of the resulting `String`; treat it as opaque binary data.\\n\\n**Safety**: This function is `unsafe` to call from a strict Rust perspective because it takes and dereferences raw pointers. In idiomatic Rust code, you should wrap it with a safe abstraction that ensures:\\n\\n- `input` is non-null and references at least `length` bytes\\n- `output` is non-null and points to a valid `String` instance\\n\\nExample usage inside `unsafe` context:\\n\\n```rust\\nuse bitcoinleveldb_compat::snappy_compress;\\n\\nunsafe {\\n    let data = b\\\"hello leveldb\\\";\\n    let mut out = String::new();\\n    let ok = snappy_compress(data.as_ptr(), data.len(), &mut out as *mut String);\\n    assert!(ok);\\n    // `out` now holds the compressed Snappy payload as bytes in a String\\n}\\n```\\n\\n### `snappy_uncompress`\\n\\n```rust\\n#[cfg(feature = \\\"leveldb_snappy\\\")]\\npub fn snappy_uncompress(input: *const u8, length: usize, output: *mut u8) -> bool\\n```\\n\\n- **Input**: `input[0..length)` is a Snappy-compressed buffer.\\n- **Output**: Raw bytes are written starting at `output`.\\n- **Return**: `true` on successful decompression, `false` on invalid or corrupt input.\\n\\nConstraints:\\n\\n- The caller must ensure that `output` points to a writable buffer of at least `n` bytes, where `n` is the value returned by a successful `snappy_get_uncompressed_length` call on the same `input`.\\n- The function uses `ptr::copy_nonoverlapping` to write the decompressed data.\\n\\nExample pattern:\\n\\n```rust\\nuse bitcoinleveldb_compat::{\\n    snappy_compress,\\n    snappy_uncompress,\\n    snappy_get_uncompressed_length,\\n};\\n\\nunsafe {\\n    let data = b\\\"block index payload\\\";\\n\\n    // 1. Compress\\n    let mut compressed = String::new();\\n    assert!(snappy_compress(data.as_ptr(), data.len(), &mut compressed as *mut String));\\n\\n    // 2. Query uncompressed length\\n    let mut out_len: usize = 0;\\n    let ok = snappy_get_uncompressed_length(\\n        compressed.as_ptr(),\\n        compressed.len(),\\n        &mut out_len as *mut usize,\\n    );\\n    assert!(ok);\\n\\n    // 3. Allocate output buffer\\n    let mut out = vec![0u8; out_len];\\n\\n    // 4. Decompress\\n    let ok = snappy_uncompress(\\n        compressed.as_ptr(),\\n        compressed.len(),\\n        out.as_mut_ptr(),\\n    );\\n    assert!(ok);\\n    assert_eq!(&out[..], data);\\n}\\n```\\n\\n### `snappy_get_uncompressed_length`\\n\\n```rust\\n#[cfg(feature = \\\"leveldb_snappy\\\")]\\npub fn snappy_get_uncompressed_length(\\n    input: *const u8,\\n    length: usize,\\n    result: *mut usize,\\n) -> bool\\n```\\n\\nThis function attempts to uncompress the buffer internally to determine the output length and writes it into `*result`.\\n\\n- **Success path**: returns `true` and sets `*result` to the decompressed length.\\n- **Failure**: returns `false` and leaves `*result` unspecified.\\n\\nNote that the implementation currently does *full* decompression to compute the length instead of using Snappy's cheap-length-query primitive. This is acceptable for compatibility but may be less efficient; consult the repository if efficiency is critical and consider contributing an optimized implementation.\\n\\n---\\n\\n## CRC32C Acceleration\\n\\n```rust\\npub fn acceleratedcrc32c(crc: u32, buf: *const u8, size: usize) -> u32\\n```\\n\\n- If `buf` is null or `size == 0`, the function returns the original `crc` unchanged.\\n- Otherwise, it computes an extended CRC32C over `buf[0..size)` via `crc32c_extend(crc, data)` and returns the new CRC.\\n\\nThis corresponds to the mathematical operation:\\n\\n\\\\[\\n\\\\text{new_crc} = \\\\operatorname{CRC32C\\\\_extend}(\\\\text{crc}, \\\\text{buf})\\n\\\\]\\n\\nwhere CRC32C is the Castagnoli polynomial-based CRC with well-defined compositional properties (you can extend a prefix CRC with suffix bytes without recomputing over the entire concatenated buffer).\\n\\nExample:\\n\\n```rust\\nuse bitcoinleveldb_compat::acceleratedcrc32c;\\n\\nunsafe {\\n    let part1 = b\\\"header\\\";\\n    let part2 = b\\\"body\\\";\\n\\n    let mut crc = 0u32;\\n    crc = acceleratedcrc32c(crc, part1.as_ptr(), part1.len());\\n    crc = acceleratedcrc32c(crc, part2.as_ptr(), part2.len());\\n\\n    // `crc` is now the CRC32C of b\\\"headerbody\\\".\\n}\\n```\\n\\n---\\n\\n## `port` Module: Mutex and Condition Variable\\n\\nThe `port` module re-implements the LevelDB `port::Mutex` and `port::CondVar` APIs, but on top of Rust's synchronization primitives (`parking_lot::RawMutex` and `std::sync::Condvar`), preserving the original semantics.\\n\\n### `port::Mutex`\\n\\n```rust\\n#[LOCKABLE]\\npub struct Mutex {\\n    mu: parking_lot::RawMutex,\\n    is_locked: AtomicBool,\\n}\\n\\nimpl Mutex {\\n    pub fn new() -> Self;\\n    pub fn lock(&mut self);\\n    pub fn unlock(&mut self);\\n    pub fn assert_held(&mut self);\\n}\\n```\\n\\nKey behaviors:\\n\\n- `lock()` blocks until the mutex is obtained, then flips `is_locked` to `true`.\\n- `unlock()` sets `is_locked` to `false` and releases the underlying `RawMutex`.\\n- `assert_held()` issues a `debug_assert!` that `is_locked` is `true`, used for internal invariants consistent with LevelDB's expectations.\\n\\nThis mutex is marked `Send` and `Sync`, so it can be shared across threads. It is explicitly *not* a RAII-guarded mutex; you must call `lock()`/`unlock()` manually, which is closer to how the C++ code interacts with `port::Mutex`.\\n\\nExample:\\n\\n```rust\\nuse bitcoinleveldb_compat::port::Mutex;\\n\\nlet mut mu = Mutex::new();\\n\\nmu.lock();\\n// critical section\\nmu.assert_held();\\nmu.unlock();\\n```\\n\\n### `port::CondVar`\\n\\n```rust\\npub struct CondVar {\\n    cv:      std::sync::Condvar,\\n    mu:      *const Mutex,\\n    waiters: std::sync::Mutex<usize>,\\n}\\n\\nimpl CondVar {\\n    pub fn new(mu: *mut Mutex) -> Self;\\n    pub fn wait(&mut self);\\n    pub fn signal(&mut self);\\n    pub fn signal_all(&mut self);\\n}\\n```\\n\\nSemantics mirror LevelDB:\\n\\n- `CondVar::new(mu)` associates the condition variable with a specific `port::Mutex` pointer. The pointer is assumed to outlive the `CondVar`.\\n- `wait()` must be called while holding `mu`:\\n  - Registers the caller as a waiter (increments waiter count).\\n  - Releases `mu`.\\n  - Blocks on the internal `Condvar`.\\n  - On wakeup, decrements waiter count and re-acquires `mu` before returning.\\n- `signal()` wakes a single waiting thread (if any).\\n- `signal_all()` wakes all waiters.\\n\\nThere is a small internal `StdMutex<usize>` tracking waiters; poisoning is detected and logged but recovered from by taking the inner state.\\n\\nExample usage:\\n\\n```rust\\nuse bitcoinleveldb_compat::port::{Mutex, CondVar};\\nuse std::sync::Arc;\\nuse std::thread;\\n\\nlet mu = Arc::new(Mutex::new());\\nlet cond = Arc::new(std::sync::Mutex::new(CondVar::new(Arc::as_ptr(&mu) as *mut _)));\\nlet ready = Arc::new(std::sync::atomic::AtomicBool::new(false));\\n\\n// Producer\\n{\\n    let mu = mu.clone();\\n    let cond = cond.clone();\\n    let ready = ready.clone();\\n    thread::spawn(move || {\\n        let mut mu_ref = mu; // explicit binding\\n        mu_ref.lock();\\n        ready.store(true, std::sync::atomic::Ordering::SeqCst);\\n        cond.lock().unwrap().signal_all();\\n        mu_ref.unlock();\\n    });\\n}\\n\\n// Consumer\\nmu.lock();\\nwhile !ready.load(std::sync::atomic::Ordering::SeqCst) {\\n    cond.lock().unwrap().wait();\\n}\\nmu.unlock();\\n```\\n\\nThis pattern closely tracks the LevelDB idiom: check predicate under lock, call `wait()` to sleep if not satisfied, and re-evaluate after wake-up.\\n\\n---\\n\\n## Heap Profiling Stub\\n\\n```rust\\npub fn get_heap_profile(\\n    func: fn(_0: *mut c_void, _1: *const u8, _2: i32) -> c_void,\\n    arg: *mut c_void,\\n) -> bool\\n```\\n\\nThis function always logs that heap profiling is not supported and returns `false`. It exists solely to satisfy link-time expectations from LevelDB/Bitcoin code that may conditionally call into `get_heap_profile`.\\n\\nIf you need real heap profiling, you should layer a dedicated solution over or in place of this stub and adjust your integration accordingly.\\n\\n---\\n\\n## Tracing and Diagnostics\\n\\nAll public functions are annotated with `#[instrument]` from the `tracing` ecosystem. This means:\\n\\n- Every call generates a span with structured fields (e.g., `length`, `size`, pointer values).\\n- Errors and exceptional conditions are logged with `debug!`, `warn!`, or `error!` levels.\\n\\nIn production systems, this makes it significantly easier to diagnose concurrency issues, mis-sized buffers, or misconfigured features (e.g., Snappy disabled when expected).\\n\\nTo consume these logs, wire up a `tracing` subscriber in your binary:\\n\\n```rust\\nuse tracing_subscriber::FmtSubscriber;\\n\\nfn main() {\\n    let subscriber = FmtSubscriber::builder()\\n        .with_max_level(tracing::Level::TRACE)\\n        .finish();\\n\\n    tracing::subscriber::set_global_default(subscriber)\\n        .expect(\\\"setting default subscriber failed\\\");\\n\\n    // your application using bitcoinleveldb-compat\\n}\\n```\\n\\n---\\n\\n## Safety and FFI Considerations\\n\\nThis crate presents a C-like API surface for the sake of Bitcoin/LevelDB compatibility:\\n\\n- Raw pointers (`*const u8`, `*mut u8`, `*mut String`, `*mut usize`)\\n- Manual memory management responsibilities for the caller\\n- No lifetime tracking in the type system\\n\\nWhen used from Rust, prefer to encapsulate these calls behind safe wrappers that:\\n\\n- Own and manage the input/output buffers\\n- Avoid null pointers\\n- Guarantee length invariants\\n\\nWhen used from C/C++ via FFI, ensure that the ABI and calling conventions are matched, and that the Rust side is compiled with a stable layout and visibility for the symbols in question.\\n\\n---\\n\\n## License\\n\\nThis crate is distributed under the terms of the **MIT license**.\\n\\n---\\n\\n## Provenance and Reliability\\n\\nThis README was generated by an AI model from the available code snippets and repository metadata. While the description is intended to be accurate and precise, the source code is always the definitive reference. Consult the repository for up-to-date behavior, edge cases, and integration details.\\n\",\n    \"package_categories\": [\n      \"algorithms\",\n      \"concurrency\",\n      \"cryptography\",\n      \"development-tools\",\n      \"network-programming\"\n    ],\n    \"package_description\": \"LevelDB-compatible low-level utilities for Bitcoin: Snappy compression shims, accelerated CRC32C, and ported mutex/condvar primitives with tracing, matching the C++ LevelDB/Bitcoin Core interfaces.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"leveldb\",\n      \"snappy\",\n      \"crc32c\",\n      \"concurrency\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 5162, "completion_tokens": 4005, "total_tokens": 9167, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
