{"id": "batch_req_692ce34a60548190bbb4982407b27519", "custom_id": "bitcoinleveldb-crc32-ai-readme-request", "response": {"status_code": 200, "request_id": "66a826c49011db0f88eb0bd7ff18539c", "body": {"id": "chatcmpl-ChmCce45UCRZBTHrF1dhvV8JVTRMf", "object": "chat.completion", "created": 1764549430, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoinleveldb-crc32\",\n    \"full_readme_markdown\": \"# bitcoinleveldb-crc32\\n\\nLow-level, allocation-free CRC32C primitives extracted from the Bitcoin LevelDB port, with explicit control over masking, alignment, and hardware acceleration probing.\\n\\nThis crate is intended for consumers who need tight control over binary layout and performance characteristics, and who are comfortable working with raw pointers and unsafe Rust when necessary.\\n\\n> Note: This README was generated by an AI model and may not be perfectly accurate, though it is designed to be technically precise and highly usable.\\n\\n---\\n\\n## Overview\\n\\n`bitcoinleveldb-crc32` provides a small, focused API around the CRC32C (Castagnoli) checksum, mirroring the behavior and conventions of the original LevelDB implementation used in Bitcoin.\\n\\nThe design goals are:\\n\\n- **Bit\u2011for\u2011bit compatibility** with LevelDB's CRC32C implementation\\n- **No hidden allocations**; operates directly on `*const u8` buffers\\n- **Masking support** suitable for on-disk or on-wire embedding of CRCs\\n- **Alignment utilities** for efficient SIMD or hardware-accelerated backends\\n- **Hardware capability probing** to determine if CRC32C acceleration is available\\n\\nThis crate is particularly useful in contexts such as:\\n\\n- Storage engines and LSM trees (LevelDB, RocksDB-style systems)\\n- Filesystem or block-level integrity checks\\n- Network protocols that embed CRC32C checksums in framing\\n- Reimplementations of Bitcoin Core's LevelDB-based storage in Rust\\n\\nThe exposed functions are instrumented with [`tracing`](https://docs.rs/tracing) to allow fine-grained observability in high-performance applications.\\n\\n---\\n\\n## CRC32C background\\n\\nCRC32C is a 32-bit cyclic redundancy check using the Castagnoli polynomial\\n\\\\[ p(x) = x^{32} + x^{28} + x^{27} + x^{26} + x^{25} + x^{23} + x^{22} + x^{20} + x^{19} + x^{18} + x^{14} + x^{13} + x^{11} + x^{10} + x^9 + x^8 + x^6 + 1 \\\\]\\nwhich is widely used due to its strong error-detection properties and efficient hardware support (e.g., SSE4.2 `crc32` instructions on x86, corresponding intrinsics on other architectures).\\n\\nThe library maintains compatibility with LevelDB's treatment of:\\n\\n- Initial CRC seed\\n- Bit ordering and reflection\\n- Final XOR and masking conventions\\n\\nso that checksums computed here will match those stored by Bitcoin's C++ LevelDB bindings, given identical inputs.\\n\\n---\\n\\n## Features at a glance\\n\\n- `crc32c_value` \u2014 Compute CRC32C of a contiguous buffer.\\n- `crc32c_extend` \u2014 Incrementally update a running CRC32C over streaming data.\\n- `crc32c_mask` / `crc32c_unmask` \u2014 Apply and remove LevelDB-compatible CRC masking for storing CRCs inside data.\\n- `crc32c_read_uint32le` \u2014 Read a little-endian `u32` from a 32-bit aligned pointer (no allocation, no copy beyond a 4-byte stack buffer).\\n- `crc32c_round_up` \u2014 Align a pointer to a power-of-two boundary for SIMD or hardware-friendly access.\\n- `crc32c_can_accelerate` \u2014 Probe at runtime whether a hardware-accelerated backend is active and correct.\\n\\nAll functions are `#[inline]` (where appropriate) and instrumented with `tracing::instrument` annotations.\\n\\n---\\n\\n## Safety model\\n\\nMost functions accept raw pointers (`*const u8`). The caller is responsible for:\\n\\n- Ensuring the pointer is non-null and points to at least `n` valid bytes where required\\n- Respecting any implied alignment when using `crc32c_read_uint32le` and `crc32c_round_up`\\n- Avoiding data races when used in concurrent contexts\\n\\nThe library itself does **not** perform bounds checking; it is designed for use in performance-critical engines where the caller typically controls the full lifecycle of the buffers.\\n\\n---\\n\\n## Installation\\n\\nAdd to `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoinleveldb-crc32 = \\\"0.1.19\\\"\\ntracing = \\\"0.1\\\" # for instrumentation visibility (optional but recommended)\\n```\\n\\nThis crate targets Rust edition 2021 and is licensed under MIT.\\n\\n---\\n\\n## API reference and usage\\n\\nThe public interface consists of the following functions:\\n\\n### `crc32c_value`\\n\\n```rust\\nuse bitcoinleveldb_crc32::crc32c_value;\\n\\nfn crc_of_slice(data: &[u8]) -> u32 {\\n    unsafe { crc32c_value(data.as_ptr(), data.len()) }\\n}\\n```\\n\\nComputes the CRC32C value of `data[0..n)`. Internally it simply seeds the CRC with `0` and invokes `crc32c_extend`.\\n\\n**Semantics:**\\n\\n- Equivalent to `crc32c_extend(0, data, n)`\\n- Designed for one-shot checksums over contiguous memory\\n\\n### `crc32c_extend`\\n\\n```rust\\nuse bitcoinleveldb_crc32::crc32c_extend;\\n\\nfn crc_stream(chunks: &[&[u8]]) -> u32 {\\n    let mut crc = 0u32;\\n    for chunk in chunks {\\n        unsafe {\\n            crc = crc32c_extend(crc, chunk.as_ptr(), chunk.len());\\n        }\\n    }\\n    crc\\n}\\n```\\n\\nExtends an existing CRC32C value `crc` with additional bytes `data[0..n)`, as if concatenating the underlying byte streams.\\n\\nThis is suitable for:\\n\\n- Streaming data ingestion\\n- Log-structured storage\\n- Incrementally computing CRCs over large files without storing them in memory at once\\n\\nImplementation notes:\\n\\n- Currently calls a `crc32c_extend_portable` backend, but is architected to allow a hardware-accelerated path.\\n\\n### `crc32c_mask` and `crc32c_unmask`\\n\\n```rust\\nuse bitcoinleveldb_crc32::{crc32c_mask, crc32c_unmask};\\n\\nlet crc: u32 = 0x1234_5678;\\nlet masked = crc32c_mask(crc);\\nassert_eq!(crc, crc32c_unmask(masked));\\n```\\n\\nMasking is necessary when embedding a CRC inside the data that is itself being checksummed. Without masking, the CRC field can cause pathological fixed points where the checksum of the structure always equals the embedded CRC, even if other bits change in certain patterns.\\n\\n**LevelDB-style masking algorithm:**\\n\\n1. Rotate the CRC right by 15 bits (or equivalently left by 17 bits for the remaining bits),\\n2. Add a fixed constant `MASK_DELTA` using wrapping arithmetic.\\n\\nThis mapping is invertible; `crc32c_unmask` reverses the operation by:\\n\\n1. Subtracting `MASK_DELTA` with wrapping semantics,\\n2. Rotating left by 15 bits (right by 17 for the remaining bits).\\n\\nUse these when you store CRCs in:\\n\\n- SSTable files\\n- WAL (write-ahead log) records\\n- Protocol frames that might themselves be protected by a higher-level CRC\\n\\n### `crc32c_read_uint32le`\\n\\n```rust\\nuse bitcoinleveldb_crc32::crc32c_read_uint32le;\\n\\nfn read_u32_le(buf: &[u8]) -> u32 {\\n    assert!(buf.len() >= 4);\\n    unsafe { crc32c_read_uint32le(buf.as_ptr()) }\\n}\\n```\\n\\nReads a 32-bit little-endian integer from a 32-bit-aligned buffer.\\n\\n**Constraints and behavior:**\\n\\n- `buffer` must be valid for at least 4 bytes of read access.\\n- Assumes platform is little-endian or handles conversion via `u32::from_le_bytes`.\\n- Internally, copies 4 bytes into a stack buffer and interprets them as `u32`.\\n\\nTypical usage is to efficiently parse on-disk or on-wire headers that carry lengths, CRCs, or version fields.\\n\\n### `crc32c_round_up`\\n\\n```rust\\nuse bitcoinleveldb_crc32::crc32c_round_up;\\n\\nfn align_to_64(ptr: *const u8) -> *mut u8 {\\n    // 64 must be a power of two; enforced by debug_assert in the function.\\n    crc32c_round_up::<64>(ptr)\\n}\\n```\\n\\nRounds a pointer up to the smallest address `>= pointer` that is aligned to `N` bytes, where `N` is a power of two.\\n\\nThis is a standard alignment operation:\\n\\n\\\\[\\n\\\\text{rounded} = (\\\\text{addr} + N - 1) \\\\& \\\\neg (N - 1)\\n\\\\]\\n\\nApplications:\\n\\n- Aligning buffers for vectorized CRC implementations\\n- Ensuring cacheline or page alignment for IO-bound data structures\\n\\n### `crc32c_can_accelerate`\\n\\n```rust\\nuse bitcoinleveldb_crc32::crc32c_can_accelerate;\\n\\nif crc32c_can_accelerate() {\\n    // Hardware-accelerated CRC32C backend is active and passes self-test.\\n} else {\\n    // Fallback to portable implementation.\\n}\\n```\\n\\nPerforms a self-test using the original LevelDB logic:\\n\\n- Compute `AcceleratedCRC32C(0, b\\\"TestCRCBuffer\\\", 14)`.\\n- Compare against the constant `0xdcbc59fa`.\\n\\nIf and only if the computed value matches, the accelerated backend is considered correct and available.\\n\\nThis function is useful for:\\n\\n- Runtime feature detection\\n- Deciding whether to favor a hardware-accelerated path vs a portable scalar fallback\\n\\n---\\n\\n## Tracing and observability\\n\\nAll public functions are annotated with `#[instrument(level = \\\"trace\\\", skip_all)]` from the `tracing` crate, and emit `trace!` events with relevant metadata:\\n\\n- `crc32c_value`: length and resulting CRC\\n- `crc32c_mask` / `crc32c_unmask`: input and transformed values\\n- `crc32c_read_uint32le`: pointer and decoded value\\n- `crc32c_round_up`: original and aligned addresses, alignment\\n- `crc32c_can_accelerate`: computed and expected CRCs, data length, decision flag\\n- `crc32c_extend`: initial CRC, length, final CRC\\n\\nTo enable these logs:\\n\\n```rust\\nuse tracing_subscriber::FmtSubscriber;\\n\\nfn main() {\\n    let subscriber = FmtSubscriber::builder()\\n        .with_max_level(tracing::Level::TRACE)\\n        .finish();\\n\\n    tracing::subscriber::set_global_default(subscriber)\\n        .expect(\\\"setting tracing default failed\\\");\\n\\n    // call functions from bitcoinleveldb-crc32 here\\n}\\n```\\n\\nIn production, you may choose to record only higher levels (e.g., `INFO` or `WARN`) and enable `TRACE` selectively during diagnostics or benchmarking.\\n\\n---\\n\\n## Safety and correctness checklist\\n\\nWhen integrating this crate into a storage engine or protocol implementation, verify the following:\\n\\n1. **Pointer validity**: All pointers passed into the functions must be derived from valid Rust slices, vectors, or other properly allocated memory regions.\\n2. **Bounds**: Ensure that `n` never exceeds the actual buffer length.\\n3. **Alignment**: Only rely on `crc32c_read_uint32le` for buffers that are at least naturally aligned or non-problematic on your target architecture.\\n4. **Masking usage**: If you store CRCs inside the data they protect, always mask before writing and unmask after reading, consistently.\\n5. **Interoperability**: When targeting existing LevelDB data or Bitcoin Core\u2019s on-disk formats, verify one or two known-checksum fixtures to confirm end-to-end compatibility.\\n\\n---\\n\\n## Repository, license, and maintenance\\n\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n- **Crate**: `bitcoinleveldb-crc32`\\n- **License**: MIT\\n- **Rust edition**: 2021\\n- **Authors**: `klebs <none>`\\n\\nThis crate is intended as a modular component within the broader `bitcoin-rs` project. For higher-level abstractions (e.g., full LevelDB bindings or Bitcoin node functionality), consult that repository.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"data-structures\"\n    ],\n    \"package_description\": \"Low-level, LevelDB-compatible CRC32C (Castagnoli) primitives for Bitcoin-related storage and streaming, including masking, alignment helpers, and optional hardware acceleration probing.\",\n    \"package_keywords\": [\n      \"crc32c\",\n      \"leveldb\",\n      \"bitcoin\",\n      \"checksum\",\n      \"storage\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 3061, "completion_tokens": 2985, "total_tokens": 6046, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
