{"id": "batch_req_692cdaa3f31081909680c67aeda9cac6", "custom_id": "bitcoin-siphash-ai-readme-request", "response": {"status_code": 200, "request_id": "c167eefe4d30f89e17f404b5ed66c304", "body": {"id": "chatcmpl-ChlcoDk11DKtJuLWskmvuYSjOAydx", "object": "chat.completion", "created": 1764547210, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-siphash\",\n    \"full_readme_markdown\": \"# bitcoin-siphash\\n\\nBitcoin-Core-compatible SipHash-2-4 primitives and utilities, factored out as a standalone Rust crate.\\n\\nThis crate exposes:\\n\\n- Low-level macros mirroring Bitcoin Core's C++ macros:\\n  - `rotl!` \u2013 64-bit rotate-left.\\n  - `sipround!` \u2013 a single SipHash compression round (`SIPROUND`).\\n- A streaming SipHash-2-4 state machine:\\n  - `BitcoinSipHasher` \u2013 incremental, constant-time, branch-free where it matters.\\n- Two optimized helpers for hashing 256-bit values (Bitcoin-style `uint256`):\\n  - `sip_hash_uint256` \u2013 SipHash-2-4 over a 256-bit value.\\n  - `sip_hash_uint_256extra` \u2013 SipHash-2-4 over a 256-bit value plus an additional 32-bit tag.\\n- A `rotl64` helper as a `const fn` for compile-time evaluation.\\n\\nAll algorithms are direct, structurally faithful translations of the Bitcoin Core reference implementation and are intended for consensus-critical and index-key use in Bitcoin-related code.\\n\\n> NOTE: This README was generated by an AI model. It may not be perfectly accurate in every detail, but it is designed to be a high-fidelity, technically sound description of the crate.\\n\\n---\\n\\n## Background: SipHash-2-4 in Bitcoin\\n\\nSipHash is a family of keyed pseudorandom functions over byte strings, designed by Aumasson and Bernstein. `SipHash-2-4` refers to the parameterization with 2 compression rounds per message block and 4 finalization rounds. It is used in Bitcoin Core for structured hashing tasks such as hash table keys, short transaction IDs, and other non-cryptographic but DoS-sensitive indexing scenarios.\\n\\nBitcoin treats SipHash as a keyed PRF, not as a collision-resistant hash for consensus content. Security properties that matter here:\\n\\n- **Keyed**: Protects against adversarially chosen inputs targeting hash table collisions.\\n- **Constant-time and branch-free** in the hot path: reduces side channels and improves predictability.\\n- **Deterministic bit-exact behavior**: necessary for consensus-adjacent indexing and compatibility with existing nodes.\\n\\nThis crate aims to reproduce that behavior exactly, but in idiomatic Rust, enabling interoperability with Bitcoin Core's C++ implementation.\\n\\n---\\n\\n## Crate goals and scope\\n\\n- Provide **bit-for-bit compatibility** with Bitcoin Core's SipHash usage.\\n- Expose **low-level building blocks** for crates that need to implement Bitcoin's hash-indexing logic.\\n- Preserve **macro-level semantics** (`ROTL`, `SIPROUND`) while restoring Rust macro hygiene.\\n- Avoid unnecessary abstraction layers so that **generated assembly remains close to the reference**.\\n\\nThis crate does *not* attempt to be a general-purpose cryptographic library; it focuses on Bitcoin-style usages.\\n\\n---\\n\\n## Features at a glance\\n\\n- `rotl!` \u2013 macro for `rotate_left` with wrap-around semantics.\\n- `sipround!` \u2013 a single SipHash compression round; logs state transitions via `tracing` when enabled.\\n- `rotl64(x, b)` \u2013 `const fn` rotate-left useful in const contexts.\\n- `BitcoinSipHasher` \u2013 streaming SipHash-2-4 state:\\n  - `new(k0, k1)` \u2013 initialize state with a 128-bit key `(k0, k1)`.\\n  - `write(&mut self, data: &[u8])` \u2013 append arbitrary bytes.\\n  - `write_u64(&mut self, data: u64)` \u2013 append exactly 8 bytes in little-endian order, with alignment checking.\\n  - `finalize(&self) -> u64` \u2013 non-destructive finalization (does not mutate `self`).\\n- `sip_hash_uint256(k0, k1, &u256)` \u2013 optimized SipHash-2-4 for a 256-bit value.\\n- `sip_hash_uint_256extra(k0, k1, &u256, extra: u32)` \u2013 optimized SipHash-2-4 for a 256-bit value plus a 32-bit tag.\\n\\n---\\n\\n## Dependency surface\\n\\n- **Rust edition:** 2021\\n- **License:** MIT\\n- **Core dependencies:**\\n  - `tracing` for optional debug/trace instrumentation.\\n  - Derive macros `CopyGetters`, `MutGetters`, `Getters` (from `derive-getters` or equivalent), used to generate ergonomic accessors for `BitcoinSipHasher`'s internal state.\\n  - A `u256` type from a companion crate (for example, the `bitcoin-rs` project). This crate assumes a `u256` with a method `get_uint64(i: usize) -> u64` providing little-endian 64-bit limbs.\\n\\nYou are expected to supply a `u256` implementation that matches this interface if you directly use `sip_hash_uint256` or `sip_hash_uint_256extra`.\\n\\n---\\n\\n## Usage\\n\\n### 1. Basic keyed SipHash over arbitrary bytes\\n\\n```rust\\nuse bitcoin_siphash::BitcoinSipHasher;\\n\\nfn keyed_hash(key0: u64, key1: u64, msg: &[u8]) -> u64 {\\n    let mut hasher = BitcoinSipHasher::new(key0, key1);\\n    hasher.write(msg);\\n    hasher.finalize()\\n}\\n```\\n\\nThis uses the streaming interface with the exact SipHash-2-4 constant/round structure used in Bitcoin Core.\\n\\n### 2. Block-aligned `u64` streaming\\n\\nFor callers that naturally process 64-bit words, using `write_u64` is more direct:\\n\\n```rust\\nuse bitcoin_siphash::BitcoinSipHasher;\\n\\nfn hash_u64_blocks(key0: u64, key1: u64, blocks: &[u64]) -> u64 {\\n    let mut h = BitcoinSipHasher::new(key0, key1);\\n\\n    for &w in blocks {\\n        // Precondition: current count is a multiple of 8 bytes.\\n        h.write_u64(w);\\n    }\\n\\n    h.finalize()\\n}\\n```\\n\\nInternally, `write_u64` asserts that the byte count is aligned to 8 bytes. This mirrors Bitcoin Core's assumption that certain usages are limb-aligned.\\n\\n### 3. Hashing a 256-bit value (Bitcoin-style `uint256`)\\n\\nThe helper `sip_hash_uint256` is equivalent to constructing a `BitcoinSipHasher`, writing the four 64-bit limbs, and finalizing:\\n\\n```rust\\nuse bitcoin_siphash::sip_hash_uint256;\\nuse your_uint256_crate::u256; // you supply this\\n\\nfn short_id(key0: u64, key1: u64, txid: &u256) -> u64 {\\n    sip_hash_uint256(key0, key1, txid)\\n}\\n```\\n\\nConceptually, this is:\\n\\n```rust\\n// Pseudocode equivalence\\nlet h = BitcoinSipHasher::new(k0, k1)\\n    .write_u64(val.get_uint64(0))\\n    .write_u64(val.get_uint64(1))\\n    .write_u64(val.get_uint64(2))\\n    .write_u64(val.get_uint64(3));\\nlet out = h.finalize();\\n```\\n\\nBut implemented as a single optimized routine with fewer temporaries and branches.\\n\\n### 4. Hashing a 256-bit value plus a 32-bit tag\\n\\n`SipHashUint256Extra` from Bitcoin Core is translated as `sip_hash_uint_256extra` here. It treats the data as 32 bytes (`u256`) plus a 4-byte tag, for a total logical length of 36 bytes:\\n\\n```rust\\nuse bitcoin_siphash::sip_hash_uint_256extra;\\nuse your_uint256_crate::u256;\\n\\nfn hash_txid_with_tag(k0: u64, k1: u64, id: &u256, extra: u32) -> u64 {\\n    sip_hash_uint_256extra(k0, k1, id, extra)\\n}\\n```\\n\\nInternally, the length encoding and finalization steps are kept exactly as in the Bitcoin Core C++ implementation (including the `(36u64 << 56)` length tag and the standard `v2 ^= 0xFF` finalization pattern).\\n\\n---\\n\\n## Low-level macros: `rotl!` and `sipround!`\\n\\n### `rotl!`\\n\\n```rust\\nuse bitcoin_siphash::rotl;\\n\\nlet x: u64 = 0x0123_4567_89ab_cdef;\\nlet r: u32 = 13;\\nlet y: u64 = rotl!(x, r);\\nassert_eq!(y, x.rotate_left(r));\\n```\\n\\n`rotl!` is kept close in spirit to Bitcoin Core's `ROTL` macro, but leverages Rust's intrinsic `rotate_left` on integer types.\\n\\n### `sipround!`\\n\\n`sipround!` is the core compression round of SipHash. It operates on four mutable `u64` variables, which are passed by identifier. This design matches the original C++ macro but is macro-hygienic:\\n\\n```rust\\nuse bitcoin_siphash::sipround;\\n\\nlet (mut v0, mut v1, mut v2, mut v3) = (1u64, 2, 3, 4);\\n\\nsipround!(v0, v1, v2, v3);\\n// v0..v3 now contain the transformed state.\\n```\\n\\nWhen the `tracing` subscriber is enabled at trace level, entry and exit states of every `sipround!` invocation are logged. This is helpful for implementation verification and bit-level debugging against Bitcoin Core's reference output.\\n\\n---\\n\\n## `rotl64` helper\\n\\n```rust\\nuse bitcoin_siphash::rotl64;\\n\\nconst X: u64 = 0x0123_4567_89ab_cdef;\\nconst R: u32 = 32;\\nconst Y: u64 = rotl64(X, R);\\n\\n// Use Y in other const contexts.\\n```\\n\\n`rotl64` is a `const fn` rotate-left implementation, deliberately written with explicit shifts:\\n\\n```rust\\npub fn rotl64(x: u64, b: u32) -> u64 {\\n    (x << b) | (x >> (64 - b))\\n}\\n```\\n\\nThis allows the compiler to evaluate rotations at compile time without depending on macro expansion.\\n\\n---\\n\\n## Design notes and invariants\\n\\n### Streaming state (`BitcoinSipHasher`)\\n\\n`BitcoinSipHasher` keeps the standard SipHash internal state:\\n\\n- `v: [u64; 4]` \u2013 the four SipHash state words, keyed during `new(k0, k1)`.\\n- `tmp: u64` \u2013 buffer for partial 64-bit blocks constructed byte-by-byte.\\n- `count: u8` \u2013 total number of bytes absorbed so far modulo 256.\\n\\nKey invariants:\\n\\n- After any call to `write_u64`, `count % 8 == 0` (enforced by `assert_eq!`).\\n- `write` packs bytes into `tmp` little-endian, consuming a full block when `count & 7 == 0`.\\n- `finalize` computes the final 64-bit result by:\\n  1. Encoding the total byte count into the high 8 bits of the last partial word: `tmp | ((count as u64) << 56)`.\\n  2. Injecting that word into the state (`v3 ^= t; ... v0 ^= t`).\\n  3. Applying the standard `v2 ^= 0xFF` finalization constant and 4 SipRounds.\\n  4. XOR-folding `v0 ^ v1 ^ v2 ^ v3`.\\n\\n`finalize(&self)` is **non-destructive**: you may call it multiple times on the same state to recompute the digest without mutating the underlying state. This is different from some streaming interfaces that finalize by consuming.\\n\\n### Constant-time and branch behavior\\n\\nThe core block processing (`sipround!` and its use in `sip_hash_uint256` and `sip_hash_uint_256extra`) is branch-free with respect to secret data; loops in `write` may depend on input length but not on input value. This is consistent with the expectations for SipHash in protocol-adjacent contexts.\\n\\n---\\n\\n## Integration with `u256`\\n\\nThe crate assumes a `u256` with the following minimal interface:\\n\\n```rust\\ntrait U256Like {\\n    fn get_uint64(&self, i: usize) -> u64; // little-endian limb access: 0..=3\\n}\\n```\\n\\nThe `bitcoin-rs` repository (https://github.com/klebs6/bitcoin-rs) likely provides such a type. If you use a custom `u256`, you can write a small adapter or implement the same method signatures.\\n\\nThe order of limbs and the endianness are consensus-relevant if you are replicating Bitcoin Core behavior; ensure your `u256` matches Core's layout.\\n\\n---\\n\\n## Logging and diagnostics\\n\\nThe crate uses `tracing` macros (`trace!`, `debug!`) to instrument:\\n\\n- Hasher initialization (`BitcoinSipHasher::new`).\\n- `write_u64` input words.\\n- Entry/exit states of `sipround!` for both streaming use and compact helpers.\\n- Final output values of the high-level SipHash helpers.\\n\\nTo use this effectively, configure a subscriber with at least `Level::TRACE` in your application or tests. For performance-critical production builds where logs are not needed, compile with logging disabled or at a higher severity threshold.\\n\\n---\\n\\n## Example: verifying against Bitcoin Core\\n\\nA robust way to validate compatibility is to compare outputs with the C++ reference implementation. One pattern is:\\n\\n1. Choose fixed keys `(k0, k1)` and random `uint256` values.\\n2. Compute `SipHashUint256` / `SipHashUint256Extra` in C++.\\n3. Compute `sip_hash_uint256` / `sip_hash_uint_256extra` in Rust.\\n4. Assert equality for many test vectors.\\n\\nWith tracing enabled, you can also log intermediate states and compare per-round values.\\n\\n---\\n\\n## Safety, `no_std`, and environment assumptions\\n\\n- This crate is currently written assuming `std` is available (for logging infrastructure and potentially for dependencies). With minor adjustments (not documented here), it could be made `no_std` + `alloc`-friendly if the dependency stack permits.\\n- All arithmetic uses wrapping semantics (`wrapping_add`, shifts, and rotates) to match the original C++ code paths and to avoid undefined behavior.\\n\\n---\\n\\n## Repository and maintenance\\n\\n- **Repository:** <https://github.com/klebs6/bitcoin-rs>\\n- **Crate:** `bitcoin-siphash` (this component of the broader `bitcoin-rs` ecosystem)\\n- **License:** MIT\\n\\nIf you rely on this crate for consensus-adjacent code or production infrastructure, you should:\\n\\n- Vendor and pin exact versions (e.g., via `Cargo.lock` and reproducible builds).\\n- Maintain your own test vectors and CI that cross-check against Bitcoin Core.\\n\\n---\\n\\n## Disclaimer\\n\\nThis README was generated by an AI model based on the public interface and comments of the `bitcoin-siphash` crate. While care was taken to provide accurate and precise documentation, you should treat this as an auxiliary description, not as canonical specification. Always consult the crate source itself and upstream Bitcoin Core code when precision is critical.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"network-programming\",\n      \"development-tools\",\n      \"science\"\n    ],\n    \"package_description\": \"Bitcoin-Core-compatible SipHash-2-4 implementation in Rust, including low-level SIPROUND/ROTL macros, a streaming BitcoinSipHasher, and optimized helpers for hashing 256-bit values with optional 32-bit tags.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"siphash\",\n      \"hashing\",\n      \"cryptography\",\n      \"uint256\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 4782, "completion_tokens": 3728, "total_tokens": 8510, "prompt_tokens_details": {"cached_tokens": 0, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
