{"custom_id":"bitcoin-bitstream-ai-readme-request","method":"POST","url":"/v1/chat/completions","body":{"max_completion_tokens":8192,"messages":[{"content":"We would like you to write a README.md for a rust crate with maximally helpful content.\nAdditionally, we would like you to generate several fields from the Cargo.toml package section for this crate.\nWe will show you the strict json output format we would like you to provide.\nPlease tailor your response for an apex consumer of maximal intelligence.\nA reader of this README.md should have a good sense of what the crate does and how to use it after reading what you write.\nPlease include a messaage indicating that this README.md file was generated by an AI model and may not be 100% accurate however it should be pretty good.\n\n\nCarefully read and parse the information we sent you.\n\nWe want to generate all information items requested by our schema:\n\n- Read the description of each field. Use it, along with the content we sent you to generate an appropriate value for each.\n- Ensure that each generated field optimally serves its desired purpose.\n- Each item should be deep, detailed, and specific. Use optimally descriptive and useful language. Do not be too verbose.\n- Do not add any extra keys to the generated object. Generate precisely what we ask of you: no more, no less.\n- For fields which are of an enum type: pick *exactly one variant*. Do not generate any information for the unselected variants.\n- For array fields: supply a JSON list [ ... ] of items, each conforming to the correct item type.\n- For map fields: Provide a JSON object { \"key_as_string\": <value>, ... }. Keys must be valid JSON strings. Keys and Values must conform to the key and value schemas we provide to you. Fill all subfields of each and every map value.\n- If we ask you to justify a map field, provide your justification/confidence score for the entire map. Do not attempt to separately justify each map element.\n- Likewise, if we ask you to justify an array field, provide your justification/confidence score for the entire array. Do not attempt to separately justify each element.\n- Provide numeric fields as real JSON numbers (not strings).\n- For string fields: provide the value precisely as a string literal. If optional, you may set it to null.\n- If we ask you to justify or provide confidence scores for the fields of a structure, please do so carefully. For each field we ask you to justify, please explain or justify your choice clearly. Confidence scores must be specified as real JSON numbers in the range `[0..1]`.\n- If we ask to you generate an optional field, either fill it or set it to null.\n- If we ask you to justify your choice of an enum variant, please explain your choice clearly. Do not justify your decision to leave a variant unselected. Provide your justification as a JSON string. Provide your confidence score as a real JSON number in the range `[0..1]`.\n- In terms of the JSON format we would like you to provide, the object itself will be deserialied based on the following schema. \n- We begin exactly at the top: the data should not be nested under a parent named 'fields' or anything similar.\n\n## Here is the schema to use:\n\nObject {\n    \"fields\": Object {\n        \"crate_name\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be the name of our crate, *verbatim*, trimmed for use as a toml field\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"full_readme_markdown\": Object {\n            \"generation_instructions\": String(\"\\\"This string should be valid markdown representing the readme for this crate.\\\\n\\\\n Please make it terse, useful, and designed for an industrious commercially savy consumer of industrious nature. \\\\n\\\\n Advanced vocabulary and concepts are welcome. \\\\n\\\\n If this crate involves concepts from mathematics and/or physics, please describe and document them here.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_categories\": Object {\n            \"generation_instructions\": String(\"\\\"These categories will be used in our Cargo.toml file.\\\\n\\\\n It is important that users of this crate can find it on crates.io.\\\\n\\\\n Choose maximum 5 categories and make sure they are actually meaningful for our crate.\\\\n\\\\n These categories should only be chosen from among the legal crates.io categories. \\\\n\\\\n The ONLY legal categoreis are:\\\\n\\\\n``\\\\n accessibility\\\\n aerospace\\\\n algorithms\\\\n api-bindings\\\\n asynchronous\\\\n authentication\\\\n caching\\\\n command-line-interface\\\\n command-line-utilities\\\\n compilers\\\\n compression\\\\n computer-vision\\\\n concurrency\\\\n config\\\\n cryptography\\\\n data-structures\\\\n database\\\\n database-implementations\\\\n date-and-time\\\\n development-tools\\\\n email\\\\n embedded\\\\n emulators\\\\n encoding\\\\n external-ffi-bindings\\\\n filesystem\\\\n finance\\\\n game-development\\\\n game-engines\\\\n games\\\\n graphics\\\\n gui\\\\n hardware-support\\\\n internationalization\\\\n localization\\\\n mathematics\\\\n memory-management\\\\n multimedia\\\\n network-programming\\\\n no-std\\\\n os\\\\n parser-implementations\\\\n parsing\\\\n rendering\\\\n rust-patterns\\\\n science\\\\n simulation\\\\n template-engine\\\\n text-editors\\\\n text-processing\\\\n value-formatting\\\\n virtualization\\\\n visualization\\\\n wasm\\\\n web-programming\\\\n ``\\\\n\\\\n DO NOT specify a category that is not on this list.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n        \"package_description\": Object {\n            \"generation_instructions\": String(\"\\\"We will place this package_description in our Cargo.toml file so the users of this crate\\\\n know what it does.\\\\n\\\\n The discription should be technical, clear, and useful. It should be terse.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"string\"),\n        },\n        \"package_keywords\": Object {\n            \"generation_instructions\": String(\"\\\"These keywords will be used in our Cargo.toml file so the users of this crate can easily\\\\n find it in the package system. Keywords should be useful, varied, meaningful, and reflect\\\\n the contents of our crate. They should make it easy to find. Please provide exactly five.\\\"\"),\n            \"required\": Bool(true),\n            \"type\": String(\"array_of_strings\"),\n        },\n    },\n    \"struct_docs\": String(\" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\"),\n    \"struct_name\": String(\"AiReadmeWriterDesiredOutput\"),\n    \"type\": String(\"struct\"),\n}\n\n## Please keep the following in mind:\n\nEntry phrasing:\n\n- Ensure entries are concise and focused.\n- Ensure there are no vague phrases (e.g., avoid starting with \"Illustrates the something something...\"; instead, use direct details like \"The hanging green vines on the garden wall\").\n\nEnsure Clarity and Consistency:\n\n- Use clear, grammatically correct sentences.\n- Maintain a consistent tone and style throughout.\n\nEnrich Content:\n\n- Communicate additional information where appropriate to enhance depth and value.\n- If a mathematical, physical, or otherwise technical background is helpful, please provide it.\n- Ensure that the content is comprehensive and meets all requirements.\n\nFocus Language:\n\n- Use deliberate and precise language.\n- Avoid vague verbs and keep the maximally intelligent and detail oriented audience in mind. \n- We explicitly ban the words `hush`, `subtle`, `mythic`, and `aura`. Please keep your vocabulary choices rigorous.\n- Do not use modern cultural references \n- Do not generically reference ideas which do not belong in the global environment.\n\n## Present the Final JSON:\n\n- Format the output as a JSON object.\n- Include all fields properly named from the schema we sent you.\n\nEnsure Proper Formatting:\n\n- Use proper JSON syntax with keys and arrays.\n- Ensure that all entries are correctly placed in their respective places.\n\nProvide only the final JSON data as specified by the schema. \n\nDo not include any schema generation instructions, meta-fields, nested-templates (unless directly asked) or extraneous information. \n\nProvide only the populated fields and their values, conforming exactly to the required structure without embedding any intermediate annotations or placeholders.\n\nYour output should only consist of the JSON object. do *not* include a preamble or postamble to your response. \n\nWe seek to successfully parse your response directly as JSON.\n\nFor the final answer, output the result only as a valid JSON object, wrapped inside triple backticks with json immediately after the opening backticks.\nThe JSON must be parser-ready:\n– No additional text before or after the block\n– No markdown or prose outside the fenced block\n– No HTML escaping of quotes, slashes, or other characters\n– Indentation and whitespace preserved exactly as written\n– The content between the fences must be valid JSON as per RFC 8259","role":"system"},{"content":"We have a rust crate named 'bitcoin-bitstream' 0.1.19. \n\nHere is the interface:\n/// Backend API required by `OverrideStream`.\npub trait Backend {\n    fn size(&self) -> usize;\n    fn ignore(&mut self, amount: usize);\n}\n\n\npub trait GetType {\n    fn get_type(&self) -> i32;\n}\n\n\npub trait GetVersion {\n    fn get_version(&self) -> i32;\n}\n\n\npub trait StreamItems {\n    fn stream<Item>(&mut self, x: Item);\n}\n\n\npub trait StreamInto {\n    fn stream_into<Item>(&self, x: &mut Item);\n}\n\n\npub trait Init {\n    fn init(&mut self) -> bool;\n}\n\ntype ZeroAfterFreeVecIter = std::vec::IntoIter<u8, ZeroAfterFreeAllocator>;\n\n#[derive(Getters, Setters, Builder)]\n#[getset(get = \"pub\", set = \"pub\")]\npub struct OverrideStream<Stream>  {\n    stream:    *mut Stream,\n    n_type:    i32,\n    n_version: i32,\n}\n\n\n/// A dummy data type to identify deserializing constructors.\n///\n/// By convention, a constructor of T with signature:\n///    `T::T(deserialize_type, Stream& s)`\n/// is a deserializing constructor in C++ code.\npub struct DeserializeType  { }\n\n\n#[derive(Getters, Setters, Builder)]\n#[getset(get = \"pub\", set = \"pub\")]\npub struct BitStreamReader<IStream: Default + Read>  {\n    istream: Rc<RefCell<IStream>>,\n    buffer:  u8,\n    offset:  i32,\n}\n\n\n#[derive(Getters, Setters, Builder)]\n#[getset(get = \"pub\", set = \"pub\")]\npub struct BitStreamWriter<OStream: Default + Write>  {\n    ostream: Rc<RefCell<OStream>>,\n    buffer:  u8,\n    offset:  i32,\n}\n\n\n#[derive(Getters, Setters, Builder)]\n#[getset(get = \"pub\", set = \"pub\")]\npub struct DataStream  {\n    vch:        SerializeData,\n    n_read_pos: u32,\n    n_type:     i32,\n    n_version:  i32,\n}\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn writebe16(ptr: *mut u8, x: u16) {\n    info!(\"writebe16 called with 0x{:04X}\", x);\n    let bytes = x.to_be_bytes();\n    unsafe {\n        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr, 2);\n    }\n    debug!(\"writebe16 completed\");\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn writele16(ptr: *mut u8, x: u16) {\n    info!(\"writele16 called with 0x{:04X}\", x);\n    let bytes = x.to_le_bytes();\n    unsafe {\n        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr, 2);\n    }\n    debug!(\"writele16 completed\");\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn writele32(ptr: *mut u8, x: u32) {\n    info!(\"writele32 called with 0x{:08X}\", x);\n    let bytes = x.to_le_bytes();\n    unsafe {\n        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr, 4);\n    }\n    debug!(\"writele32 completed\");\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn writele64(ptr: *mut u8, x: u64) {\n    info!(\"writele64 called with 0x{:016X}\", x);\n    let bytes = x.to_le_bytes();\n    unsafe {\n        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr, 8);\n    }\n    debug!(\"writele64 completed\");\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn writebe32(ptr: *mut u8, x: u32) {\n    info!(\"writebe32 called with 0x{:08X}\", x);\n    let bytes = x.to_be_bytes();\n    unsafe {\n        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr, 4);\n    }\n    debug!(\"writebe32 completed\");\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn writebe64(ptr: *mut u8, x: u64) {\n    info!(\"writebe64 called with 0x{:016X}\", x);\n    let bytes = x.to_be_bytes();\n    unsafe {\n        std::ptr::copy_nonoverlapping(bytes.as_ptr(), ptr, 8);\n    }\n    debug!(\"writebe64 completed\");\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn readle16(ptr: *const u8) -> u16 {\n    info!(\"readle16 called\");\n    unsafe {\n        let mut tmp = [0u8; 2];\n        std::ptr::copy_nonoverlapping(ptr, tmp.as_mut_ptr(), 2);\n        let val = u16::from_le_bytes(tmp);\n        debug!(\"readle16 returning 0x{:04X}\", val);\n        val\n    }\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn readle32(ptr: *const u8) -> u32 {\n    info!(\"readle32 called\");\n    unsafe {\n        let mut tmp = [0u8; 4];\n        std::ptr::copy_nonoverlapping(ptr, tmp.as_mut_ptr(), 4);\n        let val = u32::from_le_bytes(tmp);\n        debug!(\"readle32 returning 0x{:08X}\", val);\n        val\n    }\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn readle64(ptr: *const u8) -> u64 {\n    info!(\"readle64 called\");\n    unsafe {\n        let mut tmp = [0u8; 8];\n        std::ptr::copy_nonoverlapping(ptr, tmp.as_mut_ptr(), 8);\n        let val = u64::from_le_bytes(tmp);\n        debug!(\"readle64 returning 0x{:016X}\", val);\n        val\n    }\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn readbe16(ptr: *const u8) -> u16 {\n    info!(\"readbe16 called\");\n    unsafe {\n        let mut tmp = [0u8; 2];\n        std::ptr::copy_nonoverlapping(ptr, tmp.as_mut_ptr(), 2);\n        let val = u16::from_be_bytes(tmp);\n        debug!(\"readbe16 returning 0x{:04X}\", val);\n        val\n    }\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn readbe32(ptr: *const u8) -> u32 {\n    info!(\"readbe32 called\");\n    unsafe {\n        let mut tmp = [0u8; 4];\n        std::ptr::copy_nonoverlapping(ptr, tmp.as_mut_ptr(), 4);\n        let val = u32::from_be_bytes(tmp);\n        debug!(\"readbe32 returning 0x{:08X}\", val);\n        val\n    }\n}\n\n\n#[instrument(level = \"trace\", skip(ptr))]\n#[inline]\npub fn readbe64(ptr: *const u8) -> u64 {\n    info!(\"readbe64 called\");\n    unsafe {\n        let mut tmp = [0u8; 8];\n        std::ptr::copy_nonoverlapping(ptr, tmp.as_mut_ptr(), 8);\n        let val = u64::from_be_bytes(tmp);\n        debug!(\"readbe64 returning 0x{:016X}\", val);\n        val\n    }\n}\n\n\n#[instrument(level = \"trace\")]\npub fn count_bits(x: u64) -> u64 {\n    info!(\"count_bits invoked with x={}\", x);\n    // \"Return the smallest number n such that (x >> n) == 0 (or 64 if highest bit is set).\"\n    // Equivalently, in Rust we can do:\n    let count = if x == 0 {\n        0\n    } else {\n        64 - x.leading_zeros() as u64\n    };\n    debug!(\"count_bits returning {}\", count);\n    count\n}\n\nimpl<Stream> StreamInto for OverrideStream<Stream> {\n\n    #[inline]\n    fn stream_into<Item>(&self, _rhs: &mut Item) {\n        todo!(\"OverrideStream::stream_into placeholder called\");\n        // ::Serialize(*this, obj) in C++ (not implemented here)\n    }\n}\n\nimpl<Stream> StreamItems for OverrideStream<Stream> {\n\n    #[inline]\n    fn stream<Item>(&mut self, _x: Item) {\n        todo!(\"OverrideStream::stream placeholder called\");\n        // ::Unserialize(*this, obj) in C++ (not implemented here)\n    }\n}\n\nimpl<Stream> GetType for OverrideStream<Stream> {\n\n    fn get_type(&self) -> i32 {\n        self.n_type\n    }\n}\n\nimpl<Stream> GetVersion for OverrideStream<Stream> {\n\n    fn get_version(&self) -> i32 {\n        self.n_version\n    }\n}\n\nimpl<Stream: Backend> OverrideStream<Stream> {\n\n    #[instrument(level = \"trace\")]\n    pub fn new(stream_ptr: *mut Stream, n_type_in: i32, n_version_in: i32) -> Self {\n        info!(\"Constructing OverrideStream, type={} version={}\", n_type_in, n_version_in);\n        Self {\n            stream: stream_ptr,\n            n_type: n_type_in,\n            n_version: n_version_in,\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self, pch))]\n    pub fn write(&mut self, pch: *const u8, n_size: usize) {\n        info!(\"OverrideStream::write called, n_size={}\", n_size);\n        unsafe {\n            if let Some(s) = self.stream.as_mut() {\n                let slice = std::slice::from_raw_parts(pch, n_size);\n                s.write_all(slice).expect(\"OverrideStream backend write failed\");\n            } else {\n                error!(\"OverrideStream has null pointer to Stream\");\n                panic!(\"OverrideStream::write called on null stream pointer\");\n            }\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self, pch))]\n    pub fn read(&mut self, pch: *mut u8, n_size: usize) {\n        info!(\"OverrideStream::read called, n_size={}\", n_size);\n        unsafe {\n            if let Some(s) = self.stream.as_mut() {\n                let slice = std::slice::from_raw_parts_mut(pch, n_size);\n                s.read_exact(slice).expect(\"OverrideStream backend read failed\");\n            } else {\n                error!(\"OverrideStream has null pointer to Stream\");\n                panic!(\"OverrideStream::read called on null stream pointer\");\n            }\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn size(&self) -> usize {\n        unsafe {\n            self.stream.as_ref().map_or(0, |s| s.size())\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn ignore(&mut self, amount: usize) {\n        info!(\"OverrideStream::ignore called, amount={}\", amount);\n        unsafe {\n            if let Some(s) = self.stream.as_mut() {\n                s.ignore(amount);\n            } else {\n                error!(\"OverrideStream has null pointer to Stream\");\n                panic!(\"OverrideStream::ignore called on null stream pointer\");\n            }\n        }\n    }\n}\n\nimpl<IStream: Default + Read> BitStreamReader<IStream> {\n\n    #[instrument(level = \"trace\", skip(istream))]\n    pub fn new(istream: Rc<RefCell<IStream>>) -> Self {\n        info!(\"Constructing BitStreamReader\");\n        Self {\n            istream,\n            buffer: 0,\n            offset: 8, // match the original c++ default\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn read(&mut self, mut nbits: i32) -> u64 {\n        use std::io::{Read as _, Error};          // bring trait into scope\n    \n        info!(\"Reading {} bits from BitStreamReader\", nbits);\n    \n        if !(0..=64).contains(&nbits) {\n            error!(\"Invalid nbits: {}\", nbits);\n            panic!(\"nbits must be between 0 and 64\");\n        }\n    \n        let mut data: u64 = 0;\n        while nbits > 0 {\n            if self.offset == 8 {\n                trace!(\"Offset == 8; fetching next byte from underlying stream\");\n                let mut one_byte = [0u8; 1];\n                self.istream\n                    .borrow_mut()\n                    .read_exact(&mut one_byte)\n                    .expect(\"BitStreamReader: underlying stream read failed\");\n                self.buffer = one_byte[0];\n                self.offset = 0;\n            }\n    \n            let bits = (8 - self.offset).min(nbits);\n            data <<= bits;\n    \n            let shifted = ((self.buffer << self.offset) & 0xFF) >> (8 - bits);\n            data |= shifted as u64;\n    \n            self.offset += bits;\n            nbits       -= bits;\n        }\n    \n        debug!(\"BitStreamReader returning data={}\", data);\n        data\n    }\n}\n\nimpl<OStream: Default + Write> Drop for BitStreamWriter<OStream> {\n\n    #[instrument(level = \"trace\", skip(self))]\n    fn drop(&mut self) {\n        info!(\"Dropping BitStreamWriter, flushing pending bits\");\n        self.flush();\n    }\n}\n\nimpl<OStream: Default + Write> BitStreamWriter<OStream> {\n\n    #[instrument(level = \"trace\", skip(ostream))]\n    pub fn new(ostream: Rc<RefCell<OStream>>) -> Self {\n        info!(\"Constructing BitStreamWriter\");\n        Self {\n            ostream,\n            buffer: 0,\n            offset: 0,\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn write(&mut self, data: u64, mut nbits: i32) {\n        info!(\"BitStreamWriter writing {} bits from data={}\", nbits, data);\n    \n        if nbits < 0 || nbits > 64 {\n            error!(\"Invalid nbits: {}\", nbits);\n            panic!(\"nbits must be between 0 and 64\");\n        }\n    \n        while nbits > 0 {\n            let bits = (8 - self.offset).min(nbits);\n            // from c++: m_buffer |= (data << (64 - nbits)) >> (64 - 8 + m_offset);\n    \n            let shift_amount = 64 - nbits;\n            let partial = ((data << shift_amount) >> (64 - 8 + self.offset)) as u8;\n            self.buffer |= partial;\n    \n            self.offset += bits;\n            nbits       -= bits;\n    \n            if self.offset == 8 {\n                self.flush();\n            }\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn flush(&mut self) {\n        use std::io::Write as _;                  // bring trait into scope\n    \n        debug!(\"BitStreamWriter flush called, offset={}\", self.offset);\n    \n        if self.offset == 0 {\n            trace!(\"Nothing to flush (offset = 0)\");\n            return;\n        }\n    \n        let one_byte = [self.buffer];\n        self.ostream\n            .borrow_mut()\n            .write_all(&one_byte)\n            .expect(\"BitStreamWriter: underlying stream write failed\");\n    \n        self.buffer = 0;\n        self.offset = 0;\n    }\n}\n\nimpl std::ops::Index<usize> for DataStream {\n\n    type Output = u8;\n\n    #[inline]\n    fn index(&self, pos: usize) -> &Self::Output {\n        &self.vch[pos + self.n_read_pos as usize]\n    }\n}\n\nimpl std::ops::IndexMut<usize> for DataStream {\n\n    #[inline]\n    fn index_mut(&mut self, pos: usize) -> &mut Self::Output {\n        &mut self.vch[pos + self.n_read_pos as usize]\n    }\n}\n\nimpl StreamInto for DataStream {\n\n    #[inline]\n    fn stream_into<Item>(&self, _rhs: &mut Item) {\n        trace!(\"DataStream::stream_into called, but not implemented in this translation\");\n        // Equivalent to ::Serialize(*this, obj) in C++\n        // We do not have a direct \"Serialize\" function in this snippet, so it's a placeholder.\n    }\n}\n\nimpl StreamItems for DataStream {\n\n    #[inline]\n    fn stream<Item>(&mut self, _x: Item) {\n        trace!(\"DataStream::stream called, but not implemented in this translation\");\n        // Equivalent to ::Unserialize(*this, obj) in C++\n        // We do not have a direct \"Unserialize\" function in this snippet, so it's a placeholder.\n    }\n}\n\nimpl DataStream {\n\n    #[instrument(level = \"trace\")]\n    pub fn new(n_type_in: i32, n_version_in: i32) -> Self {\n        info!(\"Constructing DataStream (empty), type={} version={}\", n_type_in, n_version_in);\n        Self {\n            vch: Vec::<u8,ZeroAfterFreeAllocator>::new_in(ZeroAfterFreeAllocator),\n            n_read_pos: 0,\n            n_type: n_type_in,\n            n_version: n_version_in,\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(sp))]\n    pub fn new_with_slice(sp: &[u8], n_type_in: i32, n_version_in: i32) -> Self {\n        info!(\"Constructing DataStream from slice, type={} version={}\", n_type_in, n_version_in);\n        let mut v: SerializeData = Vec::<u8,ZeroAfterFreeAllocator>::new_in(ZeroAfterFreeAllocator);\n        v.extend_from_slice(sp);\n    \n        Self {\n            vch: v,\n            n_read_pos: 0,\n            n_type: n_type_in,\n            n_version: n_version_in,\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(_args))]\n    pub fn new_with_args<Args>(n_type_in: i32, n_version_in: i32, _args: Args) -> Self {\n        info!(\"Constructing DataStream with args, type={} version={}\", n_type_in, n_version_in);\n        // In C++ code, this calls ::SerializeMany(*this, args...).\n        // This snippet is a placeholder, as we do not have the real definition for SerializeMany.\n        Self {\n            vch: Vec::<u8,ZeroAfterFreeAllocator>::new_in(ZeroAfterFreeAllocator),\n            n_read_pos: 0,\n            n_type: n_type_in,\n            n_version: n_version_in,\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn str_(&self) -> String {\n        info!(\"DataStream::str_ called, returning string from internal buffer\");\n        String::from_utf8_lossy(&self.vch[self.n_read_pos as usize..]).to_string()\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn begin(&self) -> std::slice::Iter<'_, u8> {\n        self.vch[self.n_read_pos as usize..].iter()\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn begin_mut(&mut self) -> std::slice::IterMut<'_, u8> {\n        let start = self.n_read_pos as usize;\n        self.vch[start..].iter_mut()\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn end(&self) -> std::slice::Iter<'_, u8> {\n        // This returns an empty iterator at the end\n        self.vch[self.vch.len()..].iter()\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn end_mut(&mut self) -> std::slice::IterMut<'_, u8> {\n        let end = self.vch.len();\n        self.vch[end..].iter_mut()\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn size(&self) -> usize {\n        let sz = self.vch.len().saturating_sub(self.n_read_pos as usize);\n        trace!(\"DataStream::size returning {}\", sz);\n        sz\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn empty(&self) -> bool {\n        let is_empty = self.n_read_pos as usize == self.vch.len();\n        trace!(\"DataStream::empty returning {}\", is_empty);\n        is_empty\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn resize(&mut self, n: usize, c: Option<u8>) {\n        let fill = c.unwrap_or(0);\n        info!(\"DataStream::resize to {}, fill={}\", n, fill);\n        self.vch.resize(n + self.n_read_pos as usize, fill);\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn reserve(&mut self, n: usize) {\n        info!(\"DataStream::reserve to {}\", n);\n        self.vch.reserve(n + self.n_read_pos as usize);\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn clear(&mut self) {\n        info!(\"DataStream::clear called\");\n        self.vch.clear();\n        self.n_read_pos = 0;\n    }\n\n    #[instrument(level = \"trace\", skip(self, it))]\n    pub fn insert_item(&mut self, it: std::slice::Iter<'_, u8>, x: u8) -> ZeroAfterFreeVecIter {\n        info!(\"DataStream::insert_item called, single byte={}\", x);\n        let idx = (it.as_slice().as_ptr() as usize)\n            .saturating_sub(self.vch.as_ptr() as usize);\n        self.vch.insert(idx, x);\n        self.vch.clone().into_iter()\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn insert_multi(\n        &mut self,\n        it:        std::slice::Iter<'_, u8>,\n        n:         usize,\n        x:         u8\n    )\n    {\n        info!(\"DataStream::insert_multi called, inserting {} copies of {}\", n, x);\n        let idx = (it.as_slice().as_ptr() as usize)\n            .saturating_sub(self.vch.as_ptr() as usize);\n        self.vch.splice(idx..idx, std::iter::repeat(x).take(n));\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn as_slice(&self) -> &[u8] {\n        let start = self.n_read_pos as usize;\n        &self.vch[start..]\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n        let start = self.n_read_pos as usize;\n        &mut self.vch[start..]\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn data_mut(&mut self) -> *mut u8 {\n        let start = self.n_read_pos as usize;\n        let ptr = self.vch.as_mut_ptr().wrapping_add(start);\n        trace!(\"DataStream::data_mut returning pointer={:?}\", ptr);\n        ptr\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn data(&self) -> *const u8 {\n        let start = self.n_read_pos as usize;\n        let ptr = self.vch.as_ptr().wrapping_add(start);\n        trace!(\"DataStream::data returning pointer={:?}\", ptr);\n        ptr\n    }\n\n    #[instrument(level = \"trace\", skip(self, first, last))]\n    pub fn insert_with_iterator_range(\n        &mut self,\n        it:        std::slice::Iter<'_, u8>,\n        mut first: std::slice::Iter<'_, u8>,\n        mut last:  std::slice::Iter<'_, u8>\n    )\n    {\n        info!(\"DataStream::insert_with_iterator_range called\");\n        let first_ptr = first.as_slice().as_ptr() as usize;\n        let last_ptr  = last.as_slice().as_ptr() as usize;\n        if last_ptr == first_ptr {\n            trace!(\"Nothing to insert; last == first\");\n            return;\n        }\n        let count = last_ptr.saturating_sub(first_ptr);\n        let idx   = (it.as_slice().as_ptr() as usize)\n            .saturating_sub(self.vch.as_ptr() as usize);\n    \n        // In the original C++: if it==vch.begin()+nReadPos and count <= nReadPos, do special front insert\n        let front_idx = self.n_read_pos as usize;\n        if idx == front_idx && count <= front_idx {\n            trace!(\"Performing special front insertion with memmove\");\n            self.n_read_pos -= count as u32;\n            // Move the data into the front region:\n            unsafe {\n                let dst = self.vch.as_mut_ptr().add(self.n_read_pos as usize);\n                let src = first.as_slice().as_ptr();\n                std::ptr::copy(src, dst, count);\n            }\n        } else {\n            let src_slice = &first.as_slice()[..count];\n            self.vch.splice(idx..idx, src_slice.iter().cloned());\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn insert_with_pointer_range(\n        &mut self,\n        it:        std::slice::Iter<'_, u8>,\n        first:     *const u8,\n        last:      *const u8\n    )\n    {\n        info!(\"DataStream::insert_with_pointer_range called\");\n        let count = unsafe { last.offset_from(first) };\n        if count <= 0 {\n            trace!(\"Nothing to insert; last == first or invalid range\");\n            return;\n        }\n        let idx = (it.as_slice().as_ptr() as usize)\n            .saturating_sub(self.vch.as_ptr() as usize);\n    \n        let front_idx = self.n_read_pos as usize;\n        if idx == front_idx && (count as u32) <= self.n_read_pos {\n            trace!(\"Performing special front insertion with memmove\");\n            self.n_read_pos -= count as u32;\n            unsafe {\n                let dst = self.vch.as_mut_ptr().add(self.n_read_pos as usize);\n                std::ptr::copy_nonoverlapping(first, dst, count as usize);\n            }\n        } else {\n            let src_slice = unsafe {\n                std::slice::from_raw_parts(first, count as usize)\n            };\n            self.vch.splice(idx..idx, src_slice.iter().cloned());\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn erase(&mut self, it: std::slice::Iter<'_, u8>) -> ZeroAfterFreeVecIter {\n        info!(\"DataStream::erase called\");\n        let idx = (it.as_slice().as_ptr() as usize)\n            .saturating_sub(self.vch.as_ptr() as usize);\n    \n        if idx == self.n_read_pos as usize {\n            self.n_read_pos += 1;\n            if self.n_read_pos as usize >= self.vch.len() {\n                trace!(\"Erasing everything; clearing data\");\n                self.n_read_pos = 0;\n                self.vch.clear();\n            }\n        } else {\n            self.vch.remove(idx);\n        }\n        self.vch.clone().into_iter()\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn erase_range(&mut self, first: std::slice::Iter<'_, u8>, last: std::slice::Iter<'_, u8>) -> ZeroAfterFreeVecIter {\n        info!(\"DataStream::erase_range called\");\n        let first_idx = (first.as_slice().as_ptr() as usize)\n            .saturating_sub(self.vch.as_ptr() as usize);\n        let last_idx  = (last.as_slice().as_ptr() as usize)\n            .saturating_sub(self.vch.as_ptr() as usize);\n    \n        if first_idx == self.n_read_pos as usize && last_idx == self.vch.len() {\n            trace!(\"Front‑to‑end erase; clearing\");\n            self.n_read_pos = 0;\n            self.vch.clear();\n        } else if first_idx == self.n_read_pos as usize {\n            trace!(\"Front‑to‑mid erase\");\n            self.n_read_pos = last_idx as u32;\n        } else {\n            self.vch.drain(first_idx..last_idx);\n        }\n        self.vch.clone().into_iter()\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn compact(&mut self) {\n        info!(\"DataStream::compact called\");\n        let front_idx = self.n_read_pos as usize;\n        if front_idx > 0 && front_idx <= self.vch.len() {\n            self.vch.drain(0..front_idx);\n        }\n        self.n_read_pos = 0;\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn rewind(&mut self, n: Option<usize>) -> bool {\n        info!(\"DataStream::rewind called with n={:?}\", n);\n        match n {\n            None => {\n                self.n_read_pos = 0;\n                true\n            }\n            Some(val) => {\n                if val > self.n_read_pos as usize {\n                    trace!(\"Cannot rewind; requested more than n_read_pos\");\n                    false\n                } else {\n                    self.n_read_pos -= val as u32;\n                    true\n                }\n            }\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn eof(&self) -> bool {\n        let end = self.size() == 0;\n        trace!(\"DataStream::eof returning {}\", end);\n        end\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn rdbuf(&mut self) -> *mut DataStream {\n        let ptr = self as *mut DataStream;\n        trace!(\"DataStream::rdbuf returning self pointer={:?}\", ptr);\n        ptr\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn in_avail(&self) -> i32 {\n        let avail = self.size() as i32;\n        trace!(\"DataStream::in_avail returning {}\", avail);\n        avail\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_type(&mut self, n: i32) {\n        info!(\"DataStream::set_type to {}\", n);\n        self.n_type = n;\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn get_type(&self) -> i32 {\n        trace!(\"DataStream::get_type returning {}\", self.n_type);\n        self.n_type\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn set_version(&mut self, n: i32) {\n        info!(\"DataStream::set_version to {}\", n);\n        self.n_version = n;\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn get_version(&self) -> i32 {\n        trace!(\"DataStream::get_version returning {}\", self.n_version);\n        self.n_version\n    }\n\n    #[instrument(level = \"trace\", skip(self, pch))]\n    pub fn read(&mut self, pch: *mut u8, n_size: usize) {\n        info!(\"DataStream::read called, n_size={}\", n_size);\n        if n_size == 0 {\n            trace!(\"Nothing to read, returning early\");\n            return;\n        }\n        let n_read_pos_next = self.n_read_pos as usize + n_size;\n        if n_read_pos_next > self.vch.len() {\n            error!(\"DataStream::read end of data: requested beyond buffer\");\n            panic!(\"DataStream::read(): end of data\");\n        }\n        unsafe {\n            let src_slice = &self.vch[self.n_read_pos as usize..n_read_pos_next];\n            std::ptr::copy_nonoverlapping(src_slice.as_ptr(), pch, n_size);\n        }\n        if n_read_pos_next == self.vch.len() {\n            trace!(\"Read consumed entire buffer; clearing\");\n            self.n_read_pos = 0;\n            self.vch.clear();\n            return;\n        }\n        self.n_read_pos = n_read_pos_next as u32;\n    }\n\n    #[instrument(level = \"trace\", skip(self))]\n    pub fn ignore(&mut self, n_size: i32) {\n        info!(\"DataStream::ignore called, n_size={}\", n_size);\n        if n_size < 0 {\n            error!(\"Negative n_size passed to DataStream::ignore\");\n            panic!(\"DataStream::ignore(): nSize negative\");\n        }\n        let next = self.n_read_pos as i32 + n_size;\n        if next as usize >= self.vch.len() {\n            if next as usize > self.vch.len() {\n                error!(\"Attempted to ignore beyond end of data in DataStream\");\n                panic!(\"DataStream::ignore(): end of data\");\n            }\n            trace!(\"Ignoring up to the end; clearing\");\n            self.n_read_pos = 0;\n            self.vch.clear();\n            return;\n        }\n        self.n_read_pos = next as u32;\n    }\n\n    #[instrument(level = \"trace\", skip(self, pch))]\n    pub fn write(&mut self, pch: *const u8, n_size: usize) {\n        info!(\"DataStream::write called, n_size={}\", n_size);\n        unsafe {\n            let slice = std::slice::from_raw_parts(pch, n_size);\n            self.vch.extend_from_slice(slice);\n        }\n    }\n\n    #[instrument(level = \"trace\", skip(self, _s))]\n    pub fn serialize<Stream>(&self, _s: &mut Stream) {\n        info!(\"DataStream::serialize placeholder called\");\n        // In C++: if !vch.empty(), s.write((char*)vch.data(), vch.size());\n        // We have no direct definition of Stream::write in this snippet, so we omit the real call.\n    }\n\n    #[instrument(level = \"trace\", skip(self, key))]\n    pub fn xor(&mut self, key: &Vec<u8>) {\n        info!(\"DataStream::xor called with key len={}\", key.len());\n        if key.is_empty() {\n            trace!(\"Key is empty, nothing to XOR\");\n            return;\n        }\n        let mut j = 0usize;\n        let ksize = key.len();\n        for i in 0..self.size() {\n            self.vch[i + self.n_read_pos as usize] ^= key[j];\n            j += 1;\n            if j == ksize {\n                j = 0;\n            }\n        }\n    }\n}\n\n\nThis crate has the following authors:\n[\n    \"klebs <none>\",\n]\nThis crate has the following rust edition:\n2021\nThis crate has the following license:\nMIT\nThis crate is held in the following repository:\nhttps://github.com/klebs6/bitcoin-rs\n","role":"user"}],"model":"gpt-5.1"}}
