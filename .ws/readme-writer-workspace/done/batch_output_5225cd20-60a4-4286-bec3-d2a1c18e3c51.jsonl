{"id": "batch_req_692cda2e81b08190a536625c80cfbe37", "custom_id": "bitcoin-compat-ai-readme-request", "response": {"status_code": 200, "request_id": "b2f68792a71b614a12bf26f6b5603c68", "body": {"id": "chatcmpl-ChlazwpW9E8HV09cueC236oMtzf0P", "object": "chat.completion", "created": 1764547097, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-compat\",\n    \"full_readme_markdown\": \"# bitcoin-compat\\n\\nA small, low-level compatibility shim used by `bitcoin-rs` to emulate the C/C++ platform surface that upstream Bitcoin Core expects: endian helpers, byte-swapping, CPUID, errno, C-style string helpers, and portable terminal/STDIN handling.\\n\\n> **Note**: This README was generated by an AI model. It may not perfectly describe every aspect of the crate, but it should be directionally accurate and practically useful.\\n\\n---\\n\\n## Goals\\n\\n* Provide a thin, well-instrumented Rust fa\u00e7ade over platform-specific primitives that Bitcoin Core historically relies on.\\n* Preserve the C/C++ invariants (sizes, endianness, IEEE-754 behavior) required by validation, cryptography, and consensus logic.\\n* Offer a small, stable API surface that other crates can reuse when they need identical compatibility guarantees.\\n\\nThis crate is explicitly oriented around *portability constraints* (endianness, integer widths, `size_t` assumptions, `errno` semantics, terminal behavior) that matter for a consensus system like Bitcoin.\\n\\n---\\n\\n## Features Overview\\n\\n### Compile-time platform invariants\\n\\nThe crate asserts a series of assumptions at compile time using `const_assert!`:\\n\\n* **IEEE 754 floats**: `f32` and `f64` are validated to be IEC 559 (IEEE 754) compliant (`f32_is_iec559`, `f64_is_iec559`).\\n* **Eight bits per byte**: `u8::BITS == 8`.\\n* **Fixed integer widths**:\\n  * `size_of::<u16>() == 2` (16-bit short assumed)\\n  * `size_of::<i32>() == 4` (32-bit int assumed)\\n  * `size_of::<u32>() == 4`\\n* **`size_t` constraints**:\\n  * `size_of::<usize>() == 4 || size_of::<usize>() == 8`\\n* **Pointer size equivalence**:\\n  * `size_of::<usize>() == size_of::<*mut c_void>()`\\n\\nThese mirror the implicit assumptions present in C++ Bitcoin Core code and make violations immediately visible at compile time on exotic targets.\\n\\n### C-style string helper\\n\\n```rust\\npub fn strnlen(start: *const u8, max_len: usize) -> usize\\n```\\n\\n* Computes the length of a C string starting at `start`, inspecting at most `max_len` bytes.\\n* Returns `max_len` if no NUL byte is encountered.\\n* If `start` is null, it logs an error and returns `0` instead of reading arbitrary memory.\\n\\nThis is a direct semantic translation of the classic `strnlen(3)` from libc, with additional structured logging.\\n\\n### GLIBC++ sanity checks\\n\\nThese functions reproduce the behavior of upstream GLIBC++ sanity checks used by Bitcoin Core\u2019s test suite to validate ABI and library behavior.\\n\\n```rust\\npub fn sanity_test_widen(testchar: u8) -> bool\\npub fn sanity_test_list(size: u32) -> bool\\npub fn sanity_test_range_fmt() -> bool\\npub fn glibcxx_sanity_test() -> bool\\n```\\n\\n* **`sanity_test_widen`**: Round-trips a `u8` through Rust `char` and back to `u8`, verifying byte preservation (analogous to C++ `char`/`wchar_t` widening and narrowing).\\n* **`sanity_test_list`**: Exercises `LinkedList` append/pop behavior, checking list size and element order to mimic container splice/hook invariants.\\n* **`sanity_test_range_fmt`**: Intentionally triggers an out-of-range access on an empty `String` and verifies the panic is caught.\\n* **`glibcxx_sanity_test`**: Runs all of the above and returns `true` iff they all succeed.\\n\\nUse these to confirm that the standard library and runtime behave as expected on your target before executing consensus-critical logic.\\n\\n### CPUID wrapper\\n\\n```rust\\npub fn getcpuid(\\n    leaf:    u32,\\n    subleaf: u32,\\n    a:       &mut u32,\\n    b:       &mut u32,\\n    c:       &mut u32,\\n    d:       &mut u32,\\n)\\n```\\n\\n* On `x86`/`x86_64`, executes the `CPUID` instruction via `core::arch::{x86,x86_64}::__cpuid_count`.\\n* On other architectures, logs a warning and zeroes all outputs.\\n* Exposes the same logical contract as the original C++ helper, but the Rust API is safe: internal unsafe usage is fully encapsulated.\\n\\nExample:\\n\\n```rust\\nlet mut eax = 0;\\nlet mut ebx = 0;\\nlet mut ecx = 0;\\nlet mut edx = 0;\\n\\nbitcoin_compat::getcpuid(1, 0, &mut eax, &mut ebx, &mut ecx, &mut edx);\\n\\n// Inspect feature bits in ecx/edx, vendor info, etc.\\n```\\n\\n### Endian conversion helpers\\n\\nBig- and little-endian conversions are made explicit and aggressively traced:\\n\\n```rust\\npub fn htobe16(x: u16) -> u16\\npub fn htole16(x: u16) -> u16\\npub fn be_16toh(x: u16) -> u16\\npub fn le_16toh(x: u16) -> u16\\n\\npub fn htobe32(x: u32) -> u32\\npub fn htole32(x: u32) -> u32\\npub fn be_32toh(x: u32) -> u32\\npub fn le_32toh(x: u32) -> u32\\n\\npub fn htobe64(x: u64) -> u64\\npub fn htole64(x: u64) -> u64\\npub fn be_64toh(x: u64) -> u64\\npub fn le_64toh(x: u64) -> u64\\n```\\n\\nThey wrap the intrinsic `to_be`, `to_le`, `from_be`, `from_le` methods, and log hex-formatted input and output. This is particularly important for cross-checking Bitcoin wire-format serialization, which is defined in terms of specific endianness (e.g., block headers in little-endian but some hashes printed in big-endian order).\\n\\n### Byte-swapping helpers\\n\\n```rust\\npub fn bswap_16(x: u16) -> u16\\npub fn bswap_32(x: u32) -> u32\\npub fn bswap_64(x: u64) -> u64\\n```\\n\\nThese wrap `swap_bytes()` for explicit byte permutations:\\n\\n* `bswap_16`: `0xAABB \u2192 0xBBAA`\\n* `bswap_32`: `0xAABB_CCDD \u2192 0xDDCC_BBAA`\\n* `bswap_64`: `0x1122_3344_5566_7788 \u2192 0x8877_6655_4433_2211`\\n\\nThey are useful for implementing protocol-level formats that specify byte order directly, for low-level network code, and for verification of compatibility with historical C/C++ implementations.\\n\\n### Cross-platform errno\\n\\n```rust\\npub fn last_errno() -> i32\\n```\\n\\nRetrieves the thread-local `errno` value across platforms:\\n\\n* Linux/Android: `libc::__errno_location()`\\n* Darwin/BSDs: `libc::__error()`\\n* Windows: `_get_errno()`\\n\\nThis small helper decouples upper layers from OS-specific errno access patterns while still exposing the raw numeric value for comparison against C APIs.\\n\\n### STDIN / terminal handling\\n\\nThe crate provides both primitive functions and an RAII guard for manipulating terminal echo and detectability of STDIN state.\\n\\n#### Core functions\\n\\n```rust\\npub fn set_stdin_echo(enable: bool)\\npub fn stdin_terminal() -> bool\\npub fn stdin_ready() -> bool\\n```\\n\\n* **`set_stdin_echo`**:\\n  * On Unix, toggles the `ECHO` flag via `termios` (`tcgetattr`/`tcsetattr`).\\n  * On Windows, toggles the `ENABLE_ECHO_INPUT` console mode.\\n* **`stdin_terminal`**: `true` iff `STDIN` is attached to a TTY.\\n  * Unix: `isatty(STDIN_FILENO)`\\n  * Windows: `_isatty(_fileno(STDIN_FILE))`\\n* **`stdin_ready`**:\\n  * If `STDIN` is *not* a TTY, assumes it is ready (typical for pipes or redirected input) and returns `true`.\\n  * On Unix TTYs, uses `poll` with zero timeout to check for pending data.\\n  * On Windows, always returns `false` because the console subsystem does not offer a universally reliable polling interface for redirected consoles.\\n\\n#### RAII no-echo guard\\n\\n```rust\\npub struct NoechoInst;\\n\\nimpl NoechoInst {\\n    pub fn new() -> Self;\\n}\\n```\\n\\n`NoechoInst` disables terminal echo on construction and re-enables it on drop. This is an ergonomic tool for reading secrets (e.g., wallet passphrases) from the console without accidentally leaving the terminal in a broken state.\\n\\nMacros:\\n\\n```rust\\n#[macro_export]\\nmacro_rules! no_stdin_echo { {\\n    () => {\\n        let _no_echo = $crate::stdin::NoechoInst::new();\\n    };\\n} }\\n```\\n\\nThis macro creates an unnamed guard bound to `_no_echo` for the current lexical scope.\\n\\nUsage:\\n\\n```rust\\nuse bitcoin_compat::no_stdin_echo;\\n\\nfn read_secret() -> String {\\n    use std::io::{self, Read};\\n\\n    let mut buf = String::new();\\n\\n    {\\n        // Echo disabled for this scope\\n        no_stdin_echo!();\\n        io::stdin().read_line(&mut buf).expect(\\\"read failed\\\");\\n    } // echo automatically restored here\\n\\n    buf.trim_end().to_owned()\\n}\\n```\\n\\nThis pattern guarantees proper cleanup even if a panic occurs inside the guarded block.\\n\\n### Windows socket and ssize_t compatibility (C-interop)\\n\\nThe crate defines some platform-conditional type aliases and macros to emulate C-style signatures and error codes, particularly for Windows builds of networking code:\\n\\n* `type Socket = u32` on non-Windows (mirroring Unix `int` file descriptors).\\n* `type ssize_t` mapped to the appropriate signed integer width on MSVC/Windows (`i64` on `_WIN64`, `i32` otherwise).\\n* `wsaeagain!` macro that maps the `EAGAIN`/`WSAEWOULDBLOCK` mismatch.\\n\\nThese are primarily for internal compatibility with code that expects the C/POSIX/WinSock API surface.\\n\\n---\\n\\n## Usage\\n\\nAdd to `Cargo.toml` (version pinned for illustration):\\n\\n```toml\\n[dependencies]\\nbitcoin-compat = \\\"0.1.19\\\"\\n```\\n\\nExample: combine endian helpers and byte-swaps when implementing a Bitcoin-style serialization routine:\\n\\n```rust\\nuse bitcoin_compat::{htole32, bswap_32};\\n\\nfn encode_block_height(height: u32) -> [u8; 4] {\\n    // Bitcoin typically uses little-endian encoding on the wire.\\n    let le = htole32(height);\\n    le.to_le_bytes()\\n}\\n\\nfn reverse_hash_bytes(hash: [u8; 32]) -> [u8; 32] {\\n    // Often one wants to interpret a little-endian internal value\\n    // as a big-endian printable hex. A canonical approach reverses\\n    // the byte order:\\n    let mut out = hash;\\n    out.reverse();\\n    out\\n}\\n```\\n\\nOr, run the GLIBC++-style sanity tests at process startup:\\n\\n```rust\\nfn main() {\\n    if !bitcoin_compat::glibcxx_sanity_test() {\\n        eprintln!(\\\"FATAL: glibcxx sanity tests failed; incompatible runtime\\\");\\n        std::process::exit(1);\\n    }\\n\\n    // continue with the rest of the node or wallet startup\\n}\\n```\\n\\n---\\n\\n## Relationship to mathematics and computer architecture\\n\\nThe crate encodes several low-level architectural invariants that are key to reproducible behavior in a distributed consensus system:\\n\\n* **IEEE 754 floating-point**: Many analytic and estimation routines in Bitcoin Core assume specific behavior for NaNs, infinities, rounding, and division by zero. Deviations could, in principle, cause divergent behavior between nodes on different targets. By asserting IEC 559 conformance, the crate explicitly acknowledges and enforces these expectations.\\n* **Fixed integer widths and `size_t`**: Serialization sizes, checksum computations, and memory-usage accounting rely on the relationship between integer widths and pointer sizes. The compile-time `const_assert!` checks are effectively small model-checking constraints over the target architecture.\\n* **Endianness and byte ordering**: Bitcoin\u2019s on-wire protocol defines exact byte orders for headers, hashes, and integer fields. The distinction between host order, little-endian representation, and big-endian presentation (e.g., hash hex) is codified into explicit helper functions. From a mathematical perspective, these are trivial bijections on finite bitstrings, but in practice, misapplication leads to silent, non-local defects.\\n* **CPUID feature discovery**: For cryptographic primitives, feature detection (e.g., SIMD or special instruction sets) can influence both performance and, in misconfigured systems, correctness when assumptions are violated. Making the CPUID surface explicit and easily testable reduces the probability of mis-detecting CPU capabilities.\\n\\nBy aggregating these concerns into a coherent crate, `bitcoin-compat` reduces entropy and increases the chance that independent implementations converge on identical behavior.\\n\\n---\\n\\n## Repository, license, and maintenance\\n\\n* **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n* **Crate**: `bitcoin-compat`\\n* **Version**: `0.1.19`\\n* **Edition**: Rust 2021\\n* **License**: MIT\\n\\nThe crate is primarily intended as an internal building block of `bitcoin-rs`, but it is general enough to be reused by other systems that need strict C/C++ compatibility with Bitcoin Core\u2019s expectations.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"network-programming\",\n      \"science\",\n      \"mathematics\",\n      \"development-tools\"\n    ],\n    \"package_description\": \"Low-level C/C++ compatibility layer for bitcoin-rs providing cross-platform CPUID, errno, endian and byte-swap helpers, terminal/STDIN control, and compile-time architectural invariants aligned with Bitcoin Core.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"compatibility\",\n      \"endian\",\n      \"cpuid\",\n      \"errno\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 7040, "completion_tokens": 3443, "total_tokens": 10483, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
