{"id": "batch_req_692cdfa651648190b7a049fef41fa374", "custom_id": "bitcoin-hash-ai-readme-request", "response": {"status_code": 200, "request_id": "51d0149cc685c832a1f658a323320140", "body": {"id": "chatcmpl-ChlxTIBkwsNqm6kizuwCyt5c9m1Ub", "object": "chat.completion", "created": 1764548491, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-hash\",\n    \"full_readme_markdown\": \"# bitcoin-hash\\n\\nDeterministic, Bitcoin-Core\u2011faithful hashing utilities and hash\u2011centric data structures for the `bitcoin-rs` ecosystem.\\n\\nThis crate provides thin, allocation\u2011free primitives that closely mirror Bitcoin Core's C++ hashing infrastructure while exposing an idiomatic Rust API. It focuses on correctness with respect to consensus\u2011relevant behavior and on zero\u2011cost integration into performance\u2011sensitive code such as full node implementations, mempools, UTXO sets, and filter indexes.\\n\\n> **Note**\\n> This README was generated by an AI model based on the crate's public interface. It may not be perfectly accurate or complete, but it should be a strong approximation. Consult the source for authoritative details.\\n\\n---\\n\\n## Features at a Glance\\n\\n- **Consensus\u2011compatible digests**\\n  - `Hash256`: Bitcoin's double\u2011SHA256 (256\u2011bit) hash function.\\n  - `Hash160` and `hash160(..)`: Bitcoin's 160\u2011bit hash (SHA256 \u279c RIPEMD160).\\n  - `hash1`, `hash2`, `serialize_hash`: convenient helpers mirroring Bitcoin Core semantics.\\n- **Tagged hashes (BIP\u2011340 style)**\\n  - `tagged_hash(tag: &str) -> HashWriter` and pre\u2011tagged writers for Taproot:\\n    - `HASHER_TAPSIGHASH`, `HASHER_TAPLEAF`, `HASHER_TAPBRANCH`, `HASHER_TAPTWEAK`.\\n- **Specialized hashers for core data structures**\\n  - `SaltedOutpointHasher`, `SaltedTxidHasher`, `ByteVectorHash`, `SaltedSipHasher`.\\n  - `SignatureCacheHasher` implementing `bitcoin_cuckoo_cache::EightWayHasher<u256>`.\\n  - `BlockHasher`, `FilterHeaderHasher` for cheap indexing based on low\u201164\u2011bits.\\n- **Stream\u2011based hashing**\\n  - `HashWriter`: a write\u2011only, serialization\u2011style hasher.\\n  - `HashVerifier<S>`: wraps an `std::io::Read` and hashes all bytes as they are read.\\n- **Bitcoin data model utilities**\\n  - `OutPoint`: transaction outpoint (`txid` + `vout` index) with ordering, hashing, and display.\\n  - `BaseHash<HashType>`: a general fixed\u2011size hash wrapper mirroring Bitcoin Core's `BaseHash` helpers.\\n  - `AssumeUtxoHash`, `AssumeUtxoData`, `MapAssumeUtxo` for assumeUTXO snapshot metadata.\\n- **Low\u2011level helpers**\\n  - `murmur_hash3`, `read_le64`, `rotl32` \u2013 building blocks for filters, caches, and Bloom\u2011like structures.\\n\\nThe design goal is to make it trivial to port consensus\u2011critical code from Bitcoin Core while retaining Rust's type safety and trait ecosystem.\\n\\n---\\n\\n## Installation\\n\\nAdd the crate to your `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-hash = \\\"0.1.20\\\"\\n```\\n\\nThe crate targets Rust 2021 and is licensed under MIT.\\n\\n---\\n\\n## Core Types and Functions\\n\\n### 1. Fundamental hash types\\n\\n#### `Hash256`\\n\\nBitcoin defines its main digest function as `double-SHA256`:\\n\\n\\\\[\\nH_{256}(m) = \\\\text{SHA256}(\\\\text{SHA256}(m)).\\n\\\\]\\n\\n`Hash256` is a stateful hasher implementing this exact construction:\\n\\n```rust\\nuse bitcoin_hash::Hash256;\\n\\nlet mut h = Hash256::default();\\nh.write(b\\\"hello world\\\");\\nlet mut out = [0u8; Hash256::OUTPUT_SIZE];\\nh.finalize(&mut out);\\n```\\n\\nKey properties:\\n\\n- Streaming interface (`write`, `finalize`, `reset`).\\n- Zero allocation; works with fixed\u2011size arrays.\\n- Matches Bitcoin Core's behavior byte\u2011for\u2011byte when fed the same serialized data.\\n\\n#### `Hash160` and `hash160`\\n\\nBitcoin's 160\u2011bit hash for P2PKH/P2WPKH, address generation, and script templates is defined as:\\n\\n\\\\[\\nH_{160}(m) = \\\\text{RIPEMD160}(\\\\text{SHA256}(m)).\\n\\\\]\\n\\n`Hash160` is the streaming variant; `hash160` is a convenience helper operating on any `AsRef<[u8]>`:\\n\\n```rust\\nuse bitcoin_hash::hash160;\\nuse bitcoin_hash::u160; // assumed to come from the same crate or a sibling\\n\\nlet pk_bytes: Vec<u8> = get_public_key_bytes();\\nlet digest: u160 = hash160(&pk_bytes);\\n```\\n\\n### 2. High\u2011level helpers: `hash1`, `hash2`, `serialize_hash`\\n\\nThese functions capture common patterns from Bitcoin Core:\\n\\n```rust\\nuse bitcoin_hash::{hash1, hash2, serialize_hash, u256};\\n\\nlet a = b\\\"foo\\\";\\nlet b = b\\\"bar\\\";\\n\\nlet h_single: u256 = hash1(a);\\nlet h_concat: u256 = hash2(a, b);\\n\\n// `serialize_hash` exists for API compatibility with the C++ codebase.\\nlet h_ser: u256 = serialize_hash(a, None, None);\\n```\\n\\n- `hash1` \u2013 hash a single blob of bytes with `Hash256`.\\n- `hash2` \u2013 hash the concatenation of two blobs (`in1 || in2`).\\n- `serialize_hash` \u2013 placeholder for (de)serialization\u2011aware hashing; in the Rust port, it simply calls `hash1(obj.as_ref())`.\\n\\n### 3. Tagged hashes (BIP\u2011340, Taproot)\\n\\nTagged hashes are defined as in BIP\u2011340:\\n\\n\\\\[\\n\\\\text{tagged\\\\_hash}(\\\\text{tag}, m) = \\\\text{SHA256}(\\\\text{SHA256}(\\\\text{tag})\\\\,||\\\\,\\\\text{SHA256}(\\\\text{tag})\\\\,||\\\\,m).\\n\\\\]\\n\\n`tagged_hash(tag)` returns a `HashWriter` already primed with `SHA256(tag)` written twice. You then feed the payload and finalize via `HashWriter`:\\n\\n```rust\\nuse bitcoin_hash::{tagged_hash, HashWriter, u256};\\n\\nlet mut w: HashWriter = tagged_hash(\\\"TapLeaf\\\");\\nw.write(&serialized_script);\\nlet tapleaf_hash: u256 = w.get_hash();\\n```\\n\\nThe crate also exposes pre\u2011instantiated `lazy_static!` hash writers for the commonly used Taproot tags:\\n\\n- `HASHER_TAPSIGHASH` \u2013 BIP\u2011341 `TapSighash`.\\n- `HASHER_TAPLEAF` \u2013 `TapLeaf`.\\n- `HASHER_TAPBRANCH` \u2013 `TapBranch`.\\n- `HASHER_TAPTWEAK` \u2013 `TapTweak`.\\n\\nThese mirror the C++ global singletons and allow direct 1\u2011to\u20111 translation of Taproot\u2011related code.\\n\\n### 4. `HashWriter`: serialization\u2011style hashing\\n\\n`HashWriter` is a SHA256\u2011based writer that matches Bitcoin Core\u2019s `CHashWriter`:\\n\\n```rust\\nuse bitcoin_hash::{HashWriter, u256};\\n\\n// Type and version parameters are for structural compatibility\\nlet mut hw = HashWriter::new(SER_GETHASH as i32, 0);\\n\\nhw.write(&tx_bytes);\\nlet txid: u256 = hw.get_hash();       // double-SHA256\\nlet cheap: u64 = hw.get_cheap_hash(); // low 64 bits of the double-SHA256\\n```\\n\\nImportant methods:\\n\\n- `write(&mut self, pch: &[u8])` \u2013 feed bytes.\\n- `get_hash(&mut self) -> u256` \u2013 compute double\u2011SHA256; invalidates the internal state.\\n- `getsha256(&mut self) -> u256` \u2013 compute a single SHA256; invalidates the state.\\n- `get_cheap_hash(&mut self) -> u64` \u2013 the first 64 bits of `get_hash()`.\\n\\nThe type and version fields (`n_type`, `n_version`) enable future extensibility and parity with C++ serialization code, even though they may not affect the Rust implementation today.\\n\\nOperator overloads:\\n\\n```rust\\nuse bitcoin_hash::HashWriter;\\n\\nlet mut w = HashWriter::new(0, 0);\\nlet data = b\\\"payload\\\";\\n\\n// `<<` style chaining (mirrors `operator<<` in C++)\\nlet mut w2 = w << &data[..];\\nlet h = w2.get_hash();\\n```\\n\\n### 5. Stream hashing with `HashVerifier<S>`\\n\\n`HashVerifier<S>` wraps an `std::io::Read` and forwards all bytes into an internal `HashWriter`:\\n\\n```rust\\nuse bitcoin_hash::{HashVerifier, u256};\\nuse std::fs::File;\\nuse std::io::Read;\\n\\nlet file = File::open(\\\"block.dat\\\")?;\\nlet mut hv = HashVerifier::new(file);\\n\\nlet mut buf = vec![0u8; 1024];\\nhv.read(&mut buf)?;   // reads and hashes 1024 bytes\\n\\n// \u2026 read or `ignore` more \u2026\\n\\n// finalize by pulling the hash out of the embedded HashWriter\\nlet hash: u256 = hv.base.get_hash();\\n# Ok::<(), std::io::Error>(())\\n```\\n\\nAdditional capabilities:\\n\\n- `read(&mut self, buf: &mut [u8])` \u2013 `Read::read_exact` + hash.\\n- `ignore(&mut self, n: usize)` \u2013 read and hash but discard the bytes.\\n- `Shr<&mut T>` operator (`>>`\u2011like) that reads exactly `obj.as_mut().len()` and panics on I/O failure (mimicking C++ stream exceptions).\\n\\nThis is useful for validating that a streamed serialization matches an expected digest without buffering the entire payload.\\n\\n### 6. `OutPoint`: transaction output locator\\n\\n`OutPoint` represents a specific output of a transaction:\\n\\n```rust\\nuse bitcoin_hash::{OutPoint, u256};\\n\\nlet txid: u256 = get_txid();\\nlet op = OutPoint::new(&txid, 0);\\n\\nassert!(!op.is_null());\\nprintln!(\\\"{}\\\", op); // e.g. \\\"OutPoint(0123abc..., 0)\\\"\\n```\\n\\nSalient traits and methods:\\n\\n- `new(hash_in: &u256, n_in: u32) -> Self`.\\n- `set_null`, `is_null` \u2013 sentinel semantics with `OUT_POINT_NULL_INDEX`.\\n- `Display`/`to_string` \u2013 prints `OutPoint(<first 10 hex chars>, n)` (matching Bitcoin Core\u2019s `ToString`).\\n- `Ord`, `Eq`, `Hash` \u2013 uses `(hash, n)` ordering and a stable Hash implementation by writing `hash` bytes and `n` in little\u2011endian.\\n\\nThe `Hash` impl makes it suitable as a key in `HashMap<OutPoint, _>` or `HashSet<OutPoint>` using default hashers or the provided salted variants.\\n\\n### 7. Salted hashers and indexing strategies\\n\\nThe crate includes several SipHash\u2011based and structure\u2011aware hashers intended for use in high\u2011performance containers. Salting randomizes hash functions per process, mitigating collision attacks and certain denial\u2011of\u2011service vectors.\\n\\n#### `SaltedOutpointHasher`\\n\\nImplements both `BuildHasher` and `Hasher`, enabling use as a custom hasher for `HashMap`/`HashSet` keyed by `OutPoint`:\\n\\n```rust\\nuse bitcoin_hash::{OutPoint, SaltedOutpointHasher};\\nuse std::collections::HashMap;\\n\\nlet map: HashMap<OutPoint, u64, SaltedOutpointHasher> = HashMap::default();\\n```\\n\\nAdditionally, it provides an explicit `invoke` helper mirroring Bitcoin Core's `SipHashUint256Extra`:\\n\\n```rust\\nuse bitcoin_hash::{OutPoint, SaltedOutpointHasher};\\n\\nlet hasher = SaltedOutpointHasher::default();\\nlet op = get_outpoint();\\nlet idx: usize = hasher.invoke(&op);\\n```\\n\\nThe implementation uses two 64\u2011bit keys (`k0`, `k1`) seeded from `rand::rngs::OsRng` and SipHash\u20112\u20114 internally.\\n\\n#### `SaltedTxidHasher`\\n\\nSpecialized SipHash\u2011based hasher for 256\u2011bit transaction IDs (`u256`):\\n\\n```rust\\nuse bitcoin_hash::{SaltedTxidHasher, u256};\\n\\nlet txid: u256 = get_txid();\\nlet h = SaltedTxidHasher::default();\\nlet bucket: usize = h.invoke(&txid);\\n```\\n\\n#### `ByteVectorHash`\\n\\nA general SipHash\u20112\u20114 based `BuildHasher` and `Hasher` intended for arbitrary byte\u2011vector types used as keys:\\n\\n```rust\\nuse bitcoin_hash::ByteVectorHash;\\nuse std::collections::HashSet;\\n\\nlet mut set: HashSet<Vec<u8>, ByteVectorHash> = HashSet::default();\\nset.insert(b\\\"hello\\\".to_vec());\\n```\\n\\nIncludes a convenience `invoke(&self, input: &[u8]) -> usize` for ad\u2011hoc hashing.\\n\\n#### `SaltedSipHasher`\\n\\nA lighter helper using SipHash with random keys for generic byte slices:\\n\\n```rust\\nuse bitcoin_hash::SaltedSipHasher;\\n\\nlet s = SaltedSipHasher::default();\\nlet idx = s.invoke(b\\\"some script bytes\\\");\\n```\\n\\n#### `SignatureCacheHasher`\\n\\nImplements `bitcoin_cuckoo_cache::EightWayHasher<u256>`.\\n\\nMathematically, this decomposes a `u256` (32 bytes) into eight disjoint 32\u2011bit words, each producing one of the eight hash values required by the cuckoo cache structure:\\n\\n```rust\\nuse bitcoin_hash::{SignatureCacheHasher, u256};\\nuse bitcoin_cuckoo_cache::EightWayHasher;\\n\\nlet key: u256 = get_sigcache_key();\\nlet h = SignatureCacheHasher {};\\nlet buckets: [u32; 8] = h.hashes(&key);\\n```\\n\\nThis is designed specifically for Bitcoin's signature cache implementation, avoiding recomputation and extra passes over the data.\\n\\n#### `BlockHasher` and `FilterHeaderHasher`\\n\\nBoth use `read_le64(hash.as_ref())` to derive a `usize` index from the low 64 bits of a 256\u2011bit hash.\\n\\nThese are useful for cheap indexing where full cryptographic collision resistance is not required (e.g., block/file bucketing, compact filter headers).\\n\\n### 8. AssumeUTXO structures\\n\\nThe AssumeUTXO mechanism allows nodes to bootstrap validation by accepting an externally supplied UTXO snapshot, identified by a consensus\u2011critical hash and height/tx\u2011count metadata.\\n\\nThis crate models the relevant pieces:\\n\\n- `AssumeUtxoHash { base: BaseHash<u256> }` \u2013 wrapper for the hash of the serialized UTXO snapshot.\\n- `AssumeUtxoData { hash_serialized: AssumeUtxoHash, n_chain_tx: u32 }` \u2013 configuration for UTXO snapshot load/validation.\\n- `MapAssumeUtxo = HashMap<i32, AssumeUtxoData>` \u2013 map from block height (or similar integer index) to snapshot data.\\n\\nUsage example:\\n\\n```rust\\nuse bitcoin_hash::{AssumeUtxoHash, AssumeUtxoData, MapAssumeUtxo, u256};\\n\\nlet snapshot_hash: u256 = compute_snapshot_hash();\\nlet au_hash = AssumeUtxoHash::new(&snapshot_hash);\\n\\nlet data = AssumeUtxoData {\\n    hash_serialized: au_hash,\\n    n_chain_tx: 1_000_000,\\n};\\n\\nlet mut map: MapAssumeUtxo = MapAssumeUtxo::new();\\nmap.insert(700_000, data);\\n```\\n\\nBecause this configuration is security\u2011critical, any changes must be coordinated with consensus rules and deployment strategy.\\n\\n### 9. `BaseHash<HashType>`: generic fixed\u2011size hash wrapper\\n\\n`BaseHash<HashType>` encapsulates a fixed\u2011width hash type (e.g., `u256`) while exposing a pointer\u2011centric API like Bitcoin Core's `BaseHash` helpers.\\n\\nConstraints on `HashType`:\\n\\n- `Clone + Default + Debug + AsRef<[u8]> + AsMut<[u8]> + Ord + Display`.\\n\\nKey methods:\\n\\n```rust\\nuse bitcoin_hash::BaseHash;\\nuse bitcoin_hash::u256;\\n\\nlet inner: u256 = get_u256();\\nlet mut b = BaseHash::new(&inner);\\n\\nlet size = b.size();       // length in bytes\\nlet ptr = b.data();        // *const u8\\nlet s = b.to_string();     // hex string via inner Display\\n\\n// Transparent deref\\nlet as_inner: &u256 = &*b;\\n```\\n\\nPointers and ranges:\\n\\n- `begin`, `end`, `begin_mut`, `end_mut`, `data`, `data_mut` \u2013 all mirror C++ semantics.\\n- Ordering (`Ord`, `Eq`, `PartialOrd`) forwards to the inner type.\\n- `Into<Vec<u8>>` clones the underlying bytes.\\n\\nThis type is primarily aimed at ease of porting C++ code that expects raw pointer access, while preserving Rust ownership and borrowing rules.\\n\\n### 10. Low\u2011level primitives: `murmur_hash3`, `read_le64`, `rotl32`\\n\\n#### `murmur_hash3`\\n\\nImplements 32\u2011bit MurmurHash3 over a byte slice with an explicit seed:\\n\\n```rust\\nuse bitcoin_hash::murmur_hash3;\\n\\nlet seed: u32 = 0x1234_5678;\\nlet val = b\\\"key\\\";\\nlet h: u32 = murmur_hash3(seed, val);\\n```\\n\\nThis is the same primitive used in Bitcoin Core for Bloom filters, compact filters, and certain probabilistic data structures. The function operates in little\u2011endian and performs finalization mixing steps as in the reference design.\\n\\n#### `read_le64`\\n\\nReads the first eight bytes of a slice as a little\u2011endian `u64`:\\n\\n```rust\\nuse bitcoin_hash::read_le64;\\n\\nlet bytes = [1u8, 0, 0, 0, 0, 0, 0, 0];\\nlet x = read_le64(&bytes);\\nassert_eq!(x, 1);\\n```\\n\\nUsed for cheap hashing and indexing where full collision resistance is unnecessary.\\n\\n#### `rotl32`\\n\\nA small wrapper over `u32::rotate_left`:\\n\\n```rust\\nuse bitcoin_hash::rotl32;\\n\\nlet x = 0x1234_5678u32;\\nlet y = rotl32(x, 5); // rotate left by 5 bits\\n```\\n\\nPrimarily used inside hashing primitives; supplied to keep ported code structurally identical.\\n\\n---\\n\\n## Error Handling and Invariants\\n\\n- Many methods are annotated with `debug_assert!` checks rather than returning `Result`. These are designed to catch internal misuse during development without impacting release performance.\\n- `HashVerifier::read` and `ignore` surface `std::io::Result<()>`, but the `Shr` operator implementation panics on I/O failure to emulate C++ stream exceptions.\\n- Hashing functions expect correctly sized inputs; where necessary they copy fixed\u2011length slices with explicit bounds checks.\\n\\nDownstream consumers should treat these primitives as low\u2011level building blocks with the expectation that higher\u2011level components handle user\u2011facing validation and error reporting.\\n\\n---\\n\\n## Example: hashing a serialized transaction\\n\\n```rust\\nuse bitcoin_hash::{HashWriter, u256};\\n\\nfn txid_from_serialized_bytes(tx_bytes: &[u8]) -> u256 {\\n    let mut hw = HashWriter::new(SER_GETHASH as i32, 0);\\n    hw.write(tx_bytes);\\n    hw.get_hash()\\n}\\n```\\n\\nIf you already have a single, contiguous slice of the serialized transaction, you may instead use `hash1(tx_bytes)`.\\n\\n---\\n\\n## Example: using custom hashers for collections\\n\\n```rust\\nuse bitcoin_hash::{OutPoint, SaltedOutpointHasher, u256};\\nuse std::collections::HashMap;\\n\\nlet mut utxo: HashMap<OutPoint, u64, SaltedOutpointHasher> = HashMap::default();\\n\\nlet txid: u256 = get_txid();\\nlet op = OutPoint::new(&txid, 1);\\nutxo.insert(op.clone(), 42);\\n\\nassert_eq!(utxo.get(&op), Some(&42));\\n```\\n\\nBecause `SaltedOutpointHasher` implements `BuildHasher`, `HashMap::default()` yields a map with that hasher and fresh per\u2011process SipHash keys.\\n\\n---\\n\\n## Repository, License, and Contributions\\n\\n- **Crate**: `bitcoin-hash` `0.1.20`\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n- **License**: MIT\\n- **Rust edition**: 2021\\n- **Author**: `klebs <none>`\\n\\nContributions should respect consensus compatibility with Bitcoin Core. Any change to hashing behavior, serialization, or snapshot verification logic must be carefully reviewed, as subtle divergences can lead to consensus splits or security regressions.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"mathematics\",\n      \"network-programming\",\n      \"science\",\n      \"development-tools\"\n    ],\n    \"package_description\": \"Bitcoin-Core compatible hashing primitives and hashers for u256-based types, Taproot tagged hashes, OutPoint keys, signature caches, and AssumeUTXO metadata, designed for consensus-safe use in high-performance Rust Bitcoin implementations.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"hashing\",\n      \"taproot\",\n      \"siphash\",\n      \"utxo\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 8873, "completion_tokens": 5134, "total_tokens": 14007, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
