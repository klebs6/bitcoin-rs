{"custom_id":"request-0","method":"POST","url":"/v1/chat/completions","body":{"max_completion_tokens":8192,"messages":[{"content":"We would like you to write a README.md for a rust crate with maximally helpful content.\nAdditionally, we would like you to generate several fields from the Cargo.toml package section for this crate.\nWe will show you the strict json output format we would like you to provide.\nPlease tailor your response for an apex consumer of maximal intelligence.\nA reader of this README.md should have a good sense of what the crate does and how to use it after reading what you write.\nPlease include a messaage indicating that this README.md file was generated by an AI model and may not be 100% accurate however it should be pretty good.\n\n\nCarefully read and parse the information we sent you.\nWe want to generate all information items requested by our schema:\n\n- Read the description of each field. Use it, along with the content we sent you to generate an appropriate value for each.\n- Ensure that each generated field optimally serves its desired purpose.\n- Each item should be deep, detailed, and specific. Use optimally descriptive and useful language. Do not be too verbose.\n- In terms of the JSON format we would like you to provide, all schema items should live at the top level of the json object. \n  The object itself will be deserialied based on the schema. \n  The fields should not be nested under a parent named 'fields' or anything similar.\n\nHere is the schema to Use:\n\n{\"fields\":{\"crate_name\":{\"generation_instructions\":\"This string should be the name of our crate, *verbatim*, trimmed for use as a toml field\",\"required\":true,\"type\":\"string\"},\"full_readme_markdown\":{\"generation_instructions\":\"This string should be valid markdown representing the readme for this crate.\\n\\n Please make it terse, useful, and designed for an industrious commercially savy consumer of industrious nature. \\n\\n Advanced vocabulary and concepts are welcome. \\n\\n If this crate involves concepts from mathematics and/or physics, please describe and document them here.\",\"required\":true,\"type\":\"string\"},\"package_categories\":{\"generation_instructions\":\"These categories will be used in our Cargo.toml file.\\n\\n It is important that users of this crate can find it on crates.io.\\n\\n Choose maximum 5 categories and make sure they are actually meaningful for our crate.\\n\\n These categories should only be chosen from among the legal crates.io categories. \\n\\n The ONLY legal categoreis are:\\n\\n``\\n accessibility\\n aerospace\\n algorithms\\n api-bindings\\n asynchronous\\n authentication\\n caching\\n command-line-interface\\n command-line-utilities\\n compilers\\n compression\\n computer-vision\\n concurrency\\n config\\n cryptography\\n data-structures\\n database\\n database-implementations\\n date-and-time\\n development-tools\\n email\\n embedded\\n emulators\\n encoding\\n external-ffi-bindings\\n filesystem\\n finance\\n game-development\\n game-engines\\n games\\n graphics\\n gui\\n hardware-support\\n internationalization\\n localization\\n mathematics\\n memory-management\\n multimedia\\n network-programming\\n no-std\\n os\\n parser-implementations\\n parsing\\n rendering\\n rust-patterns\\n science\\n simulation\\n template-engine\\n text-editors\\n text-processing\\n value-formatting\\n virtualization\\n visualization\\n wasm\\n web-programming\\n ``\\n\\n DO NOT specify a category that is not on this list.\",\"required\":true,\"type\":\"array_of_strings\"},\"package_description\":{\"generation_instructions\":\"We will place this package_description in our Cargo.toml file so the users of this crate\\n know what it does.\\n\\n The discription should be technical, clear, and useful. It should be terse.\",\"required\":true,\"type\":\"string\"},\"package_keywords\":{\"generation_instructions\":\"These keywords will be used in our Cargo.toml file so the users of this crate can easily\\n find it in the package system. Keywords should be useful, varied, meaningful, and reflect\\n the contents of our crate. They should make it easy to find. Please provide exactly five.\",\"required\":true,\"type\":\"array_of_strings\"}},\"struct_docs\":\" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\"struct_name\":\"AiReadmeWriterDesiredOutput\"}\nRephrase Entries:\n\n- Ensure entries are concise and focused.\n- Ensure there are no vague phrases (e.g., avoid starting with \"Illustrates the something something...\"; instead, use direct details like \"The hanging green vines on the garden wall\").\n\nEnsure Clarity and Consistency:\n\n- Use clear, grammatically correct sentences.\n- Maintain a consistent tone and style throughout.\n\nEnrich Content:\n\n- Communicate additional information where appropriate to enhance depth and value.\n- If a mathematical, physical, or otherwise technical background is helpful, please provide it.\n- Ensure that the content is comprehensive and meets all requirements.\nFocus Language:\n\n- Use deliberate and precise language.\n- Avoid vague verbs and keep the maximally intelligent and detail oriented audience in mind.\n- Do not use modern cultural references or generically reference ideas which do not fit the overall aura of our setting.\n\nPresent the Final JSON:\n\n- Format the output as a JSON object.\n- Include all fields properly named from the schema we sent you.\n\nEnsure Proper Formatting:\n\n- Use proper JSON syntax with keys and arrays.\n- Ensure that all entries are correctly placed in their respective places.\n\nYour output should only consist of the JSON object. do *not* include a preamble or postamble to your response. \nWe would like to be able to parse your response directly as JSON.\n\n","role":"system"},{"content":"We have a rust crate named 'bitcoin-bigint' 0.1.18. \n\nHere is the interface:\n#[macro_export]\nmacro_rules! define_baseuint_bitor { {\n    ($uint_type:ident, $bits:expr, $limbs:expr) => {\n\n        impl core::ops::BitOrAssign<&$uint_type> for $uint_type {\n            #[inline]\n            fn bitor_assign(&mut self, b: &$uint_type) {\n                for i in 0..$limbs {\n                    self.pn[i] |= b.pn[i];\n                }\n            }\n        }\n\n        impl core::ops::BitOrAssign<u64> for $uint_type {\n            #[inline]\n            fn bitor_assign(&mut self, b: u64) {\n                self.pn[0] |= (b & 0xffff_ffff) as u32;\n                if $limbs > 1 {\n                    self.pn[1] |= ((b >> 32) & 0xffff_ffff) as u32;\n                }\n            }\n        }\n\n        impl core::ops::BitOr<&$uint_type> for $uint_type {\n            type Output = $uint_type;\n            fn bitor(self, other: &$uint_type) -> Self::Output {\n                let mut ret = self.clone();\n                ret |= other;\n                ret\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_addassign { {\n    ($uint_type:ident, $bits:expr, $limbs:expr) => {\n\n        impl core::ops::AddAssign<&$uint_type> for $uint_type {\n            /// Addition with carry. `self += other`\n            #[inline]\n            fn add_assign(&mut self, other: &Self) {\n                let mut carry = 0u64;\n                for i in 0..$limbs {\n                    let sum = carry + (self.pn[i] as u64) + (other.pn[i] as u64);\n                    self.pn[i] = (sum & 0xffff_ffff) as u32;\n                    carry = sum >> 32;\n                }\n            }\n        }\n\n        impl core::ops::AddAssign<u64> for $uint_type {\n            /// self += u64 => construct a temporary $uint_type from the u64, then add\n            #[inline]\n            fn add_assign(&mut self, other: u64) {\n                let mut b = Self::default();\n                // Put lower 32 bits in pn[0], upper 32 bits in pn[1] if available\n                b.pn[0] = (other & 0xffff_ffff) as u32;\n                if $limbs > 1 {\n                    b.pn[1] = ((other >> 32) & 0xffff_ffff) as u32;\n                }\n                *self += &b;\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_add_sub_mul_div { {\n    ($uint_type:ident, $bits:expr, $limbs:expr) => {\n\n        impl core::ops::Add<&$uint_type> for $uint_type {\n            type Output = $uint_type;\n            fn add(self, other: &$uint_type) -> Self::Output {\n                let mut ret = self.clone();\n                ret += other;\n                ret\n            }\n        }\n\n        impl core::ops::Sub<&$uint_type> for $uint_type {\n            type Output = $uint_type;\n            fn sub(self, other: &$uint_type) -> Self::Output {\n                let mut ret = self.clone();\n                ret -= other; // we rely on SubAssign\n                ret\n            }\n        }\n\n        impl core::ops::Mul<&$uint_type> for $uint_type {\n            type Output = $uint_type;\n            fn mul(self, other: &$uint_type) -> Self::Output {\n                let mut ret = self.clone();\n                ret *= other; // we rely on MulAssign\n                ret\n            }\n        }\n\n        impl core::ops::Div<&$uint_type> for $uint_type {\n            type Output = $uint_type;\n            fn div(self, other: &$uint_type) -> Self::Output {\n                let mut ret = self.clone();\n                ret /= other; // we rely on DivAssign\n                ret\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_uint_shl_shr { {\n    ($name:ident, $bits:expr, $limbs:expr) => {\n\n        // Shl<&$name>\n        impl core::ops::Shl<&$name> for $name {\n            type Output = $name;\n            fn shl(self, rhs: &Self) -> Self::Output {\n                let shift_raw = rhs.pn[0];\n                let shift_bits = shift_raw.min($bits as u32);\n                let mut ret = self.clone();\n                ret <<= shift_bits;\n                ret\n            }\n        }\n\n        // ShlAssign<u32>\n        impl core::ops::ShlAssign<u32> for $name {\n            fn shl_assign(&mut self, shift: u32) {\n                trace!(\"ShlAssign<u32>: self <<= {}, BITS={}\", shift, $bits);\n                if shift as usize >= $bits {\n                    for limb in self.pn.iter_mut() {\n                        *limb = 0;\n                    }\n                    return;\n                }\n                if shift == 0 {\n                    return;\n                }\n\n                let limb_shift = (shift / 32) as usize;\n                let bit_shift  = shift % 32;\n                let old = self.clone();\n\n                // zero out self\n                for limb in self.pn.iter_mut() {\n                    *limb = 0;\n                }\n\n                for i in 0..$limbs {\n                    let val = old.pn[i];\n                    if val == 0 {\n                        continue;\n                    }\n                    let new_i = i + limb_shift;\n                    if new_i < $limbs {\n                        self.pn[new_i] |= val << bit_shift;\n                    }\n                    if bit_shift != 0 && (new_i + 1) < $limbs {\n                        self.pn[new_i + 1] |= val >> (32 - bit_shift);\n                    }\n                }\n\n                debug!(\"ShlAssign complete => self={:?}\", self);\n            }\n        }\n\n        // Shr<&$name>\n        impl core::ops::Shr<&$name> for $name {\n            type Output = $name;\n            fn shr(self, rhs: &Self) -> Self::Output {\n                let shift_raw = rhs.pn[0];\n                let shift_bits = shift_raw.min($bits as u32);\n                let mut ret = self.clone();\n                ret >>= shift_bits;\n                ret\n            }\n        }\n\n        // ShrAssign<u32>\n        impl core::ops::ShrAssign<u32> for $name {\n            fn shr_assign(&mut self, shift: u32) {\n                tracing::trace!(\n                    \"Entering shr_assign<u32>: BITS={}, shift={}, initial self={:X?}\",\n                    $bits,\n                    shift,\n                    self.pn\n                );\n                let num_limbs = $limbs;\n\n                if shift as usize >= $bits {\n                    for limb in self.pn.iter_mut() {\n                        *limb = 0;\n                    }\n                    tracing::trace!(\n                        \"Leaving shr_assign<u32>; shift >= {}, self=0 => {:X?}\",\n                        $bits,\n                        self.pn\n                    );\n                    return;\n                }\n\n                let limb_shift = (shift / 32) as usize;\n                let bit_shift = shift % 32;\n\n                if limb_shift > 0 {\n                    for i in 0..(num_limbs - limb_shift) {\n                        self.pn[i] = self.pn[i + limb_shift];\n                    }\n                    for i in (num_limbs - limb_shift)..num_limbs {\n                        self.pn[i] = 0;\n                    }\n                    tracing::debug!(\n                        \"After shifting whole limbs => limb_shift={}, partial self={:X?}\",\n                        limb_shift,\n                        self.pn\n                    );\n                }\n\n                if bit_shift > 0 {\n                    let mut prev = 0u32;\n                    for i in (0..num_limbs).rev() {\n                        let current = self.pn[i];\n                        self.pn[i] = (current >> bit_shift) | (prev << (32 - bit_shift));\n                        prev = current;\n                    }\n                    tracing::debug!(\n                        \"After shifting bits => bit_shift={}, final self={:X?}\",\n                        bit_shift,\n                        self.pn\n                    );\n                }\n\n                tracing::trace!(\"Leaving shr_assign<u32>; final self={:X?}\", self.pn);\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_fromstr { {\n\n    ($uint_type:ident, $bits:expr, $limbs:expr) => {\n\n        impl FromStr for $uint_type {\n            type Err = &'static str;\n            fn from_str(s: &str) -> Result<Self, Self::Err> {\n                Ok(Self::from(s))\n            }\n        }\n\n        impl From<&str> for $uint_type {\n            fn from(s_in: &str) -> Self {\n                trace!(\"Converting string '{}' into {} via From<&str>, BITS={}.\", s_in, stringify!($uint_type), $bits);\n\n                let mut s = s_in.trim();\n                if s.len() > 2 {\n                    let prefix = &s[..2];\n                    if prefix.eq_ignore_ascii_case(\"0x\") {\n                        s = &s[2..];\n                    }\n                }\n                s = s.trim();\n\n                let mut hex_digits = Vec::with_capacity(s.len());\n                for ch in s.chars() {\n                    match ch {\n                        '_' => { continue; }\n                        '0'..='9' | 'a'..='f' | 'A'..='F' => {\n                            hex_digits.push(ch.to_ascii_uppercase());\n                        }\n                        _ => {\n                            break;\n                        }\n                    }\n                }\n                if hex_digits.is_empty() {\n                    debug!(\"No valid hex digits found => returning 0.\");\n                    return Self::default();\n                }\n\n                let mut be_bytes = Vec::with_capacity((hex_digits.len()+1)/2);\n                let mut idx = 0usize;\n\n                if (hex_digits.len() % 2) == 1 {\n                    let nib = hex_to_val(hex_digits[0]);\n                    be_bytes.push(nib as u8);\n                    idx = 1;\n                }\n\n                while idx+1 < hex_digits.len() {\n                    let hi = hex_to_val(hex_digits[idx]);\n                    let lo = hex_to_val(hex_digits[idx+1]);\n                    let byte_val = ((hi<<4) | lo) as u8;\n                    be_bytes.push(byte_val);\n                    idx += 2;\n                }\n\n                let mut result = Self::default();\n                let mut consumed = 0usize;\n                let mut limb_idx = 0usize;\n                while consumed < be_bytes.len() && limb_idx < $limbs {\n                    let mut limb_val = 0u32;\n                    for sub_i in 0..4 {\n                        if consumed >= be_bytes.len() {\n                            break;\n                        }\n                        let be_idx = be_bytes.len()-1-consumed;\n                        let b = be_bytes[be_idx];\n                        limb_val |= (b as u32) << (8*sub_i);\n                        consumed+=1;\n                    }\n                    result.pn[limb_idx] = limb_val;\n                    limb_idx+=1;\n                }\n\n                result\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_divassign { {\n\n    ($uint_type:ident, $bits:expr, $limbs:expr) => {\n\n        impl $uint_type {\n            pub fn is_null(&self) -> bool {\n                for &limb in &self.pn {\n                    if limb != 0 {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            pub fn set_null(&mut self) {\n                for limb in &mut self.pn {\n                    *limb = 0;\n                }\n            }\n\n            fn div_assign_big(&mut self, divisor: &Self) {\n                trace!(\n                    \"{}::div_assign_big => self /= divisor (shift-sub approach). BITS={}\",\n                    stringify!($uint_type),\n                    $bits\n                );\n\n                if divisor.is_null() {\n                    panic!(\"Division by zero in BaseUInt::div_assign_big\");\n                }\n\n                if *self < *divisor {\n                    self.set_null();\n                    return;\n                }\n\n                let mut quotient = Self::default();\n                let mut remainder = self.clone();\n\n                let shift = (remainder.bits() as i32) - (divisor.bits() as i32);\n                if shift < 0 {\n                    self.set_null();\n                    return;\n                }\n                let mut shifted_div = divisor.clone();\n                shifted_div <<= shift as u32;\n                let mut s = shift;\n                while s >= 0 {\n                    if remainder >= shifted_div {\n                        remainder.sub_assign(&shifted_div);\n                        let limb_index = (s / 32) as usize;\n                        let bit_index = s as u32 % 32;\n                        quotient.pn[limb_index] |= 1 << bit_index;\n                    }\n                    shifted_div >>= 1;\n                    s -= 1;\n                }\n\n                *self = quotient;\n            }\n        }\n\n        impl core::ops::DivAssign<&$uint_type> for $uint_type {\n            #[inline]\n            fn div_assign(&mut self, other: &Self) {\n                self.div_assign_big(other);\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_from_u64 { {\n\n    ($uint_type:ident, $bits:expr, $limbs:expr) => {\n        impl From<u64> for $uint_type {\n            fn from(value: u64) -> Self {\n                let mut ret = Self::default();\n                ret.pn[0] = (value & 0xffff_ffff) as u32;\n                if $limbs > 1 {\n                    ret.pn[1] = ((value >> 32) & 0xffff_ffff) as u32;\n                }\n                ret\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! bigint { {\n\n    ($name:ident, $bits:expr, $limbs:expr) => {\n        define_base_uint_struct_and_basic! { $name ,  $bits,  $limbs}\n        define_base_uint_conversions!      { $name ,  $bits,  $limbs}\n        define_base_uint_mulassign!        { $name ,  $bits,  $limbs}\n        define_base_uint_not_neg!          { $name ,  $bits,  $limbs}\n        define_base_uint_ord_eq!           { $name ,  $bits,  $limbs}\n        define_base_uint_shl_shr!          { $name ,  $bits,  $limbs}\n        define_baseuint_addassign!         { $name ,  $bits,  $limbs}\n        define_baseuint_subassign!         { $name ,  $bits,  $limbs}\n        define_baseuint_divassign!         { $name ,  $bits,  $limbs}\n        define_baseuint_add_sub_mul_div!   { $name ,  $bits,  $limbs}\n        define_baseuint_bitand!            { $name ,  $bits,  $limbs}\n        define_baseuint_bitor!             { $name ,  $bits,  $limbs}\n        define_baseuint_bitxor!            { $name ,  $bits,  $limbs}\n        define_baseuint_fromstr!           { $name ,  $bits,  $limbs}\n        define_baseuint_from_u64!          { $name ,  $bits,  $limbs}\n        define_baseuint_get_hex!           { $name ,  $bits,  $limbs}\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_uint_ord_eq { {\n    ($name:ident, $bits:expr, $limbs:expr) => {\n\n        impl core::cmp::Ord for $name {\n            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n                for i in (0..$limbs).rev() {\n                    if self.pn[i] < other.pn[i] {\n                        return core::cmp::Ordering::Less;\n                    } else if self.pn[i] > other.pn[i] {\n                        return core::cmp::Ordering::Greater;\n                    }\n                }\n                core::cmp::Ordering::Equal\n            }\n        }\n\n        impl core::cmp::PartialOrd<$name> for $name {\n            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n                Some(self.cmp(other))\n            }\n        }\n\n        impl core::cmp::PartialEq for $name {\n            fn eq(&self, other: &Self) -> bool {\n                self.pn == other.pn\n            }\n        }\n        impl core::cmp::Eq for $name {}\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_uint_conversions { {\n    ($name:ident, $bits:expr, $limbs:expr) => {\n\n        impl $name {\n            /// set_hex(*const u8)\n            pub fn set_hex(&mut self, psz: *const u8) {\n                if psz.is_null() {\n                    // interpret null as empty => 0\n                    *self = Self::default();\n                } else {\n                    // build a &str\n                    let cstr_len = unsafe {\n                        let mut len = 0;\n                        let mut ptr = psz;\n                        while !ptr.is_null() && *ptr != 0 {\n                            ptr = ptr.add(1);\n                            len += 1;\n                        }\n                        len\n                    };\n                    let slice = unsafe { std::slice::from_raw_parts(psz, cstr_len) };\n                    let as_str = std::str::from_utf8(slice).unwrap_or(\"\");\n                    *self = Self::from(as_str);\n                }\n            }\n\n            pub fn set_hex_with_str(&mut self, str_: &str) {\n                *self = Self::from(str_);\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_uint_mulassign { {\n    ($name:ident, $bits:expr, $limbs:expr) => {\n\n        impl core::ops::MulAssign<&$name> for $name {\n            fn mul_assign(&mut self, rhs: &Self) {\n                let limb_count = $limbs; // replaced BITS/32\n                trace!(\n                    \"{}::mul_assign => self *= rhs; initial self={:08X?}, rhs={:08X?}\",\n                    stringify!($name),\n                    self.pn,\n                    rhs.pn\n                );\n\n                // We'll accumulate into a 2*limb_count array of 64-bit partials:\n                let mut accum = vec![0u64; limb_count * 2];\n\n                for i in 0..limb_count {\n                    let a_i = self.pn[i] as u64;\n                    let mut carry = 0u64;\n                    for j in 0..limb_count {\n                        let idx = i + j;\n                        let old_val = accum[idx];\n                        let mul_val = a_i.wrapping_mul(rhs.pn[j] as u64);\n                        let sum = old_val.wrapping_add(mul_val).wrapping_add(carry);\n\n                        accum[idx] = sum & 0xFFFF_FFFF;\n                        carry      = sum >> 32;\n\n                        trace!(\n                            \"  i={}, j={}, accum[{}]: old=0x{:08X}, a_i=0x{:X}, b_j=0x{:X}, mul=0x{:X}, sum=0x{:X}, new=0x{:08X}, carry=0x{:X}\",\n                            i, j, idx, \n                            (old_val & 0xFFFF_FFFF), \n                            a_i, rhs.pn[j], \n                            mul_val, sum, accum[idx], carry\n                        );\n                    }\n                    let extra_idx = i + limb_count;\n                    if extra_idx < accum.len() {\n                        let old_val = accum[extra_idx];\n                        let sum     = old_val.wrapping_add(carry);\n                        accum[extra_idx] = sum & 0xFFFF_FFFF;\n                        let leftover = sum >> 32;\n                        trace!(\n                            \"  carry-out => accum[{}] old=0x{:08X}, sum=0x{:X}, new=0x{:08X}, leftover=0x{:X}\",\n                            extra_idx,\n                            (old_val & 0xFFFF_FFFF),\n                            sum,\n                            accum[extra_idx],\n                            leftover\n                        );\n                    }\n                }\n\n                trace!(\"After i/j loops => accum= [\");\n                for (k, val) in accum.iter().enumerate() {\n                    trace!(\"    i={}: 0x{:X}\", k, val);\n                }\n                trace!(\"]\");\n\n                // copy low limbs back\n                for i in 0..limb_count {\n                    self.pn[i] = accum[i] as u32;\n                }\n\n                trace!(\"Leaving mul_assign => final self={:08X?}\", self.pn);\n            }\n        }\n\n        impl core::ops::MulAssign<u32> for $name {\n            fn mul_assign(&mut self, rhs: u32) {\n                trace!(\n                    \"Entering mul_assign<u32> with BITS={}, rhs=0x{:08X}, initial self={:X?}\",\n                    $bits,\n                    rhs,\n                    self.pn\n                );\n\n                let num_limbs = $limbs;\n                let mut carry = 0u64;\n\n                for i in 0..num_limbs {\n                    let product = (self.pn[i] as u64)\n                        .wrapping_mul(rhs as u64)\n                        .wrapping_add(carry);\n                    self.pn[i] = (product & 0xFFFF_FFFF) as u32;\n                    carry = product >> 32;\n\n                    debug!(\n                        \"  limb={}, product=0x{:X}, new=0x{:08X}, carry=0x{:08X}\",\n                        i,\n                        product,\n                        self.pn[i],\n                        carry\n                    );\n                }\n\n                trace!(\n                    \"Leaving mul_assign<u32>; final self={:X?} (carry=0x{:08X} dropped).\",\n                    self.pn,\n                    carry\n                );\n            }\n        }\n\n        impl core::ops::MulAssign<u64> for $name {\n            fn mul_assign(&mut self, rhs: u64) {\n                let limb_count = $limbs;\n                let mut carry = 0u64;\n\n                for i in 0..limb_count {\n                    let product = (self.pn[i] as u64)\n                        .wrapping_mul(rhs)\n                        .wrapping_add(carry);\n                    self.pn[i] = product as u32;\n                    carry = product >> 32;\n                }\n                // any final carry is discarded in mod 2^($bits)\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_bitxor { {\n    ($uint_type:ident, $bits:expr, $limbs:expr) => {\n\n        impl core::ops::BitXor<&$uint_type> for $uint_type {\n            type Output = $uint_type;\n            fn bitxor(self, other: &$uint_type) -> Self::Output {\n                let mut ret = self.clone();\n                ret ^= other;\n                ret\n            }\n        }\n\n        impl core::ops::BitXorAssign<&$uint_type> for $uint_type {\n            #[inline]\n            fn bitxor_assign(&mut self, b: &$uint_type) {\n                for i in 0..$limbs {\n                    self.pn[i] ^= b.pn[i];\n                }\n            }\n        }\n\n        impl core::ops::BitXorAssign<u64> for $uint_type {\n            #[inline]\n            fn bitxor_assign(&mut self, b: u64) {\n                self.pn[0] ^= (b & 0xffff_ffff) as u32;\n                if $limbs > 1 {\n                    self.pn[1] ^= ((b >> 32) & 0xffff_ffff) as u32;\n                }\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_get_hex { {\n\n    ($name:ident, $bits:expr, $limbs:expr) => {\n\n        impl $name {\n\n            /// Return this number as a big-endian hex string with *exactly* `BITS/4` hex digits\n            /// (two hex digits per byte). Leading zeros are always preserved.\n            pub fn get_hex(&self) -> String {\n                // 1) Gather bytes in little-endian (limb[0] is low 32 bits)\n                let limb_count = $limbs;\n                let total_bytes = $bits / 8; // e.g. 256 => 32 bytes\n                let mut le_bytes = Vec::with_capacity(total_bytes);\n\n                for i in 0..limb_count {\n                    let limb = self.pn[i];\n                    let limb_bytes = limb.to_le_bytes();\n                    le_bytes.extend_from_slice(&limb_bytes);\n                }\n\n                // 2) Reverse to get big-endian\n                le_bytes.reverse();\n\n                // 3) Convert to hex: always push 2 hex digits per byte\n                use std::fmt::Write;\n                let mut result = String::with_capacity(total_bytes * 2);\n                for &byte in &le_bytes {\n                    write!(result, \"{:02x}\", byte).unwrap();\n                }\n\n                result\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_uint_not_neg { {\n    ($name:ident, $bits:expr, $limbs:expr) => {\n\n        impl core::ops::Not for $name {\n            type Output = $name;\n            #[inline]\n            fn not(self) -> Self::Output {\n                let mut ret = Self::default();\n                for (i, &val) in self.pn.iter().enumerate() {\n                    ret.pn[i] = !val;\n                }\n                ret\n            }\n        }\n\n        impl core::ops::Neg for $name {\n            type Output = Self;\n            #[inline]\n            fn neg(self) -> Self::Output {\n                let mut ret = !self; // bitwise not\n                // plus 1\n                let mut carry = 1u64;\n                for limb in ret.pn.iter_mut() {\n                    let sum = *limb as u64 + carry;\n                    *limb = (sum & 0xFFFF_FFFF) as u32;\n                    carry = sum >> 32;\n                    if carry == 0 {\n                        break;\n                    }\n                }\n                ret\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_subassign { {\n    ($name:ident, $bits:expr, $limbs:expr) => {\n\n        // sub_assign(&BaseUInt)\n        impl core::ops::SubAssign<&$name> for $name {\n            fn sub_assign(&mut self, rhs: &Self) {\n                // self = self + (-rhs)\n                *self += &(-rhs.clone());\n            }\n        }\n\n        // sub_assign(u64)\n        impl core::ops::SubAssign<u64> for $name {\n            fn sub_assign(&mut self, rhs: u64) {\n                let mut b = Self::from(rhs);\n                *self += &(-b);\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_baseuint_bitand { {\n\n    ($uint_type:ident, $bits:expr, $limbs:expr) => {\n\n        impl core::ops::BitAnd<&$uint_type> for $uint_type {\n            type Output = $uint_type;\n            fn bitand(self, other: &$uint_type) -> Self::Output {\n                let mut ret = self.clone();\n                ret &= other;\n                ret\n            }\n        }\n\n        impl core::ops::BitAndAssign<&$uint_type> for $uint_type {\n            #[inline]\n            fn bitand_assign(&mut self, b: &$uint_type) {\n                for i in 0..$limbs {\n                    self.pn[i] &= b.pn[i];\n                }\n            }\n        }\n\n        impl core::ops::BitAndAssign<u64> for $uint_type {\n            fn bitand_assign(&mut self, b: u64) {\n                self.pn[0] &= (b & 0xffff_ffff) as u32;\n                if $limbs > 1 {\n                    self.pn[1] &= ((b >> 32) & 0xffff_ffff) as u32;\n                }\n                for i in 2..$limbs {\n                    self.pn[i] = 0;\n                }\n            }\n        }\n    }\n} }\n\n\n#[macro_export]\nmacro_rules! define_base_uint_struct_and_basic { {\n    ($name:ident, $bits:expr, $limbs:expr) => {\n\n        #[derive(Clone,Debug)]\n        pub struct $name {\n            pub(crate) pn: [u32; $limbs],\n        }\n\n        impl Default for $name {\n\n            fn default() -> Self {\n                Self { pn: [0; $limbs] }\n            }\n        }\n\n        impl $name {\n\n            pub const WIDTH: usize = $limbs;\n\n            pub fn get_limb(&self, index: usize) -> u32 {\n                self.pn[index]\n            }\n\n            pub fn set_limb(&mut self, index: usize, val: u32) {\n                self.pn[index] = val;\n            }\n\n            pub fn limb_count(&self) -> usize {\n                $limbs\n            }\n\n            pub fn inc_prefix(&mut self) -> &mut Self {\n                let mut i = 0;\n                while i < $limbs {\n                    self.pn[i] = self.pn[i].wrapping_add(1);\n                    if self.pn[i] != 0 {\n                        break;\n                    }\n                    i += 1;\n                }\n                self\n            }\n\n            pub fn inc_postfix(&mut self) -> Self {\n                let old = self.clone();\n                self.inc_prefix();\n                old\n            }\n\n            pub fn dec_prefix(&mut self) -> &mut Self {\n                let mut i = 0;\n                while i < $limbs {\n                    let new_val = self.pn[i].wrapping_sub(1);\n                    self.pn[i] = new_val;\n                    if new_val != 0xffff_ffff {\n                        break;\n                    }\n                    i += 1;\n                }\n                self\n            }\n\n            pub fn dec_postfix(&mut self) -> Self {\n                let old = self.clone();\n                self.dec_prefix();\n                old\n            }\n\n            pub fn size_in_bytes(&self) -> usize {\n                $limbs * core::mem::size_of::<u32>()\n            }\n\n            pub fn low64(&self) -> u64 {\n                let low0 = self.pn.get(0).cloned().unwrap_or(0) as u64;\n                let low1 = self.pn.get(1).cloned().unwrap_or(0) as u64;\n                (low1 << 32) | low0\n            }\n\n            pub fn compare_to(&self, other: &Self) -> i32 {\n                for i in (0..$limbs).rev() {\n                    if self.pn[i] < other.pn[i] {\n                        return -1;\n                    } else if self.pn[i] > other.pn[i] {\n                        return 1;\n                    }\n                }\n                0\n            }\n\n            pub fn equal_to(&self, b: u64) -> bool {\n                // For limbs > 2 => check them all zero\n                for i in 2..$limbs {\n                    if self.pn[i] != 0 {\n                        return false;\n                    }\n                }\n                let low_32 = (b & 0xffff_ffff) as u32;\n                let high_32 = ((b >> 32) & 0xffff_ffff) as u32;\n                if self.pn[0] != low_32 {\n                    return false;\n                }\n                if $limbs > 1 && self.pn[1] != high_32 {\n                    return false;\n                }\n                true\n            }\n\n            pub fn getdouble(&self) -> f64 {\n                let mut ret = 0.0;\n                let mut factor = 1.0;\n                for &limb in self.pn.iter() {\n                    ret += (limb as f64) * factor;\n                    factor *= 4294967296.0;\n                }\n                ret\n            }\n\n            pub fn bits(&self) -> u32 {\n                for pos in (0..$limbs).rev() {\n                    let limb = self.pn[pos];\n                    if limb != 0 {\n                        for nbits in (0..32).rev() {\n                            if (limb & (1 << nbits)) != 0 {\n                                return (pos as u32) * 32 + (nbits + 1);\n                            }\n                        }\n                    }\n                }\n                0\n            }\n\n            pub fn to_string(&self) -> String {\n                self.get_hex()\n            }\n        }\n    }\n} }\n\nbigint!{BaseUInt32,  32,  1}\n\n\nbigint!{BaseUInt64,  64,  2}\n\n\nbigint!{BaseUInt128, 128, 4}\n\n\nbigint!{BaseUInt160, 160, 5}\n\n\nbigint!{BaseUInt256, 256, 8}\n\npub struct SimpleLCG  {\n    state: u64,\n}\n\npub fn hex_to_val(ch: char) -> u8 {\n    match ch {\n        '0'..='9' => (ch as u8) - b'0',\n        'A'..='F' => (ch as u8) - b'A' + 10,\n        _ => 0,\n    }\n}\n\n\npub fn round_trip_hex_32(val: &BaseUInt32) -> BaseUInt32 {\n    let hex_string = val.get_hex();\n    BaseUInt32::from(hex_string.as_str())\n}\n\n\npub fn round_trip_hex_64(val: &BaseUInt64) -> BaseUInt64 {\n    let hex_string = val.get_hex();\n    BaseUInt64::from(hex_string.as_str())\n}\n\n\npub fn round_trip_hex_256(val: &BaseUInt256) -> BaseUInt256 {\n    let hex_string = val.get_hex();\n    BaseUInt256::from(hex_string.as_str())\n}\n\n\npub fn from_limbs_64(limbs: &[u32]) -> BaseUInt64 {\n    let mut x = BaseUInt64::default();\n    if !limbs.is_empty() {\n        x.pn[0] = limbs[0];\n    }\n    if limbs.len() > 1 {\n        x.pn[1] = limbs[1];\n    }\n    x\n}\n\n\npub fn to_limbs_64(x: &BaseUInt64) -> Vec<u32> {\n    vec![x.pn[0], x.pn[1]]\n}\n\n\npub fn from_limbs_256(limbs: &[u32]) -> BaseUInt256 {\n    let mut x = BaseUInt256::default();\n    for (i, &val) in limbs.iter().enumerate().take(8) {\n        x.pn[i] = val;\n    }\n    x\n}\n\n\npub fn to_limbs_256(x: &BaseUInt256) -> Vec<u32> {\n    x.pn.to_vec()\n}\n\n\npub fn dump_u64_bits(label: &str, val: u64) {\n    debug!(\"{} = 0x{:016X} => bin={:064b}\", label, val, val);\n}\n\n\npub fn dump_limb_bits(label: &str, limbs: &[u32]) {\n    // for a 64-bit BaseUInt, we have 2 limbs:\n    //   pn[0] => low 32 bits, pn[1] => high 32 bits\n    let low = (limbs[0] as u64) & 0xFFFF_FFFF;\n    let high = (limbs[1] as u64) & 0xFFFF_FFFF;\n    let combined = (high << 32) | low;\n    debug!(\"{} => pn=[0x{:08X}, 0x{:08X}] => full u64=0x{:016X}\", \n           label, limbs[0], limbs[1], combined);\n}\n\n\npub fn random_u256(rng: &mut SimpleLCG) -> BaseUInt256 {\n    let mut out = BaseUInt256::default();\n    let r0 = rng.next_u64();\n    let r1 = rng.next_u64();\n    let r2 = rng.next_u64();\n    let r3 = rng.next_u64();\n    out.pn[0] = (r0 & 0xffff_ffff) as u32;\n    out.pn[1] = ((r0 >> 32) & 0xffff_ffff) as u32;\n    out.pn[2] = (r1 & 0xffff_ffff) as u32;\n    out.pn[3] = ((r1 >> 32) & 0xffff_ffff) as u32;\n    out.pn[4] = (r2 & 0xffff_ffff) as u32;\n    out.pn[5] = ((r2 >> 32) & 0xffff_ffff) as u32;\n    out.pn[6] = (r3 & 0xffff_ffff) as u32;\n    out.pn[7] = ((r3 >> 32) & 0xffff_ffff) as u32;\n    out\n}\n\n\n/// Helper to produce a random hex string. We'll keep it to at most 40 hex digits\n/// for convenience. \npub fn random_hex_string(rng: &mut SimpleLCG, max_digits: usize) -> String {\n    use std::fmt::Write as FmtWrite;\n    let digit_count = (rng.next_u64() as usize % max_digits).max(1);\n    let mut s = String::new();\n    if (rng.next_u64() & 1) == 0 {\n        s.push_str(\"0x\");\n    }\n    for i in 0..digit_count {\n        let nibble = (rng.next_u64() & 0xF) as u8;\n        let c = std::char::from_digit(nibble as u32, 16).unwrap();\n        if i > 0 && (rng.next_u64() & 7) == 0 {\n            s.push('_');\n        }\n        if (rng.next_u64() & 1) == 0 {\n            s.push(c.to_ascii_lowercase());\n        } else {\n            s.push(c.to_ascii_uppercase());\n        }\n    }\n    s\n}\n\n\n#[inline]\npub fn base_uint_limb_count(bits: usize) -> usize {\n    // If you only ever do 160 or 256, match them:\n    match bits {\n        160 => 5,\n        256 => 8,\n        _ => panic!(\"Unsupported bits: must be 160 or 256\"),\n    }\n}\n\nimpl SimpleLCG {\n\n    pub fn new(seed: u64) -> Self {\n        Self { state: seed }\n    }\n\n    pub fn next_u64(&mut self) -> u64 {\n        self.state = self.state\n            .wrapping_mul(6364136223846793005)\n            .wrapping_add(1);\n        self.state\n    }\n}\n\n\nThis crate has the following authors:\n[\n    \"klebs <none>\",\n]\nThis crate has the following rust edition:\n2021\nThis crate has the following license:\nMIT\nThis crate is held in the following repository:\nhttps://github.com/klebz/bitcoin-rs\n","role":"user"}],"model":"gpt-4o"}}
