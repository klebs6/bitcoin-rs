{"id": "batch_req_692cd9ce6e488190b622b3eddae17228", "custom_id": "bitcoin-sync-ai-readme-request", "response": {"status_code": 200, "request_id": "1e73ee29f9f609593262c2a701bc37ea", "body": {"id": "chatcmpl-ChlZJNQcCaaGK146bjXeFwx2q2v1o", "object": "chat.completion", "created": 1764546993, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-sync\",\n    \"full_readme_markdown\": \"# bitcoin-sync\\n\\nHigh\u2011fidelity Rust reimplementation of Bitcoin Core\u2019s low\u2011level synchronization and threading primitives.\\n\\nThis crate mirrors the semantics of Bitcoin Core\u2019s C++ locking, semaphore, and thread\u2011interrupt machinery while exposing an idiomatic Rust API built on top of `parking_lot` and `tracing`. It is intended for building Bitcoin\u2011style concurrent runtimes, particularly where lock\u2011order correctness and deterministic behaviour matter more than maximal abstraction.\\n\\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate, but it is designed to be a close, technically detailed approximation of the crate\u2019s intent and usage.\\n\\n---\\n\\n## Design goals\\n\\n- **Semantic compatibility with Bitcoin Core**\\n  - Similar behaviour to `CCriticalSection`, `CThreadInterrupt`, `TraceThread`, and related helpers.\\n  - No poisoning semantics on mutex failure, matching Core\u2019s model (panic \u2260 permanent lock poisoning).\\n- **Strong debugging & lock\u2011order diagnostics**\\n  - Optional early deadlock detection via a global lock\u2011graph (when compiled with `DEBUG_LOCKORDER`).\\n  - Assertions that verify which locks are held/not\u2011held at specific call sites.\\n- **Minimal, explicit primitives**\\n  - Thin wrappers around `parking_lot` raw mutexes and condition variables.\\n  - RAII helpers (`UniqueLock`, `ReverseLock`, `SemaphoreGrant`, etc.) instead of opaque higher\u2011level frameworks.\\n- **Predictable threading behaviour**\\n  - Structured thread launch wrapper that logs lifecycle and propagates panics.\\n  - Interruptible sleeper abstraction (`ThreadInterrupt`) with well\u2011defined timing semantics.\\n\\nThis crate is deliberately low level. It is intended for experts who need precise control over lock ordering and cross\u2011thread coordination rather than generic application\u2011level concurrency.\\n\\n---\\n\\n## Features overview\\n\\n### 1. Lock abstraction: `LockApi` and `AnnotatedMixin`\\n\\n```rust\\npub trait LockApi {\\n    fn lock(&self);\\n    fn unlock(&self);\\n    fn try_lock(&self) -> bool;\\n}\\n```\\n\\n`LockApi` represents the minimal interface expected from a raw, **non\u2011poisoning** mutex. Any type implementing this trait can plug into the higher\u2011level RAII guards provided by this crate.\\n\\n`AnnotatedMixin<Parent>` wraps a `Parent: LockApi` and:\\n\\n- Forwards all lock operations.\\n- Provides a stable address and hook point for lock\u2011order tracking and future instrumentation.\\n\\n```rust\\npub struct AnnotatedMixin<Parent: LockApi> {\\n    parent: Parent,\\n}\\n\\nimpl<Parent: LockApi> LockApi for AnnotatedMixin<Parent> { /* forwards */ }\\n```\\n\\nThe primary concrete aliases are:\\n\\n```rust\\n/// Recursive lock (reentrant), no waiting (raw mutex semantics).\\npub type RecursiveMutex<T> = AnnotatedMixin<parking_lot::ReentrantMutex<T>>;\\n\\n/// Non\u2011recursive raw mutex supporting waiting.\\npub type Mutex = AnnotatedMixin<parking_lot::RawMutex>;\\n```\\n\\n`AnnotatedMixin<parking_lot::RawMutex>` implements `Default` with `RawMutex::INIT` so it can be used as a field with default construction.\\n\\n### 2. RAII locking: `UniqueLock` and `ReverseLock`\\n\\n#### `UniqueLock`\\n\\n`UniqueLock<'a, M>` is a RAII guard analogous to C++ `std::unique_lock` specialized for `M: LockApi + ?Sized`:\\n\\n```rust\\npub struct UniqueLock<'a, M: LockApi + ?Sized> {\\n    mutex: &'a M,\\n    owns:  bool,\\n    name:  &'static str,\\n    file:  &'static str,\\n    line:  u32,\\n}\\n```\\n\\nKey operations:\\n\\n- `new(mutex, name, file, line, try_: Option<bool>)` \u2013 constructs and either blocks (`lock`) or attempts `try_lock` depending on `try_`.\\n- `enter()` \u2013 acquire the lock if not already owned.\\n- `try_enter() -> bool` \u2013 try to acquire; returns whether ownership was gained.\\n- `unlock()` \u2013 explicitly release if currently owned.\\n- `owns_lock() -> bool` \u2013 mirror of C++\u2019s `owns_lock`.\\n- `Drop` \u2013 automatically unlocks if still owned.\\n\\nIt also implements `From<&UniqueLock<\u2026>> for bool`, so you can write:\\n\\n```rust\\nlet locked: bool = (&guard).into();\\n```\\n\\nThe struct records `name`, `file`, and `line`, allowing detailed logging of lock acquisition and release events via `tracing` macros inside the implementation.\\n\\n#### `ReverseLock`\\n\\n`ReverseLock` is a scoped inversion helper:\\n\\n```rust\\npub struct ReverseLock<'guard, 'lock, M: LockApi + ?Sized> {\\n    guard:    &'guard mut UniqueLock<'lock, M>,\\n    relocked: bool,\\n}\\n```\\n\\n- `ReverseLock::new(&mut guard)` unlocks the underlying mutex immediately.\\n- On `Drop`, it re\u2011enters the lock (if not already re\u2011locked).\\n\\nThis pattern is essential in Core\u2019s codebase for temporarily releasing a lock around a potentially blocking or re\u2011entrant operation without losing the association with the guard variable.\\n\\n### 3. Macros for critical sections and lock assertions\\n\\nThe crate exposes several macros to express critical sections, multi\u2011lock scopes, and assertions that a lock is (or is not) held.\\n\\n#### Scope guards\\n\\n```rust\\nlock!(cs);      // creates an unnamed UniqueLock bound to `cs`\\nlock2!(cs1, cs2); // lock two mutexes in sequence\\n\\ntry_lock!(cs, guard);  // guard: UniqueLock with try=Some(true)\\nwait_lock!(cs, guard); // guard: UniqueLock with blocking lock\\n\\nwith_lock!(cs, {\\n    // critical region\\n    do_something();\\n});\\n```\\n\\nThe `lock!` and `lock2!` macros use the `paste` crate to synthesize a unique guard name linked to the source line, ensuring RAII destruction at scope exit.\\n\\n`with_lock!` is syntactic sugar which:\\n\\n1. Acquires a `UniqueLock` on `$cs` via `lock!`.\\n2. Executes `$code` while the lock is held.\\n\\n#### Critical section tracking\\n\\nTwo macros integrate with the lock\u2011order tracking internals (see the `debug_lockorder` module):\\n\\n```rust\\nenter_critical_section!(cs);\\nleave_critical_section!(cs);\\n```\\n\\n- `enter_critical_section!(cs)` records metadata about the acquisition (name, file, line, address) and then calls `cs.lock()`.\\n- `leave_critical_section!(cs)` verifies that `cs` is the most recent critical section lock before unlocking and notifying the lock\u2011order system.\\n\\nThese macros allow the `DEBUG_LOCKORDER` logic to build a global **partial order** on lock acquisition, enabling early detection of potential deadlocks by identifying cycles in the lock graph.\\n\\n#### Lock assertions\\n\\n```rust\\nassert_lock_held!(cs);\\nassert_lock_not_held!(cs);\\n```\\n\\nThese macros call into `assert_lock_held_internal` / `assert_lock_not_held_internal`, which, under `DEBUG_LOCKORDER`, verify that `cs` is (or is not) present in the thread\u2011local lock stack. On failure they emit detailed diagnostics and either abort or panic depending on configuration.\\n\\n### 4. Semaphore & permits: `Semaphore` and `SemaphoreGrant`\\n\\n`Semaphore` is a simple counting semaphore built on top of a `Condvar` and a raw `Mutex<i32>`:\\n\\n```rust\\n#[derive(Default)]\\npub struct Semaphore {\\n    cv:    Condvar,\\n    count: Mutex<i32>,\\n}\\n``\\n\\nOperations:\\n\\n- `Semaphore::new(init: i32)` \u2013 create with an initial permit count (must be \u2265 0).\\n- `wait(&self)` \u2013 block until `count > 0`, then decrement.\\n- `try_wait(&self) -> bool` \u2013 non\u2011blocking attempt; `true` if a permit was consumed.\\n- `post(&self)` \u2013 increment `count` and wake one waiter.\\n\\n`SemaphoreGrant` is a RAII wrapper around a single permit:\\n\\n```rust\\n#[derive(Clone)]\\npub struct SemaphoreGrant {\\n    sem:        Arc<Semaphore>,\\n    have_grant: bool,\\n}\\n```\\n\\nSemantics:\\n\\n- `SemaphoreGrant::new(sema: Arc<Semaphore>, try_: Option<bool>)` \u2013 constructs a grant and either blocks or tries to acquire immediately.\\n- `acquire(&mut self)` \u2013 blocking acquisition if not already holding a permit.\\n- `try_acquire(&mut self) -> bool` \u2013 attempt acquisition without blocking.\\n- `release(&mut self)` \u2013 return the permit if currently held.\\n- `move_to(&mut self, target: &mut SemaphoreGrant)` \u2013 transfer ownership of a permit to `target`.\\n- `Drop` \u2013 automatically releases any held permit.\\n\\nLike `UniqueLock`, `SemaphoreGrant` implements `From<&SemaphoreGrant> for bool` so it can be treated as a truth value indicating permit ownership.\\n\\n`WaitTimedOut(bool)` is a thin wrapper with `.timed_out() -> bool` to express timeout results in a self\u2011documenting fashion.\\n\\n### 5. Thread management: `launch_traced_thread!` and `trace_thread`\\n\\n#### `launch_traced_thread!`\\n\\n```rust\\nlaunch_traced_thread!(\\\"indexer\\\", || {\\n    // your thread body\\n});\\n```\\n\\nExpands to `std::thread::Builder::new().name(...).spawn(...)` and delegates the body to `trace_thread`, panicking immediately if thread creation fails.\\n\\n#### `trace_thread`\\n\\n```rust\\npub fn trace_thread<F>(thread_name: &str, thread_func: F)\\nwhere\\n    F: FnOnce() + Send + 'static,\\n{ /* ... */ }\\n```\\n\\n- Creates a `tracing` span named `\\\"thread\\\"` with field `name = thread_name`.\\n- Logs `\\\"<name> thread start\\\"` and `\\\"<name> thread exit\\\"` at `INFO` level.\\n- Wraps the user closure in `std::panic::catch_unwind`. If it panics, it logs the panic and re\u2011raises, preserving default Rust semantics while still emitting structured telemetry.\\n\\nThis is a direct analogue of Bitcoin Core\u2019s `TraceThread` helper.\\n\\n### 6. Interruptible sleeping: `ThreadInterrupt`\\n\\n`ThreadInterrupt` models `CThreadInterrupt` from Bitcoin Core:\\n\\n```rust\\n#[derive(Default)]\\npub struct ThreadInterrupt {\\n    cond: Condvar,\\n    gate: Mutex<()>,\\n    flag: AtomicBool,\\n}\\n```\\n\\nCore semantics:\\n\\n- `new()` \u2013 create with `flag = false`.\\n- `as_bool() -> bool` \u2013 observe the interrupt flag with `Acquire` ordering.\\n- `reset()` \u2013 clear any pending interrupt (`Release` ordering).\\n- `invoke()` \u2013 set the flag true and `notify_all()` on the condition variable.\\n- `sleep_for(rel_time: StdDuration) -> bool`:\\n  - Returns `false` if an interrupt happens **before** the full timeout elapses.\\n  - Returns `true` if the full `rel_time` passes without interruption.\\n\\nImplementation detail: `sleep_for` loops, computing the remaining time until a pre\u2011computed `deadline` and calling `Condvar::wait_for`. After each wakeup it re\u2011checks the interrupt flag and the clock.\\n\\nThis primitive is useful for threads that must be **cooperatively** cancellable while still respecting a bounded maximum sleep.\\n\\n### 7. Low\u2011level waiting: `wait_until`\\n\\n```rust\\npub fn wait_until<T: ?Sized, P>(\\n    cv:       &parking_lot::Condvar,\\n    guard:    &mut parking_lot::MutexGuard<'_, T>,\\n    deadline: std::time::Instant,\\n    mut predicate: P,\\n) -> bool\\nwhere\\n    P: FnMut() -> bool,\\n{ /* ... */ }\\n```\\n\\nThis helper repeatedly waits on `cv` until either:\\n\\n- `predicate()` becomes `true`, in which case it returns `true`, or\\n- the `deadline` is reached and a final predicate check still fails, in which case it returns that final predicate result.\\n\\nThe pattern corresponds to the standard condition\u2011variable idiom:\\n\\n\\\\[\\n  \\\\text{while } \\\\neg P \\\\text{ and } t < T_{\\\\text{deadline}}: \\\\text{ wait}.\\n\\\\]\\n\\nMathematically, this implements a partial function `f: (P, T_deadline) -> bool` where the result is the final valuation of `P` at or after the deadline, ensuring **spurious wakeups** do not violate the semantics.\\n\\n### 8. Scoped raw mutex: `ScopedRawMutex` and `ScopedRawMutexGuard`\\n\\nFor scenarios requiring direct access to a raw `parking_lot::RawMutex` while still benefiting from RAII unlocking:\\n\\n```rust\\npub struct ScopedRawMutex(RawMutex);\\n\\npub struct ScopedRawMutexGuard<'a> {\\n    lock: &'a ScopedRawMutex,\\n}\\n```\\n\\n- `ScopedRawMutex::default()` \u2013 constructs with `RawMutex::INIT`.\\n- `ScopedRawMutex::lock(&self) -> ScopedRawMutexGuard<'_>` \u2013 locks the underlying raw mutex, returning a guard.\\n- On `Drop` of `ScopedRawMutexGuard`, `RawMutexTrait::unlock` is invoked.\\n\\nThis is intentionally minimal; it exists primarily as a bridge towards the C++\u2011style code generation and binding layers.\\n\\n### 9. Debug lock\u2011order analysis (`DEBUG_LOCKORDER`)\\n\\nWhen built with `DEBUG_LOCKORDER`, the crate enables an internal module that maintains a global lock\u2011graph to detect:\\n\\n- Double\u2011locking of non\u2011recursive mutexes on the same thread.\\n- Lock order inversions across threads (potential deadlocks).\\n\\nKey concepts:\\n\\n- **LockLocation** \u2013 describes where a lock was acquired: mutex name, source file, line, thread name, and whether the acquisition was a try\u2011lock.\\n- **LockStack** \u2013 per\u2011thread stack of `(mutex_ptr, LockLocation)` pairs.\\n- **LockOrders** \u2013 a map from ordered pairs `(A, B)` to the stack snapshot when `B` was acquired after `A`.\\n- **InvLockOrders** \u2013 set of the reversed pairs `(B, A)` for fast detection of inversions.\\n\\nAlgorithmically, each time a lock is pushed, the module:\\n\\n1. Checks for **double lock**: if the same pointer already appears in the stack, it reports a double lock.\\n2. For each previously held lock `L` in the current stack, considers pair `(L, current)`:\\n   - If `(current, L)` is already in `lockorders`, a cycle exists \u2192 **potential deadlock**.\\n   - Otherwise inserts `(L, current)` into `lockorders` and `(current, L)` into `invlockorders`.\\n\\nIn both double\u2011lock and potential\u2011deadlock cases, a detailed textual dump of the involved lock stacks is produced, and `abort_or_panic` is called. A global `AtomicBool` `G_DEBUG_LOCKORDER_ABORT` determines whether to abort the process or panic.\\n\\nIn non\u2011debug builds (`cfg(not(DEBUG_LOCKORDER))`), the functions become no\u2011ops, so there is no runtime overhead beyond the macro calls themselves.\\n\\n---\\n\\n## Example usage\\n\\n### Basic mutex usage with RAII\\n\\n```rust\\nuse bitcoin_sync::{Mutex, UniqueLock};\\n\\nstatic GLOBAL: Mutex = Mutex::default();\\n\\nfn critical_section() {\\n    // Create a guard that locks immediately.\\n    let mut guard = UniqueLock::new(&GLOBAL, \\\"GLOBAL\\\", file!(), line!(), None);\\n\\n    // do work while lock is held\\n\\n    // Optionally release early\\n    guard.unlock();\\n}\\n``\\n\\n### Using the helper macros\\n\\n```rust\\nuse bitcoin_sync::{Mutex};\\nuse bitcoin_sync::{lock, with_lock};\\n\\nstatic COUNTER_LOCK: Mutex = Mutex::default();\\nstatic mut COUNTER: i32 = 0;\\n\\nfn increment() {\\n    with_lock!(COUNTER_LOCK, unsafe {\\n        COUNTER += 1;\\n    });\\n}\\n\\nfn guarded_section() {\\n    lock!(COUNTER_LOCK);\\n    // RAII guard lives until end of scope\\n}\\n```\\n\\n### Semaphore and grants\\n\\n```rust\\nuse std::sync::Arc;\\nuse bitcoin_sync::{Semaphore, SemaphoreGrant};\\n\\nfn bounded_concurrency() {\\n    let sem = Arc::new(Semaphore::new(3));\\n\\n    let mut grant = SemaphoreGrant::new(sem.clone(), None);\\n    // we now hold one permit; scope exit will release automatically\\n\\n    // do limited\u2011concurrency work here\\n\\n    // explicit release is also possible\\n    grant.release();\\n}\\n```\\n\\n### Interruptible worker thread\\n\\n```rust\\nuse std::sync::Arc;\\nuse std::time::Duration;\\nuse bitcoin_sync::{ThreadInterrupt, launch_traced_thread};\\n\\nfn main() {\\n    let ti = Arc::new(ThreadInterrupt::new());\\n    let ti_worker = ti.clone();\\n\\n    let handle = launch_traced_thread!(\\\"worker\\\", move || {\\n        while ti_worker.sleep_for(Duration::from_secs(5)) {\\n            // periodic task; returns false if interrupted\\n        }\\n        // cleanup\\n    });\\n\\n    // later\\n    ti.invoke();    // request shutdown\\n    handle.join().unwrap();\\n}\\n```\\n\\n---\\n\\n## Crate metadata\\n\\n- **Crate**: `bitcoin-sync`\\n- **Version**: `0.1.19`\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n- **License**: MIT\\n- **Edition**: Rust 2021\\n\\nThis crate is designed as a building block within a larger Bitcoin reimplementation effort; its public API focuses on concurrency primitives, not high\u2011level Bitcoin logic.\\n\\n---\\n\\n## When to use this crate\\n\\nUse `bitcoin-sync` if you:\\n\\n- Are porting or closely emulating Bitcoin Core behaviour in Rust and need compatible synchronization primitives.\\n- Need early deadlock detection and explicit lock\u2011order tracking similar to Core\u2019s `DEBUG_LOCKORDER` tooling.\\n- Prefer explicit, RAII\u2011based concurrency constructs over more abstract frameworks.\\n\\nIf you only need generic high\u2011level Rust concurrency, standard library types (`Mutex`, `RwLock`, `Condvar`) or `tokio`/`async` primitives may be more appropriate. `bitcoin-sync` is primarily for **systems programmers** who require tight control over lock semantics and diagnostics.\\n\",\n    \"package_categories\": [\n      \"concurrency\",\n      \"development-tools\",\n      \"algorithms\",\n      \"network-programming\",\n      \"cryptography\"\n    ],\n    \"package_description\": \"Low-level synchronization, semaphore, lock-order debugging, and interruptible thread utilities modelled after Bitcoin Core, built on parking_lot and tracing.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"concurrency\",\n      \"mutex\",\n      \"semaphore\",\n      \"deadlock-detection\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 9569, "completion_tokens": 4445, "total_tokens": 14014, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
