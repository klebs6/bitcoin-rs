{"id": "batch_req_692cd66d86ec8190b677743646f75486", "custom_id": "bitcoin-time-ai-readme-request", "response": {"status_code": 200, "request_id": "580b15ecc29d0df0087e49009370fd08", "body": {"id": "chatcmpl-ChlLTBgtdNGbDKYQnqUqt6jTCI485", "object": "chat.completion", "created": 1764546135, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-time\",\n    \"full_readme_markdown\": \"# bitcoin-time\\n\\nHigh\u2011fidelity time utilities and ISO\u20118601 formatting/parsing for Bitcoin\u2011style systems, ported from Bitcoin Core's C++ `std::chrono` and time logic.\\n\\n> This README was generated by an AI model. It may not be perfectly accurate, but it should be a good, reasonably faithful description of the crate.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-time` provides a small, focused toolkit for dealing with time in Bitcoin\u2011like nodes and services:\\n\\n- Strongly\u2011typed duration aliases mirroring C++ `std::chrono` typedefs.\\n- Conversion utilities between Rust `Duration` and C `timeval` for `select()`/FFI.\\n- Helpers to extract seconds/milliseconds/microseconds as integers or `f64`.\\n- ISO\u20118601 date/time formatting and parsing around Unix timestamps.\\n- A **mockable** notion of \\\"current time\\\" for deterministic testing.\\n- A generic **median filter** for time offset consensus, modeled on Bitcoin Core's time adjustment logic.\\n\\nThe design goal is *deterministic, debuggable, and testable time behavior* suitable for consensus\u2011sensitive or protocol\u2011sensitive code.\\n\\n---\\n\\n## Features at a Glance\\n\\n- `MillisToTimeval` trait to convert millisecond values into `libc::timeval` (for e.g. `select`, `poll`, or other C APIs).\\n- Duration typedefs:\\n  - `Milliseconds`, `Microseconds`, `Seconds`, `SecondsDouble` (all `StdDuration`)\\n  - `Minutes` (wrapper newtype over `Duration` preserving upstream semantics).\\n- Global mock time and time offset:\\n  - `MOCK_TIME: AtomicI64` \u2013 mock time in **seconds since Unix epoch**;\\n  - `TIME_OFFSET: Mutex<i64>` \u2013 P2P time offset in seconds.\\n- Helpers:\\n  - `count_seconds` / `count_milliseconds` / `count_microseconds` / `count_seconds_double`.\\n  - `get_time_since_epoch<T>()` \u2013 mock\u2011aware, generic over `From<StdDuration>`.\\n  - `get_system_time_since_epoch<T>()` \u2013 never mockable.\\n  - `get_time_millis_since_epoch`, `get_time_micros_since_epoch`, `get_time_seconds_since_epoch`.\\n  - `uninterruptible_sleep` \u2013 panic on negative durations, otherwise sleep fully.\\n- ISO\u20118601 conversion:\\n  - `format_iso8601date_time` \u2013 `YYYY\u2011MM\u2011DDTHH:MM:SSZ`.\\n  - `format_iso8601date` \u2013 `YYYY\u2011MM\u2011DD`.\\n  - `parse_iso8601date_time` \u2013 string \u2192 epoch seconds, fall back to `0`.\\n- `MedianFilter<T>` \u2013 generic streaming median over the last `N` values.\\n\\nAll functions are instrumented with structured logging (via tracing macros in upstream code) and are intended to be safe, simple building blocks for higher\u2011level protocols.\\n\\n---\\n\\n## Installation\\n\\n```toml\\n[dependencies]\\nbitcoin-time = \\\"0.1.19\\\"\\n```\\n\\nThis crate targets Rust **2021 edition**.\\n\\n---\\n\\n## Duration Typedefs\\n\\nThe crate mirrors Bitcoin Core's `std::chrono` typedefs so that ported logic can be left structurally intact:\\n\\n```rust\\nuse bitcoin_time::{Milliseconds, Microseconds, Seconds, SecondsDouble, Minutes};\\n\\nfn demo(d: Seconds) {\\n    let s: i64 = bitcoin_time::count_seconds(d);\\n    let ms: i64 = bitcoin_time::count_milliseconds(d as Milliseconds);\\n    let us: i64 = bitcoin_time::count_microseconds(d as Microseconds);\\n    let s_f64: f64 = bitcoin_time::count_seconds_double(d as SecondsDouble);\\n    println!(\\\"s={s}, ms={ms}, us={us}, s_f64={s_f64}\\\");\\n}\\n```\\n\\nInternally these are `std::time::Duration` (or a thin wrapper for `Minutes`), but the explicit aliases encode intent and protect call\u2011sites from relying on particular underlying units.\\n\\n---\\n\\n## Milliseconds \u2192 `timeval`\\n\\n`MillisToTimeval` abstracts conversion from millisecond counts into a `libc::timeval`, suitable for `select()` or other C APIs:\\n\\n```rust\\nuse bitcoin_time::MillisToTimeval;\\n\\nfn poll_timeout(ms: i64) -> libc::timeval {\\n    ms.millis_to_timeval()\\n}\\n\\nfn from_duration(d: std::time::Duration) -> libc::timeval {\\n    d.millis_to_timeval()\\n}\\n```\\n\\nThe implementation splits milliseconds into `tv_sec` and `tv_usec` with integer arithmetic, preserving full microsecond resolution up to the limits of `i64` and `libc::time_t`.\\n\\n---\\n\\n## ISO\u20118601 Formatting and Parsing\\n\\nFor interoperable logs, RPC, and on\u2011wire protocols, `bitcoin-time` provides deterministic conversion between Unix timestamps and ISO\u20118601 strings.\\n\\n### Formatting\\n\\n```rust\\nuse bitcoin_time::{format_iso8601date_time, format_iso8601date};\\n\\nlet epoch: i64 = 1_609_459_200; // 2020\u201112\u201131T00:00:00Z\\nlet ts = format_iso8601date_time(epoch);\\nlet d = format_iso8601date(epoch);\\n\\nassert_eq!(ts, \\\"2020-12-31T00:00:00Z\\\");\\nassert_eq!(d,  \\\"2020-12-31\\\");\\n```\\n\\nFormatting is total: invalid timestamps (e.g. out of range for the underlying library) degrade to `\\\"\\\"` rather than panicking.\\n\\n### Parsing\\n\\n```rust\\nuse bitcoin_time::parse_iso8601date_time;\\n\\nlet epoch = parse_iso8601date_time(\\\"2020-12-31T00:00:00Z\\\");\\nassert_eq!(epoch, 1_609_459_200);\\n\\n// On parse failure we get 0.\\nassert_eq!(parse_iso8601date_time(\\\"nonsense\\\"), 0);\\n```\\n\\nParsing is strict with respect to the `YYYY\u2011MM\u2011DDTHH:MM:SSZ` grammar and returns `0` on failure so protocol layers can treat invalid timestamps as sentinel values without panics.\\n\\n---\\n\\n## Mock Time and Time Offset\\n\\nConsensus\u2011critical systems often differentiate between:\\n\\n- **Physical time** \u2013 OS clock, never overridden.\\n- **Mock time** \u2013 controlled value for tests and simulations.\\n- **P2P time offset** \u2013 correction derived from peers' clocks.\\n\\n`bitcoin-time` encodes exactly these three:\\n\\n### Mock Time\\n\\n```rust\\nuse bitcoin_time::{set_mock_time, get_mock_time_since_epoch};\\nuse std::time::Instant;\\n\\n// Set mock time (seconds since epoch) relative to an `Instant`.\\nset_mock_time(Instant::now());\\n\\n// Read it back as a Duration since epoch.\\nlet mock = get_mock_time_since_epoch();\\nassert!(mock.as_secs() > 0);\\n```\\n\\n`MOCK_TIME` is **global** and expressed as seconds since Unix epoch. A value of `0` denotes \\\"no mock time\\\" and triggers fallback to real system time.\\n\\n### Time Since Epoch\\n\\n```rust\\nuse bitcoin_time::{\\n    get_time_since_epoch,\\n    get_system_time_since_epoch,\\n    get_time_millis_since_epoch,\\n    get_time_micros_since_epoch,\\n    get_time_seconds_since_epoch,\\n};\\nuse std::time::Duration as StdDuration;\\n\\n// Mock\u2011aware time since epoch.\\nlet d: StdDuration = get_time_since_epoch();\\n\\n// Real (non\u2011mockable) time.\\nlet real_d: StdDuration = get_system_time_since_epoch();\\n\\nlet ms: i64 = get_time_millis_since_epoch();\\nlet us: i64 = get_time_micros_since_epoch();\\nlet s:  i64 = get_time_seconds_since_epoch();\\n```\\n\\n`get_time_since_epoch<T>()` and `get_system_time_since_epoch<T>()` are generic over `T: From<StdDuration>`, letting you choose your own duration wrapper or fixed\u2011point representation.\\n\\n### P2P Time Offset and Adjusted Time\\n\\n```rust\\nuse bitcoin_time::{get_time_offset, get_adjusted_time, get_adjusted_datetime};\\n\\nlet offset_s: i64 = get_time_offset();\\nlet adjusted_epoch: i64 = get_adjusted_time();\\nlet adjusted_dt = get_adjusted_datetime();\\n```\\n\\nThe **time offset** is usually derived from the median of peer clocks and is meant to be small (on the order of seconds). `get_adjusted_time()` adds this offset to the current physical time to produce P2P time.\\n\\n---\\n\\n## MedianFilter\\n\\n`MedianFilter<T>` implements a sliding window median over the last `N` observations. This is used in Bitcoin Core to robustly estimate clock offsets under adversarial or noisy peer behavior.\\n\\nMathematically, for a multiset \\\\( S = \\\\{x_1, \\\\dots, x_n\\\\} \\\\) sorted in nondecreasing order, the median is:\\n\\n- \\\\( x_{(n+1)/2} \\\\) if \\\\( n \\\\) is odd;\\n- \\\\( \\\\frac{1}{2}(x_{n/2} + x_{n/2+1}) \\\\) if \\\\( n \\\\) is even.\\n\\n`MedianFilter` realizes this definition on a bounded window by retaining at most `n_size` values, copying and sorting them for each update.\\n\\n### Type Bounds\\n\\n```rust\\nimpl<T> MedianFilter<T>\\nwhere\\n    T: Copy\\n        + PartialOrd\\n        + Add<Output = T>\\n        + Div<Output = T>\\n        + From<u8>\\n```\\n\\nThe constraints enable ordering and arithmetic on `T`, and allow division by `2` for the even\u2011length case (`T::from(2u8)`). Typical choices are `i32`, `i64`, `f32`, `f64`.\\n\\n### Usage Example\\n\\n```rust\\nuse bitcoin_time::MedianFilter;\\n\\nlet mut f = MedianFilter::new(5, 0_i64);\\n\\nfor v in [1, 100, 2, 3, 1000] {\\n    f.input(v);\\n}\\n\\nlet m = f.median();\\nassert_eq!(m, 3); // median of [1, 2, 3, 100, 1000]\\nassert_eq!(f.size(), 5);\\n```\\n\\nThe implementation characteristics:\\n\\n- Bounded memory: stores at most `n_size` items.\\n- On insertion, if full, drops the oldest element (FIFO).\\n- Complexity is `O(n log n)` per insertion due to sorting; this is entirely adequate for small `n` (typical P2P consensus windows are <= a few hundred elements).\\n\\n---\\n\\n## Chrono Sanity Check\\n\\n`chrono_sanity_check()` validates that Rust's `UNIX_EPOCH` constant aligns with the Unix epoch (time `0`) by verifying that `UNIX_EPOCH.duration_since(UNIX_EPOCH)` equals `Duration::ZERO`.\\n\\n```rust\\nlet ok = bitcoin_time::chrono_sanity_check();\\nassert!(ok);\\n```\\n\\nThis function is intended as a defensive assertion for environments with potentially misconfigured or exotic time bases.\\n\\n---\\n\\n## Uninterruptible Sleep\\n\\n`uninterruptible_sleep` enforces a non\u2011negative duration and sleeps once for the full period:\\n\\n```rust\\nuse std::time::Duration;\\nuse bitcoin_time::uninterruptible_sleep;\\n\\nuninterruptible_sleep(Duration::from_millis(250));\\n```\\n\\nInternally this:\\n\\n- Rejects negative durations (`try_into()` on the underlying type will panic).\\n- Delegates to `std::thread::sleep`.\\n\\nThis is useful when the semantics require that a sleep either completes fully or aborts the program rather than returning early.\\n\\n---\\n\\n## Design Notes\\n\\n- **Epoch alignment** \u2013 All epoch computations assume the Unix epoch and are checked via `chrono_sanity_check()`.\\n- **Mock vs physical** \u2013 Functions are explicit about whether they obey `MOCK_TIME` (`get_time_since_epoch`) or bypass it (`get_system_time_since_epoch`, `get_time_millis_since_epoch`, etc.).\\n- **Integer conversions** \u2013 Conversions from `Duration` to `i64` intentionally truncate toward zero (`as_secs`, `as_millis`, `as_micros`), as required by consensus code ports.\\n- **Error handling** \u2013 Parsing and formatting favor *total* behavior without panics, returning sentinel values (`0`, empty strings) on failure, while logging through the tracing infrastructure in the original codebase.\\n\\n---\\n\\n## Repository and License\\n\\nThis crate is part of the `bitcoin-rs` project:\\n\\n- Repository: <https://github.com/klebs6/bitcoin-rs>\\n- License: MIT\\n\\nContributions should preserve deterministic behavior and compatibility with the upstream Bitcoin Core time semantics.\\n\",\n    \"package_categories\": [\n      \"date-and-time\",\n      \"cryptography\",\n      \"network-programming\",\n      \"science\"\n    ],\n    \"package_description\": \"Bitcoin Core-inspired time utilities: Unix-epoch conversions, ISO-8601 formatting/parsing, mockable system time, timeval conversion, and a generic median filter for P2P time offset estimation.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"time\",\n      \"chrono\",\n      \"iso8601\",\n      \"mock-time\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 4510, "completion_tokens": 3153, "total_tokens": 7663, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
