{"id": "batch_req_692ce0ee9c488190bbb7714332f88d37", "custom_id": "bitcoin-fees-ai-readme-request", "response": {"status_code": 200, "request_id": "11a7d6aadf18bd1fc065ee3c84e29b96", "body": {"id": "chatcmpl-Chm2qFQWYI83dVDxywlxAJJD0juVI", "object": "chat.completion", "created": 1764548824, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-fees\",\n    \"full_readme_markdown\": \"# bitcoin-fees\\n\\nHigh\u2011precision Bitcoin fee\u2011rate primitives, estimation modes, and fee filter rounding logic, extracted from Bitcoin Core and exposed as an idiomatic Rust API.\\n\\nThis crate focuses on the *numerical and policy layer* of Bitcoin transaction fees: units (sat/kvB vs sat/vB), conversion and formatting, deterministic rounding rules, and support structures for fee estimation across different confirmation horizons.\\n\\n> NOTE: This README was generated by an AI model and may not be 100% accurate; however, it should be a close approximation of the crate\u2019s intent and functionality. Consult the source for canonical semantics.\\n\\n---\\n\\n## Features at a Glance\\n\\n- **`FeeRate`** \u2013 canonical representation of fee rates in *satoshis per kilobyte* (sat/kvB), plus conversion to sat/vB; fully ordered, additive, and serializable.\\n- **`FeeEstimateMode`** \u2013 strong typing for the standard Bitcoin Core estimation modes (`UNSET`, `ECONOMICAL`, `CONSERVATIVE`) plus unit selectors (`BTC_KVB`, `SAT_VB`).\\n- **`FeeEstimateHorizon`** \u2013 identifiers for short/medium/long half\u2011life horizons used in multi\u2011timescale fee estimation models.\\n- **`FeeReason`** \u2013 structured reasons explaining *why* a particular fee estimate was chosen (e.g. conservative, mempool minimum, fallback).\\n- **`FeeFilterRounder`** \u2013 geometric bucketing and randomized back\u2011rounding of fee filter values for mempool announcement privacy, matching Core\u2019s fee filter logic.\\n- String helpers for error messages and diagnostics (`fee_modes`, `fee_mode_from_string`, etc.).\\n\\nThis crate is intended for implementers of Bitcoin nodes, wallets, fee estimators, and simulation frameworks that want deterministic, Core\u2011compatible behaviour at the fee policy level.\\n\\n---\\n\\n## Core Concepts\\n\\n### Fee Units and Conversions\\n\\nBitcoin Core historically expresses most fee policy in **sat/kvB** (satoshis per 1000 bytes). Modern tooling often reasons in **sat/vB** (satoshis per virtual byte). The relationship is purely scalar:\\n\\n\\\\[\\n\\\\text{sat/kvB} = 1000\\\\,\\\\text{sat/vB}\\n\\\\]\\n\\n`FeeRate` is intentionally stored as **sat/kvB**, mirroring Core\u2019s internal representation. Conversions are performed explicitly in methods such as `to_string` (when asked for `SAT_VB`) and `new_with_fee_paid` (when using the special `num_bytes == COIN` convention to interpret the result as sat/vB).\\n\\nThe rate is applied linearly over transaction size, with integer truncation towards zero followed by a *minimal non\u2011zero correction* to avoid hiding sign information. This mirrors Core\u2019s fee rounding semantics:\\n\\n- Fee is computed as:\\n  - `fee = floor(rate_sat_per_k * size_bytes / 1000)` with integer arithmetic.\\n- If this would yield `0` but the rate is non\u2011zero, the result is adjusted to `\u00b11 sat`.\\n\\nThis behaviour is critical in consensus\u2011adjacent tooling: you never want an apparently non\u2011zero rate to silently become zero when applied to a small transaction.\\n\\n### Fee Estimation Horizons\\n\\n`FeeEstimateHorizon` labels three separate tracking windows used by advanced fee estimators:\\n\\n- `SHORT_HALFLIFE` \u2013 sensitive to recent mempool conditions; tracks rapid changes.\\n- `MED_HALFLIFE` \u2013 intermediate stability.\\n- `LONG_HALFLIFE` \u2013 slow\u2011moving, robust to noise; suitable for conservative estimates.\\n\\nAn estimator can maintain separate `TxConfirmStats` or analogous structures for each horizon and choose between them according to the requested `FeeEstimateMode`.\\n\\n### Fee Reasons\\n\\n`FeeReason` is a structured explanation of how/why a final fee estimate was selected:\\n\\n- `NONE` \u2013 unspecified.\\n- `HALF_ESTIMATE` \u2013 estimate based on *half* the requested target with a 60% threshold.\\n- `FULL_ESTIMATE` \u2013 estimate directly for the requested target with an 85% threshold.\\n- `DOUBLE_ESTIMATE` \u2013 estimate using a *double* target horizon with a 95% threshold.\\n- `CONSERVATIVE` \u2013 conservative selection using longer horizons and double targets.\\n- `MEMPOOL_MIN` \u2013 clamped to the mempool\u2019s minimum fee.\\n- `PAYTXFEE` \u2013 user\u2011configured fixed paytxfee was applied.\\n- `FALLBACK` \u2013 fallback fee in absence of estimator data.\\n- `REQUIRED` \u2013 minimum fee required by policy or consensus.\\n\\nThis is primarily for diagnostics, logging, and API transparency.\\n\\n---\\n\\n## Crate Layout\\n\\nThe key public items exposed by this crate include:\\n\\n- Enums:\\n  - `FeeReason`\\n  - `FeeEstimateHorizon`\\n  - `FeeEstimateMode`\\n- Structs:\\n  - `FeeRate`\\n  - `FeeFilterRounder`\\n  - `FeeCalculation` (result container: estimate + reason + targets)\\n- Utility functions:\\n  - `string_for_fee_reason(FeeReason) -> String`\\n  - `string_for_fee_estimate_horizon(FeeEstimateHorizon) -> String`\\n  - `fee_mode_map() -> &'static Vec<(String, FeeEstimateMode)>`\\n  - `fee_modes(delimiter: &str) -> String`\\n  - `invalid_estimate_mode_error_message() -> String`\\n  - `fee_mode_from_string(mode_string: &str, &mut FeeEstimateMode) -> bool`\\n\\nSeveral types (`Amount`, `FastRandomContext`, constants like `COIN`, `CURRENCY_UNIT`, `CURRENCY_ATOM`, `FEE_FILTER_SPACING`, `MAX_FILTER_FEERATE`, and the `FeeRateEstimationResult` inside `FeeCalculation`) are defined elsewhere in the `bitcoin-rs` workspace. This crate focuses on the *fee\u2011specific* logic.\\n\\n---\\n\\n## Installation\\n\\n```toml\\n[dependencies]\\nbitcoin-fees = \\\"0.1.21\\\"\\n```\\n\\nThis crate targets **Rust 1.56+ with edition 2021**, and is licensed under **MIT**.\\n\\n---\\n\\n## `FeeRate`: Construction, Ordering, and Usage\\n\\n### Creating Fee Rates\\n\\n```rust\\nuse bitcoin_fees::{FeeRate, FeeEstimateMode};\\n\\n// 1. Explicit sat/kvB constructor\\nlet rate = FeeRate::new(2_500u64); // 2_500 sat/kvB\\n\\n// 2. From fee paid and transaction size in bytes\\nlet fee_paid: i64 = 15_000;       // satoshis\\nlet tx_size: u32 = 250;           // bytes\\nlet rate2 = FeeRate::new_with_fee_paid(&fee_paid, tx_size);\\n\\n// 3. Default (0 sat/kvB)\\nlet zero = FeeRate::default();\\nassert_eq!(zero.get_fee_perk(), 0);\\n```\\n\\nThe `new_with_fee_paid` constructor follows Bitcoin Core\u2019s dual\u2011unit convention: if `num_bytes == COIN (1e8)`, it interprets the resulting rate as sat/vB. This nuance matters if you are interoperating with Core\u2019s fee estimation RPCs or low\u2011level policy logic.\\n\\n### Computing Fees\\n\\n```rust\\nuse bitcoin_fees::FeeRate;\\n\\nlet rate = FeeRate::new(10_000u64); // 10_000 sat/kvB\\n\\n// Fee for a 250\u2011byte tx\\nlet fee_250 = rate.get_fee(250);   // integer arithmetic with truncation\\n\\n// Fee per kvB (exactly 1000 bytes)\\nlet per_k = rate.get_fee_perk();   // == 10_000 sat\\n```\\n\\nThe truncation\u2011toward\u2011zero plus \u00b11 sat correction ensures monotonicity with respect to the sign of the rate while preserving Core equivalence.\\n\\n### Comparison and Aggregation\\n\\n`FeeRate` implements `Ord`, `PartialOrd`, `Clone`, `Copy`, `Eq`, and `AddAssign<&FeeRate>`:\\n\\n```rust\\nuse bitcoin_fees::FeeRate;\\n\\nlet mut a = FeeRate::new(1_000u64);\\nlet b = FeeRate::new(2_000u64);\\n\\nassert!(a < b);\\n\\na += &b; // now a is 3_000 sat/kvB\\n```\\n\\nYou can use `FeeRate` directly in ordered containers (`BTreeMap`, `BTreeSet`) or as keys in priority queues for fee\u2011based mempool policies.\\n\\n### Human\u2011Readable Formatting\\n\\n```rust\\nuse bitcoin_fees::{FeeRate, FeeEstimateMode};\\n\\nlet rate = FeeRate::new(150_000u64); // 150k sat/kvB\\n\\n// Default formatting (BTC/kvB)\\nlet s_default = rate.to_string(None);\\n// e.g., \\\"0.00150000 BTC/kvB\\\" depending on COIN and CURRENCY_UNIT\\n\\n// Explicit sat/vB formatting\\nlet s_sat_vb = rate.to_string(Some(&FeeEstimateMode::SAT_VB));\\n// e.g., \\\"150.000 SAT/vB\\\"\\n\\n// Display impl delegates to to_string(None)\\nprintln!(\\\"{}\\\", rate); // BTC/kvB representation\\n```\\n\\nThe output strings use the global `CURRENCY_UNIT` (e.g. `BTC`) and `CURRENCY_ATOM` (e.g. `sat`) constants from the broader `bitcoin-rs` workspace.\\n\\n---\\n\\n## Fee Estimation Modes and Parsing\\n\\n`FeeEstimateMode` encodes both policy modes and unit choices:\\n\\n- `UNSET` \u2013 default; the caller did not specify a mode.\\n- `ECONOMICAL` \u2013 prefers lower fees, willing to accept more confirmation risk.\\n- `CONSERVATIVE` \u2013 prefers higher fees, targeting high confirmation probability.\\n- `BTC_KVB` \u2013 explicit BTC/kvB display/interpretation.\\n- `SAT_VB` \u2013 explicit sat/vB display/interpretation.\\n\\nThe crate provides lookup helpers to parse user input into these modes:\\n\\n```rust\\nuse bitcoin_fees::{FeeEstimateMode, fee_mode_from_string, fee_modes, invalid_estimate_mode_error_message};\\n\\nlet mut mode = FeeEstimateMode::UNSET;\\n\\nassert!(fee_mode_from_string(\\\"economical\\\", &mut mode));\\nassert_eq!(mode, FeeEstimateMode::ECONOMICAL);\\n\\nassert!(fee_mode_from_string(\\\"Conservative\\\", &mut mode));\\nassert_eq!(mode, FeeEstimateMode::CONSERVATIVE);\\n\\n// Listing available modes suitable for CLI docs or RPC errors\\nlet modes_csv = fee_modes(\\\", \\\"); // \\\"unset, economical, conservative\\\"\\n\\n// Standardized error message\\nlet msg = invalid_estimate_mode_error_message();\\n// \\\"Invalid estimate_mode parameter, must be one of: \\\\\\\"unset\\\\\\\", \\\\\\\"economical\\\\\\\", \\\\\\\"conservative\\\\\\\"\\\"\\n```\\n\\nThis design is useful for implementing RPC endpoints or CLIs that mirror Bitcoin Core\u2019s `estimate_mode` parameter.\\n\\n---\\n\\n## Horizons and Reasons as Strings\\n\\nFor logging and user\u2011facing APIs you can convert horizons and reasons to strings:\\n\\n```rust\\nuse bitcoin_fees::{\\n    FeeEstimateHorizon, FeeReason,\\n    string_for_fee_estimate_horizon, string_for_fee_reason,\\n};\\n\\nlet h = FeeEstimateHorizon::LONG_HALFLIFE;\\nassert_eq!(string_for_fee_estimate_horizon(h), \\\"long\\\");\\n\\nlet r = FeeReason::CONSERVATIVE;\\nlet desc = string_for_fee_reason(r);\\n// \\\"Conservative Double Target longer horizon\\\"\\n```\\n\\nThese are intended to be stable, human\u2011interpretable descriptors that can appear in logs, JSON responses, or monitoring dashboards.\\n\\n---\\n\\n## `FeeFilterRounder`: Privacy\u2011Preserving Fee Filters\\n\\nBitcoin nodes advertise a **fee filter** to peers, indicating the minimum fee rate of transactions they are interested in receiving. Broadcasting the exact minimum fee can leak information about local mempool state and policy. To mitigate this, Bitcoin Core uses a *geometric series of allowed buckets* and a slight randomization when rounding.\\n\\n`FeeFilterRounder` implements this mechanism:\\n\\n- Constructed from a `min_incremental_fee` (`FeeRate`).\\n- Builds a `BTreeSet<FloatOrd<f64>>` of bucket boundaries:\\n  - Starts from `max(1 sat, min_incremental_fee.get_fee_perk() / 2)`.\\n  - Geometric progression via a spacing factor `FEE_FILTER_SPACING`.\\n  - Truncated at `MAX_FILTER_FEERATE`.\\n  - Always includes `0`.\\n- `round(current_min_fee)` selects the bucket *at or above* `current_min_fee` and then, with 2/3 probability (and unless already at the smallest bucket), steps back by one bucket. If `current_min_fee` exceeds all buckets, the maximum bucket is chosen and the stepping\u2011back logic still applies.\\n\\nThis yields a **quantized and stochastically perturbed** fee filter, reducing the information content of a single advertised value.\\n\\n### Usage\\n\\n```rust\\nuse bitcoin_fees::{FeeFilterRounder, FeeRate};\\n\\n// Example: construct from a 1 sat/vB incremental fee.\\n// Suppose 1 sat/vB corresponds to 1000 sat/kvB internally.\\nlet incremental = FeeRate::new(1_000u64);\\nlet mut rounder = FeeFilterRounder::new(&incremental);\\n\\n// Round an internal minimum fee\\nlet internal_min_fee: i64 = 12_345; // satoshis\\nlet filter_value = rounder.round(internal_min_fee);\\n\\n// `filter_value` is quantized and randomized according to Core\u2019s rules.\\n```\\n\\n**Concurrency note:** `round` is *not* thread\u2011safe due to the use of `FastRandomContext`. Instantiate separate `FeeFilterRounder` instances per thread or guard access with external synchronization if you require concurrent usage.\\n\\n---\\n\\n## `FeeCalculation`: Carrying Estimation Results\\n\\n`FeeCalculation` bundles the outcome of a fee estimation:\\n\\n- `est: FeeRateEstimationResult` \u2013 estimator output (defined elsewhere in the workspace).\\n- `reason: FeeReason` \u2013 structured reason for the selected estimate.\\n- `desired_target: i32` \u2013 requested confirmation target (e.g. N blocks).\\n- `returned_target: i32` \u2013 target that the estimator actually used.\\n\\nThis struct is convenient for exposing rich estimation results through internal APIs or RPC layers, while remaining decoupled from any particular estimator implementation.\\n\\n---\\n\\n## Integration Patterns\\n\\n### Wallet Fee Selection\\n\\nA minimal wallet integration might:\\n\\n1. Choose `FeeEstimateMode` based on user preference (economical vs conservative).\\n2. Query an estimator that returns a `FeeRate` and `FeeReason`.\\n3. Apply `FeeRate::get_fee(tx_vsize)` to obtain fee in satoshis.\\n4. Present both the computed fee and the `FeeReason` description to the user.\\n\\n### Node Fee Filter Logic\\n\\nA node implementation can:\\n\\n1. Track a mempool\u2011derived minimum fee internally.\\n2. Maintain a `FeeFilterRounder` seeded from local fee policy.\\n3. Periodically call `round(min_fee)` to produce updated fee filter values.\\n4. Advertise these values via peer protocol messages.\\n\\n### Simulation and Research\\n\\nFor fee\u2011market modelling or backtesting:\\n\\n- Use `FeeEstimateHorizon` to index datasets by decay half\u2011life.\\n- Use `FeeRate` for consistent units and rounding when computing transaction inclusion thresholds.\\n- Use `FeeReason` to introspect the trade\u2011off between aggressive and conservative policies.\\n\\n---\\n\\n## Relationship to Bitcoin Core\\n\\nThis crate is derived from and intended to be behaviourally aligned with **Bitcoin Core**\u2019s fee handling logic. The integer arithmetic, choice of 1000\u2011byte kilobyte, truncation rules, and fee filter bucketing all matter for exact equivalence.\\n\\nIf you require strict compatibility with Core for wallet fee selection, mempool policies, or RPC emulation, you should:\\n\\n- Treat this crate\u2019s behaviour as the authoritative reference for fee\u2011rate math.\\n- Keep the crate version synchronized with the upstream `bitcoin-rs` repository (`https://github.com/klebs6/bitcoin-rs`).\\n\\n---\\n\\n## License\\n\\nThis crate is distributed under the **MIT** license.\\n\\n---\\n\\n## Provenance and Accuracy\\n\\nThis README was generated by an AI model based on the public interface of the `bitcoin-fees` crate and may contain minor inaccuracies or omissions. For production\u2011critical applications, always validate behavioural details against the source code and, if relevant, upstream Bitcoin Core.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"finance\",\n      \"algorithms\",\n      \"network-programming\",\n      \"science\"\n    ],\n    \"package_description\": \"Bitcoin Core\u2013compatible fee-rate primitives, estimation modes, horizons, and fee-filter rounding logic for building nodes, wallets, and fee estimators in Rust.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"fees\",\n      \"feerate\",\n      \"mempool\",\n      \"wallet\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 4606, "completion_tokens": 3925, "total_tokens": 8531, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
