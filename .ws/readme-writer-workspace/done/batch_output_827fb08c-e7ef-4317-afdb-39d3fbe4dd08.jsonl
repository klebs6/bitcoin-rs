{"id": "batch_req_692cd223a89481909c3aaaece85b0f2b", "custom_id": "bitcoin-amt-ai-readme-request", "response": {"status_code": 200, "request_id": "b3a40f1a1a635492f849736f492f80f3", "body": {"id": "chatcmpl-Chl3tQNYuHqSyXuZCwxibetUqJLng", "object": "chat.completion", "created": 1764545045, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-amt\",\n    \"full_readme_markdown\": \"# bitcoin-amt\\n\\nType-safe Bitcoin amount primitives and wallet ownership flags extracted from `bitcoin-core` semantics.\\n\\n> **Note**: This README was generated by an AI model and may not be 100% accurate, though it should be a close approximation of the crate's intent and API.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-amt` provides minimal but semantically rich primitives for working with Bitcoin wallet amounts and ownership classification, closely mirroring Bitcoin Core's `IsMine` logic and money range checks.\\n\\nIt focuses on three concerns:\\n\\n1. **Amount representation** in satoshis, including negative values for intermediate accounting.\\n2. **Wallet ownership flags** (\\\"IsMine\\\" semantics) via a bitflag type.\\n3. **Cachable per-flag amounts** split between watch-only and spendable balances.\\n\\nThe crate is intentionally small and low-level. It is designed to be embedded within higher-level Bitcoin libraries, wallet engines, and UTXO/accounting layers.\\n\\n## Crate Features at a Glance\\n\\n- `Amount = i64` in **satoshis** (1 BTC = 100_000_000 sats).\\n- `money_range(&Amount) -> bool` validating values against `MAX_MONEY`.\\n- `IsMineType` as a `bitflags!`-based classification of ownership:\\n  - `ISMINE_NO`\\n  - `ISMINE_WATCH_ONLY`\\n  - `ISMINE_SPENDABLE`\\n  - `ISMINE_USED`\\n  - `ISMINE_ALL`\\n  - `ISMINE_ALL_USED`\\n  - `ISMINE_ENUM_ELEMENTS` (sentinel / count of logical enum elements)\\n- `IsMineFilter = u8`, suitable for compact storage and indexing.\\n- `CachableAmount`: an indexed cache of amounts keyed by `IsMine` flags, tracking which entries are valid via a `BitSet`.\\n\\nThis mirrors Bitcoin Core wallet semantics sufficiently to integrate with descriptor-based or legacy wallet designs.\\n\\n## Installation\\n\\nAdd to your `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-amt = \\\"0.1.19\\\"\\n```\\n\\nThe crate targets Rust **edition 2021** and is licensed under **MIT**.\\n\\n## Core Types\\n\\n### `Amount`\\n\\n```rust\\n/// Amount in satoshis (can be negative)\\npub type Amount = i64;\\n```\\n\\nDesign notes:\\n- **Unit**: always satoshis, not BTC.\\n- **Sign**: can be negative to support internal accounting (e.g., deltas, fees, reorg adjustments).\\n\\nYou are responsible for using `money_range` (or stronger invariants) to ensure that user-facing balances stay within the protocol-defined range.\\n\\n### `IsMineFilter`\\n\\n```rust\\n/// Used for bitflags of isminetype\\npub type IsMineFilter = u8;\\n```\\n\\n`IsMineFilter` is a compact, indexable representation (0-based) that corresponds to flags in `IsMineType` and to indices in the `CachableAmount::value` array.\\n\\nIt is suitable for:\\n- Array indexing\\n- Compact serialization (e.g., in persistence formats or network messages internal to a wallet implementation)\\n\\n### `IsMineType`\\n\\n```rust\\nbitflags! {\\n    pub struct IsMineType: u32 {\\n        const ISMINE_NO            = 0;\\n        const ISMINE_WATCH_ONLY    = 1 << 0;\\n        const ISMINE_SPENDABLE     = 1 << 1;\\n        const ISMINE_USED          = 1 << 2;\\n        const ISMINE_ALL           = Self::ISMINE_WATCH_ONLY.bits | Self::ISMINE_SPENDABLE.bits;\\n        const ISMINE_ALL_USED      = Self::ISMINE_ALL.bits        | Self::ISMINE_USED.bits;\\n        const ISMINE_ENUM_ELEMENTS = Self::ISMINE_ALL_USED.bits + 1;\\n    }\\n}\\n```\\n\\nThe semantics follow Bitcoin Core's `IsMine` description:\\n\\n- **LegacyScriptPubKeyMan**\\n  - `ISMINE_NO`: scriptPubKey not in wallet.\\n  - `ISMINE_WATCH_ONLY`: scriptPubKey imported as watch-only.\\n  - `ISMINE_SPENDABLE`: scriptPubKey corresponds to an address whose private key is in the wallet.\\n  - `ISMINE_USED`: scriptPubKey corresponds to a **used** address (helps wallet hygiene, gap limit handling, and privacy heuristics).\\n  - `ISMINE_ALL`: all flags except `USED`.\\n  - `ISMINE_ALL_USED`: all flags including `USED`.\\n\\n- **DescriptorScriptPubKeyMan / future ScriptPubKeyMan**\\n  - `ISMINE_NO`: scriptPubKey not in wallet.\\n  - `ISMINE_SPENDABLE`: scriptPubKey matches a descriptor-derived wallet script.\\n  - `ISMINE_USED`: same notion of usedness as above.\\n\\n`ISMINE_ENUM_ELEMENTS` acts as a sentinel for sizing arrays that store per-flag values.\\n\\n### `CachableAmount`\\n\\n```rust\\n/// Cachable amount subdivided into watchonly and spendable parts.\\npub struct CachableAmount {\\n    cached: BitSet,\\n    value: [Amount; IsMineType::ISMINE_ENUM_ELEMENTS.bits as usize],\\n}\\n```\\n\\n`CachableAmount` maintains a small array of `Amount` values, each associated with a particular `IsMineFilter` index, and a parallel `BitSet` that tracks which entries are validly computed.\\n\\nThis is primarily used to cache balances in wallet contexts, e.g.:\\n- total watch-only value,\\n- total spendable value,\\n- partitioned by flags such as `USED`.\\n\\n#### Methods\\n\\n```rust\\nimpl CachableAmount {\\n    #[inline]\\n    pub fn reset(&mut self) {\\n        self.cached.reset();\\n    }\\n\\n    pub fn set(&mut self, filter: IsMineFilter, value: Amount) {\\n        self.cached.set(filter.into(), true);\\n        self.value[filter as usize] = value;\\n    }\\n}\\n```\\n\\n- `reset` invalidates all cached values.\\n- `set` marks the entry for `filter` as valid and stores the `Amount` in the backing array.\\n\\nWallet implementations typically combine this with additional getters that:\\n- check the `BitSet` before reading a value,\\n- lazily compute aggregates if not cached.\\n\\n## Range Checking\\n\\n```rust\\n#[inline]\\npub fn money_range(n_value: &Amount) -> bool {\\n    *n_value >= 0 && *n_value <= MAX_MONEY\\n}\\n```\\n\\n`money_range` enforces the economic constraint that a value must be within `[0, MAX_MONEY]`, where `MAX_MONEY` is the protocol-level upper bound (typically 21_000_000 BTC expressed in satoshis, i.e. `2_100_000_000_000_000` sats).\\n\\nUse this function whenever you:\\n- accept external values that should represent real balances,\\n- validate transaction outputs or computed wallet totals,\\n- guard against overflow or pathological values during deserialization.\\n\\nNote: `Amount` can be negative, but `money_range` explicitly forbids negative values. This allows you to distinguish between internal deltas and externally valid balances.\\n\\n## Example Usage\\n\\n### Basic amount handling\\n\\n```rust\\nuse bitcoin_amt::{Amount, money_range};\\n\\nfn validate_user_balance(balance_sats: i64) -> Option<Amount> {\\n    let amt: Amount = balance_sats;\\n    if money_range(&amt) {\\n        Some(amt)\\n    } else {\\n        None\\n    }\\n}\\n```\\n\\n### Caching watch-only vs spendable\\n\\n```rust\\nuse bitcoin_amt::{Amount, IsMineFilter, CachableAmount};\\n\\nfn update_cache(cache: &mut CachableAmount, watch_only: Amount, spendable: Amount) {\\n    const FILTER_WATCH_ONLY: IsMineFilter = 1; // example mapping\\n    const FILTER_SPENDABLE: IsMineFilter = 2;  // example mapping\\n\\n    cache.set(FILTER_WATCH_ONLY, watch_only);\\n    cache.set(FILTER_SPENDABLE, spendable);\\n}\\n```\\n\\nIn a real wallet, `IsMineFilter` values should be aligned with your mapping from `IsMineType` variants to indices.\\n\\n## Integration Notes\\n\\n- **Repository**: <https://github.com/klebs6/bitcoin-rs>\\n- **License**: MIT\\n- **Intended consumers**: Low-level Bitcoin wallet engines, indexing nodes, UTXO managers, and analytic tooling that need to stay semantically close to Bitcoin Core.\\n\\nThe crate does not attempt to provide a complete wallet; instead, it aims to provide interoperable primitives for money amounts and ownership semantics that can be shared across higher-level components.\\n\\nWhen integrating:\\n- Propagate `Amount` throughout your accounting layer in satoshis.\\n- Use `IsMineType` and `IsMineFilter` to partition balances.\\n- Employ `CachableAmount` in your balance cache or view abstraction to avoid recomputing aggregates on each query.\\n\\n---\\n\\nIf any detail appears inconsistent with the actual implementation, please consult the source in the `bitcoin-rs` repository and treat this README as a high-level guide rather than a formal specification.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"finance\",\n      \"network-programming\"\n    ],\n    \"package_description\": \"Low-level Bitcoin amount and wallet ownership flag primitives mirroring Bitcoin Core IsMine semantics, including satoshi amounts, money range validation, and cachable per-flag balances.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"wallet\",\n      \"amount\",\n      \"ismine\",\n      \"satoshis\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 2955, "completion_tokens": 2264, "total_tokens": 5219, "prompt_tokens_details": {"cached_tokens": 0, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
