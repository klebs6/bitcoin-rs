{"id": "batch_req_692cdd52b06881908bd67eac8ec76deb", "custom_id": "bitcoin-sha256-ai-readme-request", "response": {"status_code": 200, "request_id": "494c037e2d40061034ee8e7326071e7b", "body": {"id": "chatcmpl-ChlnvL7e1hn2SLTO4bq3m8NVUhswm", "object": "chat.completion", "created": 1764547899, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-sha256\",\n    \"full_readme_markdown\": \"# bitcoin-sha256\\n\\nAn aggressively optimized, Bitcoin-Core\u2013compatible SHA\u2011256 implementation in Rust, with explicit control over compression rounds, FFI\u2011oriented entry points, and CPU\u2011feature\u2013aware backend selection.\\n\\n> NOTE: This README.md was generated by an AI model. It may not perfectly describe the crate, but it should be a close and reasonably accurate approximation.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-sha256` provides a low\u2011level, **bit\u2011for\u2011bit compatible** SHA\u2011256 implementation tuned for Bitcoin workloads:\\n\\n- Streaming hasher `Sha256` implementing `std::io::Write`.\\n- A `ComputeSha256` trait for computing SHA\u2011256 on `u256` values.\\n- Explicit, FIPS\u2011180\u20114\u2013accurate bitwise primitives for \u03a3/\u03c3, Ch, Maj, and a canonical `sha256_round` implementation.\\n- Single\u2011block and batched compression entry points that mirror Bitcoin Core\u2019s C++ layout.\\n- Auto\u2011detected CPU backends (scalar, SHANI, AVX2) for double\u2011SHA\u2011256 on 64\u2011byte blocks.\\n- FFI\u2011compatible pointer APIs for integration with C/C++ or other runtime systems.\\n\\nThe design goal is **mechanical fidelity** to Bitcoin Core\u2019s SHA\u2011256 logic while leveraging Rust\u2019s type system and tooling (e.g., `tracing`) for observability and safety where it does not interfere with performance.\\n\\n---\\n\\n## Features at a Glance\\n\\n- **Canonical SHA\u2011256 compression**\\n  - `sha256_transform_block` implements the full 64\u2011round compression function on a single 64\u2011byte block, with explicit round scheduling and feed\u2011forward.\\n  - `sha256_round` gives a pedagogical, round\u2011by\u2011round view of the inner operation, matching the original C++ macro semantics.\\n\\n- **Streaming hasher**\\n  - `Sha256` struct represents a stateful hasher:\\n    - `s: [u32; 8]` \u2013 internal state words.\\n    - `buf: [u8; 64]` \u2013 64\u2011byte block buffer.\\n    - `bytes: u64` \u2013 total bytes consumed.\\n  - Implements `Default`, `Write`, and convenient helpers like `new`, `reset`, `finalize`, and `finalize_wipe`.\\n\\n- **Bitcoin\u2011style double\u2011SHA\u2011256**\\n  - Scalar reference path: `transform_d64_scalar(out32, in64)` computes `SHA256(SHA256(message))` for a single 64\u2011byte message.\\n  - Backend abstraction (`Sha256Backend`) supports optimized 2\u2011way, 4\u2011way, and 8\u2011way double\u2011SHA\u2011256 transforms.\\n\\n- **Backend auto\u2011detection**\\n  - `sha256auto_detect()` inspects CPU features (e.g., `sha`, `avx2`) and configures the best implementation:\\n    - Standard scalar backend.\\n    - SHANI\u2011accelerated backend (`enable-shani` feature).\\n    - AVX2 8\u2011way double\u2011SHA\u2011256 (`enable-avx2` feature).\\n  - Returns a human\u2011readable description closely mirroring Bitcoin Core\u2019s strings, e.g.:\\n    - `\\\"standard\\\"`\\n    - `\\\"shani(1way,2way)\\\"`\\n    - `\\\"avx2(8way)\\\"`\\n    - `\\\"shani(1way,2way),avx2(8way)\\\"`\\n\\n- **FFI\u2011friendly surface**\\n  - Pointer\u2011based APIs such as `sha256_write`, `sha256_finalize`, `sha256_transform`, `transform_d64_scalar`, and the `TransformType` / `TransformD64Type` aliases allow direct integration with C ABI call sites.\\n\\n- **Internal validation**\\n  - `self_test()` exhaustively validates compression states and double\u2011SHA\u2011256 helpers against canonical fixtures, including misaligned input cases used in Bitcoin Core.\\n\\n---\\n\\n## Cryptographic Background\\n\\nThe implementation is a direct encoding of FIPS\u00a0180\u20114 (SHA\u2011256) semantics:\\n\\n- **State**: eight 32\u2011bit words \\\\( (a,b,c,d,e,f,g,h) \\\\).\\n- **Message schedule** \\\\(w_0,\\\\dots,w_{63}\\\\):\\n  - First 16 words are big\u2011endian decoded input.\\n  - Remaining 48 words derive via:\\n    \\\\[\\n    w_t = w_{t-16} + \\\\sigma_0(w_{t-15}) + w_{t-7} + \\\\sigma_1(w_{t-2}) \\\\pmod{2^{32}}\\n    \\\\]\\n- **Round function** for round \\\\(t\\\\):\\n  - `Ch` (choice): \\\\( \\\\operatorname{Ch}(x,y,z) = z \\\\oplus (x \\\\land (y \\\\oplus z)) \\\\)\\n  - `Maj` (majority): \\\\( \\\\operatorname{Maj}(x,y,z) = (x \\\\land y) \\\\lor (z \\\\land (x \\\\lor y)) \\\\)\\n  - Uppercase sigmas:\\n    - \\\\(\\\\Sigma_0(x) = x\\\\rotateRight{2} \\\\oplus x\\\\rotateRight{13} \\\\oplus x\\\\rotateRight{22}\\\\)\\n    - \\\\(\\\\Sigma_1(x) = x\\\\rotateRight{6} \\\\oplus x\\\\rotateRight{11} \\\\oplus x\\\\rotateRight{25}\\\\)\\n  - Lowercase sigmas for schedule:\\n    - \\\\(\\\\sigma_0(x) = x\\\\rotateRight{7} \\\\oplus x\\\\rotateRight{18} \\\\oplus (x \\\\gg 3)\\\\)\\n    - \\\\(\\\\sigma_1(x) = x\\\\rotateRight{17} \\\\oplus x\\\\rotateRight{19} \\\\oplus (x \\\\gg 10)\\\\)\\n\\nThe crate explicitly exposes these functions (`big_sigma0`, `big_sigma1`, `sha256_sigma0`, `sha256_sigma1`, `sha256_ch`, `sha256_maj`, `sha256_round`) to let advanced users audit, instrument, or swap specific components while preserving algebraic correctness.\\n\\nFor Bitcoin applications, **double\u2011SHA\u2011256** on fixed 64\u2011byte inputs is a first\u2011class workload (block headers, transaction IDs). This crate\u2019s `transform_d64_scalar` and the `TransformD64Type` family are designed specifically for that regime, enabling tight vectorization and multi\u2011lane execution.\\n\\n---\\n\\n## Installation\\n\\nAdd to your `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-sha256 = \\\"0.1.20\\\"\\n```\\n\\nOptional CPU\u2011specific features:\\n\\n```toml\\n[dependencies.bitcoin-sha256]\\nversion = \\\"0.1.20\\\"\\nfeatures = [\\\"enable-shani\\\", \\\"enable-avx2\\\"]\\n```\\n\\n> Note: exact feature names and combinations should be verified against the published crate metadata.\\n\\n---\\n\\n## Core Types and Traits\\n\\n### `Sha256`\\n\\nStreaming hasher for SHA\u2011256. Internally equivalent to the FIPS\u00a0180\u20114 reference with Bitcoin Core\u2013style block handling.\\n\\nKey capabilities:\\n\\n- `Sha256::new() -> Sha256` \u2013 construct a freshly initialized hasher.\\n- `Sha256::reset(&mut self)` \u2013 reset to IV, zeroing buffer and counters.\\n- `Sha256::finalize(&mut self, &mut [u8; 32])` \u2013 finalize without wiping internal state words.\\n- `Sha256::finalize_wipe(&mut self, &mut [u8; 32])` \u2013 finalize and zero state words for better key\u2011material hygiene.\\n- `Sha256::initialize(&mut self)` \u2013 (re)initialize internal state from IV.\\n- `Sha256::write_ptr(&mut self, data: *const u8, len: usize)` \u2013 low\u2011level pointer writer.\\n- `Sha256::write_from_iterator(&mut self, iter: Box<dyn Iterator<Item = u8>>, len: usize)` \u2013 drive from a byte iterator of known length.\\n\\n`Sha256` also implements `std::io::Write`, making it straightforward to integrate into existing I/O paths.\\n\\n#### Example: Hashing arbitrary data\\n\\n```rust\\nuse bitcoin_sha256::Sha256; // path may differ depending on crate layout\\n\\nfn sha256_bytes(data: &[u8]) -> [u8; 32] {\\n    let mut hasher = Sha256::new();\\n    use std::io::Write;\\n\\n    hasher.write_all(data).expect(\\\"write to Sha256\\\");\\n\\n    let mut out = [0u8; 32];\\n    hasher.finalize(&mut out);\\n    out\\n}\\n```\\n\\n### `ComputeSha256`\\n\\nTrait for computing SHA\u2011256 on types that can be treated as a 32\u2011byte value.\\n\\n```rust\\npub trait ComputeSha256 {\\n    fn sha256(&self) -> u256;\\n}\\n```\\n\\nThe crate provides an implementation for `u256`:\\n\\n```rust\\nimpl ComputeSha256 for u256 {\\n    fn sha256(&self) -> u256 {\\n        let mut result = u256::zero();\\n        let mut sha = Sha256::new();\\n        sha.write(self.as_ref());\\n        sha.finalize(result.as_mut_slice_exact());\\n        result\\n    }\\n}\\n```\\n\\nThis is particularly convenient for Bitcoin transaction IDs and block hashes.\\n\\n#### Example: Hashing a `u256`\\n\\n```rust\\nuse bitcoin_sha256::ComputeSha256; // and a suitable u256 type from your stack\\n\\nfn double_sha256_u256(x: &u256) -> u256 {\\n    x.sha256()\\n}\\n```\\n\\n> The exact `u256` type originates from the surrounding `bitcoin-rs` ecosystem; ensure you import the correct one.\\n\\n---\\n\\n## Low\u2011Level Compression API\\n\\nThe crate exposes the complete compression machinery for expert users.\\n\\n### IV initialization\\n\\n```rust\\npub fn sha256_initialize(s: *mut u32)\\n```\\n\\nWrites the standard FIPS\u00a0180\u20114 IV into an 8\u2011word state array pointed to by `s`.\\n\\n### Single\u2011block compression\\n\\n```rust\\npub fn sha256_transform_block(s: *mut u32, chunk: *const u8)\\n```\\n\\n- `s`: pointer to 8 writable `u32` words.\\n- `chunk`: pointer to exactly 64 bytes.\\n- Performs one SHA\u2011256 compression on the block and feed\u2011forwards the result into `*s`.\\n\\n### Batched compression\\n\\n```rust\\npub fn sha256_transform(s: *mut u32, chunk: *const u8, blocks: usize)\\n```\\n\\nProcesses `blocks` consecutive 64\u2011byte chunks starting at `chunk`.\\n\\n### Big\u2011endian word API\\n\\n```rust\\npub fn sha256_transform_one_block_be_words(s: *mut u32, chunk: *const u32)\\n```\\n\\nProcesses a 64\u2011byte chunk represented as 16 big\u2011endian `u32` words.\\n\\n### Bitwise components\\n\\n```rust\\npub fn big_sigma0(x: u32) -> u32\\npub fn big_sigma1(x: u32) -> u32\\npub fn sha256_sigma0(x: u32) -> u32\\npub fn sha256_sigma1(x: u32) -> u32\\npub fn sha256_ch(x: u32, y: u32, z: u32) -> u32\\npub fn sha256_maj(x: u32, y: u32, z: u32) -> u32\\n\\npub fn sha256_round(\\n    a: u32, b: u32, c: u32, d: &mut u32,\\n    e: u32, f: u32, g: u32, h: &mut u32,\\n    k: u32, w: u32,\\n)\\n```\\n\\nThese are useful for:\\n\\n- Writing alternative or instrumented compression loops.\\n- Formal verification or symbolic execution environments.\\n- Fine\u2011grained performance and microarchitectural analysis.\\n\\n---\\n\\n## Double\u2011SHA\u2011256 Helpers and Backends\\n\\n### Scalar reference path\\n\\n```rust\\npub fn transform_d64_scalar(out32: *mut u8, in64: *const u8)\\n```\\n\\nComputes `SHA256(SHA256(m))` for a single 64\u2011byte message `m`:\\n\\n1. Hashes the 64\u2011byte message with standard SHA\u2011256.\\n2. Serializes the first digest to big\u2011endian bytes.\\n3. Hashes that 32\u2011byte digest with SHA\u2011256 again.\\n4. Writes the final 32\u2011byte result to `out32`.\\n\\nThis implementation is architecturally neutral and acts as the reference behavior against which vectorized backends are validated.\\n\\n### Backend abstraction\\n\\n```rust\\npub type TransformType    = unsafe fn(*mut u32, *const u8, usize);\\npub type TransformD64Type = unsafe fn(*mut u8,  *const u8);\\n\\npub(crate) struct Sha256Backend {\\n    transform: TransformType,\\n    d64:       TransformD64Type,\\n    d64_2:     Option<TransformD64Type>,\\n    d64_4:     Option<TransformD64Type>,\\n    d64_8:     Option<TransformD64Type>,\\n    desc:      &'static str,\\n}\\n```\\n\\nDispatch helpers:\\n\\n```rust\\npub fn dispatch_transform(state: *mut u32, chunk: *const u8, blocks: usize)\\npub fn dispatch_d64(out: *mut u8, inp: *const u8)\\n```\\n\\nThey route through the globally selected backend configured by `sha256auto_detect()`.\\n\\n#### Auto\u2011detection\\n\\n```rust\\npub fn sha256auto_detect() -> String\\n```\\n\\n- Inspects `x86_64` CPU features using `std::arch::is_x86_feature_detected!`.\\n- Conditionally enables SHANI and AVX2 double\u2011SHA\u2011256 implementations.\\n- Publishes chosen function pointers into global `TRANSFORM*` slots.\\n- Runs `self_test()` to guarantee that the chosen backend is bit\u2011exact.\\n\\nYou should call `sha256auto_detect()` early in your process if you intend to use the global function pointers or want deterministic logging of which backend was selected.\\n\\n#### Example: Explicit backend selection and use\\n\\n```rust\\nfn init_and_use_backend(header: &[u8; 64]) -> [u8; 32] {\\n    let desc = bitcoin_sha256::sha256auto_detect();\\n    eprintln!(\\\"Selected SHA-256 backend: {desc}\\\");\\n\\n    let mut out = [0u8; 32];\\n    unsafe {\\n        bitcoin_sha256::dispatch_d64(out.as_mut_ptr(), header.as_ptr());\\n    }\\n    out\\n}\\n```\\n\\n> All pointer\u2011based functions are `unsafe` for a reason: you must uphold the documented size and aliasing constraints.\\n\\n---\\n\\n## Tagged Hash Initialization\\n\\nBitcoin uses **tagged hashes** of the form\\n\\n\\\\[\\nH(\\\\text{tag} \\\\parallel \\\\text{tag} \\\\parallel m)\\n\\\\]\\n\\nwhere \\\\(H\\\\) is SHA\u2011256 and \\\\(\\\\text{tag}\\\\) is a context string (e.g., `\\\"TapLeaf\\\"`).\\n\\nThe helper:\\n\\n```rust\\npub fn sha256_initialize_tagged(hash: *mut Sha256, tag: *const u8, taglen: usize)\\n```\\n\\nperforms:\\n\\n1. Initialize a `Sha256` context.\\n2. Compute `SHA256(tag)` into a temporary 32\u2011byte buffer.\\n3. Reset the context.\\n4. Write `SHA256(tag) || SHA256(tag)` into the context.\\n\\nAfter calling this, `hash` is ready to receive the message `m` such that `finalize` yields `SHA256(SHA256(tag) || SHA256(tag) || m)`.\\n\\n---\\n\\n## FFI Surface and Safety Contracts\\n\\nA subset of functions is specifically shaped for FFI use:\\n\\n- `sha256_write(hash: *mut Sha256, data: *const u8, len: usize)`\\n- `sha256_finalize(hash: *mut Sha256, out32: *mut u8)`\\n- `sha256_transform(s: *mut u32, chunk: *const u8, blocks: usize)`\\n- `transform_d64_scalar(out32: *mut u8, in64: *const u8)`\\n\\nTypical safety pre\u2011conditions:\\n\\n- Pointers must be valid for reads/writes of the documented length.\\n- Pointers must obey Rust\u2019s aliasing rules (i.e., do not create mutable aliases that overlap with other live references).\\n- Regions must not overlap when the API says so.\\n\\nUse these from C or C++ by exposing C\u2011ABI wrappers in your Rust crate that depend on `bitcoin-sha256`.\\n\\n---\\n\\n## Self\u2011Testing\\n\\n```rust\\npub fn self_test() -> bool\\n```\\n\\nRuns an internal suite that checks:\\n\\n1. Multiple\u2011block compression states against precomputed fixtures.\\n2. Double\u2011SHA\u2011256 helpers (scalar and available vectorized variants) against canonical outputs.\\n\\nIf any mismatch is detected, diagnostic information is printed to `stderr`. `sha256auto_detect()` calls `self_test()` and panics on failure to avoid silently running with an incorrect backend.\\n\\nYou can also integrate `self_test()` into your own startup checks if you manage backends manually.\\n\\n---\\n\\n## Logging and Instrumentation\\n\\nThe crate uses the `tracing` ecosystem for internal observability under the `\\\"sha256\\\"` target. Functions such as `sha256_sigma0`, `sha256_sigma1`, `sha256_round`, `sha256_transform`, `Sha256::write_ptr`, and `self_test` emit trace\u2011level events.\\n\\nTo use this effectively, include a `tracing-subscriber` setup in your binary and enable the `sha256` target at the desired level (e.g., TRACE in dev builds, OFF or ERROR in production).\\n\\n---\\n\\n## Performance Considerations\\n\\n- Core hot paths are annotated with `#[inline(always)]` where it materially affects performance, matching Bitcoin Core\u2019s expectations.\\n- The internal buffering strategy in `Sha256::write_ptr` minimizes copying by:\\n  - Topping up a partially filled internal 64\u2011byte buffer.\\n  - Processing as many full blocks as possible directly from the caller\u2019s memory.\\n  - Buffering any trailing bytes < 64.\\n- Double\u2011SHA\u2011256 backends are designed to maximize throughput on x86\u201164 with SHANI and AVX2 by processing multiple 64\u2011byte lanes in parallel.\\n\\nYou should benchmark your specific workload with and without the SHANI/AVX2 features enabled to measure the impact on your deployment targets.\\n\\n---\\n\\n## License\\n\\nThis crate is distributed under the **MIT** license.\\n\\nSee the repository for full license text:\\n\\n- Repository: <https://github.com/klebs6/bitcoin-rs>\\n\\n---\\n\\n## Disclaimer\\n\\nThis README was generated by an AI model and may not be perfectly synchronized with the actual crate version, public API surface, or feature flags. Always consult the source code and `Cargo.toml` of the published `bitcoin-sha256` crate for authoritative reference.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"science\",\n      \"mathematics\",\n      \"performance\"\n    ],\n    \"package_description\": \"Bitcoin-Core\u2013compatible SHA-256 and double-SHA-256 implementation in Rust with streaming hasher, explicit compression rounds, FFI-ready APIs, and CPU-feature-aware backend selection (scalar, SHANI, AVX2).\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"sha256\",\n      \"double-sha256\",\n      \"cryptography\",\n      \"hashing\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 12138, "completion_tokens": 4591, "total_tokens": 16729, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
