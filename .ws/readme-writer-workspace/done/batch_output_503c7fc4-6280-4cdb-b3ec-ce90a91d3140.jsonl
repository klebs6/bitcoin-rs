{"id": "batch_req_692cd2f389108190926c5991386338e0", "custom_id": "bitcoin-bech32m-ai-readme-request", "response": {"status_code": 200, "request_id": "791969d7253a811a93144c6326107d7d", "body": {"id": "chatcmpl-Chl74NN8GpJJAFsbZlHvJnRdSOECh", "object": "chat.completion", "created": 1764545242, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-bech32m\",\n    \"full_readme_markdown\": \"# bitcoin-bech32m\\n\\nA minimal, self-contained implementation of Bitcoin's Bech32 and Bech32m checksum algorithm (BIP-173, BIP-350) in Rust.\\n\\n> **Note**: This README was generated by an AI model. It may not be perfectly accurate in every detail, but it is intended to be a high-quality and practically useful overview.\\n\\n---\\n\\n## Overview\\n\\n`bitcoin-bech32m` provides low-level primitives for encoding and decoding Bech32 and Bech32m strings as used in modern Bitcoin address and data encodings:\\n\\n- **Bech32** (BIP-173) \u2014 used by legacy SegWit addresses (e.g. `bc1qw508d6...`).\\n- **Bech32m** (BIP-350) \u2014 used by Taproot and future SegWit versions (e.g. `bc1p...`).\\n\\nThis crate focuses on:\\n\\n- Exact adherence to the reference checksum construction.\\n- Transparent access to the underlying finite-field polynomial arithmetic (`poly_mod`).\\n- Explicit control over encoding type (`Encoding::BECH32` vs `Encoding::BECH32M`).\\n- Deterministic, allocation-conscious implementation with explicit data paths.\\n\\nIt is designed for consumers who want deterministic, inspectable primitives rather than a high-level address abstraction.\\n\\n---\\n\\n## Core Concepts\\n\\nBech32/Bech32m encodings are built from the following components:\\n\\n- **HRP (Human-Readable Part)**: network or application discriminator, ASCII, lower-case enforced by this crate (e.g. `\\\"bc\\\"`, `\\\"tb\\\"`, `\\\"lnbc\\\"`).\\n- **Data part**: base-32 sequence over a restricted 32-character alphabet; typically derived from underlying binary data by regrouping bits into 5-bit symbols.\\n- **Checksum**: 6 symbols that guarantee high-probability detection of input corruption.\\n\\nMathematically, the checksum is constructed as a **BCH code** over GF(32):\\n\\n- Data symbols are treated as coefficients of a polynomial \\\\( v(x) \\\\) over GF(32).\\n- The checksum is the remainder of \\\\( v(x) \\\\) times a fixed factor modulo a generator polynomial \\\\( g(x) \\\\) of degree 6:\\n\\n  \\\\[\\n  g(x) = x^6 + {29}x^5 + {22}x^4 + {20}x^3 + {21}x^2 + {29}x + {18}\\n  \\\\]\\n\\n- The implementation uses an efficient bit-packed state machine (`poly_mod`) to evolve the remainder as new symbols are appended.\\n- **Bech32 vs Bech32m** differ only by a final XOR with an encoding-specific constant (1 for Bech32, `0x2bc830a3` for Bech32m), which shifts the target remainder from `1` to `0x2bc830a3` and yields different error-locality invariants.\\n\\nThis crate exposes these mechanics directly so you can reason about correctness, compose your own higher-level encodings, or integrate with existing protocol logic where full control is required.\\n\\n---\\n\\n## Installation\\n\\nAdd the crate to your `Cargo.toml`:\\n\\n```toml\\n[dependencies]\\nbitcoin-bech32m = \\\"0.1.20\\\"\\n```\\n\\n---\\n\\n## Data Model\\n\\n### `Encoding`\\n\\n```rust\\n#[derive(Debug, PartialEq, Eq)]\\npub enum Encoding {\\n    INVALID,\\n    BECH32,\\n    BECH32M,\\n}\\n```\\n\\nRepresents the logical checksum variant:\\n\\n- `Encoding::BECH32`  \u2014 BIP-173 checksum constant.\\n- `Encoding::BECH32M` \u2014 BIP-350 checksum constant.\\n- `Encoding::INVALID` \u2014 used to signal decoding / verification failure.\\n\\n### `DecodeResult`\\n\\n```rust\\n#[derive(Debug, Getters)]\\n#[getset(get = \\\"pub\\\")]\\npub struct DecodeResult {\\n    encoding: Encoding,\\n    hrp:      String,\\n    data:     Vec<u8>,\\n}\\n\\nimpl Default for DecodeResult { /* ... */ }\\nimpl DecodeResult {\\n    pub fn new(enc: Encoding, h: String, d: Vec<u8>) -> Self { /* ... */ }\\n}\\n```\\n\\n`DecodeResult` captures the outcome of decoding a Bech32/Bech32m string:\\n\\n- `encoding()` \u2192 `Encoding`\\n- `hrp()`      \u2192 `&String` (normalized to lower-case)\\n- `data()`     \u2192 `&Vec<u8>` (payload without the 6-symbol checksum)\\n\\nOn any validation failure, `decode` returns `DecodeResult::default()`, which has:\\n\\n- `encoding == Encoding::INVALID`\\n- `hrp == \\\"\\\"`\\n- `data == []`\\n\\nCallers should treat `Encoding::INVALID` as the definitive failure signal.\\n\\n---\\n\\n## High-Level Usage\\n\\n### Encoding a Bech32 / Bech32m String\\n\\n```rust\\nuse bitcoin_bech32m::{Encoding, encode};\\n\\nfn main() {\\n    let hrp = String::from(\\\"bc\\\");         // human-readable part, must be lowercase\\n    let data: Vec<u8> = vec![0, 1, 2, 3];  // 5-bit groups (0..31), not raw bytes\\n\\n    // Bech32m for modern SegWit (e.g. Taproot)\\n    let addr = encode(Encoding::BECH32M, &hrp, &data);\\n    println!(\\\"{}\\\", addr);\\n}\\n```\\n\\n**Important**: `values` passed into `encode` are *already base32 symbols* (5-bit groups). The crate intentionally does not perform 8-bit \u2194 5-bit regrouping for you. This separation keeps the primitive pure and lets higher-level libraries decide how to map application data into 5-bit symbols.\\n\\n### Decoding a Bech32 / Bech32m String\\n\\n```rust\\nuse bitcoin_bech32m::{decode, Encoding};\\n\\nfn main() {\\n    let input = \\\"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty\\\";\\n\\n    let res = decode(input);\\n    if res.encoding() == &Encoding::INVALID {\\n        eprintln!(\\\"Invalid Bech32/Bech32m string\\\");\\n        return;\\n    }\\n\\n    println!(\\\"encoding = {:?}\\\", res.encoding());\\n    println!(\\\"hrp       = {}\\\",  res.hrp());\\n    println!(\\\"data ({} symbols) = {:?}\\\", res.data().len(), res.data());\\n}\\n```\\n\\nThe decoder enforces the following invariants:\\n\\n- All characters must be printable ASCII in `[0x21..0x7e]`.\\n- No mixed case: either entirely lower-case or entirely upper-case inputs (the HRP is normalized to lower-case in the result).\\n- Presence of a separator `'1'` that is not the first character.\\n- Total length \u2264 90 characters.\\n- At least 6 checksum symbols (`sep + 7 \u2264 input.len()`).\\n- All data characters must live in the Bech32 alphabet.\\n- Checksum must match Bech32 or Bech32m.\\n\\nIf any of these checks fail, you receive `DecodeResult::default()` with `Encoding::INVALID`.\\n\\n---\\n\\n## Lower-Level Primitives\\n\\nThese functions are useful when you need deeper control or are designing custom protocols on top of Bech32/Bech32m.\\n\\n### `encoding_constant`\\n\\n```rust\\npub fn encoding_constant(encoding: Encoding) -> u32\\n```\\n\\nReturns the final XOR constant used in the checksum definition:\\n\\n- For `Encoding::BECH32`  \u2192 `1`\\n- For `Encoding::BECH32M` \u2192 `0x2bc830a3`\\n\\nThe function asserts that `encoding` is either `BECH32` or `BECH32M`.\\n\\n### `expand_hrp`\\n\\n```rust\\npub fn expand_hrp(hrp: &String) -> Vec<u8>\\n```\\n\\nExpands the human-readable part into a sequence of 5-bit-like values used as the prefix to the checksum computation. This follows BIP-173 exactly:\\n\\n- High 5 bits of each character.\\n- A zero separator.\\n- Low 5 bits of each character.\\n\\nThis is part of the domain separation between HRP and data.\\n\\n### `poly_mod`\\n\\n```rust\\npub fn poly_mod(v: &Vec<u8>) -> u32\\n```\\n\\nComputes the polynomial remainder used by the Bech32/Bech32m checksum algorithm. The input vector is interpreted as coefficients in GF(32) as specified in the BIP and associated finite-field analysis:\\n\\n- Remainder is evolved iteratively as symbols are appended.\\n- Internally, state `c` is a 30-bit packed representation of the coefficients modulo the generator polynomial.\\n- Conditional XOR with precomputed constants implements multiplication by `{1, 2, 4, 8, 16}` in GF(32) times the `k(x) = x^6 mod g(x)` term.\\n\\nThis is an excellent hook if you need to:\\n\\n- Validate your own implementation by cross-checking remainders.\\n- Explore alternative BCH generator polynomials or code parameters.\\n- Perform incremental checksum updates as data streams in.\\n\\n### `create_checksum`\\n\\n```rust\\npub fn create_checksum(encoding: Encoding, hrp: &String, values: &Vec<u8>) -> Vec<u8>\\n```\\n\\nBuilds the 6-symbol checksum for a given HRP and data vector:\\n\\n1. Concatenates `expand_hrp(hrp)` and `values`.\\n2. Appends six zero symbols.\\n3. Runs `poly_mod` and XORs the result with `encoding_constant(encoding)`.\\n4. Decomposes the resulting 30-bit value into six 5-bit symbols.\\n\\nThe returned vector can be appended to the original data to produce a fully checksummed sequence.\\n\\n### `verify_checksum`\\n\\n```rust\\npub fn verify_checksum(hrp: &String, values: &Vec<u8>) -> Encoding\\n```\\n\\nDetermines whether the provided HRP and data+checksum vector is consistent with either Bech32 or Bech32m:\\n\\n- Returns `Encoding::BECH32` if the remainder equals `encoding_constant(BECH32)`.\\n- Returns `Encoding::BECH32M` if the remainder equals `encoding_constant(BECH32M)`.\\n- Returns `Encoding::INVALID` otherwise.\\n\\nThis lets you distinguish which variant a decoded string uses, which is essential for correct downstream semantics (e.g. SegWit version validation).\\n\\n### `encode`\\n\\n```rust\\npub fn encode(encoding: Encoding, hrp: &String, values: &Vec<u8>) -> String\\n```\\n\\nConstructs a full Bech32/Bech32m string from:\\n\\n- A lower-case HRP (asserts that no characters in `hrp` are upper-case).\\n- Data symbols `values` in `0..=31`.\\n- A 6-symbol checksum computed via `create_checksum`.\\n\\nThe final string is:\\n\\n```text\\n<lowercase-hrp> \\\"1\\\" <data+checksum encoded using the Bech32 charset>\\n```\\n\\nIf you supply a HRP containing any uppercase letters, the function will panic via assertion failure. This is deliberate: using a mixed-case HRP breaks the canonical encoding properties required by BIP-173/350.\\n\\n### `decode`\\n\\n```rust\\npub fn decode(input: &str) -> DecodeResult\\n```\\n\\nComprehensive decoder that:\\n\\n1. Validates character range and case uniformity.\\n2. Locates the separator `'1'` and checks length constraints.\\n3. Translates the post-separator section into 5-bit values using an internal reverse-charset table.\\n4. Normalizes the HRP to lower-case.\\n5. Runs `verify_checksum` to identify encoding type or reject the string.\\n\\nThis is the entry point you will generally use for reading Bech32/Bech32m strings.\\n\\n### Utility: `cat`\\n\\n```rust\\npub fn cat<T: Copy>(v1: Vec<T>, v2: &Vec<T>) -> Vec<T>\\n```\\n\\nEfficient vector concatenation that takes ownership of the first vector and appends the second by copying. Used internally in checksum construction, but also usable for general concatenation in Bech32-related pipelines.\\n\\n### Utility: `lower_case`\\n\\n```rust\\npub fn lower_case(c: u8) -> u8\\n```\\n\\nMaps a single ASCII byte to its lowercase form, panicking if the conversion fails. Primarily useful where you need to enforce canonical casing on raw bytes rather than `char`s.\\n\\n---\\n\\n## Error Handling and Invariants\\n\\nThis crate prefers **deterministic failure modes** with simple semantics:\\n\\n- **Decoding** never panics on malformed input \u2014 instead it returns `DecodeResult::default()`.\\n- **Encoding** may panic if used incorrectly, specifically:\\n  - HRP contains uppercase characters.\\n  - An invalid `Encoding` variant is passed to `encoding_constant` (the function asserts that the variant is one of the two valid constants).\\n\\nThese invariants are intended to keep protocol-facing code predictable while surfacing programmer errors early in development.\\n\\n---\\n\\n## Integration Patterns\\n\\n### Building Bitcoin Address Support\\n\\nTypical Bitcoin address stacks perform the following steps:\\n\\n1. Derive a witness program (version + program bytes).\\n2. Convert uint8 data into 5-bit base32 symbols.\\n3. Use `encode(Encoding::BECH32 or Encoding::BECH32M, &hrp, &symbols)` to produce the final address.\\n4. On decoding, use `decode`, check `Encoding`, HRP, and then convert the `data()` 5-bit symbols back into 8-bit bytes.\\n\\n`bitcoin-bech32m` intentionally focuses on steps (3) and (4). You are free to choose any bit-grouping strategy (or integrate an existing one) without being constrained by this crate.\\n\\n### Custom Protocol Tags\\n\\nBecause the HRP is an arbitrary ASCII string, you can define protocol-specific prefixes (e.g. `\\\"cust1\\\"`, `\\\"sig1\\\"`) and still benefit from Bech32m's strong error-detection guarantees. Use `Encoding::BECH32M` for new constructions unless you have a compatibility requirement for the original Bech32.\\n\\n---\\n\\n## Performance Considerations\\n\\n- Uses pre-allocation (`reserve`) in key paths to reduce allocations.\\n- The checksum state machine (`poly_mod`) is branch-predictable with a small set of conditional XOR operations.\\n- Suitable for high-throughput address validation or encoding in services that handle large volumes of Bitcoin-related traffic.\\n\\nThe algorithmic complexity is linear in input length, with very small constant factors.\\n\\n---\\n\\n## License\\n\\nThis crate is licensed under the **MIT** license.\\n\\nSee the repository for details:\\n\\n- Repository: <https://github.com/klebs6/bitcoin-rs>\\n\\n---\\n\\n## Disclaimer\\n\\nThis README was generated by an AI model. While it is designed to be technically accurate and practically useful, it may not reflect every nuance of the implementation or the latest changes. Always consult the source code and official BIPs (173 and 350) when implementing security-sensitive systems.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"encoding\",\n      \"network-programming\",\n      \"parsing\",\n      \"mathematics\"\n    ],\n    \"package_description\": \"Low-level Rust implementation of Bitcoin Bech32 and Bech32m (BIP-173, BIP-350) encoding/decoding, exposing checksum primitives, HRP expansion, and polynomial BCH code over GF(32) for robust address and protocol string handling.\",\n    \"package_keywords\": [\n      \"bitcoin\",\n      \"bech32\",\n      \"bech32m\",\n      \"checksum\",\n      \"bip-350\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 5903, "completion_tokens": 3707, "total_tokens": 9610, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
