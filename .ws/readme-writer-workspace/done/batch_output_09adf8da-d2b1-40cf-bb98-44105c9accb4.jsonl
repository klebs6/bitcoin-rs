{"id": "batch_req_692cdff02d7881908f70e77eec112b07", "custom_id": "bitcoin-hmac-sha512-ai-readme-request", "response": {"status_code": 200, "request_id": "543481379f841d798a099238e6465c64", "body": {"id": "chatcmpl-ChlykDKszVcJS9XPz5wTR7PUoslWD", "object": "chat.completion", "created": 1764548570, "model": "gpt-5.1-2025-11-13", "choices": [{"index": 0, "message": {"role": "assistant", "content": "```json\n{\n  \"fields\": {\n    \"crate_name\": \"bitcoin-hmac-sha512\",\n    \"full_readme_markdown\": \"# bitcoin-hmac-sha512\\n\\nA minimal, FFI\u2011friendly HMAC\u2011SHA\u2011512 implementation tailored for Bitcoin-style cryptographic workflows.\\n\\nThis crate exposes a low-level `HmacSha512` type that:\\n\\n- Implements **HMAC** (Keyed-Hash Message Authentication Code) using **SHA\u2011512** as specified in [RFC 2104] and [FIPS 198-1].\\n- Uses raw pointers (`*const u8`) and explicit lengths for data and keys.\\n- Avoids heap allocations and operates entirely on fixed-size stack buffers.\\n- Targets use in performance\u2011sensitive or foreign\u2011language (C/C++) bindings scenarios.\\n\\n> **Note**: This README was generated by an AI model and may not be 100% accurate. However, it should be a strong starting point and reasonably faithful to the crate's intent and interface.\\n\\n[RFC 2104]: https://datatracker.ietf.org/doc/html/rfc2104\\n[FIPS 198-1]: https://csrc.nist.gov/publications/detail/fips/198/1/final\\n\\n---\\n\\n## Core API\\n\\n```rust\\npub struct HmacSha512  {\\n    outer: Sha512,\\n    inner: Sha512,\\n}\\n\\nimpl HmacSha512 {\\n    pub fn new(key: *const u8, keylen: usize) -> Self;\\n\\n    pub fn write(&mut self, data: *const u8, len: usize) -> &mut HmacSha512;\\n\\n    pub fn finalize(&mut self, hash: &mut [u8; HMAC_SHA512_OUTPUT_SIZE]);\\n\\n    pub fn finalize_to_array(self) -> [u8; 64];\\n}\\n```\\n\\n`HMAC_SHA512_OUTPUT_SIZE` is expected to be `64` (the SHA\u2011512 digest size in bytes).\\n\\n### Construction\\n\\n```rust\\nuse bitcoin_hmac_sha512::HmacSha512;\\n\\n// Example key and message\\nlet key: [u8; 32] = [0x11; 32];\\nlet msg: [u8; 16] = [0x22; 16];\\n\\nlet mut hmac = unsafe { HmacSha512::new(key.as_ptr(), key.len()) };\\n```\\n\\nSemantics of `new`:\\n\\n- If `keylen <= 128` (one SHA\u2011512 block):\\n  - The key is copied into a 128\u2011byte buffer and zero\u2011padded.\\n- If `keylen > 128`:\\n  - The key is first hashed with SHA\u2011512 (producing 64 bytes), then that digest is zero\u2011padded to 128 bytes.\\n- From this **block-sized key** `rkey`, the inner/outer pads are created:\\n  - `outer_key = rkey ^ 0x5c`\\n  - `inner_key = rkey ^ 0x36` (via `rkey ^ (0x5c ^ 0x36)` in the code)\\n- Two internal `Sha512` states are initialized by absorbing these pads.\\n\\nThis is the canonical HMAC key-derivation procedure.\\n\\n### Incremental input (`write`)\\n\\n```rust\\nunsafe {\\n    hmac.write(msg.as_ptr(), msg.len());\\n}\\n\\n// Additional chunks may follow; the state is streaming.\\n```\\n\\nProperties:\\n\\n- `write` feeds bytes into the **inner** SHA\u2011512 state.\\n- Multiple calls append data logically: `write(a); write(b)` \u2261 `write(a || b)`.\\n- Returns `&mut HmacSha512` to allow chaining.\\n\\nExample:\\n\\n```rust\\nunsafe {\\n    HmacSha512::new(key.as_ptr(), key.len())\\n        .write(b\\\"hello\\\".as_ptr(), 5)\\n        .write(b\\\" world\\\".as_ptr(), 6);\\n}\\n```\\n\\n### Finalization\\n\\nThere are two ways to obtain the final 64\u2011byte MAC.\\n\\n#### 1. `finalize(&mut self, hash: &mut [u8; 64])`\\n\\n```rust\\nlet mut hmac = unsafe { HmacSha512::new(key.as_ptr(), key.len()) };\\nunsafe { hmac.write(msg.as_ptr(), msg.len()); }\\n\\nlet mut out = [0u8; 64];\\nhmac.finalize(&mut out);\\n\\n// `out` now contains the HMAC-SHA-512 tag.\\n```\\n\\nMechanics:\\n\\n1. The inner `Sha512` is finalized into a 64\u2011byte temporary buffer.\\n2. That inner digest is then fed into the outer `Sha512` state.\\n3. The outer state is finalized into the user\u2011provided buffer `hash`.\\n\\nThis matches the formal HMAC definition:\\n\\n\\\\[\\n\\\\operatorname{HMAC}_k(m) = H\\\\bigl((k'\\\\oplus opad) \\\\; || \\\\; H((k'\\\\oplus ipad) || m)\\\\bigr)\\n\\\\]\\n\\nwhere `H = SHA\u2011512` and `k'` is the block\u2011sized key derived from `k`.\\n\\n#### 2. `finalize_to_array(self) -> [u8; 64]`\\n\\n```rust\\nlet tag: [u8; 64] = unsafe {\\n    HmacSha512::new(key.as_ptr(), key.len())\\n        .write(msg.as_ptr(), msg.len())\\n        .finalize_to_array()\\n};\\n```\\n\\nThis convenience method consumes `self`, internally calls `finalize`, and returns the 64\u2011byte array by value.\\n\\n---\\n\\n## Safety and Usage Constraints\\n\\nThis crate is intentionally low\u2011level and uses raw pointers for maximum interop and minimal abstraction.\\n\\n### `unsafe` requirements\\n\\nAll of the following must hold whenever you call functions that take pointers:\\n\\n- `key` and `data` pointers must be **valid** for reads of `keylen`/`len` bytes.\\n- The memory they point to must be **properly aligned** for `u8` (trivially true for standard slices/arrays).\\n- The buffers must be **non\u2011overlapping** with internal state in ways assumed by `ptr::copy_nonoverlapping`.\\n- They must remain valid for the full duration of the call.\\n\\nTherefore, you will usually write:\\n\\n```rust\\nlet key: Vec<u8> = obtain_key();\\nlet msg: Vec<u8> = obtain_msg();\\n\\nlet mut hmac = unsafe { HmacSha512::new(key.as_ptr(), key.len()) };\\nunsafe { hmac.write(msg.as_ptr(), msg.len()); }\\n\\nlet mut out = [0u8; 64];\\nhmac.finalize(&mut out);\\n```\\n\\n### Thread safety\\n\\n`HmacSha512` instances are not intrinsically synchronized. Treat them as single\u2011threaded objects: one instance per logical computation, no concurrent mutation across threads without external synchronization.\\n\\n### Zeroization and key erasure\\n\\nThe snippet does not explicitly zeroize:\\n\\n- The internal key buffer `rkey` after initialization.\\n- Intermediate state in `Sha512` after use.\\n\\nIf you need strict key erasure semantics (e.g., side\u2011channel\u2011aware zeroization), verify the implementation of `Sha512` and consider wrapping usage with a secure\u2011memory abstraction.\\n\\n---\\n\\n## Intended Use Cases\\n\\n- **Bitcoin / cryptocurrency libraries** that already depend on SHA\u2011512 internally and want a compact HMAC adaptor.\\n- **FFI bindings** where the host language (C/C++/Go/others) holds raw buffers and lengths and calls into Rust.\\n- **Deterministic key derivation** or message authentication where SHA\u2011512 is mandated by protocol.\\n\\nNotably, HMAC-SHA-512 is ubiquitous in:\\n\\n- HD wallet key derivation procedures (e.g., BIP32 uses HMAC-SHA-512 under a fixed key for chain code generation).\\n- MAC layers in bespoke protocols that rely on 512\u2011bit security margins.\\n\\n---\\n\\n## Mathematical Background\\n\\nHMAC is defined as:\\n\\n\\\\[\\n\\\\operatorname{HMAC}_k(m) = H\\\\bigl((k'\\\\oplus opad) \\\\; || \\\\; H((k'\\\\oplus ipad) || m)\\\\bigr)\\n\\\\]\\n\\n- `H` is a cryptographic hash function (here: SHA\u2011512).\\n- `k` is the secret key; `k'` is `k` either truncated or hashed and then padded to the block size `B=128` bytes.\\n- `ipad` is the byte `0x36` repeated `B` times.\\n- `opad` is the byte `0x5c` repeated `B` times.\\n\\nThis construction provides:\\n\\n- **PRF** (pseudorandom function) behavior assuming the underlying hash behaves as a PRF on its compression function.\\n- **Message authentication** and **integrity** when the key is secret.\\n\\nThe implementation in this crate follows the standard two\u2011pass formulation using two `Sha512` instances and XOR padding.\\n\\n---\\n\\n## Example: Constant\u2011time tag comparison\\n\\nWhen verifying an HMAC tag, always compare in constant time to avoid timing side channels.\\n\\n```rust\\nfn ct_eq(a: &[u8], b: &[u8]) -> bool {\\n    if a.len() != b.len() { return false; }\\n    let mut acc = 0u8;\\n    for (&x, &y) in a.iter().zip(b.iter()) {\\n        acc |= x ^ y;\\n    }\\n    acc == 0\\n}\\n\\nfn verify_tag(key: &[u8], msg: &[u8], expected: &[u8; 64]) -> bool {\\n    let mut out = [0u8; 64];\\n    let mut hmac = unsafe { HmacSha512::new(key.as_ptr(), key.len()) };\\n    unsafe { hmac.write(msg.as_ptr(), msg.len()); }\\n    hmac.finalize(&mut out);\\n\\n    ct_eq(&out, expected)\\n}\\n```\\n\\nYou may wish to replace `ct_eq` with a formally audited constant\u2011time comparison from another crate when integrating into production systems.\\n\\n---\\n\\n## Integration Guidelines\\n\\n- **No\u2011std**: From the given interface, the crate itself appears independent of heap allocation and most of `std`, but verify the manifest and any additional modules before assuming `#![no_std]` compatibility.\\n- **Versioning**: This documentation aligns with crate version `0.1.1` as indicated by the user. If using another version, confirm that the API matches.\\n- **License**: MIT, suitable for both open\u2011source and proprietary integration.\\n\\n---\\n\\n## Disclaimer\\n\\nThis README.md file was generated by an AI model and may not be fully accurate in every implementation detail. It should, however, provide a high\u2011quality description and a practically usable guide to the crate as described.\\n\",\n    \"package_categories\": [\n      \"cryptography\",\n      \"algorithms\",\n      \"science\"\n    ],\n    \"package_description\": \"Low-level, FFI-friendly HMAC-SHA-512 implementation for Bitcoin-style cryptographic workflows, using raw pointers and fixed-size buffers for high-performance message authentication.\",\n    \"package_keywords\": [\n      \"hmac\",\n      \"sha512\",\n      \"bitcoin\",\n      \"cryptography\",\n      \"ffi\"\n    ]\n  },\n  \"struct_docs\": \" This structure is a directive indicating which fields we need you to provide for us in your response to our query.\\n\",\n  \"struct_name\": \"AiReadmeWriterDesiredOutput\",\n  \"type\": \"struct\"\n}\n```", "refusal": null, "annotations": []}, "finish_reason": "stop"}], "usage": {"prompt_tokens": 2470, "completion_tokens": 2650, "total_tokens": 5120, "prompt_tokens_details": {"cached_tokens": 1792, "audio_tokens": 0}, "completion_tokens_details": {"reasoning_tokens": 0, "audio_tokens": 0, "accepted_prediction_tokens": 0, "rejected_prediction_tokens": 0}}, "service_tier": "default", "system_fingerprint": null}}, "error": null}
