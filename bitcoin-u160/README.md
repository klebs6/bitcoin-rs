# bitcoin-u160

The `bitcoin-u160` crate provides an efficient representation for handling 160-bit opaque data blobs, typically used in Bitcoin and cryptographic applications. This crate is especially useful for developers seeking a robust, low-level interface for managing and manipulating 160-bit data structures without the overhead of integer operations.

## Features

- **Efficient Data Handling**: `u160` offers methods to construct from strings, vectors, and byte arrays, maintaining the integrity and validity of 160-bit data.
- **Compile-Time Array Construction**: Provides an interface to construct a `u160` object at compile-time using 20-byte arrays.
- **String Conversion**: Supports conversion to and from strings in hexadecimal format, providing ease of use for developers.
- **Compatibility with Byte Conventions**: Mirrors standard library conventions for byte ordering, supporting little-endian conversions.
- **Debugging and Logging**: Includes formatting capabilities that integrate with standard Rust `Debug` traits and supports tracing for observability.

## Usage

Add `bitcoin-u160` to your `Cargo.toml`:

```toml
[dependencies]
bitcoin-u160 = "0.1.18"
```

### Example

```rust
use bitcoin_u160::u160;

fn main() {
    // Create a u160 instance from a hexadecimal string
    let my_u160 = u160::from("0123456789abcdef0123456789abcdef01234567");
    println!("{:?}", my_u160);

    // Convert a byte array into a u160 instance
    let bytes: [u8; 20] = [0u8; 20];
    let my_u160_from_bytes = u160::from_le_bytes(bytes);
    println!("{:?}", my_u160_from_bytes);
}
```

For detailed documentation and further examples, visit the [repository](https://github.com/klebs6/bitcoin-rs).

---
This README file was generated by an AI model and may not be 100% accurate. However, it should provide a good foundational understanding of how to work with the `bitcoin-u160` crate.
