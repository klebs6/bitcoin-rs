#!/usr/bin/env raku

use Grammar::Tracer;
use Data::Dump::Tree;
use Config::TOML;

my %descriptions = %(
    "bitcoin-addr"               => "a service with information about it",
    "bitcoin-addrman"            => "stochastic address manager",
    "bitcoin-aes"                => "wrapper around a constant time AES implementation",
    "bitcoin-amt"                => "structs representing amounts in satoshis (which can be negative)",
    "bitcoin-argsman"            => "a manager for config and environment arguments",
    "bitcoin-asmap"              => "tools for working with the asmap",
    "bitcoin-banman"             => "banman manages two related but distinct concepts: banning and discouragement",
    "bitcoin-base58"             => "base58 encoding contians some useful properties -- especially for disallowing certain characters which look the same in some fonts",
    "bitcoin-bdb"                => "wrapper around a berkeley database",
    "bitcoin-bech32m"            => "string encoding formats used in newer address types",
    "bitcoin-bench"              => "benchmarks",
    "bitcoin-block"              => "blocks",
    "bitcoin-blockencoding"      => "blocks",
    "bitcoin-blockfilter"        => "blockfilter struct as defined in BIP 157",
    "bitcoin-blockman"           => "maintains a tree of blocks which is consulted to determine where the most-work tip is",
    "bitcoin-blockpolicy"        => "tools used for estimating the feerate needed for a transaction to be included in a block within a certain number of blocks",
    "bitcoin-bloom"              => "bloom filter is a probabilistic filter which SPV clients provide so we can filter the transactions we send them -- this allows for significantly more efficient transaction and block downloads",
    "bitcoin-cfg"                => "build dependency for specifying cfg aliases and cargo directives",
    "bitcoin-chacha"             => "classes for the ChaCha20 256 bitstream cipher",
    "bitcoin-chain-consensus"    => "structures for handling consensus on the chain",
    "bitcoin-chainman"           => "provides abstractions that allow the retrieval of the current most-work (active) chainstate, as well as chainstates which may be in background use to validate UTXO snapshots",
    "bitcoin-checkqueue"         => "one thread is assumed to push batches of verifications onto the CheckQueue, where they are processed",
    "bitcoin-cli"                => "command line",
    "bitcoin-client-ui"          => "signals for UI communication",
    "bitcoin-coincontrol"        => "coin stats",
    "bitcoin-coinselect"         => "abstractions for filtering which OutputGroups we may use in coin selection -- an OutputGroup is a group of UTXOs paid to the same output script",
    "bitcoin-coinsview"          => "abstractions for facilitating access to the UTXO set",
    "bitcoin-compat"             => "platform specific code and constant assertions for certain assumptions",
    "bitcoin-compressor"         => "compressor for scripts, amounts, etc",
    "bitcoin-connman"            => "a manager for connections and network access",
    "bitcoin-crc32c"             => "wrapper around crc32c functions",
    "bitcoin-crypter"            => "encryption/decryption context with key information",
    "bitcoin-cuckoo-cache"       => "high performance cache primitives",
    "bitcoin-daemon"             => "hooks to launch the bitcoin daemon",
    "bitcoin-db"                 => "wrappers around the bitcoin leveldb system",
    "bitcoin-deployment"         => "abstractions to help manage deployments",
    "bitcoin-derive"             => "proc macros for the bitcoin system",
    "bitcoin-dns"                => "functions to allow for service lookup -- resolve host strings to their corresponding network addresses",
    "bitcoin-dummywallet"        => "dummy wallet",
    "bitcoin-dumpwallet"         => "persist wallet to and from disk",
    "bitcoin-epoch"              => "RAII-style guard for using epoch-based graph traversal algorithms",
    "bitcoin-fees"               => "provides tools for working with and estimating bitcoin fees",
    "bitcoin-foundblock"         => "find block, find first block with time and height, find ancestor by height, find ancestor by hash, etc",
    "bitcoin-fuzz"               => "contains the bitcoin fuzz tests",
    "bitcoin-golombrice"         => "implements a golomb coded set as defined in BIP 158 -- provides encoding/decoding",
    "bitcoin-hash"               => "tools and context for hashing bytes",
    "bitcoin-hdchain"            => "simple HD chain data model",
    "bitcoin-hdkeypath"          => "tools for parsing and formatting HD keypaths",
    "bitcoin-http"               => "tools for managing the http subsystem",
    "bitcoin-imports"            => "encapsulates most third party deps for the bitcoin ecosystem",
    "bitcoin-index"              => "abstractions for working with indices of blockchain data",
    "bitcoin-indexed-chain"      => "abstractions for working with an in-memory indexed chain of blocks",
    "bitcoin-indirectmap"        => "map whose keys are pointers, but are compared by their dereferenced values",
    "bitcoin-init"               => "tools for handling process startup",
    "bitcoin-ipc"                => "tools for handling inter-process communication",
    "bitcoin-keymetadata"        => "abstractions for representing key metadata",
    "bitcoin-keypool"            => "the wallet holds one or several keypools.  These are sets of keys that have not yet been used to provide addresses or receive change.  This crate provides abstractions for working with keys from a wallet's keypool",
    "bitcoin-key"                => "tools for working with encapsulated public/private keys",
    "bitcoin-leveldb"            => "facade into the leveldb subsystem",
    "bitcoin-log"                => "abstractions around the system logger",
    "bitcoin-mainsignals"        => "used to manage a list of callbacks -- used to track which callbacks are registered, as well as any callbacks that are just unregistered and about to be deleted when they are done executing",
    "bitcoin-mem"                => "traits for tracking dynamic and recursive memory usage",
    "bitcoin-merkle"             => "contains two primary interfaces: 1) PartialMerkleTree -- represents a subset of the txid's of a known block, in a way that allows recovery of the list of txid's and the merkle root in an authenticated way.  2) MerkleBlock, used to relay blocks as header + Vec<MerkleBranch> to filtered nodes",
    "bitcoin-message"            => "tools for verification, hashing, and signing of messages",
    "bitcoin-miner"              => "tools for the BlockAssembler",
    "bitcoin-muhash"             => "MuHash is a hashing algorithm that supports adding set elements in any order but also deleting in any order.  As a result, it can maintain a running sum for a set of data as a whole, and add/remove when data is added to or removed from it. A downside is that computing an inverse is relatively expensive.",
    "bitcoin-net"                => "networking tools",
    "bitcoin-net-zmq"            => "networking tools for ZMQ",
    "bitcoin-netmsg"             => "transport protocol agnostic message container",
    "bitcoin-netpermissions"     => "net permissions flags",
    "bitcoin-network"            => "an abstraction representing a Network -- an address may belong to more than one Network",
    "bitcoin-node"               => "a node represents a peer in the network",
    "bitcoin-noui"               => "non-GUI handlers",
    "bitcoin-packages"           => "a package is an ordered list of transactions.  The transactions cannot conflict with (spend the same inputs as) one another",
    "bitcoin-peerman"            => "a manager for handling peers",
    "bitcoin-policy"             => "policy code for checking transaction attributes",
    "bitcoin-poly1305"           => "Poly1305 is a universal hash function suitable for use as a one-time authenticator and, when combined with a cipher, a message authentication code (MAC). It takes a 32-byte one-time key and a message and produces a 16-byte tag, which can be used to authenticate the message.",
    "bitcoin-portmap"            => "tools for port mapping",
    "bitcoin-pow"                => "tools for calculating and checking proof of work",
    "bitcoin-proxy"              => "tools for working with various proxy types (socks5, etc)",
    "bitcoin-psbt"               => "tools for working with partially signed transactions",
    "bitcoin-qt"                 => "GUI application layer code",
    "bitcoin-random"             => "random numbers in bitcoin",
    "bitcoin-rbf"                => "replace-by-fee state, enforcement, and utilities",
    "bitcoin-remote"             => "bitcoin RPC registrations and errors",
    "bitcoin-restapi"            => "http rest requests",
    "bitcoin-ripemd"             => "RIPEMD-160 -- made up of 80 stages made up of 5 blocks that run 16 times each",
    "bitcoin-sam"                => "I2P SAM session",
    "bitcoin-scheduler"          => "simple class for background tasks that should be run periodically or once after a while",
    "bitcoin-scripting"          => "bitcoin scripting system",
    "bitcoin-scriptpubkeyman"    => "manages some (or all) script pubkeys used in a walled -- contains the scripts and keys related to them which it manages",
    "bitcoin-secp256k1"          => "secp256k1 subsystem",
    "bitcoin-serialize"          => "tools for serialization",
    "bitcoin-service"            => "a service is a combination of a network address and a TCP port",
    "bitcoin-service-flags"      => "these are the flags which are required for a peer to support for them to be interesting to us -- ie, for us to wish to use one of our few outbound connection slots for or for us to wish to prioritize keeping their connection around.",
    "bitcoin-settings"           => "represents a settings value type",
    "bitcoin-sha1"               => "secure hash algorithm 1",
    "bitcoin-sha256"             => "(from wikipedia) SHA-256 and SHA-512 are novel hash functions computed with eight 32-bit and 64-bit words, respectively. They use different shift amounts and additive constants, but their structures are otherwise virtually identical, differing only in the number of rounds.",
    "bitcoin-sha3"               => "(from wikipedia) Although part of the same series of standards, SHA-3 (Keccak) is internally different from the MD5-like structure of SHA-1 and SHA-2. -- Keccak is based on a novel approach called sponge construction. Sponge construction is based on a wide random function or random permutation, and allows inputting (`absorbing` in sponge terminology) any amount of data, and outputting (`squeezing`) any amount of data, while acting as a pseudorandom function with regard to all previous inputs. This leads to great flexibility.",
    "bitcoin-sha512"             => "(from wikipedia) SHA-256 and SHA-512 are novel hash functions computed with eight 32-bit and 64-bit words, respectively. They use different shift amounts and additive constants, but their structures are otherwise virtually identical, differing only in the number of rounds.",
    "bitcoin-signet"             => "generate the signet tx corresponding to the given block -- the signed tx commits to everything in the block except 1) it hashes a modified merkle root with the signet signature removed.  2) it skips the nonce",
    "bitcoin-signingprovider"    => "an interface to be implemented by keystores that support signing",
    "bitcoin-siphash"            => "(from wikipedia) Although designed for use as a hash function to ensure security, SipHash is fundamentally different from cryptographic hash functions like SHA in that it is only suitable as a message authentication code: a keyed hash function like HMAC. That is, SHA is designed so that it is difficult for an attacker to find two messages X and Y such that SHA(X) = SHA(Y), even though anyone may compute SHA(X). SipHash instead guarantees that, having seen Xi and SipHash(Xi, k), an attacker who does not know the key k cannot find (any information about) k or SipHash(Y, k) for any message Y ∉ \{Xi\} which they have not seen before.",
    "bitcoin-sock"               => "RAII-helper class to manage a socket.  closes the socket automatically on drop",
    "bitcoin-sqlite"             => "wrapper around an SQLite database",
    "bitcoin-string"             => "string utilities for the bitcoin system -- BilingualStr, strings representing money",
    "bitcoin-subnet"             => "abstractions representing a subnet",
    "bitcoin-support"            => "allocators, memory cleansing, events, locked pools, memory arenas, etc",
    "bitcoin-sync"               => "synchronization primitives",
    "bitcoin-system"             => "system-level utilities",
    "bitcoin-test"               => "test framework for the bitcoin system",
    "bitcoin-time"               => "time utilities",
    "bitcoin-tokenpipe"          => "an interprocess or interthread pipe for sending tokens (one byte values) over",
    "bitcoin-top"                => "miscellaneous utilities -- this crate should probably be yanked and merged elsewhere",
    "bitcoin-tor"                => "tor control and connections",
    "bitcoin-tx"                 => "tools for working with bitcoin transactions",
    "bitcoin-txmempool"          => "TxMemPool stores valid-according-to-the-current-best-chain transactions that may be included in the next block",
    "bitcoin-txmempoolentry"     => "TxMemPoolEntry stores data about the corresponding transaction, as well as data about all in-mempool transactions that depend on the transaction (descendant transactions)",
    "bitcoin-univalue"           => "univalues and various token utilities",
    "bitcoin-validation"         => "tools for capturing information about block/transaction validation",
    "bitcoin-version"            => "tools related to versioning",
    "bitcoin-walletdb"           => "tools for interacting with the wallet database",
    "bitcoinchain-client"        => "interface to let node manage chain clients (wallets, or maybe tools for monitoring and analysis in the future)",
    "bitcoinchain-interface"     => "interface for giving clients ability to access the chain state, receive notifications, estimate fees, and submit transactions",
    "bitcoinchain-notifications" => "interface for notifying when, for example: transactions are added/removed to the mempool, blocks are connected/disconnected, the block tip is updated, or the chain state is flushed",
    "bitcoinchain-params"        => "chain parameters define various tweakable parameters of a given instance of the bitcoin system -- this crate contains utilities for working with them",
    "bitcoinleveldb-arena"       => "allocation arena for the bitcoin leveldb",
    "bitcoinleveldb-batch"       => "batch processing for the bitcoin leveldb",
    "bitcoinleveldb-bench"       => "benchmarks for the bitcoin leveldb",
    "bitcoinleveldb-bloom"       => "bloom filters for the bitcoin leveldb",
    "bitcoinleveldb-cache"       => "a cache is an interface that maps keys to values.  It has internal synchronization and may be safely accessed concurrently from multiple threads.  It may automatically evict entries to make room for new entries.  Values have a specified charge against the cache capacity. A builtin cache implementation with an LRU eviction policy is provided",
    "bitcoinleveldb-cfg"         => "configuration for the bitcoin leveldb",
    "bitcoinleveldb-coding"      => "endian-neutral encodings for the bitcoin leveldb -- fixed-length numbers are encoded LSB first.  Strings are encoded prefixed by their length in varint format",
    "bitcoinleveldb-comparator"  => "comparator for bitcoin leveldb",
    "bitcoinleveldb-compat"      => "platform specific code for the bitcoin leveldb",
    "bitcoinleveldb-crc32"       => "a portable implementation of crc32c used in bitcoin leveldb",
    "bitcoinleveldb-db"          => "a DB is a persistent ordered map from keys to values.  A DB is safe for concurrent access from multiple threads without any external synchronization",
    "bitcoinleveldb-dumpfile"    => "tools for persisting objects to disk",
    "bitcoinleveldb-duplex"      => "tools for two-level iteration",
    "bitcoinleveldb-env"         => "an Env is an interface used by the leveldb implementation to access operating system functionality like the filesystem etc.",
    "bitcoinleveldb-file"        => "contains file abstractions from the bitcoin leveldb",
    "bitcoinleveldb-filter"      => "a filter block is stored near the end of a table file.  It contains filters (eg blooms) for all data blocks in the table combined into a single filter block.",
    "bitcoinleveldb-hash"        => "simple hash functions used for internal data structures",
    "bitcoinleveldb-histogram"   => "simple histograms for use in leveldb",
    "bitcoinleveldb-key"         => "keys and values",
    "bitcoinleveldb-limiter"     => "helper abstractions used to limit resource usage to avoid exhaustion",
    "bitcoinleveldb-log"         => "an interface for writing log messages",
    "bitcoinleveldb-lru"         => "LRU cache implementation",
    "bitcoinleveldb-memenv"      => "environment that stores its data in memory and delegates all non-file storage tasks to base_env",
    "bitcoinleveldb-memtable"    => "in memory MemTable -- typically implemented by a SkipList",
    "bitcoinleveldb-merger"      => "an iterator that provides the union of the data in its children.  Takes ownership of the child iterators and will delete them when the result iterator is deleted",
    "bitcoinleveldb-meta"        => "leveldb metadata",
    "bitcoinleveldb-options"     => "options to control the behavior of a database",
    "bitcoinleveldb-posix"       => "posix file interface",
    "bitcoinleveldb-rand"        => "a very simple random number generator.  Not especially good at generating truly random bits, but good for basic usage in leveldb",
    "bitcoinleveldb-repair"      => "allows us to recover the contents of a descriptor from the other files we find",
    "bitcoinleveldb-skiplist"    => "skiplist datastructure implementation and iterators",
    "bitcoinleveldb-slice"       => "slices contain a pointer into some external storage and a size.  The user of a slice must ensure that the slice is not used after the corresponding external storage has been deallocated",
    "bitcoinleveldb-snapshot"    => "abstract handle to a particular state of a DB -- snapshots are kept in a doubly-linked list in the DB.  Each SnapshotImpl corresponds to a particular sequence number",
    "bitcoinleveldb-status"      => "a status encapsulates the result of an operation.  It may indicate success, or it may indicate an error with an associated error message",
    "bitcoinleveldb-sync"        => "helper classes for synchronization",
    "bitcoinleveldb-table"       => "abstractions for working with Tables -- a Table is a sorted map from strings to strings.  Tables are immutable and persistent.  A Table may be safely accessed from multiple threads without external synchronization.",
    "bitcoinleveldb-test"        => "compaction and corruption tests to be run on a leveldb instance",
    "bitcoinleveldb-util"        => "basic utilities used throughout leveldb",
    "bitcoinleveldb-version"     => "tools for working with versions -- each Version keeps track of a set of Table files per level.  The entire set of versions is maintained in a VersionSet",
    "bitcoinleveldb-versionedit" => "abstraction representing an edit on a particular version",
    "bitcoinnode-interface"      => "toplevel interface for a bitcoin node (aka bitcoind process)",
    "bitcoinnode-stats"          => "tools for analyzing node usage behavior",
    "bitcoinnode-txrelay"        => "node transaction relays",
    "bitcoinrpc-blockchain"      => "rpc tools interacting with the blockchain",
    "bitcoinrpc-dump"            => "rpc tools for dumping data",
    "bitcoinrpc-mining"          => "rpc tools related to mining",
    "bitcoinrpc-misc"            => "miscellanous rpc requests",
    "bitcoinrpc-net"             => "rpc requests related to networking",
    "bitcoinrpc-server"          => "tools to launch an RPC server",
    "bitcoinrpc-txn"             => "rpc tools interacting with transactions",
    "bitcoinrpc-util"            => "rpc utilities",
    "bitcoinrpc-wallet"          => "rpc tools for working with wallets",
    "bitcoinsecp256k1-bench"     => "benchmarks for the secp256k1 subsystem",
    "bitcoinsecp256k1-ec"        => "tools for running elliptic curve cryptography",
    "bitcoinsecp256k1-field"     => "field element module for usage in EC",
    "bitcoinsecp256k1-group"     => "abstracts a group element of the secp256k1 curve in affine coordinates",
    "bitcoinsecp256k1-keys"      => "structures to represent elliptic curve keys",
    "bitcoinsecp256k1-modinv"    => "implements modular inversion based on the paper: `fast constant-time gcd computation and modular inversion` by Daniel J. Bernstein and Bo-Yin Yang.",
    "bitcoinsecp256k1-parse"     => "please do not link this crate directly -- defines functions that parse DER with various errors and violations.",
    "bitcoinsecp256k1-recovery"  => "data structures which support PubKey recovery",
    "bitcoinsecp256k1-scalar"    => "scalars modulo the group order of the secp256k1 curve",
    "bitcoinsecp256k1-schnorr"   => "this crate implements a variant of Schnorr signatures compliant with BIP340",
    "bitcoinsecp256k1-scratch"   => "opaque data structures which manage rewritable scratch space",
    "bitcoinwallet-client"       => "wallet chain client that, in addition to having chain client methods for starting up, shutting down, registering RPCs, also has additional methods (called by the GUI) to load and create wallets",
    "bitcoinwallet-context"      => "a WalletContext contains references to state shared between wallet instances.  Future shared state can be added to these as an alternative to adding global variables.",
    "bitcoinwallet-feature"      => "tools for managing particular wallet features -- descriptors can contain wallet metadata",
    "bitcoinwallet-fees"         => "tools for working with wallet fees",
    "bitcoinwallet-init"         => "wallet initialization code",
    "bitcoinwallet-interface"    => "an interface for defining a bitcoin wallet -- contains various structs used throughout the wallet subsystem",
    "bitcoinwallet-library"      => "a wallet maintains a set of transactions and balances, and provides the ability to create new transactions",
    "bitcoinwallet-receive"      => "an interface for receiving funds with a bitcoin wallet",
    "bitcoinwallet-salvage"      => "an interface for recovering wallet data",
    "bitcoinwallet-spend"        => "an interface for sending funds with a bitcoin wallet",
);

sub ensure-correct-toml($file) {

    say "ensuring correct data inside $file";

    my %toml = from-toml($file.IO.slurp);

    my $name = %toml<package><name>;

    %toml<package><description>   = %descriptions{$name};
    %toml<package><readme>        = "../README";
    %toml<package><repository>    = "https://github.com/klebs6/bitcoin-rs";
    %toml<package><documentation> = "https://docs.rs/$name";

    $file.IO.spurt: to-toml(%toml);
}

for %descriptions.keys.sort -> $crate {

    my $toml = $crate ~ "/Cargo.toml";

    ensure-correct-toml($toml);
}
