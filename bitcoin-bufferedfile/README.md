# bitcoin-bufferedfile

`bitcoin-bufferedfile` is a Rust crate that provides a non-refcounted RAII wrapper around a `FILE*` pointer, implementing a ring buffer for efficient deserialization. It guarantees rewind capabilities to a specified number of bytes, ensuring robust and efficient buffered file operations. The crate is integral for managing streams where control over buffer size, read positions, and rewind functionality is paramount.

## Key Features

- **BufferedFile**: The core component that wraps a `FILE*` pointer, allowing structured reading with explicit control over the reading position and limits.
- **BufferedFileReadable Trait**: Allows types to be read from a `BufferedFile` using the `>>` operator, resembling C++-style streaming operations.
- **Rewind and Limit Controls**: Configure and enforce read boundaries and rewinding capabilities.
- **RAII Safety**: Automatically closes the underlying file handle when the `BufferedFile` goes out of scope.

## Usage

To create a `BufferedFile`, specify the buffer size and desired rewind capacity:

```rust
use bitcoin_bufferedfile::BufferedFile;

let file_ptr: *mut libc::FILE = // obtain FILE* from elsewhere;
let buffer = BufferedFile::new(file_ptr, 1024, 128, 0, 0);

// Use buffer for reading and deserialization purposes.
```

Implement the `BufferedFileReadable` trait for types that require streamed input:

```rust
use bitcoin_bufferedfile::{BufferedFile, BufferedFileReadable};

struct MyType { /* fields */ }

impl BufferedFileReadable for MyType {
    fn read_from_buffer(stream: &mut BufferedFile, out: &mut Self) {
        // implement deserialization logic
    }
}
```

## Safety
Ensure any usage of `BufferedFile` and its operations are safeguarded by checking valid pointers and maintaining strict panic conditions to avoid unsafe states.

## Note
This README is generated by an AI model and while it strives for accuracy, it's recommended to review and adapt it to ensure it fits the exact use case and API stability of `bitcoin-bufferedfile`.